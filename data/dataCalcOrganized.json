[[{"term": "class", "name": "CalcTest", "data": "class CalcTest(unittest.TestCase):\n\tdef test_add1(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.add(7, 8), 15)\n\n\tdef test_add2(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.add(-7, 8), 1)\n\n\tdef test_add3(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.add(7, -8), -1)\n\n\tdef test_add4(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.add(0, 8), 8)\n\n\tdef test_add5(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.add(0, -8), -8)\n\n\tdef test_add6(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.add(0, 0), 0)\n\n\tdef test_minus1(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.minus(7, 8), -1)\n\n\tdef test_minus2(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.minus(8, 7), 1)\n\n\tdef test_minus3(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.minus(0, 8), -8)\n\n\tdef test_minus4(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.minus(0, -8), 8)\n\n\tdef test_minus5(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.minus(8, 0), 8)\n\n\tdef test_minus6(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.minus(-8, 0), -8)\n\n\tdef test_multiply1(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.multiply(1, 8), 8)\n\n\tdef test_multiply2(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.multiply(0, 8), 0)\n\n\tdef test_multiply3(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.multiply(5, 8), 40)\n\n\tdef test_multiply4(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.multiply(-5, 8), -40)\n\n\tdef test_multiply5(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.multiply(-5, -8), 40)\n\n\tdef test_divide1(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.divide(10, 5), 2)\n\n\tdef test_divide2(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.divide(10, -5), -2)\n\n\tdef test_divide3(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.divide(-10, 5), -2)\n\n\tdef test_divide4(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.divide(-10, -5), 2)\n\n\tdef test_divide5(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.divide(0, 10), 0)\n\n\tdef test_divide6(self):\n\t\tcalc = Calcium()\n\t\tself.assertEqual(calc.divide(0, -10), 0)\n\n\tdef test_divide7(self):\n\t\tcalc = Calcium()\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.divide(10, 0)\n\n\tdef test_divide8(self):\n\t\tcalc = Calcium()\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.divide(-10, 0)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from Calcium import Calcium"]}], [{"term": "def", "name": "test_aims_interface", "data": "def test_aims_interface():\n\t# test the new command handling + legacy behavior\n\taims_command = 'aims.x'\n\taims_command_alternative = 'mpirun -np 4 fhiaims.x'\n\toutfilename = 'alternative_aims.out'\n\toutfilename_default = 'aims.out'\n\tcommand = '{0:s} > {1:s}'.format(aims_command, outfilename)\n\tcommand_default = '{0:s} > {1:s}'.format(aims_command, outfilename_default)\n\tlegacy_command = 'aims.version.serial.x > aims.out'\n\tlegacy_aims_command = legacy_command.split('>')[0].strip()\n\tlegacy_outfilename = legacy_command.split('>')[-1].strip()\n\n\t# legacy behavior of empty init\n\tcalc = Aims()\n\tassert calc.command == legacy_command\n\tassert calc.outfilename == legacy_outfilename\n\tassert calc.aims_command == legacy_aims_command\n\n\t# behavior of empty init with env variable\n\tos.environ['ASE_AIMS_COMMAND'] = aims_command_alternative\n\tcalc = Aims()\n\tassert calc.command == '{0} > {1}'.format(\n\t\taims_command_alternative, outfilename_default)\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command_alternative\n\n\t# legacy behavior of \"proper\" command\n\tcalc = Aims(run_command=command)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# legacy behavior of an \"improper\" command\n\tcalc = Aims(run_command=aims_command)\n\tassert calc.command == command_default\n\tassert calc.aims_command == aims_command\n\tassert calc.outfilename == outfilename_default\n\n\t# fixed \"command\"  behavior\n\tcalc = Aims(command=command)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# novel way to use aims_command, no specific outfile\n\tcalc = Aims(aims_command=aims_command)\n\tassert calc.command == command_default\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command\n\n\tcalc = Aims(aims_command=aims_command,\n\t\t\t\toutfilename=outfilename)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# # testing the setters\n\tcalc.command = command_default\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command\n\tassert calc.command == command_default\n\n\t# calc.set_aims_command(aims_command_alternative)\n\tcalc.aims_command = aims_command_alternative\n\tassert calc.aims_command == aims_command_alternative\n\tassert calc.outfilename == outfilename_default\n\tassert calc.command == '{} > {}'.format(\n\t\taims_command_alternative, outfilename_default)\n\n\tcalc.outfilename = outfilename\n\tassert calc.command == '{} > {}'.format(\n\t\taims_command_alternative, outfilename)\n\tassert calc.aims_command == aims_command_alternative\n\tassert calc.outfilename == outfilename\n\n\t# test writing files\n\ttmp_dir = tempfile.mkdtemp()\n\twater = Atoms('HOH', [(1, 0, 0), (0, 0, 0), (0, 1, 0)])\n\tcalc = Aims(xc='PBE',\n\t\t\t\toutput=['dipole'],\n\t\t\t\tsc_accuracy_etot=1e-6,\n\t\t\t\tsc_accuracy_eev=1e-3,\n\t\t\t\tsc_accuracy_rho=1e-6,\n\t\t\t\tspecies_dir=\"/data/rittmeyer/FHIaims/species_defaults/light/\",\n\t\t\t\tsc_accuracy_forces=1e-4,\n\t\t\t\tlabel=tmp_dir,\n\t\t\t\t)\n\ttry:\n\t\tcalc.prepare_input_files()\n\t\traise AssertionError\n\texcept ValueError:\n\t\tpass\n\n\tcalc.atoms = water\n\tcalc.prepare_input_files()\n\tfor f in ['control.in', 'geometry.in']:\n\t\tassert os.path.isfile(os.path.join(tmp_dir, f))\n", "description": null, "category": "math", "imports": ["import tempfile", "import os", "import pytest", "from ase.calculators.aims import Aims", "from ase import Atoms"]}], [{"term": "def", "name": "calcular", "data": "def calcular(id):\n\n\tglobal multiplicadorRatios\n\n\tdb.consultaVisor(id)\n\tviaCalc= str(db.itemsVisor).split(\", \")\n\n\tinicioCalcX=[]\n\tinicioCalcY=[]\n\trutaCalcX=[]\n\trutaCalcY=[]\n\ttopCalcX=[]\n\ttopCalcY=[]\n\n\tnumIniciPresas= int(len(str(viaCalc[4].replace(\"'\",\"\").replace(\"-\",\"\")))/4)\n\tnumRutaPresas= int(len(str(viaCalc[5].replace(\"'\",\"\").replace(\"-\",\"\")))/4)\n\tnumTopPresas= int(len(str(viaCalc[6].replace(\"'\",\"\").replace(\"-\",\"\")))/4)\n\tnumTotalPresas= numIniciPresas + numRutaPresas + numTopPresas\n\n\tcolumnas= int(viaCalc[7])\n\tfilas= int(viaCalc[8])\n\t\t\n\tn=2\n\tinicioCalc= [str(viaCalc[4].replace(\"'\",\"\").replace(\"-\",\"\"))[index : index + n] for index in range(0, len(str(viaCalc[4].replace(\"'\",\"\").replace(\"-\",\"\"))), n)]\n\tfor i in inicioCalc[::2]:\n\t\tinicioCalcY.append(i)\n\tfor i in inicioCalc[1::2]:\n\t\tinicioCalcX.append(i)\n\t\t\t\n\trutaCalc= [str(viaCalc[5].replace(\"'\",\"\").replace(\"-\",\"\"))[index : index + n] for index in range(0, len(str(viaCalc[5].replace(\"'\",\"\").replace(\"-\",\"\"))), n)] \n\tfor i in rutaCalc[::2]:\n\t\trutaCalcY.append(i)\n\tfor i in rutaCalc[1::2]:\n\t\trutaCalcX.append(i)\n\n\ttopCalc= [str(viaCalc[6].replace(\"'\",\"\").replace(\"-\",\"\"))[index : index + n] for index in range(0, len(str(viaCalc[6].replace(\"'\",\"\").replace(\"-\",\"\"))), n)] \n\tfor i in topCalc[::2]:\n\t\ttopCalcY.append(i)\n\tfor i in topCalc[1::2]:\n\t\ttopCalcX.append(i)\n\n\tviaCalcY= inicioCalcY + rutaCalcY + topCalcY\n\tviaCalcX= inicioCalcX + rutaCalcX + topCalcX\n\n\t#RATIOS -------------------------------------------------------------------------------------------------------------------------------------\n\t\n\t#COMO M\u00c1S SE ACERQUE A 1, M\u00c1S DIF\u00cdCIL\n\n\t# 1 - Porcentaje de ocupaci\u00f3n de las presas en el tablero\n\tratioDimensiones= round(1-(numTotalPresas/(columnas*filas)), 3)\n\t\n\t# 2 - Distancia de la primera presa de todas en relaci\u00f3n con la \u00faltima o pen\u00faltima en el eje Y\n\tratioInicioTopY = round((abs(int(inicioCalcY[0]) - int(topCalcY[0])+1))/filas, 3)\n\n\t# 3 - Distancia de la primera presa de todas en relaci\u00f3n con la \u00faltima o pen\u00faltima en el eje X\n\tratioInicioTopX = round((abs(int(inicioCalcX[0]) - int(topCalcX[0])+1))/columnas, 3)\n\n\t# 4 - Distancia entre cada una de las presas con la siguiente\n\tratioDistanciaY= []\n\tratioDistanciaX= []\n\tratioDistancia= 0\n\tfor i in range(int(((len(inicioCalc) + len(rutaCalc) + len(topCalc))/2)-1)):\n\t\tratioDistanciaY.append(abs(int(viaCalcY[i])-int(viaCalcY[i+1])))  \n\tfor i in range(int(((len(inicioCalc) + len(rutaCalc) + len(topCalc))/2)-1)):\n\t\tratioDistanciaX.append(abs(int(viaCalcX[i])-int(viaCalcX[i+1])))\n\tfor i in range(len(ratioDistanciaY)):\n\t\tratioDistancia = ratioDistancia + ratioDistanciaY[i] + ratioDistanciaX[i]\n\n\tratioDistancia= ratioDistancia + 1\n\tratioDistancia= round(1 - abs(numTotalPresas/ratioDistancia) ,3)\n\n\t# 5 - Inclinaci\u00f3n (0\u00ba = 0% , 80\u00ba = 100%)\n\tratioInclinacion= (1/80*int(viaCalc[9][:-2]))\n\n\t#------------------------------------------------------\n\n\tratioInicioTop= (ratioInicioTopY + ratioInicioTopX) / 2\n\n\tmultiplicadorRatios = round( (ratioDimensiones + ratioInicioTop + ratioDistancia + (ratioInclinacion*2))/\t 5\t*10, 3)\n\n\n\n\t# IMPRESIONES POR CONSOLA ---------------------------------------------------------------------------------------------------------------------\n\t\n\t# print(\"\\tPresas por tipo: \" + str(numIniciPresas) + \" \" + str(numRutaPresas) + \" \" + str(numTopPresas))\n\t# print(\"\\tColumnas x filas: \" + str(columnas) + \" \" + str(filas))\n\n\t# print(\"\\tInicio: \" + str(viaCalc[4]))\n\t# print(\"\\t\\t\" + str(inicioCalcX))\n\t# print(\"\\t\\t\" + str(inicioCalcY))\n\t# print(\"\\tRuta: \" + str(viaCalc[5]))\n\t# print(\"\\t\\t\" + str(rutaCalcX))\n\t# print(\"\\t\\t\" + str(rutaCalcY))\n\t# print(\"\\tTop: \" + str(viaCalc[6]))\n\t# print(\"\\t\\t\" + str(topCalcX))\n\t# print(\"\\t\\t\" + str(topCalcY))\n\t# print(\"\\tPresas via eje X concatenadas: \" + str(viaCalcX))\n\t# print(\"\\tPresas via eje Y concatenadas: \" + str(viaCalcY))\n\n\tprint(\"\\n\\t---------Ratios-----------------------\")\n\tprint(\"\\tDimensiones: \" + str(ratioDimensiones))\n\tprint(\"\\tDistancia inicio top Y: \" + str(ratioInicioTopY))\n\tprint(\"\\tDistancia inicio top X: \" + str(ratioInicioTopX))\n\tprint(\"\\tRatio distancia entre cada presa: \" + str(ratioDistancia))\n\tprint(\"\\tRatio inclinaci\u00f3n: \" + str(ratioInclinacion))\n\t#print()\n\tprint(\"\\t----------------------------------------\")\n\titemsPrint= str(db.itemsVisor).split(\",\")\n\tprint(\"\\t\" + str(itemsPrint[0].replace(\"[(\",\"\")) + \" - \" + str(itemsPrint[1].replace(\"'\",\"\")))\n\tprint(\"\\t = \" + str(multiplicadorRatios))\n\n\tcalcNivelAprox()\n\n\tprint(\"\\t = \" + str(nivelAprox))\n\tprint(\"\\tWORK IN PROGRESS\")\n\tprint(\"Se aceptan sugerencias y aportaciones: gerard.ggf@gmail.com\")\n\n", "description": null, "category": "math", "imports": ["from tkinter.constants import ROUND", "import db"]}, {"term": "def", "name": "calcNivelAprox", "data": "def calcNivelAprox():\n\n\tglobal nivelAprox\n\n\tif(multiplicadorRatios>0) and (multiplicadorRatios<1):\n\t\tnivelAprox= \"III\"\n\telif(multiplicadorRatios>=1) and (multiplicadorRatios<2.5):\n\t\tnivelAprox= \"IV\"\n\telif(multiplicadorRatios>=2.5) and (multiplicadorRatios<3.5):\n\t\tnivelAprox= \"V\"\n\telif(multiplicadorRatios>=3.5) and (multiplicadorRatios<4.5):\n\t\tnivelAprox= \"V+\"\n\n\telif(multiplicadorRatios>=4.5) and (multiplicadorRatios<5):\n\t\tnivelAprox= \"6A\"\n\telif(multiplicadorRatios>=5) and (multiplicadorRatios<5.5):\n\t\tnivelAprox= \"6A+\"\n\telif(multiplicadorRatios>=5.5) and (multiplicadorRatios<6):\n\t\tnivelAprox= \"6B\"\n\telif(multiplicadorRatios>=6) and (multiplicadorRatios<6.5):\n\t\tnivelAprox= \"6B+\"\n\telif(multiplicadorRatios>=6.5) and (multiplicadorRatios<7):\n\t\tnivelAprox= \"6C\"\n\telif(multiplicadorRatios>=7) and (multiplicadorRatios<7.4):\n\t\tnivelAprox= \"6C+\"\n\t\n\telif(multiplicadorRatios>=7.4) and (multiplicadorRatios<7.8):\n\t\tnivelAprox= \"7A\"\n\telif(multiplicadorRatios>=7.8) and (multiplicadorRatios<8.2):\n\t\tnivelAprox= \"7A+\"\n\telif(multiplicadorRatios>=8.2) and (multiplicadorRatios<8.5):\n\t\tnivelAprox= \"7B\"\n\telif(multiplicadorRatios>=8.5) and (multiplicadorRatios<8.7):\n\t\tnivelAprox= \"7B+\"\n\telif(multiplicadorRatios>=8.7) and (multiplicadorRatios<8.85):\n\t\tnivelAprox= \"7C\"\n\telif(multiplicadorRatios>=8.85) and (multiplicadorRatios<9):\n\t\tnivelAprox= \"7C+\"\n\n\telif(multiplicadorRatios>=9) and (multiplicadorRatios<9.1):\n\t\tnivelAprox= \"8A\"\n\telif(multiplicadorRatios>=9.1) and (multiplicadorRatios<9.2):\n\t\tnivelAprox= \"8A+\"\n\telif(multiplicadorRatios>=9.2) and (multiplicadorRatios<9.3):\n\t\tnivelAprox= \"8B\"\n\telif(multiplicadorRatios>=9.3) and (multiplicadorRatios<9.4):\n\t\tnivelAprox= \"8B+\"\n\telif(multiplicadorRatios>=9.4) and (multiplicadorRatios<9.5):\n\t\tnivelAprox= \"8C\"\n\telif(multiplicadorRatios>=9.5) and (multiplicadorRatios<9.6):\n\t\tnivelAprox= \"8C+\"\n\n\telif(multiplicadorRatios>=9.6) and (multiplicadorRatios<9.68):\n\t\tnivelAprox= \"9A\"\n\telif(multiplicadorRatios>=9.68) and (multiplicadorRatios<9.76):\n\t\tnivelAprox= \"9A+\"\n\telif(multiplicadorRatios>=9.76) and (multiplicadorRatios<9.84):\n\t\tnivelAprox= \"9B\"\n\telif(multiplicadorRatios>=9.84) and (multiplicadorRatios<9.9):\n\t\tnivelAprox= \"9B+\"\n\telif(multiplicadorRatios>=9.9) and (multiplicadorRatios<9.95):\n\t\tnivelAprox= \"9C\"\n\telif(multiplicadorRatios>=9.95) and (multiplicadorRatios<=9.97):\n\t\tnivelAprox= \"9C+\"\n\n\telif(multiplicadorRatios>=9.97) and (multiplicadorRatios<9.975):\n\t\tnivelAprox= \"10A\"\n\telif(multiplicadorRatios>=9.975) and (multiplicadorRatios<9.98):\n\t\tnivelAprox= \"10A+\"\n\telif(multiplicadorRatios>=9.98) and (multiplicadorRatios<9.985):\n\t\tnivelAprox= \"10B\"\n\telif(multiplicadorRatios>=9.985) and (multiplicadorRatios<9.99):\n\t\tnivelAprox= \"10B+\"\n\telif(multiplicadorRatios>=9.99) and (multiplicadorRatios<9.995):\n\t\tnivelAprox= \"10C\"\n\telif(multiplicadorRatios>=9.995) and (multiplicadorRatios<=9.998):\n\t\tnivelAprox= \"10C+\"\n\telif(multiplicadorRatios>=9.998) and (multiplicadorRatios<=10):\n\t\tnivelAprox= \"11A\"\n\t\n\n\telse:\n", "description": null, "category": "math", "imports": ["from tkinter.constants import ROUND", "import db"]}], [{"term": "def", "name": "system", "data": "def system():\n\treturn bulk('Al', 'fcc', a=4.5, cubic=True)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "expected_nelect_from_vasp", "data": "def expected_nelect_from_vasp():\n\t# Expected number of electrons from the specified system\n\t# with no charge\n\treturn 12\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_charge", "data": "def test_vasp_charge(factory, system, expected_nelect_from_vasp):\n\t\"\"\"\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied charge works correctly.\n\n\tTest that the number of charge found matches the expected.\n\t\"\"\"\n\n\t# Dummy calculation to let VASP determine default number of electrons\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False)\n\tsystem.calc = calc\n\tsystem.get_potential_energy()\n\n\tdefault_nelect_from_vasp = calc.get_number_of_electrons()\n\tassert default_nelect_from_vasp == expected_nelect_from_vasp\n\n", "description": "\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied charge works correctly.\n\n\tTest that the number of charge found matches the expected.\n\t", "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_no_inputs", "data": "def test_vasp_no_inputs(system, factory):\n\t# Make sure that no nelect was written into INCAR yet (as it wasn't\n\t# necessary)\n\tcalc = factory.calc()\n\tsystem.calc = calc\n\tsystem.get_potential_energy()\n\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] is None\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_minus_charge", "data": "def test_vasp_minus_charge(factory, system, expected_nelect_from_vasp):\n\t# Compare VASP's output nelect from before minus charge to default nelect\n\t# determined by us minus charge\n\tcharge = -2\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tcharge=charge)\n\tcalc.initialize(system)\n\tcalc.write_input(system)\n\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] == expected_nelect_from_vasp - charge\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_nelect_charge_conflict", "data": "def test_vasp_nelect_charge_conflict(factory, system,\n\t\t\t\t\t\t\t\t\t expected_nelect_from_vasp):\n\t# Test that conflicts between explicitly given nelect and charge are\n\t# detected\n\tcharge = -2\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tnelect=expected_nelect_from_vasp - charge + 1,\n\t\t\t\t\t\tcharge=charge)\n\tsystem.calc = calc\n\twith pytest.raises(ValueError):\n\t\tsystem.get_potential_energy()\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_nelect_no_write", "data": "def test_vasp_nelect_no_write(factory, system):\n\t# Test that nothing is written if charge is 0 and nelect not given\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tcharge=0)\n\tcalc.initialize(system)\n\tcalc.write_input(system)\n\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] is None\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_nelect", "data": "def test_vasp_nelect(factory, system):\n\t# Test that explicitly given nelect still works as expected\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tnelect=15)\n\tcalc.calculate(system)\n\tassert calc.get_number_of_electrons() == 15\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}], [{"term": "def", "name": "default_chunk", "data": "def default_chunk():\n\tlines = [\"TEST\", \"A\", \"TEST\", \"| Number of atoms: 200 atoms\"]\n\treturn AimsOutChunk(lines)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_reverse_search_for", "data": "def test_reverse_search_for(default_chunk):\n\tassert default_chunk.reverse_search_for([\"TEST\"]) == 2\n\tassert default_chunk.reverse_search_for([\"TEST\"], 1) == 2\n\n\tassert default_chunk.reverse_search_for([\"TEST A\"]) == LINE_NOT_FOUND\n\n\tassert default_chunk.reverse_search_for([\"A\"]) == 1\n\tassert default_chunk.reverse_search_for([\"A\"], 2) == LINE_NOT_FOUND\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_search_for_all", "data": "def test_search_for_all(default_chunk):\n\tassert default_chunk.search_for_all(\"TEST\") == [0, 2]\n\tassert default_chunk.search_for_all(\"TEST\", 0, 1) == [0]\n\tassert default_chunk.search_for_all(\"TEST\", 1, -1) == [2]\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_search_parse_scalar", "data": "def test_search_parse_scalar(default_chunk):\n\tassert default_chunk.parse_scalar(\"n_atoms\") == 200\n\tassert default_chunk.parse_scalar(\"n_electrons\") is None\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "empty_header_chunk", "data": "def empty_header_chunk():\n\treturn AimsOutHeaderChunk([])\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_missing_parameter", "data": "def test_missing_parameter(attrname, empty_header_chunk):\n\twith pytest.raises(AimsParseError, match=\"No information about\"):\n\t\tgetattr(empty_header_chunk, attrname)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_default_header_electronic_temperature", "data": "def test_default_header_electronic_temperature(empty_header_chunk):\n\tassert empty_header_chunk.electronic_temperature == 0.1\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_default_header_constraints", "data": "def test_default_header_constraints(empty_header_chunk):\n\tassert empty_header_chunk.constraints == []\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_default_header_initial_cell", "data": "def test_default_header_initial_cell(empty_header_chunk):\n\tassert empty_header_chunk.initial_cell is None\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_default_header_is_md", "data": "def test_default_header_is_md(empty_header_chunk):\n\tassert not empty_header_chunk.is_md\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_default_header_is_relaxation", "data": "def test_default_header_is_relaxation(empty_header_chunk):\n\tassert not empty_header_chunk.is_relaxation\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_default_header_n_k_points", "data": "def test_default_header_n_k_points(empty_header_chunk):\n\tassert empty_header_chunk.n_k_points is None\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_default_header_k_points", "data": "def test_default_header_k_points(empty_header_chunk):\n\tassert empty_header_chunk.k_points is None\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_default_header_k_point_weights", "data": "def test_default_header_k_point_weights(empty_header_chunk):\n\tassert empty_header_chunk.k_point_weights is None\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "initial_cell", "data": "def initial_cell():\n\treturn np.array(\n\t\t[\n\t\t\t[1.00000000, 2.70300000, 3.70300000],\n\t\t\t[4.70300000, 2.00000000, 6.70300000],\n\t\t\t[8.70300000, 7.70300000, 3.00000000],\n\t\t]\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "initial_positions", "data": "def initial_positions():\n\treturn (np.array([[0.000, 1.000, 2.000], [2.703, 3.703, 4.703]]),)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "header_chunk", "data": "def header_chunk():\n\tlines = \"\"\"\n\t\t| Number of atoms\t\t\t\t   :\t\t2\n\t\t| Number of Kohn-Sham states (occupied + empty):\t   3\n\t\tThe structure contains\t\t2 atoms,  and a total of\t\t 28.000 electrons.\n\t\t| Number of spin channels\t\t   :\t\t2\n\t\tOccupation type: Gaussian broadening, width =   0.500000E-01 eV.\n\t\tFound relaxation constraint for atom\t  1: x coordinate fixed.\n\t\tFound relaxation constraint for atom\t  1: y coordinate fixed.\n\t\tFound relaxation constraint for atom\t  2: All coordinates fixed.\n\t\tInput geometry:\n\t\t| Unit cell:\n\t\t|\t\t1.00000000\t\t2.70300000\t\t3.70300000\n\t\t|\t\t4.70300000\t\t2.00000000\t\t6.70300000\n\t\t|\t\t8.70300000\t\t7.70300000\t\t3.00000000\n\t\t| Atomic structure:\n\t\t|\t   Atom\t\t\t\tx [A]\t\t\ty [A]\t\t\tz [A]\n\t\t|\t1: Species Na\t\t\t0.00000000\t\t1.00000000\t\t2.00000000\n\t\t|\t2: Species Cl\t\t\t2.70300000\t\t3.70300000\t\t4.70300000\n\t\tInitializing the k-points\n\t\tUsing symmetry for reducing the k-points\n\t\t| k-points reduced from:\t\t8 to\t\t8\n\t\t| Number of k-points\t\t\t\t\t\t\t :\t\t 8\n\t\tThe eigenvectors in the calculations are REAL.\n\t\t| K-points in task   0:\t\t 2\n\t\t| K-points in task   1:\t\t 2\n\t\t| K-points in task   2:\t\t 2\n\t\t| K-points in task   3:\t\t 2\n\t\t| k-point: 1 at\t 0.000000\t0.000000\t0.000000  , weight:   0.12500000\n\t\t| k-point: 2 at\t 0.000000\t0.000000\t0.500000  , weight:   0.12500000\n\t\t| k-point: 3 at\t 0.000000\t0.500000\t0.000000  , weight:   0.12500000\n\t\t| k-point: 4 at\t 0.000000\t0.500000\t0.500000  , weight:   0.12500000\n\t\t| k-point: 5 at\t 0.500000\t0.000000\t0.000000  , weight:   0.12500000\n\t\t| k-point: 6 at\t 0.500000\t0.000000\t0.500000  , weight:   0.12500000\n\t\t| k-point: 7 at\t 0.500000\t0.500000\t0.000000  , weight:   0.12500000\n\t\t| k-point: 8 at\t 0.500000\t0.500000\t0.500000  , weight:   0.12500000\n\t\tGeometry relaxation: A file \"geometry.in.next_step\" is written out by default after each step.\n\t\tComplete information for previous time-step:\n\t\"\"\"\n\tlines = lines.splitlines()\n\tfor ll, line in enumerate(lines):\n\t\tlines[ll] = line.strip()\n\n\treturn AimsOutHeaderChunk(lines)\n\n", "description": "\n\t\t| Number of atoms\t\t\t\t   :\t\t2\n\t\t| Number of Kohn-Sham states (occupied + empty):\t   3\n\t\tThe structure contains\t\t2 atoms,  and a total of\t\t 28.000 electrons.\n\t\t| Number of spin channels\t\t   :\t\t2\n\t\tOccupation type: Gaussian broadening, width =   0.500000E-01 eV.\n\t\tFound relaxation constraint for atom\t  1: x coordinate fixed.\n\t\tFound relaxation constraint for atom\t  1: y coordinate fixed.\n\t\tFound relaxation constraint for atom\t  2: All coordinates fixed.\n\t\tInput geometry:\n\t\t| Unit cell:\n\t\t|\t\t1.00000000\t\t2.70300000\t\t3.70300000\n\t\t|\t\t4.70300000\t\t2.00000000\t\t6.70300000\n\t\t|\t\t8.70300000\t\t7.70300000\t\t3.00000000\n\t\t| Atomic structure:\n\t\t|\t   Atom\t\t\t\tx [A]\t\t\ty [A]\t\t\tz [A]\n\t\t|\t1: Species Na\t\t\t0.00000000\t\t1.00000000\t\t2.00000000\n\t\t|\t2: Species Cl\t\t\t2.70300000\t\t3.70300000\t\t4.70300000\n\t\tInitializing the k-points\n\t\tUsing symmetry for reducing the k-points\n\t\t| k-points reduced from:\t\t8 to\t\t8\n\t\t| Number of k-points\t\t\t\t\t\t\t :\t\t 8\n\t\tThe eigenvectors in the calculations are REAL.\n\t\t| K-points in task   0:\t\t 2\n\t\t| K-points in task   1:\t\t 2\n\t\t| K-points in task   2:\t\t 2\n\t\t| K-points in task   3:\t\t 2\n\t\t| k-point: 1 at\t 0.000000\t0.000000\t0.000000  , weight:   0.12500000\n\t\t| k-point: 2 at\t 0.000000\t0.000000\t0.500000  , weight:   0.12500000\n\t\t| k-point: 3 at\t 0.000000\t0.500000\t0.000000  , weight:   0.12500000\n\t\t| k-point: 4 at\t 0.000000\t0.500000\t0.500000  , weight:   0.12500000\n\t\t| k-point: 5 at\t 0.500000\t0.000000\t0.000000  , weight:   0.12500000\n\t\t| k-point: 6 at\t 0.500000\t0.000000\t0.500000  , weight:   0.12500000\n\t\t| k-point: 7 at\t 0.500000\t0.500000\t0.000000  , weight:   0.12500000\n\t\t| k-point: 8 at\t 0.500000\t0.500000\t0.500000  , weight:   0.12500000\n\t\tGeometry relaxation: A file \"geometry.in.next_step\" is written out by default after each step.\n\t\tComplete information for previous time-step:\n\t", "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_n_atoms", "data": "def test_header_n_atoms(header_chunk):\n\tassert header_chunk.n_atoms == 2\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_n_bands", "data": "def test_header_n_bands(header_chunk):\n\tassert header_chunk.n_bands == 3\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_n_electrons", "data": "def test_header_n_electrons(header_chunk):\n\tassert header_chunk.n_electrons == 28\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_n_spins", "data": "def test_header_n_spins(header_chunk):\n\tassert header_chunk.n_spins == 2\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_constraints", "data": "def test_header_constraints(header_chunk):\n\tassert len(header_chunk.constraints) == 2\n\tassert header_chunk.constraints[0].index == 0\n\tassert header_chunk.constraints[1].index == 1\n\tassert np.all(header_chunk.constraints[0].mask == [False, False, True])\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_initial_atoms", "data": "def test_header_initial_atoms(header_chunk, initial_cell, initial_positions):\n\tassert len(header_chunk.initial_atoms) == 2\n\tassert np.allclose(\n\t\theader_chunk.initial_atoms.cell,\n\t\tinitial_cell,\n\t)\n\tassert np.allclose(header_chunk.initial_atoms.positions, initial_positions)\n\tassert np.all([\"Na\", \"Cl\"] == header_chunk.initial_atoms.symbols)\n\tassert all(\n\t\t[\n\t\t\tstr(const_1) == str(const_2)\n\t\t\tfor const_1, const_2 in zip(\n\t\t\t\theader_chunk.constraints, header_chunk.initial_atoms.constraints\n\t\t\t)\n\t\t]\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_initial_cell", "data": "def test_header_initial_cell(header_chunk, initial_cell):\n\tassert np.allclose(header_chunk.initial_cell, initial_cell)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_electronic_temperature", "data": "def test_header_electronic_temperature(header_chunk):\n\tassert header_chunk.electronic_temperature == 0.05\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_is_md", "data": "def test_header_is_md(header_chunk):\n\tassert header_chunk.is_md\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_is_relaxation", "data": "def test_header_is_relaxation(header_chunk):\n\tassert header_chunk.is_relaxation\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_n_k_points", "data": "def test_header_n_k_points(header_chunk):\n\tassert header_chunk.n_k_points == 8\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "k_points", "data": "def k_points():\n\treturn np.array(\n\t\t[\n\t\t\t[0.000, 0.000, 0.000],\n\t\t\t[0.000, 0.000, 0.500],\n\t\t\t[0.000, 0.500, 0.000],\n\t\t\t[0.000, 0.500, 0.500],\n\t\t\t[0.500, 0.000, 0.000],\n\t\t\t[0.500, 0.000, 0.500],\n\t\t\t[0.500, 0.500, 0.000],\n\t\t\t[0.500, 0.500, 0.500],\n\t\t]\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "k_point_weights", "data": "def k_point_weights():\n\treturn np.full((8), 0.125)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_k_point_weights", "data": "def test_header_k_point_weights(header_chunk, k_point_weights):\n\tassert np.allclose(header_chunk.k_point_weights, k_point_weights)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_k_points", "data": "def test_header_k_points(header_chunk, k_points):\n\tassert np.allclose(header_chunk.k_points, k_points)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_header_summary", "data": "def test_header_header_summary(header_chunk, k_points, k_point_weights):\n\theader_summary = {\n\t\t\"initial_atoms\": header_chunk.initial_atoms,\n\t\t\"initial_cell\": header_chunk.initial_cell,\n\t\t\"constraints\": header_chunk.constraints,\n\t\t\"is_relaxation\": True,\n\t\t\"is_md\": True,\n\t\t\"n_atoms\": 2,\n\t\t\"n_bands\": 3,\n\t\t\"n_electrons\": 28,\n\t\t\"n_spins\": 2,\n\t\t\"electronic_temperature\": 0.05,\n\t\t\"n_k_points\": 8,\n\t\t\"k_points\": k_points,\n\t\t\"k_point_weights\": k_point_weights,\n\t}\n\tfor key, val in header_chunk.header_summary.items():\n\t\tif isinstance(val, np.ndarray):\n\t\t\tassert np.allclose(val, header_summary[key])\n\t\telse:\n\t\t\tassert val == header_summary[key]\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "empty_calc_chunk", "data": "def empty_calc_chunk(header_chunk):\n\treturn AimsOutCalcChunk([], header_chunk)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_transfer_n_atoms", "data": "def test_header_transfer_n_atoms(empty_calc_chunk):\n\tassert empty_calc_chunk.n_atoms == 2\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_transfer_n_bands", "data": "def test_header_transfer_n_bands(empty_calc_chunk):\n\tassert empty_calc_chunk.n_bands == 3\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_transfer_n_electrons", "data": "def test_header_transfer_n_electrons(empty_calc_chunk):\n\tassert empty_calc_chunk.n_electrons == 28\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_transfer_n_spins", "data": "def test_header_transfer_n_spins(empty_calc_chunk):\n\tassert empty_calc_chunk.n_spins == 2\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_transfer_constraints", "data": "def test_header_transfer_constraints(empty_calc_chunk):\n\tassert len(empty_calc_chunk.constraints) == 2\n\tassert empty_calc_chunk.constraints[0].index == 0\n\tassert empty_calc_chunk.constraints[1].index == 1\n\tassert np.all(empty_calc_chunk.constraints[0].mask == [False, False, True])\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_transfer_initial_cell", "data": "def test_header_transfer_initial_cell(empty_calc_chunk, initial_cell):\n\tassert np.allclose(empty_calc_chunk.initial_cell, initial_cell)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_transfer_initial_atoms", "data": "def test_header_transfer_initial_atoms(\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_transfer_electronic_temperature", "data": "def test_header_transfer_electronic_temperature(empty_calc_chunk):\n\tassert empty_calc_chunk.electronic_temperature == 0.05\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_transfer_n_k_points", "data": "def test_header_transfer_n_k_points(empty_calc_chunk):\n\tassert empty_calc_chunk.n_k_points == 8\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_transfer_k_point_weights", "data": "def test_header_transfer_k_point_weights(empty_calc_chunk, k_point_weights):\n\tassert np.allclose(empty_calc_chunk.k_point_weights, k_point_weights)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_header_transfer_k_points", "data": "def test_header_transfer_k_points(empty_calc_chunk, k_points):\n\tassert np.allclose(empty_calc_chunk.k_points, k_points)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_default_calc_energy_raises_error", "data": "def test_default_calc_energy_raises_error(empty_calc_chunk):\n\twith pytest.raises(\n\t\tAimsParseError, match=\"No energy is associated with the structure.\"\n\t):\n\t\tgetattr(empty_calc_chunk, \"energy\")\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_chunk_defaults_none", "data": "def test_chunk_defaults_none(attrname, empty_calc_chunk):\n\tassert getattr(empty_calc_chunk, attrname) is None\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_default_calc_is_metallic", "data": "def test_default_calc_is_metallic(empty_calc_chunk):\n\tassert not empty_calc_chunk.is_metallic\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_default_calc_converged", "data": "def test_default_calc_converged(empty_calc_chunk):\n\tassert not empty_calc_chunk.converged\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "calc_chunk", "data": "def calc_chunk(header_chunk):\n\tlines = \"\"\"\n\t\t| Number of self-consistency cycles\t\t  :\t\t   58\n\t\t| N = N_up - N_down (sum over all k points):\t\t 0.00000\n\t\t| Chemical potential (Fermi level):\t-8.24271207 eV\n\t\tTotal atomic forces (unitary forces were cleaned, then relaxation constraints were applied) [eV/Ang]:\n\t\t|\t1\t\t  1.000000000000000E+00\t\t  2.000000000000000E+00\t\t  3.000000000000000E+00\n\t\t|\t2\t\t  6.000000000000000E+00\t\t  5.000000000000000E+00\t\t  4.000000000000000E+00\n\t\t- Per atom stress (eV) used for heat flux calculation:\n\t\tAtom   | Stress components (1,1), (2,2), (3,3), (1,2), (1,3), (2,3)\n\t\t-------------------------------------------------------------------\n\t\t1 |\t-1.0000000000E+01   -2.0000000000E+01   -3.0000000000E+01   -4.0000000000E+01   -5.0000000000E+01   -6.0000000000E+01\n\t\t2 |\t 1.0000000000E+01\t2.0000000000E+01\t3.0000000000E+01\t4.0000000000E+01\t5.0000000000E+01\t6.0000000000E+01\n\t\t-------------------------------------------------------------------\n\t\t+-------------------------------------------------------------------+\n\t\t|\t\t\t  Analytical stress tensor - Symmetrized\t\t\t   |\n\t\t|\t\t\t\t  Cartesian components [eV/A**3]\t\t\t\t   |\n\t\t+-------------------------------------------------------------------+\n\t\t|\t\t\t\tx\t\t\t\ty\t\t\t\tz\t\t\t\t|\n\t\t|\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   |\n\t\t|  x\t\t 1.00000000\t   2.00000000\t   3.00000000\t\t   |\n\t\t|  y\t\t 2.00000000\t   5.00000000\t   6.00000000\t\t   |\n\t\t|  z\t\t 3.00000000\t   6.00000000\t   7.00000000\t\t   |\n\t\t|\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   |\n\t\t|  Pressure:\t   0.00383825   [eV/A**3]\t\t\t\t\t\t   |\n\t\t|\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   |\n\t\t+-------------------------------------------------------------------+\n\t\tEnergy and forces in a compact form:\n\t\t| Total energy uncorrected\t  :\t\t -0.169503986610555E+05 eV\n\t\t| Total energy corrected\t\t:\t\t -2.169503986610555E+05 eV  <-- do not rely on this value for anything but (periodic) metals\n\t\t| Electronic free energy\t\t:\t\t -3.169503986610555E+05 eV\n\t\tPerforming Hirshfeld analysis of fragment charges and moments.\n\t\t----------------------------------------------------------------------\n\t\t| Atom\t 1: Na\n\t\t|   Hirshfeld charge\t\t:\t  0.20898543\n\t\t|   Free atom volume\t\t:\t 82.26734086\n\t\t|   Hirshfeld volume\t\t:\t 73.39467444\n\t\t|   Hirshfeld spin moment   :\t  0.00000000\n\t\t|   Hirshfeld dipole vector :\t  0.00000000\t   0.00000000\t  -0.00000000\n\t\t|   Hirshfeld dipole moment :\t  0.00000000\n\t\t|   Hirshfeld second moments:\t  0.19955428\t   0.00000002\t   0.00000002\n\t\t|\t\t\t\t\t\t\t\t  0.00000002\t   0.19955473\t  -0.00000005\n\t\t|\t\t\t\t\t\t\t\t  0.00000002\t  -0.00000005\t   0.19955473\n\t\t----------------------------------------------------------------------\n\t\t| Atom\t 2: Cl\n\t\t|   Hirshfeld charge\t\t:\t -0.20840994\n\t\t|   Free atom volume\t\t:\t 65.62593663\n\t\t|   Hirshfeld volume\t\t:\t 62.86011074\n\t\t|   Hirshfeld spin moment   :\t  0.00000000\n\t\t|   Hirshfeld dipole vector :\t  0.00000000\t   0.00000000\t   0.00000000\n\t\t|   Hirshfeld dipole moment :\t  0.00000000\n\t\t|   Hirshfeld second moments:\t  0.01482616\t  -0.00000001\t  -0.00000001\n\t\t|\t\t\t\t\t\t\t\t -0.00000001\t   0.01482641\t   0.00000001\n\t\t|\t\t\t\t\t\t\t\t -0.00000001\t   0.00000001\t   0.01482641\n\t\t----------------------------------------------------------------------\n\t\tWriting Kohn-Sham eigenvalues.\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   1 at\t0.000000\t0.000000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.036749\t\t   1.000000\n\t\t2\t\t1\t\t\t 0.183747\t\t   5.000000\n\t\t3\t\t0\t\t\t 0.330744\t\t   9.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   1 at\t0.000000\t0.000000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.110248\t\t   3.000000\n\t\t2\t\t1\t\t\t 0.257245\t\t   7.000000\n\t\t3\t\t0\t\t\t 0.404243\t\t   11.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   2 at\t0.000000\t0.000000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.477741\t\t   13.000000\n\t\t2\t\t1\t\t\t 0.624739\t\t   17.000000\n\t\t3\t\t0\t\t\t 0.771736\t\t   21.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   2 at\t0.000000\t0.000000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.551240\t\t   15.000000\n\t\t2\t\t1\t\t\t 0.698237\t\t   19.000000\n\t\t3\t\t0\t\t\t 0.845234\t\t   23.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   3 at\t0.000000\t0.500000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.918733\t\t   25.000000\n\t\t2\t\t1\t\t\t 1.065730\t\t   29.000000\n\t\t3\t\t0\t\t\t 1.212728\t\t   33.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   3 at\t0.000000\t0.500000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.992232\t\t   27.000000\n\t\t2\t\t1\t\t\t 1.139229\t\t   31.000000\n\t\t3\t\t0\t\t\t 1.286226\t\t   35.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   4 at\t0.000000\t0.500000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 1.359725\t\t   37.000000\n\t\t2\t\t1\t\t\t 1.506722\t\t   41.000000\n\t\t3\t\t0\t\t\t 1.653720\t\t   45.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   4 at\t0.000000\t0.500000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 1.433224\t\t   39.000000\n\t\t2\t\t1\t\t\t 1.580221\t\t   43.000000\n\t\t3\t\t0\t\t\t 1.727218\t\t   47.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   5 at\t0.500000\t0.000000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 1.800717\t\t   49.000000\n\t\t2\t\t1\t\t\t 1.947714\t\t   53.000000\n\t\t3\t\t0\t\t\t 2.094711\t\t   57.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   5 at\t0.500000\t0.000000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 1.874216\t\t   51.000000\n\t\t2\t\t1\t\t\t 2.021213\t\t   55.000000\n\t\t3\t\t0\t\t\t 2.168210\t\t   59.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   6 at\t0.500000\t0.000000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 2.241709\t\t   61.000000\n\t\t2\t\t1\t\t\t 2.388706\t\t   65.000000\n\t\t3\t\t0\t\t\t 2.535703\t\t   69.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   6 at\t0.500000\t0.000000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 2.315207\t\t   63.000000\n\t\t2\t\t1\t\t\t 2.462205\t\t   67.000000\n\t\t3\t\t0\t\t\t 2.609202\t\t   71.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   7 at\t0.500000\t0.500000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 2.682701\t\t   73.000000\n\t\t2\t\t1\t\t\t 2.829698\t\t   77.000000\n\t\t3\t\t0\t\t\t 2.976695\t\t   81.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   7 at\t0.500000\t0.500000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 2.756199\t\t   75.000000\n\t\t2\t\t1\t\t\t 2.903197\t\t   79.000000\n\t\t3\t\t0\t\t\t 3.050194\t\t   83.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   8 at\t0.500000\t0.500000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 3.123693\t\t   85.000000\n\t\t2\t\t1\t\t\t 3.270690\t\t   89.000000\n\t\t3\t\t0\t\t\t 3.417687\t\t   93.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   8 at\t0.500000\t0.500000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 3.197191\t\t   87.000000\n\t\t2\t\t1\t\t\t 3.344189\t\t   91.000000\n\t\t3\t\t0\t\t\t 3.491186\t\t   95.000000\n\n\t\tCurrent spin moment of the entire structure :\n\t\t| N = N_up - N_down (sum over all k points):\t\t 0.00000\n\t\t| S (sum over all k points)\t\t\t\t:\t\t 0.00000\n\n\t\tWhat follows are estimated values for band gap, HOMO, LUMO, etc.\n\t\t| They are estimated on a discrete k-point grid and not necessarily exact.\n\t\t| For converged numbers, create a DOS and/or band structure plot on a denser k-grid.\n\n\t\tHighest occupied state (VBM) at\t -8.19345940 eV (relative to internal zero)\n\t\t| Occupation number:\t  1.00000000\n\t\t| K-point:\t   1 at\t0.000000\t0.000000\t0.000000 (in units of recip. lattice)\n\t\t| Spin channel:\t\t1\n\n\t\tLowest unoccupied state (CBM) at\t-3.62542909 eV (relative to internal zero)\n\t\t| Occupation number:\t  0.00000000\n\t\t| K-point:\t   1 at\t0.000000\t0.000000\t0.000000 (in units of recip. lattice)\n\t\t| Spin channel:\t\t1\n\n\t\tESTIMATED overall HOMO-LUMO gap:\t  4.56803031 eV between HOMO at k-point 1 and LUMO at k-point 1\n\t\t| This appears to be a direct band gap.\n\t\tThe gap value is above 0.2 eV. Unless you are using a very sparse k-point grid\n\t\tthis system is most likely an insulator or a semiconductor.\n\t\t| Chemical Potential\t\t\t\t\t\t  :\t-7.44914181 eV\n\n\t\tSelf-consistency cycle converged.\n\t\tmaterial is metallic within the approximate finite broadening function (occupation_type)\n\t\tHave a nice day.\n\t\t------------------------------------------------------------\n\t\"\"\"\n\tlines = lines.splitlines()\n\tfor ll, line in enumerate(lines):\n\t\tlines[ll] = line.strip()\n\treturn AimsOutCalcChunk(lines, header_chunk)\n\n", "description": "\n\t\t| Number of self-consistency cycles\t\t  :\t\t   58\n\t\t| N = N_up - N_down (sum over all k points):\t\t 0.00000\n\t\t| Chemical potential (Fermi level):\t-8.24271207 eV\n\t\tTotal atomic forces (unitary forces were cleaned, then relaxation constraints were applied) [eV/Ang]:\n\t\t|\t1\t\t  1.000000000000000E+00\t\t  2.000000000000000E+00\t\t  3.000000000000000E+00\n\t\t|\t2\t\t  6.000000000000000E+00\t\t  5.000000000000000E+00\t\t  4.000000000000000E+00\n\t\t- Per atom stress (eV) used for heat flux calculation:\n\t\tAtom   | Stress components (1,1), (2,2), (3,3), (1,2), (1,3), (2,3)\n\t\t-------------------------------------------------------------------\n\t\t1 |\t-1.0000000000E+01   -2.0000000000E+01   -3.0000000000E+01   -4.0000000000E+01   -5.0000000000E+01   -6.0000000000E+01\n\t\t2 |\t 1.0000000000E+01\t2.0000000000E+01\t3.0000000000E+01\t4.0000000000E+01\t5.0000000000E+01\t6.0000000000E+01\n\t\t-------------------------------------------------------------------\n\t\t+-------------------------------------------------------------------+\n\t\t|\t\t\t  Analytical stress tensor - Symmetrized\t\t\t   |\n\t\t|\t\t\t\t  Cartesian components [eV/A**3]\t\t\t\t   |\n\t\t+-------------------------------------------------------------------+\n\t\t|\t\t\t\tx\t\t\t\ty\t\t\t\tz\t\t\t\t|\n\t\t|\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   |\n\t\t|  x\t\t 1.00000000\t   2.00000000\t   3.00000000\t\t   |\n\t\t|  y\t\t 2.00000000\t   5.00000000\t   6.00000000\t\t   |\n\t\t|  z\t\t 3.00000000\t   6.00000000\t   7.00000000\t\t   |\n\t\t|\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   |\n\t\t|  Pressure:\t   0.00383825   [eV/A**3]\t\t\t\t\t\t   |\n\t\t|\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   |\n\t\t+-------------------------------------------------------------------+\n\t\tEnergy and forces in a compact form:\n\t\t| Total energy uncorrected\t  :\t\t -0.169503986610555E+05 eV\n\t\t| Total energy corrected\t\t:\t\t -2.169503986610555E+05 eV  <-- do not rely on this value for anything but (periodic) metals\n\t\t| Electronic free energy\t\t:\t\t -3.169503986610555E+05 eV\n\t\tPerforming Hirshfeld analysis of fragment charges and moments.\n\t\t----------------------------------------------------------------------\n\t\t| Atom\t 1: Na\n\t\t|   Hirshfeld charge\t\t:\t  0.20898543\n\t\t|   Free atom volume\t\t:\t 82.26734086\n\t\t|   Hirshfeld volume\t\t:\t 73.39467444\n\t\t|   Hirshfeld spin moment   :\t  0.00000000\n\t\t|   Hirshfeld dipole vector :\t  0.00000000\t   0.00000000\t  -0.00000000\n\t\t|   Hirshfeld dipole moment :\t  0.00000000\n\t\t|   Hirshfeld second moments:\t  0.19955428\t   0.00000002\t   0.00000002\n\t\t|\t\t\t\t\t\t\t\t  0.00000002\t   0.19955473\t  -0.00000005\n\t\t|\t\t\t\t\t\t\t\t  0.00000002\t  -0.00000005\t   0.19955473\n\t\t----------------------------------------------------------------------\n\t\t| Atom\t 2: Cl\n\t\t|   Hirshfeld charge\t\t:\t -0.20840994\n\t\t|   Free atom volume\t\t:\t 65.62593663\n\t\t|   Hirshfeld volume\t\t:\t 62.86011074\n\t\t|   Hirshfeld spin moment   :\t  0.00000000\n\t\t|   Hirshfeld dipole vector :\t  0.00000000\t   0.00000000\t   0.00000000\n\t\t|   Hirshfeld dipole moment :\t  0.00000000\n\t\t|   Hirshfeld second moments:\t  0.01482616\t  -0.00000001\t  -0.00000001\n\t\t|\t\t\t\t\t\t\t\t -0.00000001\t   0.01482641\t   0.00000001\n\t\t|\t\t\t\t\t\t\t\t -0.00000001\t   0.00000001\t   0.01482641\n\t\t----------------------------------------------------------------------\n\t\tWriting Kohn-Sham eigenvalues.\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   1 at\t0.000000\t0.000000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.036749\t\t   1.000000\n\t\t2\t\t1\t\t\t 0.183747\t\t   5.000000\n\t\t3\t\t0\t\t\t 0.330744\t\t   9.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   1 at\t0.000000\t0.000000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.110248\t\t   3.000000\n\t\t2\t\t1\t\t\t 0.257245\t\t   7.000000\n\t\t3\t\t0\t\t\t 0.404243\t\t   11.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   2 at\t0.000000\t0.000000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.477741\t\t   13.000000\n\t\t2\t\t1\t\t\t 0.624739\t\t   17.000000\n\t\t3\t\t0\t\t\t 0.771736\t\t   21.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   2 at\t0.000000\t0.000000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.551240\t\t   15.000000\n\t\t2\t\t1\t\t\t 0.698237\t\t   19.000000\n\t\t3\t\t0\t\t\t 0.845234\t\t   23.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   3 at\t0.000000\t0.500000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.918733\t\t   25.000000\n\t\t2\t\t1\t\t\t 1.065730\t\t   29.000000\n\t\t3\t\t0\t\t\t 1.212728\t\t   33.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   3 at\t0.000000\t0.500000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 0.992232\t\t   27.000000\n\t\t2\t\t1\t\t\t 1.139229\t\t   31.000000\n\t\t3\t\t0\t\t\t 1.286226\t\t   35.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   4 at\t0.000000\t0.500000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 1.359725\t\t   37.000000\n\t\t2\t\t1\t\t\t 1.506722\t\t   41.000000\n\t\t3\t\t0\t\t\t 1.653720\t\t   45.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   4 at\t0.000000\t0.500000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 1.433224\t\t   39.000000\n\t\t2\t\t1\t\t\t 1.580221\t\t   43.000000\n\t\t3\t\t0\t\t\t 1.727218\t\t   47.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   5 at\t0.500000\t0.000000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 1.800717\t\t   49.000000\n\t\t2\t\t1\t\t\t 1.947714\t\t   53.000000\n\t\t3\t\t0\t\t\t 2.094711\t\t   57.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   5 at\t0.500000\t0.000000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 1.874216\t\t   51.000000\n\t\t2\t\t1\t\t\t 2.021213\t\t   55.000000\n\t\t3\t\t0\t\t\t 2.168210\t\t   59.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   6 at\t0.500000\t0.000000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 2.241709\t\t   61.000000\n\t\t2\t\t1\t\t\t 2.388706\t\t   65.000000\n\t\t3\t\t0\t\t\t 2.535703\t\t   69.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   6 at\t0.500000\t0.000000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 2.315207\t\t   63.000000\n\t\t2\t\t1\t\t\t 2.462205\t\t   67.000000\n\t\t3\t\t0\t\t\t 2.609202\t\t   71.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   7 at\t0.500000\t0.500000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 2.682701\t\t   73.000000\n\t\t2\t\t1\t\t\t 2.829698\t\t   77.000000\n\t\t3\t\t0\t\t\t 2.976695\t\t   81.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   7 at\t0.500000\t0.500000\t0.000000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 2.756199\t\t   75.000000\n\t\t2\t\t1\t\t\t 2.903197\t\t   79.000000\n\t\t3\t\t0\t\t\t 3.050194\t\t   83.000000\n\n\n\t\tSpin-up eigenvalues:\n\t\tK-point:\t   8 at\t0.500000\t0.500000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 3.123693\t\t   85.000000\n\t\t2\t\t1\t\t\t 3.270690\t\t   89.000000\n\t\t3\t\t0\t\t\t 3.417687\t\t   93.000000\n\n\t\tSpin-down eigenvalues:\n\t\tK-point:\t   8 at\t0.500000\t0.500000\t0.500000 (in units of recip. lattice)\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t\t1\t\t\t 3.197191\t\t   87.000000\n\t\t2\t\t1\t\t\t 3.344189\t\t   91.000000\n\t\t3\t\t0\t\t\t 3.491186\t\t   95.000000\n\n\t\tCurrent spin moment of the entire structure :\n\t\t| N = N_up - N_down (sum over all k points):\t\t 0.00000\n\t\t| S (sum over all k points)\t\t\t\t:\t\t 0.00000\n\n\t\tWhat follows are estimated values for band gap, HOMO, LUMO, etc.\n\t\t| They are estimated on a discrete k-point grid and not necessarily exact.\n\t\t| For converged numbers, create a DOS and/or band structure plot on a denser k-grid.\n\n\t\tHighest occupied state (VBM) at\t -8.19345940 eV (relative to internal zero)\n\t\t| Occupation number:\t  1.00000000\n\t\t| K-point:\t   1 at\t0.000000\t0.000000\t0.000000 (in units of recip. lattice)\n\t\t| Spin channel:\t\t1\n\n\t\tLowest unoccupied state (CBM) at\t-3.62542909 eV (relative to internal zero)\n\t\t| Occupation number:\t  0.00000000\n\t\t| K-point:\t   1 at\t0.000000\t0.000000\t0.000000 (in units of recip. lattice)\n\t\t| Spin channel:\t\t1\n\n\t\tESTIMATED overall HOMO-LUMO gap:\t  4.56803031 eV between HOMO at k-point 1 and LUMO at k-point 1\n\t\t| This appears to be a direct band gap.\n\t\tThe gap value is above 0.2 eV. Unless you are using a very sparse k-point grid\n\t\tthis system is most likely an insulator or a semiconductor.\n\t\t| Chemical Potential\t\t\t\t\t\t  :\t-7.44914181 eV\n\n\t\tSelf-consistency cycle converged.\n\t\tmaterial is metallic within the approximate finite broadening function (occupation_type)\n\t\tHave a nice day.\n\t\t------------------------------------------------------------\n\t", "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "eigenvalues_occupancies", "data": "def eigenvalues_occupancies():\n\teigenvalues_occupancies = np.arange(8 * 3 * 4).reshape((8, 3, 2, 2))\n\teigenvalues_occupancies[:, 0, :, 0] = 1.0\n\teigenvalues_occupancies[:, 1, :, 0] = 1.0\n\teigenvalues_occupancies[:, 2, :, 0] = 0.0\n\n\treturn eigenvalues_occupancies\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_atoms", "data": "def test_calc_atoms(calc_chunk, initial_cell, initial_positions):\n\tassert len(calc_chunk.atoms) == 2\n\tassert np.allclose(calc_chunk.atoms.cell, initial_cell)\n\tassert np.allclose(calc_chunk.atoms.positions, initial_positions)\n\tassert np.all([\"Na\", \"Cl\"] == calc_chunk.atoms.symbols)\n\tassert all(\n\t\t[\n\t\t\tstr(const_1) == str(const_2)\n\t\t\tfor const_1, const_2 in zip(\n\t\t\t\tcalc_chunk.constraints, calc_chunk.atoms.constraints\n\t\t\t)\n\t\t]\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_forces", "data": "def test_calc_forces(calc_chunk):\n\tforces = np.array([[1.0, 2.0, 3.0], [6.0, 5.0, 4.0]])\n\tassert np.allclose(calc_chunk.forces, forces)\n\n\t# Different because of the constraints\n\tassert np.allclose(\n\t\tcalc_chunk.atoms.get_forces(), np.array(\n\t\t\t[[0.0, 0.0, 3.0], [0.0, 0.0, 0.0]])\n\t)\n\tassert np.allclose(\n\t\tcalc_chunk.atoms.get_forces(\n\t\t\tapply_constraint=False), forces)\n\tassert np.allclose(calc_chunk.results[\"forces\"], forces)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_stresses", "data": "def test_calc_stresses(calc_chunk):\n\tstresses = np.array(\n\t\t[\n\t\t\t[-10.0, -20.0, -30.0, -60.0, -50.0, -40.0],\n\t\t\t[10.0, 20.0, 30.0, 60.0, 50.0, 40.0],\n\t\t]\n\t)\n\tassert np.allclose(calc_chunk.stresses, stresses)\n\tassert np.allclose(calc_chunk.atoms.get_stresses(), stresses)\n\tassert np.allclose(calc_chunk.results[\"stresses\"], stresses)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_stress", "data": "def test_calc_stress(calc_chunk):\n\tstress = full_3x3_to_voigt_6_stress(\n\t\tnp.array(\n\t\t\t[\n\t\t\t\t[1.00000000, 2.00000000, 3.00000000],\n\t\t\t\t[2.00000000, 5.00000000, 6.00000000],\n\t\t\t\t[3.00000000, 6.00000000, 7.00000000],\n\t\t\t]\n\t\t)\n\t)\n\tassert np.allclose(calc_chunk.stress, stress)\n\tassert np.allclose(calc_chunk.atoms.get_stress(), stress)\n\tassert np.allclose(calc_chunk.results[\"stress\"], stress)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_free_energy", "data": "def test_calc_free_energy(calc_chunk):\n\tfree_energy = -3.169503986610555e05\n\tassert np.abs(calc_chunk.free_energy - free_energy) < eps_hp\n\tassert (\n\t\tnp.abs(calc_chunk.atoms.calc.get_property(\n\t\t\t\"free_energy\") - free_energy) < eps_hp\n\t)\n\tassert np.abs(calc_chunk.results[\"free_energy\"] - free_energy) < eps_hp\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_energy", "data": "def test_calc_energy(calc_chunk):\n\tenergy = -2.169503986610555e05\n\tassert np.abs(calc_chunk.energy - energy) < eps_hp\n\tassert np.abs(calc_chunk.atoms.get_potential_energy() - energy) < eps_hp\n\tassert np.abs(calc_chunk.results[\"energy\"] - energy) < eps_hp\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_magnetic_moment", "data": "def test_calc_magnetic_moment(calc_chunk):\n\tmagmom = 0\n\tassert calc_chunk.magmom == magmom\n\tassert calc_chunk.atoms.get_magnetic_moment() == magmom\n\tassert calc_chunk.results[\"magmom\"] == magmom\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_n_iter", "data": "def test_calc_n_iter(calc_chunk):\n\tn_iter = 58\n\tassert calc_chunk.n_iter == n_iter\n\tassert calc_chunk.results[\"n_iter\"] == n_iter\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_fermi_energy", "data": "def test_calc_fermi_energy(calc_chunk):\n\tEf = -8.24271207\n\tassert np.abs(calc_chunk.E_f - Ef) < eps_lp\n\tassert np.abs(calc_chunk.results[\"fermi_energy\"] - Ef) < eps_lp\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_dipole", "data": "def test_calc_dipole(calc_chunk):\n\tassert calc_chunk.dipole is None\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_is_metallic", "data": "def test_calc_is_metallic(calc_chunk):\n\tassert calc_chunk.is_metallic\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_converged", "data": "def test_calc_converged(calc_chunk):\n\tassert calc_chunk.converged\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_hirshfeld_charges", "data": "def test_calc_hirshfeld_charges(calc_chunk):\n\thirshfeld_charges = [0.20898543, -0.20840994]\n\tassert np.allclose(calc_chunk.hirshfeld_charges, hirshfeld_charges)\n\tassert np.allclose(\n\t\tcalc_chunk.results[\"hirshfeld_charges\"],\n\t\thirshfeld_charges)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_hirshfeld_volumes", "data": "def test_calc_hirshfeld_volumes(calc_chunk):\n\thirshfeld_volumes = [73.39467444, 62.86011074]\n\tassert np.allclose(calc_chunk.hirshfeld_volumes, hirshfeld_volumes)\n\tassert np.allclose(\n\t\tcalc_chunk.results[\"hirshfeld_volumes\"],\n\t\thirshfeld_volumes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_hirshfeld_atomic_dipoles", "data": "def test_calc_hirshfeld_atomic_dipoles(calc_chunk):\n\thirshfeld_atomic_dipoles = np.zeros((2, 3))\n\tassert np.allclose(\n\t\tcalc_chunk.hirshfeld_atomic_dipoles,\n\t\thirshfeld_atomic_dipoles)\n\tassert np.allclose(\n\t\tcalc_chunk.results[\"hirshfeld_atomic_dipoles\"], hirshfeld_atomic_dipoles\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_hirshfeld_dipole", "data": "def test_calc_hirshfeld_dipole(calc_chunk):\n\tassert calc_chunk.hirshfeld_dipole is None\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_eigenvalues", "data": "def test_calc_eigenvalues(calc_chunk, eigenvalues_occupancies):\n\tassert np.allclose(calc_chunk.eigenvalues,\n\t\t\t\t\t   eigenvalues_occupancies[:, :, :, 1])\n\tassert np.allclose(\n\t\tcalc_chunk.results[\"eigenvalues\"], eigenvalues_occupancies[:, :, :, 1]\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_calc_occupancies", "data": "def test_calc_occupancies(calc_chunk, eigenvalues_occupancies):\n\tassert np.allclose(calc_chunk.occupancies,\n\t\t\t\t\t   eigenvalues_occupancies[:, :, :, 0])\n\tassert np.allclose(\n\t\tcalc_chunk.results[\"occupancies\"], eigenvalues_occupancies[:, :, :, 0]\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "molecular_positions", "data": "def molecular_positions():\n\treturn np.array(\n\t\t[\n\t\t\t[0.00000000, 0.00000000, 0.00000000],\n\t\t\t[0.95840000, 0.00000000, 0.00000000],\n\t\t\t[-0.24000000, 0.92790000, 0.00000000],\n\t\t]\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "molecular_header_chunk", "data": "def molecular_header_chunk():\n\tlines = \"\"\"\n\t\t| Number of atoms\t\t\t\t   :\t\t3\n\t\t| Number of spin channels\t\t   :\t\t1\n\t\tThe structure contains\t\t3 atoms  and a total of\t\t 10.000 electrons.\n\t\tInput geometry:\n\t\t| Atomic structure:\n\t\t|\t   Atom\t\t\t\tx [A]\t\t\ty [A]\t\t\tz [A]\n\t\t|\t1: Species O\t\t\t 0.00000000\t\t0.00000000\t\t0.00000000\n\t\t|\t2: Species H\t\t\t 0.95840000\t\t0.00000000\t\t0.00000000\n\t\t|\t3: Species H\t\t\t-0.24000000\t\t0.92790000\t\t0.00000000\n\t\t'Geometry relaxation: A file geometry.in.next_step is written out by default after each step.'\n\t\t| Maximum number of basis functions\t\t\t:\t\t7\n\t\t| Number of Kohn-Sham states (occupied + empty):\t   11\n\t\tReducing total number of  Kohn-Sham states to\t\t7.\n\t\"\"\"\n\n\tlines = lines.splitlines()\n\tfor ll, line in enumerate(lines):\n\t\tlines[ll] = line.strip()\n\n\treturn AimsOutHeaderChunk(lines)\n\n", "description": "\n\t\t| Number of atoms\t\t\t\t   :\t\t3\n\t\t| Number of spin channels\t\t   :\t\t1\n\t\tThe structure contains\t\t3 atoms  and a total of\t\t 10.000 electrons.\n\t\tInput geometry:\n\t\t| Atomic structure:\n\t\t|\t   Atom\t\t\t\tx [A]\t\t\ty [A]\t\t\tz [A]\n\t\t|\t1: Species O\t\t\t 0.00000000\t\t0.00000000\t\t0.00000000\n\t\t|\t2: Species H\t\t\t 0.95840000\t\t0.00000000\t\t0.00000000\n\t\t|\t3: Species H\t\t\t-0.24000000\t\t0.92790000\t\t0.00000000\n\t\t'Geometry relaxation: A file geometry.in.next_step is written out by default after each step.'\n\t\t| Maximum number of basis functions\t\t\t:\t\t7\n\t\t| Number of Kohn-Sham states (occupied + empty):\t   11\n\t\tReducing total number of  Kohn-Sham states to\t\t7.\n\t", "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_chunk_molecular_header_defaults_none", "data": "def test_chunk_molecular_header_defaults_none(attrname, molecular_header_chunk):\n\tassert getattr(molecular_header_chunk, attrname) is None\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_header_constraints", "data": "def test_molecular_header_constraints(molecular_header_chunk):\n\tassert molecular_header_chunk.constraints == []\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_header_n_bands", "data": "def test_molecular_header_n_bands(molecular_header_chunk):\n\tassert molecular_header_chunk.n_bands == 7\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_header_initial_atoms", "data": "def test_molecular_header_initial_atoms(\n\t\tmolecular_header_chunk, molecular_positions):\n\tassert len(molecular_header_chunk.initial_atoms) == 3\n\tassert np.all([\"O\", \"H\", \"H\"] ==\n\t\t\t\t  molecular_header_chunk.initial_atoms.symbols)\n\tassert np.allclose(\n\t\tmolecular_header_chunk.initial_atoms.positions,\n\t\tnp.array(\n\t\t\t[\n\t\t\t\t[0.00000000, 0.00000000, 0.00000000],\n\t\t\t\t[0.95840000, 0.00000000, 0.00000000],\n\t\t\t\t[-0.24000000, 0.92790000, 0.00000000],\n\t\t\t]\n\t\t),\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "molecular_calc_chunk", "data": "def molecular_calc_chunk(molecular_header_chunk):\n\tlines = \"\"\"\n\t\t| Number of self-consistency cycles\t\t  :\t\t   7\n\t\t| Chemical Potential\t\t\t\t\t\t  :\t-0.61315483 eV\n\t\tUpdated atomic structure:\n\t\tx [A]\t\t\t y [A]\t\t\t z [A]\n\t\tatom\t\t-0.00191785\t   -0.00243279\t\t0.00000000  O\n\t\tatom\t\t 0.97071531\t   -0.00756333\t\t0.00000000  H\n\t\tatom\t\t-0.25039746\t\t0.93789612\t   -0.00000000  H\n\t\t| Total dipole moment [eAng]\t\t  :\t\t  0.260286493869765E+00\t\t 0.336152447755231E+00\t\t 0.470003778119121E-15\n\t\tEnergy and forces in a compact form:\n\t\t| Total energy uncorrected\t  :\t\t -0.206778551123339E+04 eV\n\t\t| Total energy corrected\t\t:\t\t -5.206778551123339E+04 eV  <-- do not rely on this value for anything but (periodic) metals\n\t\t| Electronic free energy\t\t:\t\t -2.206778551123339E+04 eV\n\t\tTotal atomic forces (unitary forces cleaned) [eV/Ang]:\n\t\t|\t1\t\t  0.502371357164392E-03\t\t  0.518627676606471E-03\t\t  0.000000000000000E+00\n\t\t|\t2\t\t -0.108826758257187E-03\t\t -0.408128912334209E-03\t\t -0.649037698626122E-27\n\t\t|\t3\t\t -0.393544598907207E-03\t\t -0.110498764272267E-03\t\t -0.973556547939183E-27\n\t\tPerforming Hirshfeld analysis of fragment charges and moments.\n\t\t----------------------------------------------------------------------\n\t\t| Atom\t 1: O\n\t\t|   Hirshfeld charge\t\t:\t -0.32053200\n\t\t|   Free atom volume\t\t:\t 23.59848617\n\t\t|   Hirshfeld volume\t\t:\t 21.83060659\n\t\t|   Hirshfeld dipole vector :\t  0.04249319\t   0.05486053\t   0.00000000\n\t\t|   Hirshfeld dipole moment :\t  0.06939271\n\t\t|   Hirshfeld second moments:\t  0.04964380\t  -0.04453278\t  -0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.04453278\t   0.02659295\t   0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.00000000\t   0.00000000\t  -0.05608173\n\t\t----------------------------------------------------------------------\n\t\t| Atom\t 2: H\n\t\t|   Hirshfeld charge\t\t:\t  0.16022630\n\t\t|   Free atom volume\t\t:\t 10.48483941\n\t\t|   Hirshfeld volume\t\t:\t  6.07674041\n\t\t|   Hirshfeld dipole vector :\t  0.13710134\t  -0.00105126\t   0.00000000\n\t\t|   Hirshfeld dipole moment :\t  0.13710537\n\t\t|   Hirshfeld second moments:\t  0.12058896\t  -0.01198026\t  -0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.01198026\t   0.14550360\t   0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.00000000\t   0.00000000\t   0.10836357\n\t\t----------------------------------------------------------------------\n\t\t| Atom\t 3: H\n\t\t|   Hirshfeld charge\t\t:\t  0.16020375\n\t\t|   Free atom volume\t\t:\t 10.48483941\n\t\t|   Hirshfeld volume\t\t:\t  6.07684447\n\t\t|   Hirshfeld dipole vector :\t -0.03534982\t   0.13248706\t   0.00000000\n\t\t|   Hirshfeld dipole moment :\t  0.13712195\n\t\t|   Hirshfeld second moments:\t  0.14974686\t  -0.00443579\t  -0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.00443579\t   0.11633028\t  -0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.00000000\t  -0.00000000\t   0.10836209\n\t\t----------------\n\t\tWriting Kohn-Sham eigenvalues.\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t   2.00000\t\t -18.640915\t\t -507.24511\n\t\t2\t   2.00000\t\t  -0.918449\t\t  -24.99226\n\t\t3\t   2.00000\t\t  -0.482216\t\t  -13.12175\n\t\t4\t   2.00000\t\t  -0.338691\t\t   -9.21626\n\t\t5\t   2.00000\t\t  -0.264427\t\t   -7.19543\n\t\t6\t   0.00000\t\t  -0.000414\t\t   -0.01127\n\t\t7\t   0.00000\t\t   0.095040\t\t\t2.58616\n\n\t\tHighest occupied state (VBM) at\t -7.19542820 eV\n\t\t| Occupation number:\t  2.00000000\n\n\t\tLowest unoccupied state (CBM) at\t-0.01126981 eV\n\t\t| Occupation number:\t  0.00000000\n\n\t\tOverall HOMO-LUMO gap:\t  7.18415839 eV.\n\t\t| Chemical Potential\t\t\t\t\t\t  :\t-0.61315483 eV\n\n\t\tSelf-consistency cycle converged.\n\t\tHave a nice day.\n\t\t------------------------------------------------------------\n\n\t\"\"\"\n\tlines = lines.splitlines()\n\tfor ll, line in enumerate(lines):\n\t\tlines[ll] = line.strip()\n\treturn AimsOutCalcChunk(lines, molecular_header_chunk)\n\n", "description": "\n\t\t| Number of self-consistency cycles\t\t  :\t\t   7\n\t\t| Chemical Potential\t\t\t\t\t\t  :\t-0.61315483 eV\n\t\tUpdated atomic structure:\n\t\tx [A]\t\t\t y [A]\t\t\t z [A]\n\t\tatom\t\t-0.00191785\t   -0.00243279\t\t0.00000000  O\n\t\tatom\t\t 0.97071531\t   -0.00756333\t\t0.00000000  H\n\t\tatom\t\t-0.25039746\t\t0.93789612\t   -0.00000000  H\n\t\t| Total dipole moment [eAng]\t\t  :\t\t  0.260286493869765E+00\t\t 0.336152447755231E+00\t\t 0.470003778119121E-15\n\t\tEnergy and forces in a compact form:\n\t\t| Total energy uncorrected\t  :\t\t -0.206778551123339E+04 eV\n\t\t| Total energy corrected\t\t:\t\t -5.206778551123339E+04 eV  <-- do not rely on this value for anything but (periodic) metals\n\t\t| Electronic free energy\t\t:\t\t -2.206778551123339E+04 eV\n\t\tTotal atomic forces (unitary forces cleaned) [eV/Ang]:\n\t\t|\t1\t\t  0.502371357164392E-03\t\t  0.518627676606471E-03\t\t  0.000000000000000E+00\n\t\t|\t2\t\t -0.108826758257187E-03\t\t -0.408128912334209E-03\t\t -0.649037698626122E-27\n\t\t|\t3\t\t -0.393544598907207E-03\t\t -0.110498764272267E-03\t\t -0.973556547939183E-27\n\t\tPerforming Hirshfeld analysis of fragment charges and moments.\n\t\t----------------------------------------------------------------------\n\t\t| Atom\t 1: O\n\t\t|   Hirshfeld charge\t\t:\t -0.32053200\n\t\t|   Free atom volume\t\t:\t 23.59848617\n\t\t|   Hirshfeld volume\t\t:\t 21.83060659\n\t\t|   Hirshfeld dipole vector :\t  0.04249319\t   0.05486053\t   0.00000000\n\t\t|   Hirshfeld dipole moment :\t  0.06939271\n\t\t|   Hirshfeld second moments:\t  0.04964380\t  -0.04453278\t  -0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.04453278\t   0.02659295\t   0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.00000000\t   0.00000000\t  -0.05608173\n\t\t----------------------------------------------------------------------\n\t\t| Atom\t 2: H\n\t\t|   Hirshfeld charge\t\t:\t  0.16022630\n\t\t|   Free atom volume\t\t:\t 10.48483941\n\t\t|   Hirshfeld volume\t\t:\t  6.07674041\n\t\t|   Hirshfeld dipole vector :\t  0.13710134\t  -0.00105126\t   0.00000000\n\t\t|   Hirshfeld dipole moment :\t  0.13710537\n\t\t|   Hirshfeld second moments:\t  0.12058896\t  -0.01198026\t  -0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.01198026\t   0.14550360\t   0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.00000000\t   0.00000000\t   0.10836357\n\t\t----------------------------------------------------------------------\n\t\t| Atom\t 3: H\n\t\t|   Hirshfeld charge\t\t:\t  0.16020375\n\t\t|   Free atom volume\t\t:\t 10.48483941\n\t\t|   Hirshfeld volume\t\t:\t  6.07684447\n\t\t|   Hirshfeld dipole vector :\t -0.03534982\t   0.13248706\t   0.00000000\n\t\t|   Hirshfeld dipole moment :\t  0.13712195\n\t\t|   Hirshfeld second moments:\t  0.14974686\t  -0.00443579\t  -0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.00443579\t   0.11633028\t  -0.00000000\n\t\t|\t\t\t\t\t\t\t\t -0.00000000\t  -0.00000000\t   0.10836209\n\t\t----------------\n\t\tWriting Kohn-Sham eigenvalues.\n\n\t\tState\tOccupation\tEigenvalue [Ha]\tEigenvalue [eV]\n\t\t1\t   2.00000\t\t -18.640915\t\t -507.24511\n\t\t2\t   2.00000\t\t  -0.918449\t\t  -24.99226\n\t\t3\t   2.00000\t\t  -0.482216\t\t  -13.12175\n\t\t4\t   2.00000\t\t  -0.338691\t\t   -9.21626\n\t\t5\t   2.00000\t\t  -0.264427\t\t   -7.19543\n\t\t6\t   0.00000\t\t  -0.000414\t\t   -0.01127\n\t\t7\t   0.00000\t\t   0.095040\t\t\t2.58616\n\n\t\tHighest occupied state (VBM) at\t -7.19542820 eV\n\t\t| Occupation number:\t  2.00000000\n\n\t\tLowest unoccupied state (CBM) at\t-0.01126981 eV\n\t\t| Occupation number:\t  0.00000000\n\n\t\tOverall HOMO-LUMO gap:\t  7.18415839 eV.\n\t\t| Chemical Potential\t\t\t\t\t\t  :\t-0.61315483 eV\n\n\t\tSelf-consistency cycle converged.\n\t\tHave a nice day.\n\t\t------------------------------------------------------------\n\n\t", "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "molecular_positions", "data": "def molecular_positions():\n\treturn np.array(\n\t\t[\n\t\t\t[-0.00191785, -0.00243279, 0.00000000],\n\t\t\t[0.97071531, -0.00756333, 0.00000000],\n\t\t\t[-0.25039746, 0.93789612, 0.00000000],\n\t\t]\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_atoms", "data": "def test_molecular_calc_atoms(molecular_calc_chunk, molecular_positions):\n\tassert len(molecular_calc_chunk.atoms) == 3\n\tassert np.allclose(\n\t\tmolecular_calc_chunk.atoms.positions,\n\t\tmolecular_positions)\n\tassert np.all([\"O\", \"H\", \"H\"] == molecular_calc_chunk.atoms.symbols)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_forces", "data": "def test_molecular_calc_forces(molecular_calc_chunk):\n\tforces = np.array(\n\t\t[\n\t\t\t[0.502371357164392e-03, 0.518627676606471e-03, 0.000000000000000e00],\n\t\t\t[-0.108826758257187e-03, -0.408128912334209e-03, -0.649037698626122e-27],\n\t\t\t[-0.393544598907207e-03, -0.110498764272267e-03, -0.973556547939183e-27],\n\t\t]\n\t)\n\tassert np.allclose(molecular_calc_chunk.forces, forces)\n\tassert np.allclose(molecular_calc_chunk.atoms.get_forces(), forces)\n\tassert np.allclose(molecular_calc_chunk.results[\"forces\"], forces)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_chunk_molecular_defaults_none", "data": "def test_chunk_molecular_defaults_none(attrname, molecular_calc_chunk):\n\tassert getattr(molecular_calc_chunk, attrname) is None\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_free_energy", "data": "def test_molecular_calc_free_energy(molecular_calc_chunk):\n\tfree_energy = -2.206778551123339e04\n\tassert np.abs(molecular_calc_chunk.free_energy - free_energy) < eps_hp\n\tassert np.abs(\n\t\tmolecular_calc_chunk.results[\"free_energy\"] -\n\t\tfree_energy) < eps_hp\n\tassert (\n\t\tnp.abs(\n\t\t\tmolecular_calc_chunk.atoms.calc.get_property(\n\t\t\t\t\"free_energy\") - free_energy\n\t\t)\n\t\t< eps_hp\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_energy", "data": "def test_molecular_calc_energy(molecular_calc_chunk):\n\tenergy = -0.206778551123339e04\n\tassert np.abs(molecular_calc_chunk.energy - energy) < eps_hp\n\tassert np.abs(\n\t\tmolecular_calc_chunk.atoms.get_potential_energy() -\n\t\tenergy) < eps_hp\n\tassert np.abs(molecular_calc_chunk.results[\"energy\"] - energy) < eps_hp\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_n_iter", "data": "def test_molecular_calc_n_iter(molecular_calc_chunk):\n\tn_iter = 7\n\tassert molecular_calc_chunk.n_iter == n_iter\n\tassert molecular_calc_chunk.results[\"n_iter\"] == n_iter\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_dipole", "data": "def test_molecular_calc_dipole(molecular_calc_chunk):\n\tdipole = [0.260286493869765, 0.336152447755231, 0.470003778119121e-15]\n\tassert np.allclose(molecular_calc_chunk.dipole, dipole)\n\tassert np.allclose(molecular_calc_chunk.atoms.get_dipole_moment(), dipole)\n\tassert np.allclose(molecular_calc_chunk.results[\"dipole\"], dipole)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_is_metallic", "data": "def test_molecular_calc_is_metallic(molecular_calc_chunk):\n\tassert not molecular_calc_chunk.is_metallic\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_converged", "data": "def test_molecular_calc_converged(molecular_calc_chunk):\n\tassert molecular_calc_chunk.converged\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "molecular_hirshfeld_charges", "data": "def molecular_hirshfeld_charges():\n\treturn np.array([-0.32053200, 0.16022630, 0.16020375])\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_hirshfeld_charges", "data": "def test_molecular_calc_hirshfeld_charges(\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_hirshfeld_volumes", "data": "def test_molecular_calc_hirshfeld_volumes(molecular_calc_chunk):\n\thirshfeld_volumes = np.array([21.83060659, 6.07674041, 6.07684447])\n\tassert np.allclose(\n\t\tmolecular_calc_chunk.hirshfeld_volumes,\n\t\thirshfeld_volumes)\n\tassert np.allclose(\n\t\tmolecular_calc_chunk.results[\"hirshfeld_volumes\"], hirshfeld_volumes\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_hirshfeld_atomic_dipoles", "data": "def test_molecular_calc_hirshfeld_atomic_dipoles(molecular_calc_chunk):\n\thirshfeld_atomic_dipoles = np.array(\n\t\t[\n\t\t\t[0.04249319, 0.05486053, 0.00000000],\n\t\t\t[0.13710134, -0.00105126, 0.00000000],\n\t\t\t[-0.03534982, 0.13248706, 0.00000000],\n\t\t]\n\t)\n\tassert np.allclose(\n\t\tmolecular_calc_chunk.hirshfeld_atomic_dipoles, hirshfeld_atomic_dipoles\n\t)\n\tassert np.allclose(\n\t\tmolecular_calc_chunk.results[\"hirshfeld_atomic_dipoles\"],\n\t\thirshfeld_atomic_dipoles,\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_hirshfeld_dipole", "data": "def test_molecular_calc_hirshfeld_dipole(\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_eigenvalues", "data": "def test_molecular_calc_eigenvalues(molecular_calc_chunk):\n\teigenvalues = [\n\t\t-507.24511,\n\t\t-24.99226,\n\t\t-13.12175,\n\t\t-9.21626,\n\t\t-7.19543,\n\t\t-0.01127,\n\t\t2.58616,\n\t]\n\tassert np.allclose(molecular_calc_chunk.eigenvalues[0, :, 0], eigenvalues)\n\tassert np.allclose(\n\t\tmolecular_calc_chunk.results[\"eigenvalues\"][0, :, 0], eigenvalues\n\t)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}, {"term": "def", "name": "test_molecular_calc_occupancies", "data": "def test_molecular_calc_occupancies(molecular_calc_chunk):\n\toccupancies = [\n\t\t2.0,\n\t\t2.0,\n\t\t2.0,\n\t\t2.0,\n\t\t2.0,\n\t\t0.0,\n\t\t0.0,\n\t]\n\tassert np.allclose(molecular_calc_chunk.occupancies[0, :, 0], occupancies)\n\tassert np.allclose(\n\t\tmolecular_calc_chunk.results[\"occupancies\"][0, :, 0], occupancies\n\t)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.io import read", "from ase.io.aims import (", "from ase.stress import full_3x3_to_voigt_6_stress", "from numpy.linalg import norm", "import pytest"]}], [{"term": "def", "name": "test_calculator_label", "data": "def test_calculator_label():\n\tfrom ase.calculators.calculator import Calculator\n\n\tcalc = Calculator()\n\tassert calc.directory == '.'\n\tassert calc.prefix is None\n\tassert calc.label is None\n\n\tcalc.label = 'dir/pref'\n\tassert calc.directory == 'dir'\n\tassert calc.prefix == 'pref'\n\tassert calc.label == 'dir/pref'\n\n\tcalc.label = 'dir2/'\n\tassert calc.directory == 'dir2'\n\tassert calc.prefix is None\n\tassert calc.label == 'dir2/'\n\n\tcalc.label = 'hello'\n\tassert calc.directory == '.'\n\tassert calc.prefix == 'hello'\n\tassert calc.label == 'hello'\n\n\tcalc.label = None\n\tassert calc.label is None\n\tassert calc.prefix is None\n\tassert calc.directory == '.'\n", "description": null, "category": "math", "imports": ["\tfrom ase.calculators.calculator import Calculator"]}], [{"term": "def", "name": "test_directory_and_label", "data": "def test_directory_and_label():\n\tdef normalize(path):\n\t\t\"\"\"Helper function to normalize path\"\"\"\n\t\treturn str(Path(path))\n\n\tcalc = Calculator()\n\n\tassert calc.directory == '.'\n\tassert calc.label is None\n\n\tcalc.directory = 'somedir'\n\n\tassert calc.directory == 'somedir'\n\tassert calc.label == 'somedir/'\n\n\t# We cannot redundantly specify directory\n\twith pytest.raises(ValueError):\n\t\tcalc = Calculator(directory='somedir',\n\t\t\t\t\t\t  label='anotherdir/label')\n\n\t# Test only directory in directory\n\tcalc = Calculator(directory='somedir',\n\t\t\t\t\t  label='label')\n\n\tassert calc.directory == 'somedir'\n\tassert calc.label == 'somedir/label'\n\n\twdir = '/home/somedir'\n\tcalc = Calculator(directory=wdir,\n\t\t\t\t\t  label='label')\n\n\tassert calc.directory == normalize(wdir)\n\tassert calc.label == normalize(wdir) + '/label'\n\n\t# Test we can handle pathlib directories\n\twdir = Path('/home/somedir')\n\tcalc = Calculator(directory=wdir,\n\t\t\t\t\t  label='label')\n\tassert calc.directory == normalize(wdir)\n\tassert calc.label == normalize(wdir) + '/label'\n\n\twith pytest.raises(ValueError):\n\t\tcalc = Calculator(directory=wdir,\n\t\t\t\t\t\t  label='somedir/label')\n\n\t# Passing in empty directories with directories in label should be OK\n\tfor wdir in ['somedir', '/home/directory']:\n\t\tlabel = wdir + '/label'\n\t\texpected_label = normalize(wdir) + '/label'\n\t\tcalc = Calculator(directory='', label=label)\n\t\tassert calc.label == expected_label\n\t\tassert calc.directory == normalize(wdir)\n\n\t\tcalc = Calculator(directory='.', label=label)\n\t\tassert calc.label == expected_label\n\t\tassert calc.directory == normalize(wdir)\n\n", "description": "Helper function to normalize path", "category": "math", "imports": ["from pathlib import Path", "import pytest", "from ase.calculators.calculator import Calculator"]}, {"term": "def", "name": "test_deprecated_get_spin_polarized", "data": "def test_deprecated_get_spin_polarized():\n\tcalc = Calculator()\n\twith pytest.warns(FutureWarning):\n\t\tspinpol = calc.get_spin_polarized()\n\tassert spinpol is False\n", "description": null, "category": "math", "imports": ["from pathlib import Path", "import pytest", "from ase.calculators.calculator import Calculator"]}], [], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "atoms", "data": "def atoms():\n\treturn molecule('H2', vacuum=2.0)\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_geoopt", "data": "def test_geoopt(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(label='test_H2_GOPT', print_level='LOW')\n\tatoms.calc = calc\n\n\twith BFGS(atoms, logfile=None) as gopt:\n\t\tgopt.run(fmax=1e-6)\n\n\tdist = atoms.get_distance(0, 1)\n\tdist_ref = 0.7245595\n\tassert (dist - dist_ref) / dist_ref < 1e-7\n\n\tenergy_ref = -30.7025616943\n\tenergy = atoms.get_potential_energy()\n\tassert (energy - energy_ref) / energy_ref < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_lda", "data": "def test_h2_lda(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(label='test_H2_LDA')\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -30.6989595886\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_libxc", "data": "def test_h2_libxc(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(\n\t\txc='XC_GGA_X_PBE XC_GGA_C_PBE',\n\t\tpseudo_potential=\"GTH-PBE\",\n\t\tlabel='test_H2_libxc')\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -31.591716529642\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_ls", "data": "def test_h2_ls(cp2k_factory, atoms):\n\tinp = \"\"\"&FORCE_EVAL\n\t\t\t   &DFT\n\t\t\t\t &QS\n\t\t\t\t   LS_SCF ON\n\t\t\t\t &END QS\n\t\t\t   &END DFT\n\t\t\t &END FORCE_EVAL\"\"\"\n\tcalc = cp2k_factory.calc(label='test_H2_LS', inp=inp)\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -30.6989581747\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 5e-7\n\n", "description": "&FORCE_EVAL\n\t\t\t   &DFT\n\t\t\t\t &QS\n\t\t\t\t   LS_SCF ON\n\t\t\t\t &END QS\n\t\t\t   &END DFT\n\t\t\t &END FORCE_EVAL", "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_pbe", "data": "def test_h2_pbe(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(xc='PBE', label='test_H2_PBE')\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -31.5917284949\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_md", "data": "def test_md(cp2k_factory):\n\tcalc = cp2k_factory.calc(label='test_H2_MD')\n\tpositions = [(0, 0, 0), (0, 0, 0.7245595)]\n\tatoms = Atoms('HH', positions=positions, calculator=calc)\n\tatoms.center(vacuum=2.0)\n\n\tMaxwellBoltzmannDistribution(atoms, temperature_K=0.5 * 300,\n\t\t\t\t\t\t\t\t force_temp=True)\n\tenergy_start = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n\twith VelocityVerlet(atoms, 0.5 * units.fs) as dyn:\n\t\tdyn.run(20)\n\n\tenergy_end = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n\tassert abs(energy_start - energy_end) < 1e-4\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_o2", "data": "def test_o2(cp2k_factory):\n\tcalc = cp2k_factory.calc(\n\t\tlabel='test_O2', uks=True, cutoff=150 * units.Rydberg,\n\t\tbasis_set=\"SZV-MOLOPT-SR-GTH\")\n\to2 = molecule('O2', calculator=calc)\n\to2.center(vacuum=2.0)\n\tenergy = o2.get_potential_energy()\n\tenergy_ref = -861.057011375\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_restart", "data": "def test_restart(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc()\n\tatoms.calc = calc\n\tatoms.get_potential_energy()\n\tcalc.write('test_restart')  # write a restart\n\tcalc2 = cp2k_factory.calc(restart='test_restart')  # load a restart\n\tassert not calc2.calculation_required(atoms, ['energy'])\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_unknown_keywords", "data": "def test_unknown_keywords(cp2k_factory):\n\twith pytest.raises(CalculatorSetupError):\n\t\tcp2k_factory.calc(dummy_nonexistent_keyword='hello')\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}], [{"term": "def", "name": "run", "data": "def run(atoms):\n\tatoms.get_forces()\n\tprint(sorted(atoms.calc.results))\n\tfor key, value in atoms.calc.results.items():\n\t\tif isinstance(value, np.ndarray):\n\t\t\tprint(key, value.shape, value.dtype)\n\t\telse:\n\t\t\tprint(key, value)\n\n\tfor name in required_quantities:\n\t\tassert name in atoms.calc.results\n\n\treturn atoms.calc.results\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_si", "data": "def test_si(factory):\n\tatoms = bulk('Si')\n\tatoms.calc = factory.calc(nbands=4 * len(atoms), kpts=[4, 4, 4])\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_au", "data": "def test_au(factory, pps):\n\tatoms = bulk('Au')\n\tatoms.calc = factory.calc(\n\t\tpps=pps,\n\t\tnbands=10 * len(atoms),\n\t\ttsmear=0.1,\n\t\toccopt=3,\n\t\tkpts=[2, 2, 2],\n\t\tpawecutdg=6.0 * Hartree,\n\t)\n\t# Somewhat awkward to set pawecutdg also when we are not doing paw,\n\t# but it's an error to pass None as pawecutdg.\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "fe_atoms", "data": "def fe_atoms():\n\treturn bulk('Fe')\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "getkwargs", "data": "def getkwargs(**kw):\n\treturn dict(nbands=8, kpts=[2, 2, 2])\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_fe_magmom", "data": "def test_fe_magmom(factory, fe_atoms):\n\tfe_atoms.calc = factory.calc()\n\trun(fe_atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_h2o", "data": "def test_h2o(factory):\n\tatoms = molecule('H2O', vacuum=2.5)\n\tatoms.calc = factory.calc()\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_o2", "data": "def test_o2(factory):\n\tatoms = molecule('O2', vacuum=2.5)\n\tatoms.calc = factory.calc()\n\trun(atoms)\n\tmagmom = atoms.get_magnetic_moment()\n\tassert magmom == pytest.approx(2, 1e-2)\n\tprint('magmom', magmom)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_manykpts", "data": "def test_manykpts(factory):\n\tatoms = bulk('Au') * (2, 2, 2)\n\tatoms.rattle(stdev=0.01)\n\tatoms.symbols[:2] = 'Cu'\n\tatoms.calc = factory.calc(nbands=len(atoms) * 7, kpts=[8, 8, 8])\n\trun(atoms, 'manykpts')\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_manyatoms", "data": "def test_manyatoms(factory):\n\tatoms = bulk('Ne', cubic=True) * (4, 2, 2)\n\tatoms.rattle(stdev=0.01)\n\tatoms.calc = factory.calc(nbands=len(atoms) * 5)\n\trun(atoms, 'manyatoms')\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}], [{"term": "def", "name": "Atoms_fcc_Ni_with_H_at_center", "data": "def Atoms_fcc_Ni_with_H_at_center():\n\tatoms = bulk(\"Ni\", cubic=True)\n\tatoms += Atom(\"H\", position=atoms.cell.diagonal() / 2)\n\treturn atoms\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "lammps_data_file_Fe", "data": "def lammps_data_file_Fe(datadir):\n\treturn datadir / \"lammpslib_simple_input.data\"\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "calc_params_Fe", "data": "def calc_params_Fe(lammps_data_file_Fe):\n\tcalc_params = {}\n\tcalc_params[\"lammps_header\"] = [\n\t\t\"units\t\t   real\",\n\t\t\"atom_style\t  full\",\n\t\t\"boundary\t\tp p p\",\n\t\t\"box tilt\t\tlarge\",\n\t\t\"pair_style\t  lj/cut/coul/long 12.500\",\n\t\t\"bond_style\t  harmonic\",\n\t\t\"angle_style\t harmonic\",\n\t\t\"kspace_style\tewald 0.0001\",\n\t\t\"kspace_modify   gewald 0.01\",\n\t\tf\"read_data\t  {lammps_data_file_Fe}\",\n\t]\n\tcalc_params[\"lmpcmds\"] = []\n\tcalc_params[\"atom_types\"] = {\"Fe\": 1}\n\tcalc_params[\"create_atoms\"] = False\n\tcalc_params[\"create_box\"] = False\n\tcalc_params[\"boundary\"] = False\n\tcalc_params[\"log_file\"] = \"test.log\"\n\tcalc_params[\"keep_alive\"] = True\n\treturn calc_params\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "Atoms_Fe", "data": "def Atoms_Fe(lammps_data_file_Fe):\n\tAtoms_Fe = ase.io.read(\n\t\tlammps_data_file_Fe,\n\t\tformat=\"lammps-data\",\n\t\tZ_of_type={1: 26},\n\t\tunits=\"real\",\n\t)\n\treturn Atoms_Fe\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_lammpslib_simple", "data": "def test_lammpslib_simple(\n\tfactory,\n\tcalc_params_NiH,\n\tAtoms_fcc_Ni_with_H_at_center,\n\tcalc_params_Fe,\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}], [{"term": "def", "name": "solution", "data": "def solution(dartResult):\n\tcalc = ''\n\tfor i in dartResult:\n\t\tif i == 'S':\n\t\t\tcalc += '^1'\n\t\telif i == 'D':\n\t\t\tcalc += '^2'\n\t\telif i == 'T':\n\t\t\tcalc += '^3'\n\t\telif i == '#':\n\t\t\tcalc += '*(-1)'\n\t\t\tcalc = calc.replace('+*','*')\n\t\telif i == '*':\n\t\t\ttemp = []\n\t\t\tfor i in range(len(calc)):\n\t\t\t\tif calc[i] == '+':\n\t\t\t\t\ttemp.append(i)\n\t\t\tif(temp == []):\n\t\t\t\tcalc += '*2+'\n\t\t\telif(len(temp) == 1):\n\t\t\t\tcalc += '*2+'\n\t\t\ttemp = sorted(temp, reverse=True)[0:2]\n\t\t\tfor i in temp:\n\t\t\t\tprint(temp)\n\t\t\t\trestText = calc[i:]\n\t\t\t\tcalc = calc[0:i] + '*2' + restText\n\t\telse :\n\t\t\tcalc += i\n\t\tif i is not dartResult[-1] and (i =='S' or i == 'D' or i =='T' or i == '#'):\n\t\t\t\tcalc += '+'\n\tcalc = calc.rstrip('+').replace('^','**')\n\treturn eval(calc)\n", "description": null, "category": "math", "imports": []}, {"term": "def", "name": "best_solution", "data": "def best_solution(dartResult):\n\tscore = []\n\tn = ''\n\tfor i in dartResult:\n\t\tif i.isnumeric():\n\t\t\tn += i\n\t\telif i == 'S':\n\t\t\tscore.append(int(n) ** 1)\n\t\t\tn = ''\n\t\telif i == 'D':\n\t\t\tscore.append(int(n) ** 2)\n\t\t\tn = ''\n\t\telif i == 'T':\n\t\t\tscore.append(int(n) ** 3)\n\t\t\tn = ''\n\t\telif i == '*':\n\t\t\tif len(score) > 1:\n\t\t\t\tscore[-2] *= 2\n\t\t\tscore[-1] *= 2\n\t\telif i == '#':\n\t\t\tscore[-1] *= -1\n\treturn sum(score)\n", "description": null, "category": "math", "imports": []}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"Cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "test_h2dft_old", "data": "def test_h2dft_old(name):\n\tfactory = ObsoleteFactoryWrapper(name)\n\trun(factory)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "test_h2dft", "data": "def test_h2dft(factory):\n\trun(factory)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "run", "data": "def run(factory):\n\tname = factory.name\n\tcalc = factory.calc(label=name, xc='LDA')\n\th2 = molecule('H2', calculator=calc)\n\th2.center(vacuum=2.0)\n\te2 = h2.get_potential_energy()\n\tcalc.set(xc='PBE')\n\te2pbe = h2.get_potential_energy()\n\th1 = h2.copy()\n\tdel h1[1]\n\th1.set_initial_magnetic_moments([1])\n\th1.calc = calc\n\te1pbe = h1.get_potential_energy()\n\tcalc.set(xc='LDA')\n\te1 = h1.get_potential_energy()\n\ttry:\n\t\tm1 = h1.get_magnetic_moment()\n\texcept NotImplementedError:\n\t\tpass\n\telse:\n\t\tprint(m1)\n\tprint(2 * e1 - e2)\n\tprint(2 * e1pbe - e2pbe)\n\tprint(e1, e2, e1pbe, e2pbe)\n\tcalc = factory.calc(restart=name)\n\tprint(calc.parameters, calc.results, calc.atoms)\n\tassert not calc.calculation_required(h1, ['energy'])\n\th1 = calc.get_atoms()\n\tprint(h1.get_potential_energy())\n\tlabel = 'dir/' + name + '-h1'\n\tcalc = factory.calc(label=label, atoms=h1, xc='LDA')\n\tprint(h1.get_potential_energy())\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}], [{"term": "def", "name": "system", "data": "def system():\n\treturn bulk('Al', 'fcc', a=4.5, cubic=True)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_net_charge", "data": "def test_vasp_net_charge(factory, system):\n\t\"\"\"Run VASP tests to ensure that determining number of electrons from\n\tuser-supplied net charge (via the deprecated net_charge parameter) works\n\tcorrectly. This is conditional on the existence of the VASP_COMMAND or\n\tVASP_SCRIPT environment variables.\n\n\tThis is mainly a slightly reduced duplicate of the vasp_charge\n\ttest, but with flipped signs and with checks that ensure\n\tFutureWarning is emitted.\n\n\tShould be removed along with the net_charge parameter itself at\n\tsome point.\"\"\"\n\n\t# Dummy calculation to let VASP determine default number of electrons\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False)\n\tcalc.calculate(system)\n\tdefault_nelect_from_vasp = calc.get_number_of_electrons()\n\tassert default_nelect_from_vasp == 12\n\n\t# Compare VASP's output nelect from before + net charge to default nelect\n\t# determined by us + net charge\n\twith pytest.warns(FutureWarning):\n\t\tnet_charge = -2\n\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\tnet_charge=net_charge)\n\t\tcalc.initialize(system)\n\t\tcalc.write_input(system)\n\t\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] == default_nelect_from_vasp + net_charge\n\n\t# Test that conflicts between explicitly given nelect and net charge are\n\t# detected\n\twith pytest.raises(ValueError):\n\t\twith pytest.warns(FutureWarning):\n\t\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\t\tnelect=default_nelect_from_vasp + net_charge +\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tnet_charge=net_charge)\n\t\t\tcalc.calculate(system)\n\n\t# Test that conflicts between charge and net_charge are detected\n\twith pytest.raises(ValueError):\n\t\twith pytest.warns(FutureWarning):\n\t\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\t\tcharge=-net_charge - 1,\n\t\t\t\t\t\t\t\tnet_charge=net_charge)\n\t\t\tcalc.calculate(system)\n\n\t# Test that nothing is written if net charge is 0 and nelect not given\n\twith pytest.warns(FutureWarning):\n\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\tnet_charge=0)\n\t\tcalc.initialize(system)\n\t\tcalc.write_input(system)\n\t\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] is None\n", "description": "Run VASP tests to ensure that determining number of electrons from\n\tuser-supplied net charge (via the deprecated net_charge parameter) works\n\tcorrectly. This is conditional on the existence of the VASP_COMMAND or\n\tVASP_SCRIPT environment variables.\n\n\tThis is mainly a slightly reduced duplicate of the vasp_charge\n\ttest, but with flipped signs and with checks that ensure\n\tFutureWarning is emitted.\n\n\tShould be removed along with the net_charge parameter itself at\n\tsome point.", "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}], [{"term": "def", "name": "test_al", "data": "def test_al(factory):\n\tname = factory.name\n\t# What on earth does kpts=1.0 mean?  Was failing, I changed it.  --askhl\n\t# Disabled GPAW since it was failing anyway. --askhl\n\tkpts = [2, 2, 2]\n\tcalc = factory.calc(label=name, xc='LDA', kpts=kpts)\n\tal = bulk('AlO', crystalstructure='rocksalt', a=4.5)\n\tal.calc = calc\n\te = al.get_potential_energy()\n\tcalc.set(xc='PBE', kpts=kpts)\n\tepbe = al.get_potential_energy()\n\tprint(e, epbe)\n\tcalc = factory.calc(restart=name)\n\tprint(calc.parameters, calc.results, calc.atoms)\n\tassert not calc.calculation_required(al, ['energy'])\n\tal = calc.get_atoms()\n\tprint(al.get_potential_energy())\n\tlabel = 'dir/' + name + '-2'\n\tcalc = factory.calc(label=label, atoms=al, xc='LDA', kpts=kpts)\n\tprint(al.get_potential_energy())\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}], [{"term": "class", "name": "EvaluatorTest", "data": "class EvaluatorTest(unittest.TestCase):\n\t\"\"\"\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t\"\"\"\n\n\tdef test_number_input(self):\n\t\t\"\"\"\n\t\tTest different kinds of float inputs\n\n\t\tSee also\n\t\t  test_trailing_period (slightly different)\n\t\t  test_exponential_answer\n\t\t  test_si_suffix\n\t\t\"\"\"\n\t\teasy_eval = lambda x: calc.evaluator({}, {}, x)\n\n\t\tself.assertEqual(easy_eval(\"13\"), 13)\n\t\tself.assertEqual(easy_eval(\"3.14\"), 3.14)\n\t\tself.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n\t\tself.assertEqual(easy_eval(\"-13\"), -13)\n\t\tself.assertEqual(easy_eval(\"-3.14\"), -3.14)\n\t\tself.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n\tdef test_period(self):\n\t\t\"\"\"\n\t\tThe string '.' should not evaluate to anything.\n\t\t\"\"\"\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '.')\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '1+.')\n\n\tdef test_trailing_period(self):\n\t\t\"\"\"\n\t\tTest that things like '4.' will be 4 and not throw an error\n\t\t\"\"\"\n\t\tself.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n\tdef test_exponential_answer(self):\n\t\t\"\"\"\n\t\tTest for correct interpretation of scientific notation\n\t\t\"\"\"\n\t\tanswer = 50\n\t\tcorrect_responses = [\n\t\t\t\"50\", \"50.0\", \"5e1\", \"5e+1\",\n\t\t\t\"50e0\", \"50.0e0\", \"500e-1\"\n\t\t]\n\t\tincorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n\t\tfor input_str in correct_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\t\tfor input_str in incorrect_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to not equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertNotEqual(answer, result, msg=fail_msg)\n\n\tdef test_si_suffix(self):\n\t\t\"\"\"\n\t\tTest calc.py's unique functionality of interpreting si 'suffixes'.\n\n\t\tFor instance 'k' stand for 'kilo-' so '1k' should be 1,000\n\t\t\"\"\"\n\t\ttest_mapping = [\n\t\t\t('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n\t\t\t('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n\t\t\t('5.4m', 0.0054), ('8.7u', 0.0000087),\n\t\t\t('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n\t\t]\n\n\t\tfor (expr, answer) in test_mapping:\n\t\t\ttolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n\t\t\tfail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n\t\t\tfail_msg = fail_msg.format(expr[-1], expr, answer)\n\t\t\tself.assertAlmostEqual(\n\t\t\t\tcalc.evaluator({}, {}, expr), answer,\n\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t)\n\n\tdef test_operator_sanity(self):\n\t\t\"\"\"\n\t\tTest for simple things like '5+2' and '5/2'\n\t\t\"\"\"\n\t\tvar1 = 5.0\n\t\tvar2 = 2.0\n\t\toperators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n\t\tfor (operator, answer) in operators:\n\t\t\tinput_str = \"{0} {1} {2}\".format(var1, operator, var2)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n\t\t\t\toperator, input_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\tdef test_raises_zero_division_err(self):\n\t\t\"\"\"\n\t\tEnsure division by zero gives an error\n\t\t\"\"\"\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0.0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({'x': 0.0}, {}, '1/x')\n\n\tdef test_parallel_resistors(self):\n\t\t\"\"\"\n\t\tTest the parallel resistor operator ||\n\n\t\tThe formula is given by\n\t\t\ta || b || c ...\n\t\t\t= 1 / (1/a + 1/b + 1/c + ...)\n\t\tIt is the resistance of a parallel circuit of resistors with resistance\n\t\ta, b, c, etc&. See if this evaulates correctly.\n\t\t\"\"\"\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n\t\tself.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n\tdef test_parallel_resistors_with_zero(self):\n\t\t\"\"\"\n\t\tCheck the behavior of the || operator with 0\n\t\t\"\"\"\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n\tdef assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n\t\t\"\"\"\n\t\tHelper function to test many values at once\n\n\t\tTest the accuracy of evaluator's use of the function given by fname\n\t\tSpecifically, the equality of `fname(ins[i])` against outs[i].\n\t\tThis is used later to test a whole bunch of f(x) = y at a time\n\t\t\"\"\"\n\n\t\tfor (arg, val) in zip(ins, outs):\n\t\t\tinput_str = \"{0}({1})\".format(fname, arg)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n\t\t\t\tfname, input_str, val\n\t\t\t)\n\t\t\tself.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n\tdef test_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the trig functions provided in calc.py\n\n\t\twhich are: sin, cos, tan, arccos, arcsin, arctan\n\t\t\"\"\"\n\n\t\tangles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n\t\tcos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n\t\ttan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n\t\t# Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n\t\tself.assert_function_values('sin', angles, sin_values)\n\t\tself.assert_function_values('cos', angles, cos_values)\n\t\tself.assert_function_values('tan', angles, tan_values)\n\n\t\t# Include those where the real part is between -pi/2 and pi/2\n\t\tarcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n\t\tarcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n\t\tself.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n\t\t# Rather than a complex number, numpy.arcsin gives nan\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n\t\t# Include those where the real part is between 0 and pi\n\t\tarccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n\t\tarccos_angles = [0, 0.524, 0.628, 1 + 1j]\n\t\tself.assert_function_values('arccos', arccos_inputs, arccos_angles)\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n\t\t# Has the same range as arcsin\n\t\tarctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n\t\tarctan_angles = arcsin_angles\n\t\tself.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n\tdef test_reciprocal_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the reciprocal trig functions provided in calc.py\n\n\t\twhich are: sec, csc, cot, arcsec, arccsc, arccot\n\t\t\"\"\"\n\t\tangles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n\t\tcsc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n\t\tcot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n\t\tself.assert_function_values('sec', angles, sec_values)\n\t\tself.assert_function_values('csc', angles, csc_values)\n\t\tself.assert_function_values('cot', angles, cot_values)\n\n\t\tarcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n\t\tarcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n\t\tself.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n\t\tarccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n\t\tarccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n\t\tself.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n\t\t# Has the same range as arccsc\n\t\tarccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n\t\tarccot_angles = arccsc_angles\n\t\tself.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n\tdef test_hyperbolic_functions(self):\n\t\t\"\"\"\n\t\tTest the hyperbolic functions\n\n\t\twhich are: sinh, cosh, tanh, sech, csch, coth\n\t\t\"\"\"\n\t\tinputs = ['0', '0.5', '1', '2', '1+j']\n\t\tneg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n\t\tnegate = lambda x: [-k for k in x]\n\n\t\t# sinh is odd\n\t\tsinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n\t\tself.assert_function_values('sinh', inputs, sinh_vals)\n\t\tself.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n\t\t# cosh is even - do not negate\n\t\tcosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n\t\tself.assert_function_values('cosh', inputs, cosh_vals)\n\t\tself.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n\t\t# tanh is odd\n\t\ttanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n\t\tself.assert_function_values('tanh', inputs, tanh_vals)\n\t\tself.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n\t\t# sech is even - do not negate\n\t\tsech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n\t\tself.assert_function_values('sech', inputs, sech_vals)\n\t\tself.assert_function_values('sech', neg_inputs, sech_vals)\n\n\t\t# the following functions do not have 0 in their domain\n\t\tinputs = inputs[1:]\n\t\tneg_inputs = neg_inputs[1:]\n\n\t\t# csch is odd\n\t\tcsch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n\t\tself.assert_function_values('csch', inputs, csch_vals)\n\t\tself.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n\t\t# coth is odd\n\t\tcoth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n\t\tself.assert_function_values('coth', inputs, coth_vals)\n\t\tself.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n\tdef test_hyperbolic_inverses(self):\n\t\t\"\"\"\n\t\tTest the inverse hyperbolic functions\n\n\t\twhich are of the form arc[X]h\n\t\t\"\"\"\n\t\tresults = [0, 0.5, 1, 2, 1 + 1j]\n\n\t\tsinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n\t\tself.assert_function_values('arcsinh', sinh_vals, results)\n\n\t\tcosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n\t\tself.assert_function_values('arccosh', cosh_vals, results)\n\n\t\ttanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n\t\tself.assert_function_values('arctanh', tanh_vals, results)\n\n\t\tsech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n\t\tself.assert_function_values('arcsech', sech_vals, results)\n\n\t\tresults = results[1:]\n\t\tcsch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n\t\tself.assert_function_values('arccsch', csch_vals, results)\n\n\t\tcoth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n\t\tself.assert_function_values('arccoth', coth_vals, results)\n\n\tdef test_other_functions(self):\n\t\t\"\"\"\n\t\tTest the non-trig functions provided in calc.py\n\n\t\tSpecifically:\n\t\t  sqrt, log10, log2, ln, abs,\n\t\t  fact, factorial\n\t\t\"\"\"\n\n\t\t# Test sqrt\n\t\tself.assert_function_values(\n\t\t\t'sqrt',\n\t\t\t[0, 1, 2, 1024],  # -1\n\t\t\t[0, 1, 1.414, 32]  # 1j\n\t\t)\n\t\t# sqrt(-1) is NAN not j (!!).\n\n\t\t# Test logs\n\t\tself.assert_function_values(\n\t\t\t'log10',\n\t\t\t[0.1, 1, 3.162, 1000000, '1+j'],\n\t\t\t[-1, 0, 0.5, 6, 0.151 + 0.341j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'log2',\n\t\t\t[0.5, 1, 1.414, 1024, '1+j'],\n\t\t\t[-1, 0, 0.5, 10, 0.5 + 1.133j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'ln',\n\t\t\t[0.368, 1, 1.649, 2.718, 42, '1+j'],\n\t\t\t[-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n\t\t)\n\n\t\t# Test abs\n\t\tself.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n\t\t# Test factorial\n\t\tfact_inputs = [0, 1, 3, 7]\n\t\tfact_values = [1, 1, 6, 5040]\n\t\tself.assert_function_values('fact', fact_inputs, fact_values)\n\t\tself.assert_function_values('factorial', fact_inputs, fact_values)\n\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n\tdef test_constants(self):\n\t\t\"\"\"\n\t\tTest the default constants provided in calc.py\n\n\t\twhich are: j (complex number), e, pi, k, c, T, q\n\t\t\"\"\"\n\n\t\t# Of the form ('expr', python value, tolerance (or None for exact))\n\t\tdefault_variables = [\n\t\t\t('i', 1j, None),\n\t\t\t('j', 1j, None),\n\t\t\t('e', 2.7183, 1e-4),\n\t\t\t('pi', 3.1416, 1e-4),\n\t\t\t('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n\t\t\t('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n\t\t\t('T', 298.15, 0.01),  # Typical room temperature (Kelvin)\n\t\t\t('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n\t\t]\n\t\tfor (variable, value, tolerance) in default_variables:\n\t\t\tfail_msg = \"Failed on constant '{0}', not within bounds\".format(\n\t\t\t\tvariable\n\t\t\t)\n\t\t\tresult = calc.evaluator({}, {}, variable)\n\t\t\tif tolerance is None:\n\t\t\t\tself.assertEqual(value, result, msg=fail_msg)\n\t\t\telse:\n\t\t\t\tself.assertAlmostEqual(\n\t\t\t\t\tvalue, result,\n\t\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t\t)\n\n\tdef test_complex_expression(self):\n\t\t\"\"\"\n\t\tCalculate combinations of operators and default functions\n\t\t\"\"\"\n\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n\t\t\t10.180,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n\t\t\t1.6,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"10||sin(7+5)\"),\n\t\t\t-0.567, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"sin(e)\"),\n\t\t\t0.41, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"k*T/q\"),\n\t\t\t0.025, delta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"e^(j*pi)\"),\n\t\t\t-1, delta=1e-5\n\t\t)\n\n\tdef test_explicit_sci_notation(self):\n\t\t\"\"\"\n\t\tExpressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^-3\"),\n\t\t\t-0.0016\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n\t\t\t-0.0016\n\t\t)\n\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^3\"),\n\t\t\t-1600\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(3)\"),\n\t\t\t-1600\n\t\t)\n\n\tdef test_simple_vars(self):\n\t\t\"\"\"\n\t\tSubstitution of variables into simple equations\n\t\t\"\"\"\n\t\tvariables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n\t\t# Should not change value of constant\n\t\t# even with different numbers of variables...\n\t\tself.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n\t\t# Easy evaluation\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n\t\t# Test a simple equation\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, '3*x-y'),\n\t\t\t21.25, delta=0.01  # = 3 * 9.72 - 7.91\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, 'x*y'),\n\t\t\t76.89, delta=0.01\n\t\t)\n\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(\n\t\t\t\t{'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n\t\t\t\t{}, \"5\"\n\t\t\t),\n\t\t\t5\n\t\t)\n\n\tdef test_variable_case_sensitivity(self):\n\t\t\"\"\"\n\t\tTest the case sensitivity flag and corresponding behavior\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n\t\t\t8.0\n\t\t)\n\n\t\tvariables = {'t': 1.0}\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(variables, {}, \"t\", case_sensitive=True),\n\t\t\t1.0\n\t\t)\n\t\t# Recall 'T' is a default constant, with value 298.15\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, \"T\", case_sensitive=True),\n\t\t\t298, delta=0.2\n\t\t)\n\n\tdef test_simple_funcs(self):\n\t\t\"\"\"\n\t\tSubsitution of custom functions\n\t\t\"\"\"\n\t\tvariables = {'x': 4.712}\n\t\tfunctions = {'id': lambda x: x}\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n\t\tfunctions.update({'f': numpy.sin})\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, functions, 'f(x)'),\n\t\t\t-1, delta=1e-3\n\t\t)\n\n\tdef test_function_case_insensitive(self):\n\t\t\"\"\"\n\t\tTest case insensitive evaluation\n\n\t\tNormal functions with some capitals should be fine\n\t\t\"\"\"\n\t\tself.assertAlmostEqual(\n\t\t\t-0.28,\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n\t\t\tdelta=1e-3\n\t\t)\n\n\tdef test_function_case_sensitive(self):\n\t\t\"\"\"\n\t\tTest case sensitive evaluation\n\n\t\tIncorrectly capitilized should fail\n\t\tAlso, it should pick the correct version of a function.\n\t\t\"\"\"\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n\t\t# With case sensitive turned on, it should pick the right function\n\t\tfunctions = {'f': lambda x: x, 'F': lambda x: x + 1}\n\t\tself.assertEqual(\n\t\t\t6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n\t\t)\n\t\tself.assertEqual(\n\t\t\t7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n\t\t)\n\n\tdef test_undefined_vars(self):\n\t\t\"\"\"\n\t\tCheck to see if the evaluator catches undefined variables\n\t\t\"\"\"\n\t\tvariables = {'R1': 2.0, 'R3': 4.0}\n\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n\t\t\tcalc.evaluator({}, {}, \"5+7*QWSEKO\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n\t\t\tcalc.evaluator({'r1': 5}, {}, \"r1+r2\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n\t\t\tcalc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "description": "\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t", "category": "math", "imports": ["import unittest", "import numpy", "import calc", "from pyparsing import ParseException"]}], [{"term": "class", "name": "Ui_CalcIDLEPCDialog", "data": "class Ui_CalcIDLEPCDialog(object):\r\n\tdef setupUi(self, CalcIDLEPCDialog):\r\n\t\tCalcIDLEPCDialog.setObjectName(_fromUtf8(\"CalcIDLEPCDialog\"))\r\n\t\tCalcIDLEPCDialog.setWindowModality(QtCore.Qt.WindowModal)\r\n\t\tCalcIDLEPCDialog.resize(400, 300)\r\n\t\tsizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)\r\n\t\tsizePolicy.setHorizontalStretch(0)\r\n\t\tsizePolicy.setVerticalStretch(0)\r\n\t\tsizePolicy.setHeightForWidth(CalcIDLEPCDialog.sizePolicy().hasHeightForWidth())\r\n\t\tCalcIDLEPCDialog.setSizePolicy(sizePolicy)\r\n\t\tCalcIDLEPCDialog.setMinimumSize(QtCore.QSize(400, 300))\r\n\t\tCalcIDLEPCDialog.setMaximumSize(QtCore.QSize(400, 300))\r\n\t\ticon = QtGui.QIcon()\r\n\t\ticon.addPixmap(QtGui.QPixmap(_fromUtf8(\":/images/logo_icon.png\")), QtGui.QIcon.Normal, QtGui.QIcon.Off)\r\n\t\tCalcIDLEPCDialog.setWindowIcon(icon)\r\n\t\tCalcIDLEPCDialog.setModal(True)\r\n\t\tself.gridLayout = QtGui.QGridLayout(CalcIDLEPCDialog)\r\n\t\tself.gridLayout.setObjectName(_fromUtf8(\"gridLayout\"))\r\n\t\tself.textEdit = QtGui.QTextEdit(CalcIDLEPCDialog)\r\n\t\tself.textEdit.setReadOnly(True)\r\n\t\tself.textEdit.setObjectName(_fromUtf8(\"textEdit\"))\r\n\t\tself.gridLayout.addWidget(self.textEdit, 0, 0, 1, 2)\r\n\t\tself.progressBar = QtGui.QProgressBar(CalcIDLEPCDialog)\r\n\t\tself.progressBar.setProperty(\"value\", 0)\r\n\t\tself.progressBar.setObjectName(_fromUtf8(\"progressBar\"))\r\n\t\tself.gridLayout.addWidget(self.progressBar, 1, 0, 1, 1)\r\n\t\tself.pushButton = QtGui.QPushButton(CalcIDLEPCDialog)\r\n\t\tself.pushButton.setObjectName(_fromUtf8(\"pushButton\"))\r\n\t\tself.gridLayout.addWidget(self.pushButton, 1, 1, 1, 1)\r\n\r\n\t\tself.retranslateUi(CalcIDLEPCDialog)\r\n\t\tQtCore.QObject.connect(self.pushButton, QtCore.SIGNAL(_fromUtf8(\"clicked()\")), CalcIDLEPCDialog.cancel)\r\n\t\tQtCore.QMetaObject.connectSlotsByName(CalcIDLEPCDialog)\r\n\r\n\tdef retranslateUi(self, CalcIDLEPCDialog):\r\n\t\tCalcIDLEPCDialog.setWindowTitle(QtGui.QApplication.translate(\"CalcIDLEPCDialog\", \"Idle Pc Calculation\", None, QtGui.QApplication.UnicodeUTF8))\r\n\t\tself.pushButton.setText(QtGui.QApplication.translate(\"CalcIDLEPCDialog\", \"Cancel\", None, QtGui.QApplication.UnicodeUTF8))\r\n", "description": null, "category": "math", "imports": ["from PyQt4 import QtCore, QtGui\r", "import svg_resources_rc\r"]}], [{"term": "def", "name": "test_vasp_check_state", "data": "def test_vasp_check_state(factory, atoms_2co):\n\t\"\"\"Run tests to ensure that the VASP check_state() function call\n\tworks correctly, i.e. correctly sets the working directories and\n\tworks in that directory.\n\n\tThis is conditional on the existence of the VASP_COMMAND or\n\tVASP_SCRIPT environment variables\"\"\"\n\n\tatoms = atoms_2co  # aliasing\n\n\t# Test\n\tsettings = dict(xc='LDA',\n\t\t\t\t\tprec='Low',\n\t\t\t\t\talgo='Fast',\n\t\t\t\t\tismear=0,\n\t\t\t\t\tsigma=1.,\n\t\t\t\t\tistart=0,\n\t\t\t\t\tlwave=False,\n\t\t\t\t\tlcharg=False)\n\n\ts1 = atoms.get_chemical_symbols()\n\n\tcalc = factory.calc(**settings)\n\n\tatoms.calc = calc\n\n\ten1 = atoms.get_potential_energy()\n\n\t# Test JSON dumping and restarting works\n\tfi = 'json_test.json'\n\tcalc.write_json(filename=fi)\n\n\tassert os.path.isfile(fi)\n\n\tcalc2 = factory.calc()\n\tcalc2.read_json(fi)\n\tassert not calc2.calculation_required(atoms, ['energy', 'forces'])\n\ten2 = calc2.get_potential_energy()\n\tassert abs(en1 - en2) < 1e-8\n\tos.remove(fi)  # Clean up the JSON file\n\n\t# Check that the symbols remain in order (non-sorted)\n\ts2 = calc.atoms.get_chemical_symbols()\n\tassert s1 == s2\n\ts3 = sorted(s2)\n\tassert s2 != s3\n\n\t# Check that get_atoms() doesn't reset results\n\tr1 = dict(calc.results)  # Force a copy\n\tcalc.get_atoms()\n\tr2 = dict(calc.results)\n\tassert r1 == r2\n\n\t# Make a parameter change to the calculator\n\tcalc.set(sigma=0.5)\n\n\t# Check that we capture a change for float params\n\tassert calc.check_state(atoms) == ['float_params']\n\tassert calc.calculation_required(atoms, ['energy', 'forces'])\n\n\ten2 = atoms.get_potential_energy()\n\n\t# The change in sigma should result in a small change in energy\n\tassert (en1 - en2) > 1e-7\n\n\t# Now we make a change in input_params instead\n\tcalc.kpts = 2\n\n\t# Check that this requires a new calculation\n\tassert calc.check_state(atoms) == ['input_params']\n\tassert calc.calculation_required(atoms, ['energy', 'forces'])\n\n\t# Clean up\n\tcalc.clean()\n", "description": "Run tests to ensure that the VASP check_state() function call\n\tworks correctly, i.e. correctly sets the working directories and\n\tworks in that directory.\n\n\tThis is conditional on the existence of the VASP_COMMAND or\n\tVASP_SCRIPT environment variables", "category": "math", "imports": ["import os", "import pytest"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["from . import get_help", "import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["from . import get_help", "import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: f\"{get}/100\"})\n\t\t\tawait e.answer(str(f\"{get}/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: f\"{get}/\"})\n\t\t\tawait e.answer(str(f\"{get}/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: f\"{get}*\"})\n\t\t\tawait e.answer(str(f\"{get}*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["from . import get_help", "import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["from . import get_help", "import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "close", "data": "def close(val, reference, releps=releps, abseps=abseps):\n\tprint(val, reference)\n\tassert np.abs(val - reference) < max(np.abs(releps * reference), abseps)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "array_close", "data": "def array_close(val, reference, releps=releps, abseps=abseps):\n\tvalflat = val.flatten()\n\trefflat = reference.flatten()\n\tfor i, vali in enumerate(valflat):\n\t\tclose(vali, refflat[i], releps, abseps)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "system", "data": "def system():\n\treturn create_s22_system('Adenine-thymine_complex_stack')\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_forces", "data": "def test_forces(factory, system):\n\t# do all non-periodic calculations with Adenine-Thymine complex\n\n\t# Default is D3(zero)\n\tsystem.calc = factory.calc()\n\tclose(system.get_potential_energy(), -0.6681154466652238)\n\n\t# Only check forces once, for the default settings.\n\tf_ref = np.array(\n\t\t[[0.0088385621657399, -0.0118387210205813, -0.0143242057174889],\n\t\t [-0.0346912282737323, 0.0177797757792533, -0.0442349785529711],\n\t\t [0.0022759961575945, -0.0087458217241648, -0.0051887171699909],\n\t\t [-0.0049317224619103, -0.0215152368018880, -0.0062290998430756],\n\t\t [-0.0013032612752381, -0.0356240144088481, 0.0203401124180720],\n\t\t [-0.0110305568118348, -0.0182773178473497, -0.0023730575217145],\n\t\t [0.0036258610447203, -0.0074994162928053, -0.0144058177906650],\n\t\t [0.0005289754841564, -0.0035901842246731, -0.0103580836569947],\n\t\t [0.0051775352510856, -0.0051076755874038, -0.0103428268442285],\n\t\t [0.0011299493448658, -0.0185829345539878, -0.0087205807334006],\n\t\t [0.0128459160503721, -0.0248356605575975, 0.0007946691695359],\n\t\t [-0.0063194401470256, -0.0058117310787239, -0.0067932156139914],\n\t\t [0.0013749100498893, -0.0118259631230572, -0.0235404547526578],\n\t\t [0.0219558160992901, -0.0087512938555865, -0.0226017156485839],\n\t\t [0.0001168268736984, -0.0138384169778581, -0.0014850073023105],\n\t\t [0.0037893625607261, 0.0117649062330659, 0.0162375798918204],\n\t\t [0.0011352730068862, 0.0142002748861793, 0.0129337874676760],\n\t\t [-0.0049945288501837, 0.0073929058490670, 0.0088391871214417],\n\t\t [0.0039715118075548, 0.0186949615105239, 0.0114822052853407],\n\t\t [-0.0008003587963147, 0.0161735976004718, 0.0050357997715004],\n\t\t [-0.0033142342134453, 0.0153658921418049, -0.0026233088963388],\n\t\t [-0.0025451124688653, 0.0067994927521733, -0.0017127589489137],\n\t\t [-0.0010451311609669, 0.0067173068779992, 0.0044413725566098],\n\t\t [-0.0030829302438095, 0.0112138539867057, 0.0151213034444885],\n\t\t [0.0117240581287903, 0.0161749855643631, 0.0173269837053235],\n\t\t [-0.0025949288306356, 0.0158830629834040, 0.0155589787340858],\n\t\t [0.0083784268665834, 0.0082132824775010, 0.0090603749323848],\n\t\t [-0.0019694065480327, 0.0115576523485515, 0.0083901101633852],\n\t\t [-0.0020036820791533, 0.0109276020920431, 0.0204922407855956],\n\t\t [-0.0062424587308054, 0.0069848349714167, 0.0088791235460659]])\n\n\tarray_close(system.get_forces(), f_ref)\n\n\t# calculate numerical forces, but use very loose comparison criteria!\n\t# dftd3 doesn't print enough digits to stdout to get good convergence\n\tf_numer = numeric_forces(system, d=1e-4)\n\tarray_close(f_numer, f_ref, releps=1e-2, abseps=1e-3)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d2_old", "data": "def test_d2_old(factory, system):\n\tsystem.calc = factory.calc(old=True)\n\tclose(system.get_potential_energy(), -0.8923443424663762)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_bj", "data": "def test_d3_bj(factory, system):\n\tsystem.calc = factory.calc(damping='bj')\n\tclose(system.get_potential_energy(), -1.211193213979179)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_zerom", "data": "def test_d3_zerom(factory, system):\n\tsystem.calc = factory.calc(damping='zerom')\n\tclose(system.get_potential_energy(), -2.4574447613705717)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_bjm", "data": "def test_d3_bjm(factory, system):\n\tsystem.calc = factory.calc(damping='bjm')\n\tclose(system.get_potential_energy(), -1.4662085277005799)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_alternative_tz", "data": "def test_alternative_tz(factory, system):\n\tsystem.calc = factory.calc(tz=True)\n\tclose(system.get_potential_energy(), -0.6160295884482619)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_zero_abc", "data": "def test_d3_zero_abc(factory, system):\n\tsystem.calc = factory.calc(abc=True)\n\tclose(system.get_potential_energy(), -0.6528640090262864)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_zero_revpbe", "data": "def test_d3_zero_revpbe(factory, system):\n\tsystem.calc = factory.calc(xc='revpbe')\n\tclose(system.get_potential_energy(), -1.5274869363442936)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_bad_xc", "data": "def test_bad_xc(factory, system):\n\tsystem.calc = factory.calc(xc='does_not_exist')\n\twith pytest.raises(RuntimeError, match='Unknown DFTD3 functional name'):\n\t\tsystem.get_potential_energy()\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_custom_damping", "data": "def test_custom_damping(factory, system):\n\tsystem.calc = factory.calc(s6=1.1, sr6=1.1, s8=0.6, sr8=0.9, alpha6=13.0)\n\tclose(system.get_potential_energy(), -1.082846357973487)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_bj_abc", "data": "def test_d3_bj_abc(factory, system):\n\t# A couple of combinations, but not comprehensive\n\tsystem.calc = factory.calc(damping='bj', abc=True)\n\tclose(system.get_potential_energy(), -1.1959417763402416)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_zerom_b3lyp", "data": "def test_d3_zerom_b3lyp(factory, system):\n\tsystem.calc = factory.calc(damping='zerom', xc='b3-lyp')\n\tclose(system.get_potential_energy(), -1.3369234231047677)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_diamond_stress", "data": "def test_diamond_stress(factory, system):\n\tsystem = bulk('C')\n\n\tsystem.calc = factory.calc()\n\tclose(system.get_potential_energy(), -0.2160072476277501)\n\n\t# Do one stress for the default settings\n\ts_ref = np.array([0.0182329043326,\n\t\t\t\t\t  0.0182329043326,\n\t\t\t\t\t  0.0182329043326,\n\t\t\t\t\t  -3.22757439831e-14,\n\t\t\t\t\t  -3.22766949320e-14,\n\t\t\t\t\t  -3.22766949320e-14])\n\n\tarray_close(system.get_stress(), s_ref)\n\n\t# As with numerical forces, numerical stresses will not be very well\n\t# converged due to the limited number of digits printed to stdout\n\t# by dftd3. So, use very loose comparison criteria.\n\ts_numer = numeric_stress(system, d=1e-4)\n\tarray_close(s_numer, s_ref, releps=1e-2, abseps=1e-3)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_free_energy_bug", "data": "def test_free_energy_bug(factory):\n\t# Energy and free_energy should be close to equal.\n\t# Due to a bug related to legacy free_energy property handling,\n\t# it would double-count the free energy from the DFT calculation.\n\t# This test protects against that.\n\tatoms = bulk('Au', cubic=True)\n\tatoms.rattle(stdev=0.15)\n\n\tdftd3 = factory.calc(dft=EMT())\n\tatoms.calc = dftd3\n\n\te1, e2 = [atoms.get_potential_energy(force_consistent=x)\n\t\t\t  for x in [False, True]]\n\tassert e1 == pytest.approx(e2, abs=1e-14)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "class", "name": "EMTWithMagmoms", "data": "class EMTWithMagmoms(EMT):\n\timplemented_properties = [*EMT.implemented_properties, 'magmoms']\n\n\tdef dummy_magmoms(self, atoms):\n\t\treturn 1.234 + np.arange(len(atoms))\n\n\tdef calculate(self, atoms, *args, **kwargs):\n\t\tsuper().calculate(atoms, *args, **kwargs)\n\t\tself.results['magmoms'] = self.dummy_magmoms(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_non_dftd3_property", "data": "def test_non_dftd3_property(factory):\n\tdft = EMTWithMagmoms()\n\tcalc = factory.calc(dft=dft)\n\n\t# Our DFTD3 calculator should advertise that it supports this property:\n\tassert 'magmoms' in calc.implemented_properties\n\n\tatoms = bulk('Au', cubic=True)\n\tatoms.calc = calc\n\tmagmoms = atoms.get_magnetic_moments()\n\tassert magmoms == pytest.approx(dft.dummy_magmoms(atoms))\n\tprint('magmoms', magmoms)\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}], [{"term": "def", "name": "test_main", "data": "def test_main(factory, atoms_co):\n\n\t# simple test calculation of CO molecule\n\tco = atoms_co  # aliasing\n\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tprec='Low',\n\t\t\t\t\t\talgo='Fast',\n\t\t\t\t\t\tlorbit=11,\n\t\t\t\t\t\tismear=0,\n\t\t\t\t\t\tsigma=1.,\n\t\t\t\t\t\tnbands=12,\n\t\t\t\t\t\tistart=0,\n\t\t\t\t\t\tnelm=3,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tldipol=True)\n\n\tco.calc = calc\n\tenergy = co.get_potential_energy()\n\tforces = co.get_forces()\n\tdipole_moment = co.get_dipole_moment()\n\n\t# check that parsing of vasprun.xml file works\n\tconf = read('vasprun.xml')\n\tassert conf.calc.parameters['kpoints_generation']\n\tassert conf.calc.parameters['sigma'] == 1.0\n\tassert conf.calc.parameters['ialgo'] == 68\n\tassert energy - conf.get_potential_energy() == 0.0\n\n\t# Check some arrays\n\tassert np.allclose(conf.get_forces(), forces)\n\tassert np.allclose(conf.get_dipole_moment(), dipole_moment, atol=1e-6)\n\n\t# Check k-point-dependent properties\n\tassert len(conf.calc.get_eigenvalues(spin=0)) >= 12\n\tassert conf.calc.get_occupation_numbers()[2] == 2\n\tassert conf.calc.get_eigenvalues(spin=1) is None\n\tkpt = conf.calc.get_kpt(0)\n\tassert kpt.weight == 1.\n\n\t# Perform a spin-polarised calculation\n\tco.calc.set(ispin=2, ibrion=-1)\n\tco.get_potential_energy()\n\tconf = read('vasprun.xml')\n\tassert len(conf.calc.get_eigenvalues(spin=1)) >= 12\n\tassert conf.calc.get_occupation_numbers(spin=1)[0] == 1.\n\n\t# Cleanup\n\tcalc.clean()\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase.io import read"]}], [{"term": "class", "name": "classGaussianDynamics:", "data": "class GaussianDynamics:\n\tcalctype = 'optimizer'\n\tdelete = ['force']\n\tkeyword: Optional[str] = None\n\tspecial_keywords: Dict[str, str] = dict()\n\n\tdef __init__(self, atoms, calc=None):\n\t\tself.atoms = atoms\n\t\tif calc is not None:\n\t\t\tself.calc = calc\n\t\telse:\n\t\t\tif self.atoms.calc is None:\n\t\t\t\traise ValueError(\"{} requires a valid Gaussian calculator \"\n\t\t\t\t\t\t\t\t \"object!\".format(self.__class__.__name__))\n\n\t\t\tself.calc = self.atoms.calc\n\n\tdef todict(self):\n\t\treturn {'type': self.calctype,\n\t\t\t\t'optimizer': self.__class__.__name__}\n\n\tdef delete_keywords(self, kwargs):\n\t\t\"\"\"removes list of keywords (delete) from kwargs\"\"\"\n\t\tfor d in self.delete:\n\t\t\tkwargs.pop(d, None)\n\n\tdef set_keywords(self, kwargs):\n\t\targs = kwargs.pop(self.keyword, [])\n\t\tif isinstance(args, str):\n\t\t\targs = [args]\n\t\telif isinstance(args, Iterable):\n\t\t\targs = list(args)\n\n\t\tfor key, template in self.special_keywords.items():\n\t\t\tif key in kwargs:\n\t\t\t\tval = kwargs.pop(key)\n\t\t\t\targs.append(template.format(val))\n\n\t\tkwargs[self.keyword] = args\n\n\tdef run(self, **kwargs):\n\t\tcalc_old = self.atoms.calc\n\t\tparams_old = copy.deepcopy(self.calc.parameters)\n\n\t\tself.delete_keywords(kwargs)\n\t\tself.delete_keywords(self.calc.parameters)\n\t\tself.set_keywords(kwargs)\n\n\t\tself.calc.set(**kwargs)\n\t\tself.atoms.calc = self.calc\n\n\t\ttry:\n\t\t\tself.atoms.get_potential_energy()\n\t\texcept OSError:\n\t\t\tconverged = False\n\t\telse:\n\t\t\tconverged = True\n\n\t\tatoms = read(self.calc.label + '.log')\n\t\tself.atoms.cell = atoms.cell\n\t\tself.atoms.positions = atoms.positions\n\n\t\tself.calc.parameters = params_old\n\t\tself.calc.reset()\n\t\tif calc_old is not None:\n\t\t\tself.atoms.calc = calc_old\n\n\t\treturn converged\n\n", "description": "removes list of keywords (delete) from kwargs", "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}, {"term": "class", "name": "GaussianOptimizer", "data": "class GaussianOptimizer(GaussianDynamics):\n\tkeyword = 'opt'\n\tspecial_keywords = {\n\t\t'fmax': '{}',\n\t\t'steps': 'maxcycle={}',\n\t}\n\n", "description": null, "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}, {"term": "class", "name": "GaussianIRC", "data": "class GaussianIRC(GaussianDynamics):\n\tkeyword = 'irc'\n\tspecial_keywords = {\n\t\t'direction': '{}',\n\t\t'steps': 'maxpoints={}',\n\t}\n\n", "description": null, "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}, {"term": "class", "name": "Gaussian", "data": "class Gaussian(FileIOCalculator):\n\timplemented_properties = ['energy', 'forces', 'dipole']\n\tcommand = 'GAUSSIAN < PREFIX.com > PREFIX.log'\n\tdiscard_results_on_any_change = True\n\n\tdef __init__(self, *args, label='Gaussian', **kwargs):\n\t\tFileIOCalculator.__init__(self, *args, label=label, **kwargs)\n\n\tdef calculate(self, *args, **kwargs):\n\t\tgaussians = ('g16', 'g09', 'g03')\n\t\tif 'GAUSSIAN' in self.command:\n\t\t\tfor gau in gaussians:\n\t\t\t\tif which(gau):\n\t\t\t\t\tself.command = self.command.replace('GAUSSIAN', gau)\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\traise EnvironmentError('Missing Gaussian executable {}'\n\t\t\t\t\t\t\t\t\t   .format(gaussians))\n\n\t\tFileIOCalculator.calculate(self, *args, **kwargs)\n\n\tdef write_input(self, atoms, properties=None, system_changes=None):\n\t\tFileIOCalculator.write_input(self, atoms, properties, system_changes)\n\t\twrite(self.label + '.com', atoms, properties=properties,\n\t\t\t  format='gaussian-in', parallel=False, **self.parameters)\n\n\tdef read_results(self):\n\t\toutput = read(self.label + '.log', format='gaussian-out')\n\t\tself.calc = output.calc\n\t\tself.results = output.calc.results\n\n\t# Method(s) defined in the old calculator, added here for\n\t# backwards compatibility\n\tdef clean(self):\n\t\tfor suffix in ['.com', '.chk', '.log']:\n\t\t\ttry:\n\t\t\t\tos.remove(os.path.join(self.directory, self.label + suffix))\n\t\t\texcept OSError:\n\t\t\t\tpass\n\n\tdef get_version(self):\n\t\traise NotImplementedError  # not sure how to do this yet\n", "description": null, "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}], [], [{"term": "def", "name": "test_turbomole_h2o", "data": "def test_turbomole_h2o():\n\tmol = molecule('H2O')\n\n\tparams = {\n\t\t'title': 'water',\n\t\t'task': 'geometry optimization',\n\t\t'use redundant internals': True,\n\t\t'basis set name': 'def2-SV(P)',\n\t\t'total charge': 0,\n\t\t'multiplicity': 1,\n\t\t'use dft': True,\n\t\t'density functional': 'b3-lyp',\n\t\t'use resolution of identity': True,\n\t\t'ri memory': 1000,\n\t\t'force convergence': 0.001,\n\t\t'geometry optimization iterations': 50,\n\t\t'scf iterations': 100\n\t}\n\n\tcalc = Turbomole(**params)\n\tmol.calc = calc\n\tcalc.calculate(mol)\n\tassert calc.converged\n\n\t# use the get_property() method\n\tenergy = calc.get_property('energy', mol, False)\n\tassert energy is not False\n\tassert np.isclose(energy, -2076.286138, atol=1e-5)\n\tforces = calc.get_property('forces', mol, False)\n\tassert forces is not False\n\tassert np.linalg.norm(forces) < 0.01\n\tdipole = np.linalg.norm(calc.get_property('dipole', mol, False))\n\tassert np.isclose(dipole, 0.448, rtol=0.01)\n\n\t# use the get_results() method\n\tresults = calc.get_results()\n\tprint(results['molecular orbitals'])\n\n\t# use the __getitem__() method\n\tprint(calc['results']['molecular orbitals'])\n\tprint(calc['results']['geometry optimization history'])\n\n\t# perform a normal mode calculation with the optimized structure\n\n\tparams.update({\n\t\t'task': 'normal mode analysis',\n\t\t'density convergence': 1.0e-7\n\t})\n\n\tcalc = Turbomole(**params)\n\tmol.calc = calc\n\tcalc.calculate(mol)\n\n\tspectrum = calc['results']['vibrational spectrum']\n\tfreq_ref = [0, 0, 0, 0, 0, 0, 1633, 3637, 3745]\n\tfor s in spectrum:\n\t\tfor freq, mode in zip(freq_ref, range(1, 7)):\n\t\t\tif s['mode number'] == mode:\n\t\t\t\tassert np.isclose(s['frequency']['value'], freq, rtol=0.05)\n\n\tprint(calc.todict(skip_default=False))\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.calculators.turbomole import Turbomole", "from ase.build import molecule"]}], [{"term": "def", "name": "calculate", "data": "def calculate(factory, system, **kwargs):\n\tcalc = factory.calc(**kwargs)\n\tsystem.calc = calc\n\tsystem.get_potential_energy()\n\tcalc.get_eigenvalues()\n\treturn calc\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.collections import g2", "from ase.build import bulk, graphene_nanoribbon"]}, {"term": "def", "name": "test_h2o", "data": "def test_h2o(factory):\n\tcalc = calculate(factory,\n\t\t\t\t\t g2['H2O'],\n\t\t\t\t\t OutputFormat='xcrysden',\n\t\t\t\t\t SCFCalculateDipole=True)\n\tdipole = calc.get_dipole_moment()\n\tE = calc.get_potential_energy()\n\n\tprint('dipole', dipole)\n\tprint('energy', E)\n\n\t# XXX What's with the dipole not being correct?\n\t# XXX Investigate\n\n\tassert pytest.approx(dipole, abs=0.02) == [0, 0, -0.37]\n\tdipole_err = np.abs(dipole - [0., 0., -0.37]).max()\n\tassert dipole_err < 0.02, dipole_err\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.collections import g2", "from ase.build import bulk, graphene_nanoribbon"]}, {"term": "def", "name": "test_o2", "data": "def test_o2(factory):\n\tatoms = g2['O2']\n\tatoms.center(vacuum=2.5)\n\tcalculate(factory,\n\t\t\t  atoms,\n\t\t\t  BoxShape='parallelepiped',\n\t\t\t  SpinComponents='spin_polarized',\n\t\t\t  ExtraStates=2)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.collections import g2", "from ase.build import bulk, graphene_nanoribbon"]}, {"term": "def", "name": "test_si", "data": "def test_si(factory):\n\tcalc = calculate(factory,\n\t\t\t\t\t bulk('Si'),  # , orthorhombic=True),\n\t\t\t\t\t KPointsGrid=[[4, 4, 4]],\n\t\t\t\t\t KPointsUseSymmetries=True,\n\t\t\t\t\t SmearingFunction='fermi_dirac',\n\t\t\t\t\t ExtraStates=2,\n\t\t\t\t\t Smearing='0.1 * eV',\n\t\t\t\t\t ExperimentalFeatures=True,\n\t\t\t\t\t Spacing='0.45 * Angstrom')\n\teF = calc.get_fermi_level()\n\tprint('eF', eF)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.collections import g2", "from ase.build import bulk, graphene_nanoribbon"]}], [{"term": "def", "name": "test_aims_interface", "data": "def test_aims_interface():\n\t# test the new command handling + legacy behavior\n\taims_command = 'aims.x'\n\taims_command_alternative = 'mpirun -np 4 fhiaims.x'\n\toutfilename = 'alternative_aims.out'\n\toutfilename_default = 'aims.out'\n\tcommand = '{0:s} > {1:s}'.format(aims_command, outfilename)\n\t#command_alternative = '{0:s} > {1:s}'.format(aims_command_alternative, outfilename)\n\tcommand_default = '{0:s} > {1:s}'.format(aims_command, outfilename_default)\n\tlegacy_command = 'aims.version.serial.x > aims.out'\n\tlegacy_aims_command = legacy_command.split('>')[0].strip()\n\tlegacy_outfilename = legacy_command.split('>')[-1].strip()\n\n\t# legacy behavior of empty init\n\tcalc = Aims()\n\tassert calc.command == legacy_command\n\tassert calc.outfilename == legacy_outfilename\n\tassert calc.aims_command == legacy_aims_command\n\n\t# behavior of empty init with env variable\n\tos.environ['ASE_AIMS_COMMAND'] = aims_command_alternative\n\tcalc = Aims()\n\tassert calc.command == '{0} > {1}'.format(aims_command_alternative, outfilename_default)\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command_alternative\n\n\t# legacy behavior of \"proper\" command\n\tcalc = Aims(run_command=command)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# legacy behavior of an \"improper\" command\n\tcalc = Aims(run_command=aims_command)\n\tassert calc.command == command_default\n\tassert calc.aims_command == aims_command\n\tassert calc.outfilename == outfilename_default\n\n\t# fixed \"command\"  behavior\n\tcalc = Aims(command=command)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# novel way to use aims_command, no specific outfile\n\tcalc = Aims(aims_command=aims_command)\n\tassert calc.command == command_default\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command\n\n\tcalc = Aims(aims_command=aims_command,\n\t\t\t\toutfilename=outfilename)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# # testing the setters\n\tcalc.command = command_default\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command\n\tassert calc.command == command_default\n\n\t#calc.set_aims_command(aims_command_alternative)\n\tcalc.aims_command = aims_command_alternative\n\tassert calc.aims_command == aims_command_alternative\n\tassert calc.outfilename == outfilename_default\n\tassert calc.command == '{} > {}'.format(aims_command_alternative, outfilename_default)\n\n\tcalc.outfilename = outfilename\n\tassert calc.command == '{} > {}'.format(aims_command_alternative, outfilename)\n\tassert calc.aims_command == aims_command_alternative\n\tassert calc.outfilename == outfilename\n\n\t# test writing files\n\ttmp_dir = tempfile.mkdtemp()\n\twater = Atoms('HOH', [(1, 0, 0), (0, 0, 0), (0, 1, 0)])\n\tcalc = Aims(xc='PBE',\n\t\t\t\toutput=['dipole'],\n\t\t\t\tsc_accuracy_etot=1e-6,\n\t\t\t\tsc_accuracy_eev=1e-3,\n\t\t\t\tsc_accuracy_rho=1e-6,\n\t\t\t\tspecies_dir=\"/data/rittmeyer/FHIaims/species_defaults/light/\",\n\t\t\t\tsc_accuracy_forces=1e-4,\n\t\t\t\tlabel=tmp_dir,\n\t\t\t\t)\n\ttry:\n\t\tcalc.prepare_input_files()\n\t\traise AssertionError\n\texcept ValueError:\n\t\tpass\n\n\tcalc.atoms = water\n\tcalc.prepare_input_files()\n\tfor f in ['control.in', 'geometry.in']:\n\t\tassert os.path.isfile(os.path.join(tmp_dir, f))\n", "description": null, "category": "math", "imports": ["import tempfile", "import os", "import pytest", "from ase.calculators.aims import Aims", "from ase import Atoms"]}], [{"term": "def", "name": "Calc", "data": "def Calc(window, btns, expression):\n\texpression = ''.join(expression.split())\n\tif not expression.endswith('='):\n\t\texpression += '='\n\tfor char in expression:\n\t\tautomation.Logger.Write(char, writeToFile = False)\n\t\tbtns[char].Click(waitTime = 0.05)\n\twindow.SendKeys('{Ctrl}c', waitTime = 0)\n\tresult = automation.GetClipboardText()\n\tautomation.Logger.WriteLine(result, automation.ConsoleColor.Cyan, writeToFile = False)\n\ttime.sleep(1)\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import subprocess", "import uiautomation as automation", "\timport platform"]}, {"term": "def", "name": "CalcOnXP", "data": "def CalcOnXP():\n\tchars = '0123456789.+-*/=()'\n\tcalcWindow = automation.WindowControl(searchDepth = 1, ClassName = 'SciCalc')\n\tif not calcWindow.Exists(0, 0):\n\t\tsubprocess.Popen('calc')\n\tcalcWindow.SetActive()\n\tcalcWindow.SendKeys('{Alt}vs', 0.5)\n\tclearBtn = calcWindow.ButtonControl(Name = 'CE')\n\tclearBtn.Click()\n\tchar2Button = {}\n\tfor key in chars:\n\t\tchar2Button[key] = calcWindow.ButtonControl(Name = key)\n\tCalc(calcWindow, char2Button, '1234 * (4 + 5 + 6) - 78 / 90')\n\tCalc(calcWindow, char2Button, '2*3.14159*10')\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import subprocess", "import uiautomation as automation", "\timport platform"]}, {"term": "def", "name": "CalcOnWindows7And8", "data": "def CalcOnWindows7And8():\n\tchar2Id = {\n\t\t'0' : '130',\n\t\t'1' : '131',\n\t\t'2' : '132',\n\t\t'3' : '133',\n\t\t'4' : '134',\n\t\t'5' : '135',\n\t\t'6' : '136',\n\t\t'7' : '137',\n\t\t'8' : '138',\n\t\t'9' : '139',\n\t\t'.' : '84',\n\t\t'+' : '93',\n\t\t'-' : '94',\n\t\t'*' : '92',\n\t\t'/' : '91',\n\t\t'=' : '121',\n\t\t'(' : '128',\n\t\t')' : '129',\n\t}\n\tcalcWindow = automation.WindowControl(searchDepth = 1, ClassName = 'CalcFrame')\n\tif not calcWindow.Exists(0, 0):\n\t\tsubprocess.Popen('calc')\n\tcalcWindow.SetActive()\n\tcalcWindow.SendKeys('{Alt}2')\n\tclearBtn = calcWindow.ButtonControl(foundIndex= 8, Depth = 3)  #test foundIndex and Depth, the 8th button is clear\n\tif clearBtn.AutomationId == '82':\n\t\tclearBtn.Click()\n\tchar2Button = {}\n\tfor key in char2Id:\n\t\tchar2Button[key] = calcWindow.ButtonControl(AutomationId = char2Id[key])\n\tCalc(calcWindow, char2Button, '1234 * (4 + 5 + 6) - 78 / 90')\n\tCalc(calcWindow, char2Button, '2*3.14159*10')\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import subprocess", "import uiautomation as automation", "\timport platform"]}, {"term": "def", "name": "CalcOnWindows10", "data": "def CalcOnWindows10():\n\tchar2Id = {\n\t\t'0' : 'num0Button',\n\t\t'1' : 'num1Button',\n\t\t'2' : 'num2Button',\n\t\t'3' : 'num3Button',\n\t\t'4' : 'num4Button',\n\t\t'5' : 'num5Button',\n\t\t'6' : 'num6Button',\n\t\t'7' : 'num7Button',\n\t\t'8' : 'num8Button',\n\t\t'9' : 'num9Button',\n\t\t'.' : 'decimalSeparatorButton',\n\t\t'+' : 'plusButton',\n\t\t'-' : 'minusButton',\n\t\t'*' : 'multiplyButton',\n\t\t'/' : 'divideButton',\n\t\t'=' : 'equalButton',\n\t\t'(' : 'openParanthesisButton',\n\t\t')' : 'closeParanthesisButton',\n\t}\n\tcalcWindow = automation.WindowControl(searchDepth = 1, ClassName = 'ApplicationFrameWindow', Name = 'Calculator')\n\tif not calcWindow.Exists(0, 0):\n\t\tsubprocess.Popen('calc')\n\tcalcWindow.SetActive()\n\tcalcWindow.ButtonControl(AutomationId = 'NavButton').Click()\n\tcalcWindow.ListItemControl(Name = 'Scientific Calculator').Click()\n\tcalcWindow.ButtonControl(AutomationId = 'clearButton').Click()\n\tchar2Button = {}\n\tfor key in char2Id:\n\t\tchar2Button[key] = calcWindow.ButtonControl(AutomationId = char2Id[key])\n\tCalc(calcWindow, char2Button, '1234 * (4 + 5 + 6) - 78 / 90')\n\tCalc(calcWindow, char2Button, '2*3.14159*10')\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import subprocess", "import uiautomation as automation", "\timport platform"]}], [{"term": "def", "name": "systems_minimum", "data": "def systems_minimum():\n\t\"\"\"two atoms at potential minimum\"\"\"\n\n\tatoms = Atoms('H2', positions=[[0, 0, 0], [0, 0, 2 ** (1.0 / 6.0)]])\n\tcalc = LennardJones(rc=1.0e5)\n\tatoms.calc = calc\n\tyield atoms\n\n\tcalc = LennardJones(rc=1.0e5, smooth=True)\n\tatoms.calc = calc\n\tyield atoms\n\n", "description": "two atoms at potential minimum", "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_minimum_energy", "data": "def test_minimum_energy():\n\t# testing at the minimum to see if anything is on fire\n\t# See https://en.wikipedia.org/wiki/Lennard-Jones_potential\n\t# Minimum is at r=2^(1/6)*sigma, and it's -1.\n\n\tfor atoms in systems_minimum():\n\t\tassert atoms.get_potential_energy() == reference_potential_energy\n\t\tassert atoms.get_potential_energies().sum() == \\\n\t\t\treference_potential_energy\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_minimum_forces", "data": "def test_minimum_forces():\n\t# forces should be zero\n\tfor atoms in systems_minimum():\n\t\tnp.testing.assert_allclose(atoms.get_forces(), 0, atol=1e-14)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_system_changes", "data": "def test_system_changes():\n\t# https://gitlab.com/ase/ase/-/merge_requests/1817\n\n\tfor atoms in systems_minimum():\n\t\tatoms.calc.calculate(atoms, system_changes=['positions'])\n\t\tassert atoms.get_potential_energy() == reference_potential_energy\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_finite_difference", "data": "def test_finite_difference():\n\t# ensure that we got the modified forces right\n\th = 1e-10\n\tr = 8.0\n\tcalc = LennardJones(smooth=True, ro=6, rc=10, sigma=3)\n\tatoms = Atoms('H2', positions=[[0, 0, 0], [r, 0, 0]])\n\tatoms2 = Atoms('H2', positions=[[0, 0, 0], [r + h, 0, 0]])\n\tatoms.calc = calc\n\tatoms2.calc = calc\n\n\tfd_force = (atoms2.get_potential_energy() -\n\t\t\t\tatoms.get_potential_energy()) / h\n\tforce = atoms.get_forces()[0, 0]\n\n\tnp.testing.assert_allclose(fd_force, force)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "systems_bulk", "data": "def systems_bulk():\n\tatoms = bulk(\"Ar\", cubic=True)\n\tatoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n\tcalc = LennardJones(rc=10)\n\tatoms.calc = calc\n\n\tyield atoms\n\n\tatoms = bulk(\"Ar\", cubic=True)\n\tatoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n\t# somewhat hand-picked parameters, but ok for comparison\n\tcalc = LennardJones(rc=12, ro=10, smooth=True)\n\tatoms.calc = calc\n\n\tyield atoms\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_bulk_energies", "data": "def test_bulk_energies():\n\t# check energies\n\n\tfor atoms in systems_bulk():\n\t\tassert np.allclose(\n\t\t\tatoms.get_potential_energy(), atoms.get_potential_energies().sum()\n\t\t)\n\t\t# energies should be equal in this high-symmetry structure\n\t\tassert atoms.get_potential_energies().std() == pytest.approx(0.0)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_bulk_forces", "data": "def test_bulk_forces():\n\tfor atoms in systems_bulk():\n\t\t# displace atom for 0.03 \\AA\n\t\tatoms.positions[0, 0] += 0.03\n\n\t\t# check forces sum to zero\n\t\tassert np.allclose(atoms.get_forces().sum(axis=0), 0)\n\n\t\t# check reference force\n\t\tassert atoms.get_forces()[0, 0] == reference_force\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_bulk_stress", "data": "def test_bulk_stress():\n\t# check stress computation for sanity and reference\n\t# reference value computed for \"non-smooth\" LJ, so\n\t# we only test that\n\tatoms = bulk(\"Ar\", cubic=True)\n\tatoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n\tcalc = LennardJones(rc=10)\n\tatoms.calc = calc\n\n\tstress = atoms.get_stress()\n\tstresses = atoms.get_stresses()\n\n\tassert np.allclose(stress, stresses.sum(axis=0))\n\n\t# check reference pressure\n\tpressure = sum(stress[:3]) / 3\n\n\tassert pressure == reference_pressure\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}], [{"term": "def", "name": "test_siesta_read_eigenvalues_soc", "data": "def test_siesta_read_eigenvalues_soc(datadir):\n\t\"\"\" In this test, we read a stored siesta.EIG file.\"\"\"\n\tcalc = Siesta()\n\tassert calc.read_eigenvalues() == 1\n\tcalc.directory = datadir / 'siesta'\n\tprint(datadir)\n\tassert calc.read_eigenvalues() == 0\n\tassert calc.results['eigenvalues'].shape == (1, 1, 30)\n\n", "description": " In this test, we read a stored siesta.EIG file.", "category": "math", "imports": ["import ase.build", "from ase.calculators.siesta import Siesta"]}, {"term": "def", "name": "test_siesta_read_eigenvalues", "data": "def test_siesta_read_eigenvalues(siesta_factory):\n\t# Test real calculation which produces a gapped .EIG file\n\tatoms = ase.build.bulk('Si', cubic=True)\n\tcalc = siesta_factory.calc(kpts=[2, 1, 1])\n\tatoms.calc = calc\n\tatoms.get_potential_energy()\n\n\tassert calc.results['eigenvalues'].shape[:2] == (1, 2)  # spins x bands\n\tassert calc.get_k_point_weights().shape == (2,)\n\tassert calc.get_ibz_k_points().shape == (2, 3)\n", "description": null, "category": "math", "imports": ["import ase.build", "from ase.calculators.siesta import Siesta"]}], [{"term": "def", "name": "test_vasp_Al_volrelax", "data": "def test_vasp_Al_volrelax(factory):\n\t\"\"\"\n\tRun VASP tests to ensure that relaxation with the VASP calculator works.\n\tThis is conditional on the existence of the VASP_COMMAND or VASP_SCRIPT\n\tenvironment variables.\n\n\t\"\"\"\n\n\t# -- Perform Volume relaxation within Vasp\n\tdef vasp_vol_relax():\n\t\tAl = bulk('Al', 'fcc', a=4.5, cubic=True)\n\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\tisif=7,\n\t\t\t\t\t\t\tnsw=5,\n\t\t\t\t\t\t\tibrion=1,\n\t\t\t\t\t\t\tediffg=-1e-3,\n\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\tlcharg=False)\n\t\tAl.calc = calc\n\t\tAl.get_potential_energy()  # Execute\n\n\t\t# Explicitly parse atomic position output file from Vasp\n\t\tCONTCAR_Al = io.read('CONTCAR', format='vasp')\n\n\t\tprint('Stress after relaxation:\\n', calc.read_stress())\n\n\t\tprint('Al cell post relaxation from calc:\\n',\n\t\t\t  calc.get_atoms().get_cell())\n\t\tprint('Al cell post relaxation from atoms:\\n', Al.get_cell())\n\t\tprint('Al cell post relaxation from CONTCAR:\\n', CONTCAR_Al.get_cell())\n\n\t\t# All the cells should be the same.\n\t\tassert (calc.get_atoms().get_cell() == CONTCAR_Al.get_cell()).all()\n\t\tassert (Al.get_cell() == CONTCAR_Al.get_cell()).all()\n\n\t\treturn Al\n\n\t# -- Volume relaxation using ASE with Vasp as force/stress calculator\n\tdef ase_vol_relax():\n\t\tAl = bulk('Al', 'fcc', a=4.5, cubic=True)\n\t\tcalc = factory.calc(xc='LDA')\n\t\tAl.calc = calc\n\n\t\tfrom ase.constraints import StrainFilter\n\t\tsf = StrainFilter(Al)\n\t\twith BFGS(sf, logfile='relaxation.log') as qn:\n\t\t\tqn.run(fmax=0.1, steps=5)\n\n\t\tprint('Stress:\\n', calc.read_stress())\n\t\tprint('Al post ASE volume relaxation\\n', calc.get_atoms().get_cell())\n\n\t\treturn Al\n\n\t# Test function for comparing two cells\n\tdef cells_almost_equal(cellA, cellB, tol=0.01):\n\t\treturn (np.abs(cellA - cellB) < tol).all()\n\n\t# Correct LDA relaxed cell\n\ta_rel = 4.18\n\tLDA_cell = np.diag([a_rel, a_rel, a_rel])\n\n\tAl_vasp = vasp_vol_relax()\n\tAl_ase = ase_vol_relax()\n\n\tassert cells_almost_equal(LDA_cell, Al_vasp.get_cell())\n\tassert cells_almost_equal(LDA_cell, Al_ase.get_cell())\n\n\t# Cleanup\n\tAl_ase.calc.clean()\n", "description": "\n\tRun VASP tests to ensure that relaxation with the VASP calculator works.\n\tThis is conditional on the existence of the VASP_COMMAND or VASP_SCRIPT\n\tenvironment variables.\n\n\t", "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import io", "from ase.optimize import BFGS", "from ase.build import bulk", "\t\tfrom ase.constraints import StrainFilter"]}], [{"term": "def", "name": "system", "data": "def system():\n\treturn bulk('Al', 'fcc', a=4.5, cubic=True)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "expected_nelect_from_vasp", "data": "def expected_nelect_from_vasp():\n\t# Expected number of electrons from the specified system\n\t# with no charge\n\treturn 12\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_charge", "data": "def test_vasp_charge(factory, system, expected_nelect_from_vasp):\n\t\"\"\"\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied charge works correctly.\n\n\tTest that the number of charge found matches the expected.\n\t\"\"\"\n\n\t# Dummy calculation to let VASP determine default number of electrons\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False)\n\tsystem.calc = calc\n\tsystem.get_potential_energy()\n\n\tdefault_nelect_from_vasp = calc.get_number_of_electrons()\n\tassert default_nelect_from_vasp == expected_nelect_from_vasp\n\n", "description": "\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied charge works correctly.\n\n\tTest that the number of charge found matches the expected.\n\t", "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_no_inputs", "data": "def test_vasp_no_inputs(system, factory):\n\t# Make sure that no nelect was written into INCAR yet (as it wasn't necessary)\n\tcalc = factory.calc()\n\tsystem.calc = calc\n\tsystem.get_potential_energy()\n\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] is None\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_minus_charge", "data": "def test_vasp_minus_charge(factory, system, expected_nelect_from_vasp):\n\t# Compare VASP's output nelect from before minus charge to default nelect\n\t# determined by us minus charge\n\tcharge = -2\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tcharge=charge)\n\tcalc.initialize(system)\n\tcalc.write_input(system)\n\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] == expected_nelect_from_vasp - charge\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_nelect_charge_conflict", "data": "def test_vasp_nelect_charge_conflict(factory, system,\n\t\t\t\t\t\t\t\t\t expected_nelect_from_vasp):\n\t# Test that conflicts between explicitly given nelect and charge are detected\n\tcharge = -2\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tnelect=expected_nelect_from_vasp - charge + 1,\n\t\t\t\t\t\tcharge=charge)\n\tsystem.calc = calc\n\twith pytest.raises(ValueError):\n\t\tsystem.get_potential_energy()\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_nelect_no_write", "data": "def test_vasp_nelect_no_write(factory, system):\n\t# Test that nothing is written if charge is 0 and nelect not given\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tcharge=0)\n\tcalc.initialize(system)\n\tcalc.write_input(system)\n\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] is None\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_nelect", "data": "def test_vasp_nelect(factory, system):\n\t# Test that explicitly given nelect still works as expected\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tnelect=15)\n\tcalc.calculate(system)\n\tassert calc.get_number_of_electrons() == 15\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}], [{"term": "def", "name": "QA_backtest_analysis_backtest", "data": "def QA_backtest_analysis_backtest(client, code_list, assets_d, account_days, message, total_date, benchmark_data):\n\n\t# \u4e3b\u8981\u8981\u4ecemessage_history\u5206\u6790\n\t# 1.\u6536\u76ca\u7387\n\t# 2.\u80dc\u7387\n\t# 3.\u56de\u64a4\n\t\"\"\"\n\tAnnualized Returns: \u7b56\u7565\u5e74\u5316\u6536\u76ca\u7387\u3002\u8868\u793a\u6295\u8d44\u671f\u9650\u4e3a\u4e00\u5e74\u7684\u9884\u671f\u6536\u76ca\u7387\u3002\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u5f0f\u4e3a (\u7b56\u7565\u6700\u7ec8\u4ef7\u503c / \u7b56\u7565\u521d\u59cb\u4ef7\u503c)^(250 / \u56de\u6d4b\u4ea4\u6613\u65e5\u6570\u91cf) - 1\n\n\tAlpha\uff1a\u963f\u5c14\u6cd5\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u5f0f\u4e3a (\u7b56\u7565\u5e74\u5316\u6536\u76ca - \u65e0\u98ce\u9669\u6536\u76ca) - beta \u00d7 (\u53c2\u8003\u6807\u51c6\u5e74\u5316\u6536\u76ca - \u65e0\u98ce\u9669\u6536\u76ca)\uff0c\u8fd9\u91cc\u7684\u65e0\u98ce\u9669\u6536\u76ca\u6307\u7684\u662f\u4e2d\u56fd\u56fa\u5b9a\u5229\u7387\u56fd\u503a\u6536\u76ca\u7387\u66f2\u7ebf\u4e0a10\u5e74\u671f\u56fd\u503a\u7684\u5e74\u5316\u5230\u671f\u6536\u76ca\u7387\u3002\n\n\tBeta\uff1a\u8d1d\u5854\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a \u7b56\u7565\u6bcf\u65e5\u6536\u76ca\u4e0e\u53c2\u8003\u6807\u51c6\u6bcf\u65e5\u6536\u76ca\u7684\u534f\u65b9\u5dee / \u53c2\u8003\u6807\u51c6\u6bcf\u65e5\u6536\u76ca\u7684\u65b9\u5dee \u3002\n\n\tSharpe Ratio\uff1a\u590f\u666e\u6bd4\u7387\u3002\u8868\u793a\u6bcf\u627f\u53d7\u4e00\u5355\u4f4d\u603b\u98ce\u9669\uff0c\u4f1a\u4ea7\u751f\u591a\u5c11\u7684\u8d85\u989d\u62a5\u916c\u3002\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a (\u7b56\u7565\u5e74\u5316\u6536\u76ca\u7387 - \u56de\u6d4b\u8d77\u59cb\u4ea4\u6613\u65e5\u7684\u65e0\u98ce\u9669\u5229\u7387) / \u7b56\u7565\u6536\u76ca\u6ce2\u52a8\u7387 \u3002\n\n\tVolatility\uff1a\u7b56\u7565\u6536\u76ca\u6ce2\u52a8\u7387\u3002\u7528\u6765\u6d4b\u91cf\u8d44\u4ea7\u7684\u98ce\u9669\u6027\u3002\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a \u7b56\u7565\u6bcf\u65e5\u6536\u76ca\u7684\u5e74\u5316\u6807\u51c6\u5dee \u3002\n\n\tInformation Ratio\uff1a\u4fe1\u606f\u6bd4\u7387\u3002\u8861\u91cf\u8d85\u989d\u98ce\u9669\u5e26\u6765\u7684\u8d85\u989d\u6536\u76ca\u3002\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a (\u7b56\u7565\u6bcf\u65e5\u6536\u76ca - \u53c2\u8003\u6807\u51c6\u6bcf\u65e5\u6536\u76ca)\u7684\u5e74\u5316\u5747\u503c / \u5e74\u5316\u6807\u51c6\u5dee \u3002\n\n\tMax Drawdown\uff1a\u6700\u5927\u56de\u64a4\u3002\u63cf\u8ff0\u7b56\u7565\u53ef\u80fd\u51fa\u73b0\u7684\u6700\u7cdf\u7cd5\u7684\u60c5\u51b5\u3002\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a max(1 - \u7b56\u7565\u5f53\u65e5\u4ef7\u503c / \u5f53\u65e5\u4e4b\u524d\u865a\u62df\u8d26\u6237\u6700\u9ad8\u4ef7\u503c)\n\n\n\t\u5355\u6b21\u4ea4\u6613\u6536\u76ca\n\t\u6536\u76ca/\u6b21\u6570\u7684\u9891\u6b21\u76f4\u65b9\u56fe\n\t\u5355\u65e5\u6700\u5927\u6301\u4ed3\n\t\"\"\"\n\t# \u6570\u636e\u68c0\u67e5\n\tif (len(benchmark_data)) < 1:\n\t\tQA_util_log_info('Wrong with benchmark data ! ')\n\t\tsys.exit()\n\n\t# \u8ba1\u7b97\u4e00\u4e2abenchmark\n\t# \u8fd9\u4e2abenchmark \u662f\u5728\u5f00\u59cb\u7684\u90a3\u5929 \u5e02\u4ef7\u4e70\u5165\u548c\u7b56\u7565\u6240\u9009\u6807\u7684\u4e00\u81f4\u7684\u6240\u6709\u80a1\u7968,\u7136\u540e\u4e00\u76f4\u6301\u4ed3\n\tdata = pd.concat([pd.DataFrame(message['body']['account']['history'],\n\t\t\t\t\t\t\t\t   columns=['time', 'code', 'price', 'towards', 'amount', 'order_id', 'trade_id', 'commission']),\n\t\t\t\t\t  pd.DataFrame(message['body']['account']['assets'], columns=['assets'])], axis=1)\n\tdata['time'] = pd.to_datetime(data['time'], utc=False)\n\tdata.set_index('time', drop=False, inplace=True)\n\n\ttrade_history = message['body']['account']['history']\n\tcash = message['body']['account']['cash']\n\tassets = message['body']['account']['assets']\n\n\t#assets_= data.resample('D').last().dropna()\n\t# \u8ba1\u7b97\u4ea4\u6613\u65e5\n\ttrade_date = account_days\n\t# benchmark\u8d44\u4ea7\n\tbenchmark_assets = QA_backtest_calc_benchmark(\n\t\tbenchmark_data, assets[0])\n\t# d2=pd.concat([data.resample('D').last(),pd.DataFrame(benchmark_assets,columns=['benchmark'])])\n\t# benchmark\u5e74\u5316\u6536\u76ca\n\tbenchmark_annualized_returns = QA_backtest_calc_profit_per_year(\n\t\tbenchmark_assets, len(total_date))\n\t# \u8ba1\u7b97\u8d26\u6237\u7684\u6536\u76ca\n\n\t# days=len(assest_history)-1\n\t# \u7b56\u7565\u5e74\u5316\u6536\u76ca\n\tannualized_returns = QA_backtest_calc_profit_per_year(\n\t\tassets_d, len(total_date))\n\n\t# \u6536\u76ca\u77e9\u9635\n\tassest_profit = QA_backtest_calc_profit_matrix(assets)\n\tbenchmark_profit = QA_backtest_calc_profit_matrix(benchmark_assets)\n\n\t# \u7b56\u7565\u65e5\u6536\u76ca\n\tprofit_day = QA_backtest_calc_profit_matrix(assets_d)\n\t# \u80dc\u7387\n\twin_rate = QA_backtest_calc_win_rate(assest_profit)\n\t# \u65e5\u80dc\u7387\n\twin_rate_day = QA_backtest_calc_win_rate(profit_day)\n\t# \u5e74\u5316\u6ce2\u52a8\u7387\n\tvolatility_year = QA_backtest_calc_volatility(profit_day)\n\tbenchmark_volatility_year = QA_backtest_calc_volatility(benchmark_profit)\n\t# \u590f\u666e\u6bd4\u7387\n\tsharpe = QA_backtest_calc_sharpe(\n\t\tannualized_returns, 0.05, volatility_year)\n\n\t# \u6700\u5927\u56de\u64a4\n\tmax_drop = QA_backtest_calc_dropback_max(assets_d)\n\n\t# \u8ba1\u7b97beta\n\tbeta = QA_backtest_calc_beta(profit_day, benchmark_profit)\n\t# \u8ba1\u7b97Alpha\n\talpha = QA_backtest_calc_alpha(\n\t\tannualized_returns, benchmark_annualized_returns, beta, 0.05)\n\tmessage = {\n\t\t'code': code_list,\n\t\t'annualized_returns': annualized_returns,\n\t\t'benchmark_annualized_returns': benchmark_annualized_returns,\n\t\t'assets': assets_d[1:],\n\t\t'benchmark_assets': benchmark_assets[1:],\n\t\t'vol': volatility_year,\n\t\t'benchmark_vol': benchmark_volatility_year,\n\t\t'sharpe': sharpe,\n\t\t'alpha': alpha,\n\t\t'beta': beta,\n\t\t'total_date': total_date,\n\t\t'trade_date': trade_date,\n\t\t'max_drop': max_drop,\n\t\t'win_rate': win_rate}\n\treturn message\n\n", "description": "\n\tAnnualized Returns: \u7b56\u7565\u5e74\u5316\u6536\u76ca\u7387\u3002\u8868\u793a\u6295\u8d44\u671f\u9650\u4e3a\u4e00\u5e74\u7684\u9884\u671f\u6536\u76ca\u7387\u3002\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u5f0f\u4e3a (\u7b56\u7565\u6700\u7ec8\u4ef7\u503c / \u7b56\u7565\u521d\u59cb\u4ef7\u503c)^(250 / \u56de\u6d4b\u4ea4\u6613\u65e5\u6570\u91cf) - 1\n\n\tAlpha\uff1a\u963f\u5c14\u6cd5\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u5f0f\u4e3a (\u7b56\u7565\u5e74\u5316\u6536\u76ca - \u65e0\u98ce\u9669\u6536\u76ca) - beta \u00d7 (\u53c2\u8003\u6807\u51c6\u5e74\u5316\u6536\u76ca - \u65e0\u98ce\u9669\u6536\u76ca)\uff0c\u8fd9\u91cc\u7684\u65e0\u98ce\u9669\u6536\u76ca\u6307\u7684\u662f\u4e2d\u56fd\u56fa\u5b9a\u5229\u7387\u56fd\u503a\u6536\u76ca\u7387\u66f2\u7ebf\u4e0a10\u5e74\u671f\u56fd\u503a\u7684\u5e74\u5316\u5230\u671f\u6536\u76ca\u7387\u3002\n\n\tBeta\uff1a\u8d1d\u5854\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a \u7b56\u7565\u6bcf\u65e5\u6536\u76ca\u4e0e\u53c2\u8003\u6807\u51c6\u6bcf\u65e5\u6536\u76ca\u7684\u534f\u65b9\u5dee / \u53c2\u8003\u6807\u51c6\u6bcf\u65e5\u6536\u76ca\u7684\u65b9\u5dee \u3002\n\n\tSharpe Ratio\uff1a\u590f\u666e\u6bd4\u7387\u3002\u8868\u793a\u6bcf\u627f\u53d7\u4e00\u5355\u4f4d\u603b\u98ce\u9669\uff0c\u4f1a\u4ea7\u751f\u591a\u5c11\u7684\u8d85\u989d\u62a5\u916c\u3002\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a (\u7b56\u7565\u5e74\u5316\u6536\u76ca\u7387 - \u56de\u6d4b\u8d77\u59cb\u4ea4\u6613\u65e5\u7684\u65e0\u98ce\u9669\u5229\u7387) / \u7b56\u7565\u6536\u76ca\u6ce2\u52a8\u7387 \u3002\n\n\tVolatility\uff1a\u7b56\u7565\u6536\u76ca\u6ce2\u52a8\u7387\u3002\u7528\u6765\u6d4b\u91cf\u8d44\u4ea7\u7684\u98ce\u9669\u6027\u3002\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a \u7b56\u7565\u6bcf\u65e5\u6536\u76ca\u7684\u5e74\u5316\u6807\u51c6\u5dee \u3002\n\n\tInformation Ratio\uff1a\u4fe1\u606f\u6bd4\u7387\u3002\u8861\u91cf\u8d85\u989d\u98ce\u9669\u5e26\u6765\u7684\u8d85\u989d\u6536\u76ca\u3002\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a (\u7b56\u7565\u6bcf\u65e5\u6536\u76ca - \u53c2\u8003\u6807\u51c6\u6bcf\u65e5\u6536\u76ca)\u7684\u5e74\u5316\u5747\u503c / \u5e74\u5316\u6807\u51c6\u5dee \u3002\n\n\tMax Drawdown\uff1a\u6700\u5927\u56de\u64a4\u3002\u63cf\u8ff0\u7b56\u7565\u53ef\u80fd\u51fa\u73b0\u7684\u6700\u7cdf\u7cd5\u7684\u60c5\u51b5\u3002\n\t\u5177\u4f53\u8ba1\u7b97\u65b9\u6cd5\u4e3a max(1 - \u7b56\u7565\u5f53\u65e5\u4ef7\u503c / \u5f53\u65e5\u4e4b\u524d\u865a\u62df\u8d26\u6237\u6700\u9ad8\u4ef7\u503c)\n\n\n\t\u5355\u6b21\u4ea4\u6613\u6536\u76ca\n\t\u6536\u76ca/\u6b21\u6570\u7684\u9891\u6b21\u76f4\u65b9\u56fe\n\t\u5355\u65e5\u6700\u5927\u6301\u4ed3\n\t", "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_assets", "data": "def QA_backtest_calc_assets(trade_history, assets):\n\tassets_d = []\n\ttrade_date = []\n\tfor i in range(0, len(trade_history), 1):\n\t\tif trade_history[i][0] not in trade_date:\n\t\t\ttrade_date.append(trade_history[i][0])\n\t\t\tassets_d.append(assets[i])\n\t\telse:\n\t\t\tassets_d.pop(-1)\n\t\t\tassets_d.append(assets[i])\n\n\treturn assets_d\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_benchmark", "data": "def QA_backtest_calc_benchmark(benchmark_data, init_assets):\n\n\treturn list(benchmark_data['close'] / float(benchmark_data['open'][0]) * float(init_assets))\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_alpha", "data": "def QA_backtest_calc_alpha(annualized_returns, benchmark_annualized_returns, beta, r):\n\n\talpha = (annualized_returns - r) - (beta) * \\\n\t\t(benchmark_annualized_returns - r)\n\treturn alpha\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_beta", "data": "def QA_backtest_calc_beta(assest_profit, benchmark_profit):\n\tif len(assest_profit) < len(benchmark_profit):\n\t\tfor i in range(0, len(benchmark_profit) - len(assest_profit), 1):\n\t\t\tassest_profit.append(0)\n\telif len(assest_profit) > len(benchmark_profit):\n\t\tfor i in range(0, len(assest_profit) - len(benchmark_profit), 1):\n\t\t\tbenchmark_profit.append(0)\n\tcalc_cov = numpy.cov(assest_profit, benchmark_profit)\n\tbeta = calc_cov[0, 1] / calc_cov[1, 1]\n\treturn beta\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_profit", "data": "def QA_backtest_calc_profit(assest_history):\n\treturn (assest_history[-1] / assest_history[1]) - 1\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_profit_per_year", "data": "def QA_backtest_calc_profit_per_year(assest_history, days):\n\treturn math.pow(float(assest_history[-1]) / float(assest_history[0]), 250.0 / float(days)) - 1.0\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_profit_matrix", "data": "def QA_backtest_calc_profit_matrix(assest_history):\n\tassest_profit = []\n\tif len(assest_history) > 1:\n\t\tassest_profit = [assest_history[i + 1] / assest_history[i] -\n\t\t\t\t\t\t 1.0 for i in range(len(assest_history) - 1)]\n\treturn assest_profit\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_volatility", "data": "def QA_backtest_calc_volatility(assest_profit_matrix):\n\t# \u7b56\u7565\u6bcf\u65e5\u6536\u76ca\u7684\u5e74\u5316\u6807\u51c6\u5dee\n\tassest_profit = assest_profit_matrix\n\n\tvolatility_day = numpy.std(assest_profit)\n\tvolatility_year = volatility_day * math.sqrt(250)\n\treturn volatility_year\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_dropback_max", "data": "def QA_backtest_calc_dropback_max(history):\n\tdrops = []\n\tfor i in range(1, len(history), 1):\n\t\tmaxs = max(history[:i])\n\t\tcur = history[i - 1]\n\t\tdrop = 1 - cur / maxs\n\t\tdrops.append(drop)\n\tmax_drop = max(drops)\n\treturn max_drop\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_sharpe", "data": "def QA_backtest_calc_sharpe(annualized_returns, r, volatility_year):\n\t'\u8ba1\u7b97\u590f\u666e\u6bd4\u7387'\n\treturn (annualized_returns - r) / volatility_year\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_trade_date", "data": "def QA_backtest_calc_trade_date(history):\n\t'\u8ba1\u7b97\u4ea4\u6613\u65e5\u671f'\n\ttrade_date = []\n\n\t# trade_date_sse.index(history[-1][0])-trade_date_sse.index(history[0][0])\n\tfor i in range(0, len(history), 1):\n\t\tif history[i][0] not in trade_date:\n\t\t\ttrade_date.append(history[i][0])\n\treturn trade_date\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "calc_trade_time", "data": "def calc_trade_time(history):\n\treturn len(history)\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "calc_every_pnl", "data": "def calc_every_pnl(detail):\n\tpass\n\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}, {"term": "def", "name": "QA_backtest_calc_win_rate", "data": "def QA_backtest_calc_win_rate(profit_day):\n\t# \u5927\u4e8e0\u7684\u6b21\u6570\n\tabovez = 0\n\tbelowz = 0\n\tfor i in range(0, len(profit_day) - 1, 1):\n\t\tif profit_day[i] > 0:\n\t\t\tabovez = abovez + 1\n\t\telif profit_day[i] < 0:\n\t\t\tbelowz = belowz + 1\n\tif belowz == 0:\n\t\tbelowz = 1\n\tif abovez == 0:\n\t\tabovez = 1\n\twin_rate = abovez / (abovez + belowz)\n\treturn win_rate\n", "description": null, "category": "math", "imports": ["import math", "import sys", "import numpy", "import pandas as pd", "from QUANTAXIS.QAFetch.QAQuery import QA_fetch_stock_day", "from QUANTAXIS.QAUtil import QA_util_log_info, trade_date_sse"]}], [{"term": "def", "name": "_calc_denotation_accuracy", "data": "def _calc_denotation_accuracy(tables_file, examples, denotation_errors_path,\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "_calc_weighted_denotation_accuracy", "data": "def _calc_weighted_denotation_accuracy(tables_file, examples,\n\t\t\t\t\t\t\t\t\t   denotation_errors_path,\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "_write_predictions", "data": "def _write_predictions(data,\n\t\t\t\t\t   headers=('id', 'annotator', 'position',\n\t\t\t\t\t\t\t\t'answer_coordinates', 'gold_aggr',\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "class", "name": "CalcMetricsTest", "data": "class CalcMetricsTest(parameterized.TestCase):\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "test_create_tables_dict", "data": "  def test_create_tables_dict(self):\n\t_, output_tables_file, table_name = _write_tables_dict()\n\twith tf.io.gfile.GFile(output_tables_file, 'rb') as f:\n\t  tables = pickle.load(f)\n\t  assert table_name in tables\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "test_read_data_examples", "data": "  def test_read_data_examples(self):\n\tdata_path = _write_synthetic_dataset('table_1')\n\texamples = _read_data_examples(data_path)\n\tself.assertEqual(examples['dev-2-0_0'].gold_cell_coo,\n\t\t\t\t\t set([(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]))\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "test_read_predictions", "data": "  def test_read_predictions(self):\n\tdata_path = _write_synthetic_dataset('table_1')\n\texamples = _read_data_examples(data_path)\n\tpredictions_path = _write_synthetic_predictions()\n\tcalc_metrics_utils.read_predictions(predictions_path, examples)\n\tself.assertEqual(examples['dev-2-0_0'].gold_agg_function,\n\t\t\t\t\t calc_metrics_utils._Answer.COUNT)\n\tself.assertEqual(examples['dev-2-0_0'].pred_agg_function,\n\t\t\t\t\t calc_metrics_utils._Answer.NONE)\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "test_calc_structure_metrics", "data": "  def test_calc_structure_metrics(self):\n\tdata_path = _write_synthetic_dataset('table_1')\n\texamples = _read_data_examples(data_path)\n\tpredictions_path = _write_synthetic_predictions()\n\tcalc_metrics_utils.read_predictions(predictions_path, examples)\n\ttest_tmpdir = tempfile.mkdtemp()\n\tresults = calc_metrics_utils.calc_structure_metrics(\n\t\texamples, denotation_errors_path=test_tmpdir)\n\tself.assertEqual(results.aggregation_acc, 0.6)\n\tself.assertEqual(results.cell_acc, 0.6)\n\tself.assertEqual(results.joint_acc, 0.6)\n\n\tdenotation_errors = pd.read_csv(\n\t\tos.path.join(test_tmpdir, 'structured_examples.tsv'), sep='\\t')\n\tself.assertEqual(denotation_errors.iloc[0, 1], 'dev-0-0_0')\n\tself.assertEqual(denotation_errors.iloc[0, 2],\n\t\t\t\t\t calc_metrics_utils._Answer.NONE)\n\tself.assertEqual(denotation_errors.iloc[0, 3],\n\t\t\t\t\t calc_metrics_utils._Answer.NONE)\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "test_denotation_accuracy", "data": "  def test_denotation_accuracy(self):\n\ttest_tmpdir, output_tables_file, table_name = _write_tables_dict()\n\tdata_path = _write_synthetic_dataset(table_name)\n\texamples = _read_data_examples(data_path)\n\tpredictions_path = _write_synthetic_predictions()\n\tcalc_metrics_utils.read_predictions(predictions_path, examples)\n\tpredictions_file_name = 'predictions'\n\tdenotation_accuracy = _calc_denotation_accuracy(\n\t\toutput_tables_file,\n\t\texamples,\n\t\tdenotation_errors_path=test_tmpdir,\n\t\tpredictions_file_name=predictions_file_name,\n\t)\n\tself.assertEqual(denotation_accuracy, 0.8)\n\n\tdenotation_errors = pd.read_csv(\n\t\tos.path.join(test_tmpdir,\n\t\t\t\t\t 'denotation_examples_{}'.format(predictions_file_name)),\n\t\tsep='\\t')\n\tself.assertEqual(denotation_errors.iloc[0, 1], 'dev-0-0_0')\n\tself.assertEqual(denotation_errors.iloc[0, 2], '-')\n\tself.assertEqual(denotation_errors.iloc[0, 5], \"['6.13', 'Richmond']\")\n\tself.assertEqual(denotation_errors.iloc[0, 7], '[(2, 1), (2, 2)]')\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "test_weighted_denotation_accuracy", "data": "  def test_weighted_denotation_accuracy(self):\n\ttest_tmpdir, output_tables_file, table_name = _write_tables_dict()\n\tdata_path = _write_synthetic_dataset(table_name)\n\texamples = _read_data_examples(data_path)\n\tpredictions_path = _write_synthetic_predictions()\n\tcalc_metrics_utils.read_predictions(predictions_path, examples)\n\tpredictions_file_name = 'predictions'\n\tstats = _calc_weighted_denotation_accuracy(\n\t\toutput_tables_file,\n\t\texamples,\n\t\tdenotation_errors_path=test_tmpdir,\n\t\tpredictions_file_name=predictions_file_name,\n\t\tadd_weights=True,\n\t)\n\tself.assertEqual(stats['denotation_accuracy'], 0.8)\n\tself.assertEqual(stats['weighted_denotation_accuracy'], 0.5)\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "test_calc_denotation_accuracy_handles_nans", "data": "  def test_calc_denotation_accuracy_handles_nans(self):\n\ttest_tmpdir, output_tables_file, table_name = _write_tables_dict()\n\tdata_path = _write_dataset([[\n\t\t'dev-0', '0', '0', '-', table_name, '[]', '[]',\n\t\tcalc_metrics_utils._Answer.SUM, 'NAN', 0.5\n\t]])\n\texamples = _read_data_examples(data_path)\n\tpredictions_path = _write_predictions(\n\t\tdata=[['dev-0', '0', '0', '[]', '0', '1']])\n\tcalc_metrics_utils.read_predictions(predictions_path, examples)\n\tdenotation_accuracy = _calc_denotation_accuracy(\n\t\toutput_tables_file,\n\t\texamples,\n\t\tdenotation_errors_path=test_tmpdir,\n\t\tpredictions_file_name='predictions',\n\t)\n\tself.assertEqual(1.0, denotation_accuracy)\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "test_calc_denotation_accuracy_handles_low_precision_floats", "data": "  def test_calc_denotation_accuracy_handles_low_precision_floats(self):\n\ttest_tmpdir, output_tables_file, table_name = _write_tables_dict(\n\t\theaders=['FLOAT'], data=[['992.39']])\n\tdata_path = _write_dataset([[\n\t\t'dev-0', '0', '0', '-', table_name, '[]', '[]',\n\t\tcalc_metrics_utils._Answer.NONE, '992.3900146484375', 0.5\n\t]])\n\texamples = _read_data_examples(data_path)\n\tpredictions_path = _write_predictions(\n\t\tdata=[['dev-0', '0', '0', '[\"(0, 0)\"]', '0', '0']])\n\tcalc_metrics_utils.read_predictions(predictions_path, examples)\n\tdenotation_accuracy = _calc_denotation_accuracy(\n\t\toutput_tables_file,\n\t\texamples,\n\t\tdenotation_errors_path=test_tmpdir,\n\t\tpredictions_file_name='predictions',\n\t)\n\tself.assertEqual(1.0, denotation_accuracy)\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "test_calc_denotation_accuracy_without_gold_answer", "data": "  def test_calc_denotation_accuracy_without_gold_answer(self):\n\ttable = pd.DataFrame([['a', 'b'], ['0', '1']], columns=['A', 'B'])\n\tdenotation_accuracy = calc_metrics_utils.calc_denotation_accuracy(\n\t\texamples={\n\t\t\t'0':\n\t\t\t\tcalc_metrics_utils.Example(\n\t\t\t\t\texample_id='0',\n\t\t\t\t\tquestion='q',\n\t\t\t\t\ttable_id='tab_0',\n\t\t\t\t\ttable=table,\n\t\t\t\t\tgold_cell_coo=set(),\n\t\t\t\t\tgold_agg_function=calc_metrics_utils._Answer.NONE,\n\t\t\t\t\tfloat_answer=None,\n\t\t\t\t\thas_gold_answer=False,\n\t\t\t\t),\n\t\t\t'1':\n\t\t\t\tcalc_metrics_utils.Example(\n\t\t\t\t\texample_id='1',\n\t\t\t\t\tquestion='q',\n\t\t\t\t\ttable_id='tab_0',\n\t\t\t\t\ttable=table,\n\t\t\t\t\tgold_cell_coo={(0, 0)},\n\t\t\t\t\tgold_agg_function=calc_metrics_utils._Answer.NONE,\n\t\t\t\t\tfloat_answer=None,\n\t\t\t\t\thas_gold_answer=True,\n\t\t\t\t\tpred_cell_coo={(0, 0)},\n\t\t\t\t)\n\t\t},\n\t\tdenotation_errors_path=None,\n\t\tpredictions_file_name=None)\n\tself.assertEqual(0.5, denotation_accuracy)\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}, {"term": "def", "name": "test_read_predictions_without_pred_aggr", "data": "  def test_read_predictions_without_pred_aggr(self):\n\tpredictions_path = _write_predictions(\n\t\tdata=[['dev-0', '0', '0', '[\"(0,0)\"]']],\n\t\theaders=('id', 'annotator', 'position', 'answer_coordinates'))\n\texamples = {\n\t\t'dev-0-0_0':\n\t\t\tcalc_metrics_utils.Example(\n\t\t\t\texample_id='dev-0-0_0',\n\t\t\t\tquestion='q',\n\t\t\t\ttable_id='tab_0',\n\t\t\t\ttable=pd.DataFrame(),\n\t\t\t\tgold_cell_coo={},\n\t\t\t\tgold_agg_function=calc_metrics_utils._Answer.NONE,\n\t\t\t\tfloat_answer=None,\n\t\t\t\thas_gold_answer=True,\n\t\t\t)\n\t}\n\tcalc_metrics_utils.read_predictions(predictions_path, examples)\n\tself.assertLen(examples, 1)\n\tself.assertEqual(\n\t\tnext(iter(examples.values())).pred_agg_function,\n\t\tcalc_metrics_utils._Answer.NONE)\n\n", "description": null, "category": "math", "imports": ["import csv", "import os", "import pickle", "import tempfile", "from absl.testing import absltest", "from absl.testing import parameterized", "import pandas as pd", "from tapas.scripts import calc_metrics_utils", "from tapas.scripts import prediction_utils", "import tensorflow.compat.v1 as tf"]}], [{"term": "def", "name": "atoms", "data": "def atoms():\n\treturn Atoms('CHO',\n\t\t\t\t [[0.0, 0.0, 0.0],\n\t\t\t\t  [0.0, 0.0, 1.35],\n\t\t\t\t  [1.178513, 0.0, -0.416662]],\n\t\t\t\t magmoms=[0.5, 0.0, 0.5])\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase import Atoms", "from ase.io import read", "from ase.calculators.gaussian import Gaussian, GaussianOptimizer, GaussianIRC", "from ase.optimize import LBFGS"]}, {"term": "def", "name": "get_calc", "data": "def get_calc(**kwargs):\n\tkwargs.update(mem='100MW', method='hf', basis='sto-3g')\n\treturn Gaussian(**kwargs)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase import Atoms", "from ase.io import read", "from ase.calculators.gaussian import Gaussian, GaussianOptimizer, GaussianIRC", "from ase.optimize import LBFGS"]}, {"term": "def", "name": "test_optimizer", "data": "def test_optimizer(atoms):\n\tpos = atoms.positions.copy()\n\tatoms.calc = get_calc(label='opt', scf='qc')\n\topt_gauss = GaussianOptimizer(atoms)\n\topt_gauss.run(fmax='tight')\n\te_gaussopt = read('opt.log', index=-1).get_potential_energy()\n\n\tatoms.positions[:] = pos\n\tatoms.calc.set_label('sp')\n\twith LBFGS(atoms) as opt_ase:\n\t\topt_ase.run(fmax=1e-2)\n\te_aseopt = atoms.get_potential_energy()\n\tassert e_gaussopt - e_aseopt == pytest.approx(0., abs=1e-3)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase import Atoms", "from ase.io import read", "from ase.calculators.gaussian import Gaussian, GaussianOptimizer, GaussianIRC", "from ase.optimize import LBFGS"]}, {"term": "def", "name": "test_irc", "data": "def test_irc(atoms):\n\tcalc_ts = get_calc(label='ts', chk='ts.chk')\n\tts = GaussianOptimizer(atoms, calc_ts)\n\tts.run(opt='calcall,ts,noeigentest')\n\ttspos = atoms.positions.copy()\n\n\tatoms.calc = get_calc(label='sp', chk='sp.chk', freq='')\n\te_ts = atoms.get_potential_energy()\n\n\tcalc_irc_for = get_calc(label='irc_for', oldchk='sp', chk='irc_for.chk')\n\tirc_for = GaussianIRC(atoms, calc_irc_for)\n\tirc_for.run(direction='forward', irc='rcfc')\n\te_for = read('irc_for.log', index=-1).get_potential_energy()\n\n\tatoms.positions[:] = tspos\n\tcalc_irc_rev = get_calc(label='irc_rev', oldchk='sp', chk='irc_rev.chk')\n\tirc_rev = GaussianIRC(atoms, calc_irc_rev)\n\tirc_rev.run(direction='reverse', irc='rcfc')\n\te_rev = read('irc_rev.log', index=-1).get_potential_energy()\n\n\tassert e_ts - e_for == pytest.approx(1.282, abs=1e-3)\n\tassert e_ts - e_rev == pytest.approx(0.201, abs=1e-3)\n", "description": null, "category": "math", "imports": ["import pytest", "from ase import Atoms", "from ase.io import read", "from ase.calculators.gaussian import Gaussian, GaussianOptimizer, GaussianIRC", "from ase.optimize import LBFGS"]}], [{"term": "class", "name": "ClassicHisto", "data": "class ClassicHisto(Element):\n\tname = 'ClassicHisto'\n\n\tdef __init__(self,\n\t\t\t\t n_bins=50,\n\t\t\t\t y_label='Frequence',\n\t\t\t\t log_y=False,\n\t\t\t\t binning_dict=None):\n\t\tprint(binning_dict)\n\t\tsuper(ClassicHisto, self).__init__()\n\t\tself.calc_components.append(parts.CalcBinning(\n\t\t\tn_bins=n_bins,\n\t\t\tbinning_dict=binning_dict))\n\t\tself.calc_components.append(parts.CalcHistogram())\n\t\tself.calc_components.append(parts.CalcClassicHistoErrors())\n\t\tplot_hist = parts.PlotHistClassic(log_y=log_y,\n\t\t\t\t\t\t\t\t\t\t  y_label=y_label)\n\t\tself.plot_components.append(plot_hist)\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, print_function, division", "from .base_classes import Element", "from . import parts"]}, {"term": "class", "name": "ClassicRatio", "data": "class ClassicRatio(Element):\n\tname = 'ClassicRatio'\n\n\tdef __init__(self,\n\t\t\t\t n_bins=50,\n\t\t\t\t y_label=r'$\\frac{\\mathrm{Test - Ref}}{\\sigma}$',\n\t\t\t\t y_lims=None,\n\t\t\t\t binning_dict=None):\n\t\tsuper(ClassicRatio, self).__init__()\n\t\tself.calc_components.append(parts.CalcBinning(\n\t\t\tn_bins=n_bins,\n\t\t\tbinning_dict=binning_dict))\n\t\tself.calc_components.append(parts.CalcHistogram())\n\t\tself.calc_components.append(parts.CalcClassicHistoErrors())\n\t\tplot_ratio = parts.PlotRatioClassic(y_lims=y_lims,\n\t\t\t\t\t\t\t\t\t\t\ty_label=y_label)\n\t\tself.plot_components.append(plot_ratio)\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, print_function, division", "from .base_classes import Element", "from . import parts"]}, {"term": "class", "name": "AggarwalHisto", "data": "class AggarwalHisto(Element):\n\tname = 'AggarwalHisto'\n\n\tdef __init__(self,\n\t\t\t\t n_bins=50,\n\t\t\t\t y_label='Frequence',\n\t\t\t\t log_y=False,\n\t\t\t\t alpha=[0.68, 0.9, 0.99],\n\t\t\t\t bands=False,\n\t\t\t\t band_borders=True,\n\t\t\t\t band_brighten=True,\n\t\t\t\t band_alpha=0.5,\n\t\t\t\t binning_dict=None):\n\t\tsuper(AggarwalHisto, self).__init__()\n\t\tself.calc_components.append(parts.CalcBinning(\n\t\t\tn_bins=n_bins,\n\t\t\tbinning_dict=binning_dict))\n\t\tself.calc_components.append(parts.CalcHistogram())\n\t\tself.calc_components.append(parts.CalcAggarwalHistoErrors(alpha))\n\t\tplot_hist = parts.PlotHistAggerwal(log_y=log_y,\n\t\t\t\t\t\t\t\t\t\t   bands=bands,\n\t\t\t\t\t\t\t\t\t\t   band_borders=band_borders,\n\t\t\t\t\t\t\t\t\t\t   band_brighten=band_brighten,\n\t\t\t\t\t\t\t\t\t\t   band_alpha=band_alpha,\n\t\t\t\t\t\t\t\t\t\t   y_label=y_label)\n\t\tself.plot_components.append(plot_hist)\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, print_function, division", "from .base_classes import Element", "from . import parts"]}, {"term": "class", "name": "LimitedMCHisto", "data": "class LimitedMCHisto(Element):\n\tname = 'LimitedMCHisto'\n\n\tdef __init__(self,\n\t\t\t\t n_bins=50,\n\t\t\t\t y_label='Frequence',\n\t\t\t\t log_y=False,\n\t\t\t\t alpha=[0.68, 0.9, 0.99],\n\t\t\t\t bands=False,\n\t\t\t\t band_borders=True,\n\t\t\t\t band_brighten=True,\n\t\t\t\t band_alpha=0.5,\n\t\t\t\t binning_dict=None,\n\t\t\t\t likelihood='SAY'):\n\t\tsuper(LimitedMCHisto, self).__init__()\n\t\tself.calc_components.append(parts.CalcBinning(\n\t\t\tn_bins=n_bins,\n\t\t\tbinning_dict=binning_dict))\n\t\tself.calc_components.append(parts.CalcHistogram())\n\t\tself.calc_components.append(parts.CalcLimitedMCHistoErrors(alpha,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   likelihood))\n\t\tplot_hist = parts.PlotHistAggerwal(log_y=log_y,\n\t\t\t\t\t\t\t\t\t\t   bands=bands,\n\t\t\t\t\t\t\t\t\t\t   band_borders=band_borders,\n\t\t\t\t\t\t\t\t\t\t   band_brighten=band_brighten,\n\t\t\t\t\t\t\t\t\t\t   band_alpha=band_alpha,\n\t\t\t\t\t\t\t\t\t\t   y_label=y_label)\n\t\tself.plot_components.append(plot_hist)\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, print_function, division", "from .base_classes import Element", "from . import parts"]}, {"term": "class", "name": "AggarwalRatio", "data": "class AggarwalRatio(Element):\n\tname = 'AggarwalRatio'\n\n\tdef __init__(self,\n\t\t\t\t n_bins=50,\n\t\t\t\t y_label='p-value*',\n\t\t\t\t alpha=[0.68, 0.9, 0.99],\n\t\t\t\t zoomed=True,\n\t\t\t\t binning_dict=None,\n\t\t\t\t y_min_log_prob=None):\n\t\tsuper(AggarwalRatio, self).__init__()\n\t\tself.calc_components.append(parts.CalcBinning(\n\t\t\tn_bins=n_bins,\n\t\t\tbinning_dict=binning_dict))\n\t\tself.calc_components.append(parts.CalcHistogram())\n\t\tself.calc_components.append(parts.CalcAggarwalHistoErrors(alpha))\n\t\tself.calc_components.append(parts.CalcAggarwalRatios())\n\t\tself.plot_components.append(parts.PlotRatioAggerwal(\n\t\t\tzoomed=zoomed, y_label=y_label, y_min_log_prob=y_min_log_prob))\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, print_function, division", "from .base_classes import Element", "from . import parts"]}, {"term": "class", "name": "LimitedMCRatio", "data": "class LimitedMCRatio(Element):\n\tname = 'LimitedMCRatio'\n\n\tdef __init__(self,\n\t\t\t\t n_bins=50,\n\t\t\t\t y_label='p-value*',\n\t\t\t\t alpha=[0.68, 0.9, 0.99],\n\t\t\t\t zoomed=True,\n\t\t\t\t binning_dict=None,\n\t\t\t\t likelihood='SAY',\n\t\t\t\t y_min_log_prob=None):\n\t\tsuper(LimitedMCRatio, self).__init__()\n\t\tself.calc_components.append(parts.CalcBinning(\n\t\t\tn_bins=n_bins,\n\t\t\tbinning_dict=binning_dict))\n\t\tself.calc_components.append(parts.CalcHistogram())\n\t\tself.calc_components.append(parts.CalcLimitedMCHistoErrors(alpha,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   likelihood))\n\t\tself.calc_components.append(parts.CalcLimitedMCRatios())\n\t\tself.plot_components.append(parts.PlotRatioAggerwal(\n\t\t\tzoomed=zoomed, y_label=y_label, y_min_log_prob=y_min_log_prob))\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, print_function, division", "from .base_classes import Element", "from . import parts"]}, {"term": "class", "name": "Normalization", "data": "class Normalization(Element):\n\tname = 'Normalization'\n\n\tdef __init__(self, normalize=None):\n\t\tsuper(Normalization, self).__init__()\n\t\tif normalize is None:\n\t\t\tnormalize = False\n\t\tif isinstance(normalize, bool):\n\t\t\tif normalize:\n\t\t\t\tnormalize = 'sum_w'\n\t\t\tif isinstance(normalize, str):\n\t\t\t\tnormalize = normalize.lower()\n\t\t\t\tif normalize not in ['test_livetime', 'livetime', 'sum_w']:\n\t\t\t\t\traise AttributeError('Possible values for \\'normalize\\': '\n\t\t\t\t\t\t\t\t\t\t '[\\'test_livetime\\', \\'livetime\\', '\n\t\t\t\t\t\t\t\t\t\t '\\'sum_w\\', True, False]!')\n\t\tself.calc_components.append(parts.CalcNormalization(normalize))\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, print_function, division", "from .base_classes import Element", "from . import parts"]}], [{"term": "class", "name": "Stat", "data": "class Stat(NoNewAttributesAfterInit):\n\n\tdef __init__(self, name):\n\t\tself.name = name\n\t\tNoNewAttributesAfterInit.__init__(self)\n\n\tdef __repr__(self):\n\t\tif self.__doc__ is not None:\n\t\t\treturn self.__doc__\n\t\treturn (\"<%s statistic instance '%s'>\" %\n\t\t\t\t(type(self).__name__, self.name))\n\n\tdef calc_staterror(self, data):\n\t\traise NotImplementedError\n\n\tdef calc_stat(self, data, model, staterror=None, syserror=None,\n\t\t\t\t  weight=None):\n\t\traise NotImplementedError\n", "description": null, "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}, {"term": "class", "name": "Likelihood", "data": "class Likelihood(Stat):\n\t\"\"\"Maximum likelihood function\"\"\"\n\tdef __init__(self, name='likelihood'):\n\t\tStat.__init__(self, name)\n\n\t@staticmethod\n\tdef calc_staterror(data):\n\t\t# Likelihood stats do not have 'errors' associated with them.\n\t\t# return 1 to avoid dividing by 0 by some optimization methods.\n\t\treturn numpy.ones_like(data)\n\n", "description": "Maximum likelihood function", "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}, {"term": "class", "name": "Cash", "data": "class Cash(Likelihood):\n\t\"\"\"Maximum likelihood function\"\"\"\n\tdef __init__(self, name='cash'):\n\t\tLikelihood.__init__(self, name)\n\n\t@staticmethod\n\tdef calc_stat(data, model, staterror=None, syserror=None, weight=None):\n\t\treturn _statfcts.calc_cash_stat(data, model, staterror, syserror,\n\t\t\t\t\t\t\t\t\t\tweight, truncation_value)\n\n", "description": "Maximum likelihood function", "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}, {"term": "class", "name": "CStat", "data": "class CStat(Likelihood):\n\t\"\"\"Maximum likelihood function (XSPEC style)\"\"\"\n\tdef __init__(self, name='cstat'):\n\t\tLikelihood.__init__(self, name)\n\n\t@staticmethod\n\tdef calc_stat(data, model, staterror=None, syserror=None, weight=None):\n\t\treturn _statfcts.calc_cstat_stat(data, model, staterror, syserror,\n\t\t\t\t\t\t\t\t\t\t weight, truncation_value)\n\n", "description": "Maximum likelihood function (XSPEC style)", "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}, {"term": "class", "name": "Chi2", "data": "class Chi2(Stat):\n\t\"\"\"Chi Squared\"\"\"\n\tdef __init__(self, name='chi2'):\n\t\tStat.__init__(self, name)\n\n\t@staticmethod\n\tdef calc_staterror(data):\n\t\t raise StatErr('chi2noerr')\n\n\t@staticmethod\n\tdef calc_stat(data, model, staterror, syserror=None, weight=None):\n\t\treturn _statfcts.calc_chi2_stat(data, model, staterror,\n\t\t\t\t\t\t\t\t\t\tsyserror, weight, truncation_value)\n", "description": "Chi Squared", "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}, {"term": "class", "name": "LeastSq", "data": "class LeastSq(Chi2):\n\t\"\"\"Least Squared\"\"\"\n\tdef __init__(self, name='leastsq'):\n\t\tStat.__init__(self, name)\n\n\t@staticmethod\n\tdef calc_staterror(data):\n\t\treturn numpy.ones_like(data)\t\t\n\n\t@staticmethod\n\tdef calc_stat(data, model, staterror, syserror=None, weight=None):\n\t\treturn _statfcts.calc_lsq_stat(data, model, staterror,\n\t\t\t\t\t\t\t\t\t   syserror, weight, truncation_value)\n\t\n", "description": "Least Squared", "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}, {"term": "class", "name": "Chi2Gehrels", "data": "class Chi2Gehrels(Chi2):\n\t\"\"\"Chi Squared with Gehrels variance\"\"\"\n\tdef __init__(self, name='chi2gehrels'):\n\t\tChi2.__init__(self, name)\n\n\tcalc_staterror = _statfcts.calc_chi2gehrels_errors\n\n", "description": "Chi Squared with Gehrels variance", "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}, {"term": "class", "name": "Chi2ConstVar", "data": "class Chi2ConstVar(Chi2):\n\t\"\"\"Chi Squared with constant variance\"\"\"\n\tdef __init__(self, name='chi2constvar'):\n\t\tChi2.__init__(self, name)\n\n\tcalc_staterror = _statfcts.calc_chi2constvar_errors\n\n", "description": "Chi Squared with constant variance", "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}, {"term": "class", "name": "Chi2DataVar", "data": "class Chi2DataVar(Chi2):\n\t\"\"\"Chi Squared with data variance\"\"\"\n\tdef __init__(self, name='chi2datavar'):\n\t\tChi2.__init__(self, name)\n\n\tcalc_staterror = _statfcts.calc_chi2datavar_errors\n\n", "description": "Chi Squared with data variance", "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}, {"term": "class", "name": "Chi2ModVar", "data": "class Chi2ModVar(Chi2):\n\t\"\"\"Chi Squared with model amplitude variance\"\"\"\n\tdef __init__(self, name='chi2modvar'):\n\t\tChi2.__init__(self, name)\n\n\t# Statistical errors are not used\n\t@staticmethod\n\tdef calc_staterror(data):\n\t\treturn numpy.zeros_like(data)\n\n\t@staticmethod\n\tdef calc_stat(data, model, staterror, syserror=None, weight=None):\n\t\treturn _statfcts.calc_chi2modvar_stat(data, model, staterror,\n\t\t\t\t\t\t\t\t\t\t\t  syserror, weight,\n\t\t\t\t\t\t\t\t\t\t\t  truncation_value)\n\n", "description": "Chi Squared with model amplitude variance", "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}, {"term": "class", "name": "Chi2XspecVar", "data": "class Chi2XspecVar(Chi2):\n\t\"\"\"Chi Squared with data variance (XSPEC style)\"\"\"\n\tdef __init__(self, name='chi2xspecvar'):\n\t\tChi2.__init__(self, name)\n\n\tcalc_staterror = _statfcts.calc_chi2xspecvar_errors\n\n", "description": "Chi Squared with data variance (XSPEC style)", "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}, {"term": "class", "name": "UserStat", "data": "class UserStat(Stat):\n\n\tdef __init__(self, statfunc=None, errfunc=None, name='userstat'):\n\t\tself._statfuncset = False\n\t\tself.statfunc = (lambda x: None)\n\t\t\n\t\tself._staterrfuncset = False\n\t\tself.errfunc = (lambda x: None)\n\t\t\n\t\tif statfunc is not None:\n\t\t\tself.statfunc = statfunc\n\t\t\tself._statfuncset = True\n\n\t\tif errfunc is not None:\n\t\t\tself.errfunc = errfunc\n\t\t\tself._staterrfuncset = True\n\t\t\t\n\n\t\tStat.__init__(self, name)\n\n\n\tdef __getstate__(self):\n\t\tstate = self.__dict__.copy()\n\t\t# Function pointers to methods of the class\n\t\t# (of type 'instancemethod') are NOT picklable\n\t\t# remove them and restore later with a coord init\n\t\tdel state['statfunc']\n\t\tdel state['errfunc']\n\n\t\treturn state\n\n\tdef __setstate__(self, state):\n\t\t# Populate the function pointers we deleted at pickle time with\n\t\t# no-ops.\n\t\tself.__dict__['statfunc']=(lambda x: None)\n\t\tself.__dict__['errfunc']=(lambda x: None)\n\t\tself.__dict__.update(state)\n\n\n\tdef set_statfunc(self, func):\n\t\tself.statfunc = func\n\t\tself._statfuncset = True\n\n\n\tdef set_errfunc(self, func):\n\t\tself.errfunc = func\n\t\tself._staterrfuncset = True\n\n\n\tdef calc_staterror(self, data):\n\t\tif not self._staterrfuncset:\n\t\t\traise StatErr('nostat', self.name, 'calc_staterror()')\n\t\treturn self.errfunc(data)\n\n\n\tdef calc_stat(self, data, model, staterror=None, syserror=None,\n\t\t\t\t  weight=None):\n\t\tif not self._statfuncset:\n\t\t\traise StatErr('nostat', self.name, 'calc_stat()')\n\t\treturn self.statfunc(data, model, staterror, syserror, weight)\n", "description": null, "category": "math", "imports": ["import numpy", "from sherpa.utils import NoNewAttributesAfterInit", "from sherpa.utils.err import StatErr", "import sherpa.stats._statfcts", "from sherpa import get_config", "from ConfigParser import ConfigParser"]}], [], [{"term": "def", "name": "test_mopac", "data": "def test_mopac(mopac_factory):\n\t\"\"\"Test H2 molecule atomization with MOPAC.\"\"\"\n\t# Unrestricted Hartree-Fock; enable magmom calc\n\th2 = molecule('H2',\n\t\t\t\t  calculator=mopac_factory.calc(label='h2',\n\t\t\t\t\t\t\t\t\t\t\t\ttask='1SCF GRADIENTS UHF'))\n\twith Trajectory('h2.traj', mode='w') as traj:\n\t\tBFGS(h2, trajectory=traj).run(fmax=0.01)\n\te2 = h2.get_potential_energy()\n\th1 = h2.copy()\n\tdel h1[1]\n\th1.set_initial_magnetic_moments([1])\n\th1.calc = mopac_factory.calc(label='h1')\n\te1 = h1.get_potential_energy()\n\td = h2.get_distance(0, 1)\n\tea = 2 * e1 - e2\n\tprint(d, ea)\n\tassert abs(d - 0.759) < 0.001\n\tassert abs(ea - 5.907) < 0.001\n\th2o = molecule('H2O', calculator=mopac_factory.calc(label='h2o',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttasks='GRADIENTS'))\n\th2o.get_potential_energy()\n\tprint('dipole:', h2o.get_dipole_moment())\n\tatoms = MOPAC.read_atoms('h2')\n\tprint('magmom:', atoms.calc.get_magnetic_moment())\n\tprint('PM7 homo lumo:', atoms.calc.get_homo_lumo_levels())\n\tatoms.calc.set(method='AM1')\n\tatoms.get_potential_energy()\n\tprint('AM1 homo lumo:', atoms.calc.get_homo_lumo_levels())\n\tcalc = mopac_factory.calc(restart='h1')\n\tprint('magmom:', calc.get_magnetic_moment())\n\n", "description": "Test H2 molecule atomization with MOPAC.", "category": "math", "imports": ["import pytest", "from numpy.testing import assert_allclose", "from ase.build import molecule", "from ase.calculators.mopac import MOPAC", "from ase.io.trajectory import Trajectory", "from ase.optimize import BFGS"]}, {"term": "def", "name": "test_mopac_forces_consistent", "data": "def test_mopac_forces_consistent(mopac_factory):\n\t\"\"\"Check MOPAC forces follow Newton's 3rd Law\"\"\"\n\n\tch4 = molecule('CH4')\n\tch4.rattle()\n\tch4.calc = mopac_factory.calc(task='1SCF GRADIENTS', method='PM7')\n\tforces = ch4.get_forces()\n\n\tassert_allclose(forces.sum(axis=0), [0, 0, 0], atol=1e-7)\n", "description": "Check MOPAC forces follow Newton's 3rd Law", "category": "math", "imports": ["import pytest", "from numpy.testing import assert_allclose", "from ase.build import molecule", "from ase.calculators.mopac import MOPAC", "from ase.io.trajectory import Trajectory", "from ase.optimize import BFGS"]}], [{"term": "def", "name": "test_calc_mean", "data": "def test_calc_mean():\n\tassert calc_mean([1,2,3]) == 2\n\tassert calc_mean([4,2,3,3]) == 3\n", "description": null, "category": "math", "imports": ["from pytest import approx", "from calculations_functions import calc_mean, calc_sdv, calc_mode, calc_min, calc_max, calc_median, calc_sdv, calc_median_skewness, calc_mode_skewness"]}, {"term": "def", "name": "test_calc_sdv", "data": "def test_calc_sdv():\n\tassert calc_sdv([10, 12, 23, 23, 16, 23, 21, 16]) == approx(4.8989, 0.04)\n\tassert calc_sdv([234, 5443, 1 ,10, 12, 23, 23]) == approx(1888.52, 0.02)\n", "description": null, "category": "math", "imports": ["from pytest import approx", "from calculations_functions import calc_mean, calc_sdv, calc_mode, calc_min, calc_max, calc_median, calc_sdv, calc_median_skewness, calc_mode_skewness"]}, {"term": "def", "name": "test_calc_mode", "data": "def test_calc_mode():\n\tassert calc_mode([1,1,1,2,3,4,5]) == 1\n\tassert calc_mode([6,6,6,6,1,2,3,4,5,5]) == 6\n", "description": null, "category": "math", "imports": ["from pytest import approx", "from calculations_functions import calc_mean, calc_sdv, calc_mode, calc_min, calc_max, calc_median, calc_sdv, calc_median_skewness, calc_mode_skewness"]}, {"term": "def", "name": "test_calc_min", "data": "def test_calc_min():\n\tassert calc_min([1,2,3,4,5]) == 1\n\tassert calc_min([10,1,23231,3,4,5,0]) == 0\n", "description": null, "category": "math", "imports": ["from pytest import approx", "from calculations_functions import calc_mean, calc_sdv, calc_mode, calc_min, calc_max, calc_median, calc_sdv, calc_median_skewness, calc_mode_skewness"]}, {"term": "def", "name": "test_calc_max", "data": "def test_calc_max():\n\tassert calc_max([1,2,3,4,5]) == 5\n\tassert calc_max([10,1,23231,3,4,5,0]) == 23231\n", "description": null, "category": "math", "imports": ["from pytest import approx", "from calculations_functions import calc_mean, calc_sdv, calc_mode, calc_min, calc_max, calc_median, calc_sdv, calc_median_skewness, calc_mode_skewness"]}, {"term": "def", "name": "test_calc_median", "data": "def test_calc_median():\n\tassert calc_median([1,2,3,4,5]) == 3\n\tassert calc_median([2,2,4,6,6,6]) == 5\n", "description": null, "category": "math", "imports": ["from pytest import approx", "from calculations_functions import calc_mean, calc_sdv, calc_mode, calc_min, calc_max, calc_median, calc_sdv, calc_median_skewness, calc_mode_skewness"]}, {"term": "def", "name": "test_calc_median_skewness", "data": "def test_calc_median_skewness():\n", "description": null, "category": "math", "imports": ["from pytest import approx", "from calculations_functions import calc_mean, calc_sdv, calc_mode, calc_min, calc_max, calc_median, calc_sdv, calc_median_skewness, calc_mode_skewness"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "button_click", "data": "def button_click(char):\n\tglobal calc_operator\n\tcalc_operator += str(char)\n\ttext_input.set(calc_operator)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "button_clear_all", "data": "def button_clear_all():\n\tglobal calc_operator\n\tcalc_operator = \"\"\n\ttext_input.set(\"\")\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "button_delete", "data": "def button_delete():\n\tglobal calc_operator\n\ttext = calc_operator[:-1]\n\tcalc_operator = text\n\ttext_input.set(text)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "factorial", "data": "def factorial(n):\n\tif n==0 or n==1:\n\t\treturn 1\n\telse:\n\t\treturn n*factorial(n-1)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "fact_func", "data": "def fact_func():\n\tglobal calc_operator\n\tresult = str(factorial(int(calc_operator)))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_sin", "data": "def trig_sin():\n\tglobal calc_operator\n\tresult = str(math.sin(math.radians(int(calc_operator))))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_cos", "data": "def trig_cos():\n\tglobal calc_operator\n\tresult = str(math.cos(math.radians(int(calc_operator))))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_tan", "data": "def trig_tan():\n\tglobal calc_operator\n\tresult = str(math.tan(math.radians(int(calc_operator))))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_cot", "data": "def trig_cot():\n\tglobal calc_operator\n\tresult = str(1/math.tan(math.radians(int(calc_operator))))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "square_root", "data": "def square_root():\n\tglobal calc_operator\n\tif int(calc_operator)>=0:\n\t\ttemp = str(eval(calc_operator+'**(1/2)'))\n\t\tcalc_operator = temp\n\telse:\n\t\ttemp = \"ERROR\"\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "third_root", "data": "def third_root():\n\tglobal calc_operator\n\tif int(calc_operator)>=0:\n\t\ttemp = str(eval(calc_operator+'**(1/3)'))\n\t\tcalc_operator = temp\n\telse:\n\t\ttemp = \"ERROR\"\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "sign_change", "data": "def sign_change():\n\tglobal calc_operator\n\tif calc_operator[0]=='-':\n\t\ttemp = calc_operator[1:]\n\telse:\n\t\ttemp = '-'+calc_operator\n\tcalc_operator = temp\n\ttext_input.set(temp)\t\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "percent", "data": "def percent():\n\tglobal calc_operator\n\ttemp = str(eval(calc_operator+'/100'))\n\tcalc_operator = temp\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "button_equal", "data": "def button_equal():\n\tglobal calc_operator\n\ttemp_op = str(eval(calc_operator))\n\ttext_input.set(temp_op)\n\tcalc_operator = temp_op\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}], [{"term": "def", "name": "test_aims_interface", "data": "def test_aims_interface():\n\timport tempfile\n\timport os\n\n\tfrom ase.calculators.aims import Aims\n\tfrom ase import Atoms\n\n\t# test the new command handling + legacy behavior\n\taims_command = 'aims.x'\n\taims_command_alternative = 'mpirun -np 4 fhiaims.x'\n\toutfilename = 'alternative_aims.out'\n\toutfilename_default = 'aims.out'\n\tcommand = '{0:s} > {1:s}'.format(aims_command, outfilename)\n\t#command_alternative = '{0:s} > {1:s}'.format(aims_command_alternative, outfilename)\n\tcommand_default = '{0:s} > {1:s}'.format(aims_command, outfilename_default)\n\tlegacy_command = 'aims.version.serial.x > aims.out'\n\tlegacy_aims_command = legacy_command.split('>')[0].strip()\n\tlegacy_outfilename = legacy_command.split('>')[-1].strip()\n\n\t# legacy behavior of empty init\n\tcalc = Aims()\n\tassert calc.command == legacy_command\n\tassert calc.outfilename == legacy_outfilename\n\tassert calc.aims_command == legacy_aims_command\n\n\t# behavior of empty init with env variable\n\tos.environ['ASE_AIMS_COMMAND'] = aims_command_alternative\n\tcalc = Aims()\n\tassert calc.command == '{0} > {1}'.format(aims_command_alternative, outfilename_default)\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command_alternative\n\n\t# legacy behavior of \"proper\" command\n\tcalc = Aims(run_command=command)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# legacy behavior of an \"improper\" command\n\tcalc = Aims(run_command=aims_command)\n\tassert calc.command == command_default\n\tassert calc.aims_command == aims_command\n\tassert calc.outfilename == outfilename_default\n\n\t# fixed \"command\"  behavior\n\tcalc = Aims(command=command)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# novel way to use aims_command, no specific outfile\n\tcalc = Aims(aims_command=aims_command)\n\tassert calc.command == command_default\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command\n\n\tcalc = Aims(aims_command=aims_command,\n\t\t\t\toutfilename=outfilename)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# # testing the setters\n\tcalc.command = command_default\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command\n\tassert calc.command == command_default\n\n\t#calc.set_aims_command(aims_command_alternative)\n\tcalc.aims_command = aims_command_alternative\n\tassert calc.aims_command == aims_command_alternative\n\tassert calc.outfilename == outfilename_default\n\tassert calc.command == '{} > {}'.format(aims_command_alternative, outfilename_default)\n\n\tcalc.outfilename = outfilename\n\tassert calc.command == '{} > {}'.format(aims_command_alternative, outfilename)\n\tassert calc.aims_command == aims_command_alternative\n\tassert calc.outfilename == outfilename\n\n\n\t# test writing files\n\ttmp_dir = tempfile.mkdtemp()\n\twater = Atoms('HOH', [(1, 0, 0), (0, 0, 0), (0, 1, 0)])\n\tcalc = Aims(xc='PBE',\n\t\t\t\toutput=['dipole'],\n\t\t\t\tsc_accuracy_etot=1e-6,\n\t\t\t\tsc_accuracy_eev=1e-3,\n\t\t\t\tsc_accuracy_rho=1e-6,\n\t\t\t\tspecies_dir=\"/data/rittmeyer/FHIaims/species_defaults/light/\",\n\t\t\t\tsc_accuracy_forces=1e-4,\n\t\t\t\tlabel=tmp_dir,\n\t\t\t\t)\n\ttry:\n\t\tcalc.prepare_input_files()\n\t\traise AssertionError\n\texcept ValueError:\n\t\tpass\n\n\tcalc.atoms = water\n\tcalc.prepare_input_files()\n\tfor f in ['control.in', 'geometry.in']:\n\t\tassert os.path.isfile(os.path.join(tmp_dir,f))\n", "description": null, "category": "math", "imports": ["\timport tempfile", "\timport os", "\tfrom ase.calculators.aims import Aims", "\tfrom ase import Atoms"]}], [{"term": "def", "name": "test_plugin_aliases_instantiate", "data": "def test_plugin_aliases_instantiate():\n\tAddAliases()\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.aliases import AddAliases", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_aliases_hook", "data": "def test_plugin_aliases_hook():\n\tcalc = TestCalculator()\n\tplugin = AddAliases()\n\tcalc.register_plugin(plugin)\n\tassert plugin in calc.plugins\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.aliases import AddAliases", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_aliases_context_updated", "data": "def test_plugin_aliases_context_updated():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(AddAliases())\n\tassert calc.chksym(\"mksym\")\n\tassert calc.chksym(\"nCr\")\n\tassert calc.chksym(\"ncr\")\n\tassert calc.chksym(\"nPr\")\n\tassert calc.chksym(\"npr\")\n\tassert calc.chksym(\"plot_3d\")\n\tassert calc.chksym(\"plot_3d_parametric_line\")\n\tassert calc.chksym(\"plot_3d_parametric_surface\")\n\tassert calc.chksym(\"graph\")\n\tassert calc.chksym(\"graph_implicit\")\n\tassert calc.chksym(\"graph_parametric\")\n\tassert calc.chksym(\"graph3d\")\n\tassert calc.chksym(\"graph3d_parametric_line\")\n\tassert calc.chksym(\"graph3d_parametric_surface\")\n\tassert calc.chksym(\"differentiate\")\n\tassert calc.chksym(\"arcsin\")\n\tassert calc.chksym(\"arccos\")\n\tassert calc.chksym(\"arctan\")\n\tassert calc.chksym(\"arcsec\")\n\tassert calc.chksym(\"arccsc\")\n\tassert calc.chksym(\"arccot\")\n\tassert calc.chksym(\"arcsinh\")\n\tassert calc.chksym(\"arccosh\")\n\tassert calc.chksym(\"arctanh\")\n\tassert calc.chksym(\"arcsech\")\n\tassert calc.chksym(\"arccsch\")\n\tassert calc.chksym(\"arccoth\")\n\tassert calc.chksym(\"sindeg\")\n\tassert calc.chksym(\"cosdeg\")\n\tassert calc.chksym(\"tandeg\")\n\tassert calc.chksym(\"secdeg\")\n\tassert calc.chksym(\"cscdeg\")\n\tassert calc.chksym(\"cotdeg\")\n\tassert calc.chksym(\"asindeg\")\n\tassert calc.chksym(\"acosdeg\")\n\tassert calc.chksym(\"atandeg\")\n\tassert calc.chksym(\"asecdeg\")\n\tassert calc.chksym(\"acscdeg\")\n\tassert calc.chksym(\"acotdeg\")\n\tassert calc.chksym(\"arcsindeg\")\n\tassert calc.chksym(\"arccosdeg\")\n\tassert calc.chksym(\"arctandeg\")\n\tassert calc.chksym(\"arcsecdeg\")\n\tassert calc.chksym(\"arccscdeg\")\n\tassert calc.chksym(\"arccotdeg\")\n\n\tassert callable(calc.getsym(\"mksym\"))\n\tassert callable(calc.getsym(\"nCr\"))\n\tassert callable(calc.getsym(\"ncr\"))\n\tassert callable(calc.getsym(\"nPr\"))\n\tassert callable(calc.getsym(\"npr\"))\n\tassert callable(calc.getsym(\"plot_3d\"))\n\tassert callable(calc.getsym(\"plot_3d_parametric_line\"))\n\tassert callable(calc.getsym(\"plot_3d_parametric_surface\"))\n\tassert callable(calc.getsym(\"graph\"))\n\tassert callable(calc.getsym(\"graph_implicit\"))\n\tassert callable(calc.getsym(\"graph_parametric\"))\n\tassert callable(calc.getsym(\"graph3d\"))\n\tassert callable(calc.getsym(\"graph3d_parametric_line\"))\n\tassert callable(calc.getsym(\"graph3d_parametric_surface\"))\n\tassert callable(calc.getsym(\"differentiate\"))\n\tassert callable(calc.getsym(\"arcsin\"))\n\tassert callable(calc.getsym(\"arccos\"))\n\tassert callable(calc.getsym(\"arctan\"))\n\tassert callable(calc.getsym(\"arcsec\"))\n\tassert callable(calc.getsym(\"arccsc\"))\n\tassert callable(calc.getsym(\"arccot\"))\n\tassert callable(calc.getsym(\"arcsinh\"))\n\tassert callable(calc.getsym(\"arccosh\"))\n\tassert callable(calc.getsym(\"arctanh\"))\n\tassert callable(calc.getsym(\"arcsech\"))\n\tassert callable(calc.getsym(\"arccsch\"))\n\tassert callable(calc.getsym(\"arccoth\"))\n\tassert callable(calc.getsym(\"sindeg\"))\n\tassert callable(calc.getsym(\"cosdeg\"))\n\tassert callable(calc.getsym(\"tandeg\"))\n\tassert callable(calc.getsym(\"secdeg\"))\n\tassert callable(calc.getsym(\"cscdeg\"))\n\tassert callable(calc.getsym(\"cotdeg\"))\n\tassert callable(calc.getsym(\"asindeg\"))\n\tassert callable(calc.getsym(\"acosdeg\"))\n\tassert callable(calc.getsym(\"atandeg\"))\n\tassert callable(calc.getsym(\"asecdeg\"))\n\tassert callable(calc.getsym(\"acscdeg\"))\n\tassert callable(calc.getsym(\"acotdeg\"))\n\tassert callable(calc.getsym(\"arcsindeg\"))\n\tassert callable(calc.getsym(\"arccosdeg\"))\n\tassert callable(calc.getsym(\"arctandeg\"))\n\tassert callable(calc.getsym(\"arcsecdeg\"))\n\tassert callable(calc.getsym(\"arccscdeg\"))\n\tassert callable(calc.getsym(\"arccotdeg\"))\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.aliases import AddAliases", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_aliases_available", "data": "def test_plugin_aliases_available():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(AddAliases())\n\tassert callable(calc.command(\"mksym\"))\n\tassert callable(calc.command(\"nCr\"))\n\tassert callable(calc.command(\"ncr\"))\n\tassert callable(calc.command(\"nPr\"))\n\tassert callable(calc.command(\"npr\"))\n\tassert callable(calc.command(\"plot_3d\"))\n\tassert callable(calc.command(\"plot_3d_parametric_line\"))\n\tassert callable(calc.command(\"plot_3d_parametric_surface\"))\n\tassert callable(calc.command(\"graph\"))\n\tassert callable(calc.command(\"graph_implicit\"))\n\tassert callable(calc.command(\"graph_parametric\"))\n\tassert callable(calc.command(\"graph3d\"))\n\tassert callable(calc.command(\"graph3d_parametric_line\"))\n\tassert callable(calc.command(\"graph3d_parametric_surface\"))\n\tassert callable(calc.command(\"differentiate\"))\n\tassert callable(calc.command(\"arcsin\"))\n\tassert callable(calc.command(\"arccos\"))\n\tassert callable(calc.command(\"arctan\"))\n\tassert callable(calc.command(\"arcsec\"))\n\tassert callable(calc.command(\"arccsc\"))\n\tassert callable(calc.command(\"arccot\"))\n\tassert callable(calc.command(\"arcsinh\"))\n\tassert callable(calc.command(\"arccosh\"))\n\tassert callable(calc.command(\"arctanh\"))\n\tassert callable(calc.command(\"arcsech\"))\n\tassert callable(calc.command(\"arccsch\"))\n\tassert callable(calc.command(\"arccoth\"))\n\tassert callable(calc.command(\"sindeg\"))\n\tassert callable(calc.command(\"cosdeg\"))\n\tassert callable(calc.command(\"tandeg\"))\n\tassert callable(calc.command(\"secdeg\"))\n\tassert callable(calc.command(\"cscdeg\"))\n\tassert callable(calc.command(\"cotdeg\"))\n\tassert callable(calc.command(\"asindeg\"))\n\tassert callable(calc.command(\"acosdeg\"))\n\tassert callable(calc.command(\"atandeg\"))\n\tassert callable(calc.command(\"asecdeg\"))\n\tassert callable(calc.command(\"acscdeg\"))\n\tassert callable(calc.command(\"acotdeg\"))\n\tassert callable(calc.command(\"arcsindeg\"))\n\tassert callable(calc.command(\"arccosdeg\"))\n\tassert callable(calc.command(\"arctandeg\"))\n\tassert callable(calc.command(\"arcsecdeg\"))\n\tassert callable(calc.command(\"arccscdeg\"))\n\tassert callable(calc.command(\"arccotdeg\"))\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.aliases import AddAliases", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_aliases_degree_conversion", "data": "def test_plugin_aliases_degree_conversion():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(AddAliases())\n\n\tassert calc.command(\"sindeg(0)\") == 0\n\tassert calc.command(\"cosdeg(0)\") == 1\n\tassert calc.command(\"tandeg(0)\") == 0\n\t# assert calc.command(\"cscdeg(0)\") == 0\n\tassert calc.command(\"secdeg(0)\") == 1\n\t# assert calc.command(\"tandeg(0)\") == 0\n\n\tassert calc.command(\"sindeg(30)\") == calc.command(\"S(1)/2\")\n\tassert calc.command(\"cosdeg(30)\") == calc.command(\"sqrt(S(3))/2\")\n\tassert calc.command(\"tandeg(30)\") == calc.command(\"sqrt(S(3))/3\")\n\tassert calc.command(\"cscdeg(30)\") == 2\n\tassert calc.command(\"secdeg(30)\") == calc.command(\"2/sqrt(S(3))\")\n\tassert calc.command(\"cotdeg(30)\") == calc.command(\"3/sqrt(S(3))\")\n\tassert calc.command(\"sindeg(45)\") == calc.command(\"sqrt(S(2))/2\")\n\tassert calc.command(\"cosdeg(45)\") == calc.command(\"sqrt(S(2))/2\")\n\tassert calc.command(\"tandeg(45)\") == 1\n\tassert calc.command(\"cscdeg(45)\") == calc.command(\"2/sqrt(S(2))\")\n\tassert calc.command(\"secdeg(45)\") == calc.command(\"2/sqrt(S(2))\")\n\tassert calc.command(\"cotdeg(45)\") == 1\n\tassert calc.command(\"sindeg(60)\") == calc.command(\"sqrt(S(3))/2\")\n\tassert calc.command(\"cosdeg(60)\") == calc.command(\"S(1)/2\")\n\tassert calc.command(\"tandeg(60)\") == calc.command(\"sqrt(S(3))\")\n\tassert calc.command(\"cscdeg(60)\") == calc.command(\"2/sqrt(S(3))\")\n\tassert calc.command(\"secdeg(60)\") == 2\n\tassert calc.command(\"cotdeg(60)\") == calc.command(\"1/sqrt(S(3))\")\n\tassert calc.command(\"sindeg(90)\") == 1\n\tassert calc.command(\"cosdeg(90)\") == 0\n\t# assert calc.command(\"tandeg(90)\") == 0\n\t# assert calc.command(\"secdeg(90)\") == 0\n\tassert calc.command(\"cscdeg(90)\") == 1\n\t# assert calc.command(\"cotdeg(90)\") == 0\n\tassert calc.command(\"sindeg(120)\") == calc.command(\"sqrt(S(3))/2\")\n\tassert calc.command(\"cosdeg(120)\") == calc.command(\"-S(1)/2\")\n\tassert calc.command(\"tandeg(120)\") == calc.command(\"-sqrt(S(3))\")\n\tassert calc.command(\"cscdeg(120)\") == calc.command(\"2/sqrt(S(3))\")\n\tassert calc.command(\"secdeg(120)\") == -2\n\tassert calc.command(\"cotdeg(120)\") == calc.command(\"-1/sqrt(S(3))\")\n\tassert calc.command(\"sindeg(150)\") == calc.command(\"S(1)/2\")\n\tassert calc.command(\"cosdeg(150)\") == calc.command(\"-sqrt(S(3))/2\")\n\tassert calc.command(\"tandeg(150)\") == calc.command(\"-sqrt(S(3))/3\")\n\tassert calc.command(\"cscdeg(150)\") == 2\n\tassert calc.command(\"secdeg(150)\") == calc.command(\"-2/sqrt(S(3))\")\n\tassert calc.command(\"cotdeg(150)\") == calc.command(\"-3/sqrt(S(3))\")\n\tassert calc.command(\"sindeg(180)\") == 0\n\tassert calc.command(\"cosdeg(180)\") == -1\n\tassert calc.command(\"tandeg(180)\") == 0\n\t# assert calc.command(\"cscdeg(180)\") == 0\n\tassert calc.command(\"secdeg(180)\") == -1\n\t# assert calc.command(\"tandeg(180)\") == 0\n\n\tassert calc.command(\"sindeg(-30)\") == calc.command(\"-S(1)/2\")\n\tassert calc.command(\"cosdeg(-30)\") == calc.command(\"sqrt(S(3))/2\")\n\tassert calc.command(\"tandeg(-30)\") == calc.command(\"-sqrt(S(3))/3\")\n\tassert calc.command(\"cscdeg(-30)\") == -2\n\tassert calc.command(\"secdeg(-30)\") == calc.command(\"2/sqrt(S(3))\")\n\tassert calc.command(\"cotdeg(-30)\") == calc.command(\"-3/sqrt(S(3))\")\n\tassert calc.command(\"sindeg(-45)\") == calc.command(\"-sqrt(S(2))/2\")\n\tassert calc.command(\"cosdeg(-45)\") == calc.command(\"sqrt(S(2))/2\")\n\tassert calc.command(\"tandeg(-45)\") == -1\n\tassert calc.command(\"cscdeg(-45)\") == calc.command(\"-2/sqrt(S(2))\")\n\tassert calc.command(\"secdeg(-45)\") == calc.command(\"2/sqrt(S(2))\")\n\tassert calc.command(\"cotdeg(-45)\") == -1\n\tassert calc.command(\"sindeg(-60)\") == calc.command(\"-sqrt(S(3))/2\")\n\tassert calc.command(\"cosdeg(-60)\") == calc.command(\"S(1)/2\")\n\tassert calc.command(\"tandeg(-60)\") == calc.command(\"-sqrt(S(3))\")\n\tassert calc.command(\"cscdeg(-60)\") == calc.command(\"-2/sqrt(S(3))\")\n\tassert calc.command(\"secdeg(-60)\") == 2\n\tassert calc.command(\"cotdeg(-60)\") == calc.command(\"-1/sqrt(S(3))\")\n\tassert calc.command(\"sindeg(-90)\") == -1\n\tassert calc.command(\"cosdeg(-90)\") == 0\n\t# assert calc.command(\"tandeg(-90)\") == 0\n\t# assert calc.command(\"secdeg(-90)\") == 0\n\tassert calc.command(\"cscdeg(-90)\") == -1\n\t# assert calc.command(\"cotdeg(-90)\") == 0\n\tassert calc.command(\"sindeg(-120)\") == calc.command(\"-sqrt(S(3))/2\")\n\tassert calc.command(\"cosdeg(-120)\") == calc.command(\"-S(1)/2\")\n\tassert calc.command(\"tandeg(-120)\") == calc.command(\"sqrt(S(3))\")\n\tassert calc.command(\"cscdeg(-120)\") == calc.command(\"-2/sqrt(S(3))\")\n\tassert calc.command(\"secdeg(-120)\") == -2\n\tassert calc.command(\"cotdeg(-120)\") == calc.command(\"1/sqrt(S(3))\")\n\tassert calc.command(\"sindeg(-150)\") == calc.command(\"-S(1)/2\")\n\tassert calc.command(\"cosdeg(-150)\") == calc.command(\"-sqrt(S(3))/2\")\n\tassert calc.command(\"tandeg(-150)\") == calc.command(\"sqrt(S(3))/3\")\n\tassert calc.command(\"cscdeg(-150)\") == -2\n\tassert calc.command(\"secdeg(-150)\") == calc.command(\"-2/sqrt(S(3))\")\n\tassert calc.command(\"cotdeg(-150)\") == calc.command(\"3/sqrt(S(3))\")\n\tassert calc.command(\"sindeg(-180)\") == 0\n\tassert calc.command(\"cosdeg(-180)\") == -1\n\tassert calc.command(\"tandeg(-180)\") == 0\n\t# assert calc.command(\"cscdeg(-180)\") == 0\n\tassert calc.command(\"secdeg(-180)\") == -1\n\t# assert calc.command(\"tandeg(-180)\") == 0\n\n\tfor n in range(1, 10):\n\t\tfor d in range(0, 360, 10):\n\t\t\tassert calc.command(f\"sindeg({d}).evalf()\") == calc.command(f\"sindeg({d + 360*n}).evalf*(\") == calc.command(f\"sindeg({d - 360*n}).evalf()\")\n\t\t\tassert calc.command(f\"cosdeg({d}).evalf()\") == calc.command(f\"cosdeg({d + 360*n}).evalf*(\") == calc.command(f\"cosdeg({d - 360*n}).evalf()\")\n\t\t\tassert calc.command(f\"tandeg({d}).evalf()\") == calc.command(f\"tandeg({d + 180*n}).evalf*(\") == calc.command(f\"tandeg({d - 180*n}).evalf()\")\n\t\t\tassert calc.command(f\"secdeg({d}).evalf()\") == calc.command(f\"secdeg({d + 360*n}).evalf*(\") == calc.command(f\"secdeg({d - 360*n}).evalf()\")\n\t\t\tassert calc.command(f\"cscdeg({d}).evalf()\") == calc.command(f\"cscdeg({d + 360*n}).evalf*(\") == calc.command(f\"cscdeg({d - 360*n}).evalf()\")\n\t\t\tassert calc.command(f\"cotdeg({d}).evalf()\") == calc.command(f\"cotdeg({d + 180*n}).evalf*(\") == calc.command(f\"cotdeg({d - 180*n}).evalf()\")\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.aliases import AddAliases", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_aliases_invdegree_conversion", "data": "def test_plugin_aliases_invdegree_conversion():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(AddAliases())\n\n\tassert calc.command(\"asindeg(0)\") == 0\n\tassert calc.command(\"acosdeg(0)\") == 90\n\tassert calc.command(\"atandeg(0)\") == 0\n\n\tassert calc.command(\"asindeg(S(1)/2)\") == 30\n\tassert calc.command(\"acosdeg(sqrt(S(3))/2)\") == 30\n\tassert calc.command(\"atandeg(sqrt(S(3))/3)\") == 30\n\tassert calc.command(\"acscdeg(2)\") == 30\n\tassert calc.command(\"asecdeg(2/sqrt(S(3)))\") == 30\n\tassert calc.command(\"acotdeg(3/sqrt(S(3)))\") == 30\n\tassert calc.command(\"asindeg(sqrt(S(2))/2)\") == 45\n\tassert calc.command(\"acosdeg(sqrt(S(2))/2)\") == 45\n\tassert calc.command(\"atandeg(1)\") == 45\n\tassert calc.command(\"acscdeg(2/sqrt(S(2)))\") == 45\n\tassert calc.command(\"asecdeg(2/sqrt(S(2)))\") == 45\n\tassert calc.command(\"acotdeg(1)\") == 45\n\tassert calc.command(\"asindeg(sqrt(S(3))/2)\") == 60\n\tassert calc.command(\"acosdeg(S(1)/2)\") == 60\n\tassert calc.command(\"atandeg(sqrt(S(3)))\") == 60\n\tassert calc.command(\"acscdeg(2/sqrt(S(3)))\") == 60\n\tassert calc.command(\"asecdeg(2)\") == 60\n\tassert calc.command(\"acotdeg(1/sqrt(S(3)))\") == 60\n\tassert calc.command(\"asindeg(1)\") == 90\n\tassert calc.command(\"acosdeg(0)\") == 90\n\tassert calc.command(\"acscdeg(1)\") == 90\n\n\tassert calc.command(\"asindeg(-S(1)/2)\") == -30\n\tassert calc.command(\"atandeg(-sqrt(S(3))/3)\") == -30\n\tassert calc.command(\"acscdeg(-2)\") == -30\n\tassert calc.command(\"acotdeg(-3/sqrt(S(3)))\") == -30\n\tassert calc.command(\"asindeg(-sqrt(S(2))/2)\") == -45\n\tassert calc.command(\"atandeg(-1)\") == -45\n\tassert calc.command(\"acscdeg(-2/sqrt(S(2)))\") == -45\n\tassert calc.command(\"acotdeg(-1)\") == -45\n\tassert calc.command(\"asindeg(-sqrt(S(3))/2)\") == -60\n\tassert calc.command(\"atandeg(-sqrt(S(3)))\") == -60\n\tassert calc.command(\"acscdeg(-2/sqrt(S(3)))\") == -60\n\tassert calc.command(\"acotdeg(-1/sqrt(S(3)))\") == -60\n\tassert calc.command(\"asindeg(-1)\") == -90\n\tassert calc.command(\"cscdeg(-90)\") == -1\n\n\tfor d in range(-170, 171, 10):\n\t\tassert calc.command(f\"asindeg({d}).evalf()\") == calc.command(f\"arcsindeg({d}).evalf()\")\n\t\tassert calc.command(f\"acosdeg({d}).evalf()\") == calc.command(f\"arccosdeg({d}).evalf()\")\n\t\tassert calc.command(f\"atandeg({d}).evalf()\") == calc.command(f\"arctandeg({d}).evalf()\")\n\t\tassert calc.command(f\"asecdeg({d}).evalf()\") == calc.command(f\"arcsecdeg({d}).evalf()\")\n\t\tassert calc.command(f\"acscdeg({d}).evalf()\") == calc.command(f\"arccscdeg({d}).evalf()\")\n\t\tassert calc.command(f\"atandeg({d}).evalf()\") == calc.command(f\"arctandeg({d}).evalf()\")\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.aliases import AddAliases", "from tests import TestCalculator"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "class", "name": "classSpline:", "data": "class Spline:\n\t\"\"\"\n\tCubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.b, self.c, self.d, self.w = [], [], [], []\n\n\t\tself.x = x\n\t\tself.y = y\n\n\t\tself.nx = len(x)  # dimension of x\n\t\th = np.diff(x)\n\n\t\t# calc coefficient c\n\t\tself.a = [iy for iy in y]\n\n\t\t# calc coefficient c\n\t\tA = self.__calc_A(h)\n\t\tB = self.__calc_B(h)\n\t\tself.c = np.linalg.solve(A, B)\n\t\t#  print(self.c1)\n\n\t\t# calc spline coefficient b and d\n\t\tfor i in range(self.nx - 1):\n\t\t\tself.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n\t\t\ttb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n\t\t\t\t(self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n\t\t\tself.b.append(tb)\n\n\tdef calc(self, t):\n\t\t\"\"\"\n\t\tCalc position\n\n\t\tif t is outside of the input x, return None\n\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.a[i] + self.b[i] * dx + \\\n\t\t\tself.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n\t\treturn result\n\n\tdef calcd(self, t):\n\t\t\"\"\"\n\t\tCalc first derivative\n\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n\t\treturn result\n\n\tdef calcdd(self, t):\n\t\t\"\"\"\n\t\tCalc second derivative\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n\t\treturn result\n\n\tdef __search_index(self, x):\n\t\t\"\"\"\n\t\tsearch data segment index\n\t\t\"\"\"\n\t\treturn bisect.bisect(self.x, x) - 1\n\n\tdef __calc_A(self, h):\n\t\t\"\"\"\n\t\tcalc matrix A for spline coefficient c\n\t\t\"\"\"\n\t\tA = np.zeros((self.nx, self.nx))\n\t\tA[0, 0] = 1.0\n\t\tfor i in range(self.nx - 1):\n\t\t\tif i != (self.nx - 2):\n\t\t\t\tA[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n\t\t\tA[i + 1, i] = h[i]\n\t\t\tA[i, i + 1] = h[i]\n\n\t\tA[0, 1] = 0.0\n\t\tA[self.nx - 1, self.nx - 2] = 0.0\n\t\tA[self.nx - 1, self.nx - 1] = 1.0\n\t\t#  print(A)\n\t\treturn A\n\n\tdef __calc_B(self, h):\n\t\t\"\"\"\n\t\tcalc matrix B for spline coefficient c\n\t\t\"\"\"\n\t\tB = np.zeros(self.nx)\n\t\tfor i in range(self.nx - 2):\n\t\t\tB[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n\t\t\t\th[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n\t\treturn B\n\n", "description": "\n\tCubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "class", "name": "classSpline2D:", "data": "class Spline2D:\n\t\"\"\"\n\t2D Cubic Spline class\n\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.s = self.__calc_s(x, y)\n\t\tself.sx = Spline(self.s, x)\n\t\tself.sy = Spline(self.s, y)\n\n\tdef __calc_s(self, x, y):\n\t\tdx = np.diff(x)\n\t\tdy = np.diff(y)\n\t\tself.ds = np.hypot(dx, dy)\n\t\ts = [0]\n\t\ts.extend(np.cumsum(self.ds))\n\t\treturn s\n\n\tdef calc_position(self, s):\n\t\t\"\"\"\n\t\tcalc position\n\t\t\"\"\"\n\t\tx = self.sx.calc(s)\n\t\ty = self.sy.calc(s)\n\n\t\treturn x, y\n\n\tdef calc_curvature(self, s):\n\t\t\"\"\"\n\t\tcalc curvature\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tddx = self.sx.calcdd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tddy = self.sy.calcdd(s)\n\t\tk = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n\t\treturn k\n\n\tdef calc_yaw(self, s):\n\t\t\"\"\"\n\t\tcalc yaw\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tyaw = math.atan2(dy, dx)\n\t\treturn yaw\n\n", "description": "\n\t2D Cubic Spline class\n\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "calc_spline_course", "data": "def calc_spline_course(x, y, ds=0.1):\n\tsp = Spline2D(x, y)\n\ts = list(np.arange(0, sp.s[-1], ds))\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\treturn rx, ry, ryaw, rk, s\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():  # pragma: no cover\n\tprint(\"Spline 2D test\")\n\timport matplotlib.pyplot as plt\n\tx = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n\ty = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n\tds = 0.1  # [m] distance of each intepolated points\n\n\tsp = Spline2D(x, y)\n\ts = np.arange(0, sp.s[-1], ds)\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\tplt.subplots(1)\n\tplt.plot(x, y, \"xb\", label=\"input\")\n\tplt.plot(rx, ry, \"-r\", label=\"spline\")\n\tplt.grid(True)\n\tplt.axis(\"equal\")\n\tplt.xlabel(\"x[m]\")\n\tplt.ylabel(\"y[m]\")\n\tplt.legend()\n\n\tplt.subplots(1)\n\tplt.plot(s, [np.rad2deg(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"yaw angle[deg]\")\n\n\tplt.subplots(1)\n\tplt.plot(s, rk, \"-r\", label=\"curvature\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"curvature [1/m]\")\n\n\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "signal_handler", "data": "def signal_handler(signum, frame):\n\tmsg = 'FAILED`recv signal ' + str(signum) + '. exit now.'\n\tcommon.info(my_log, log_tag, time_tag + msg)\n\n\tif os.path.isfile(my_pidfile):\n\t\tos.remove(my_pidfile)\n\t\n\tsys.exit(0)\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import shutil", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "from datetime import timedelta", "from multiprocessing import Pool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "calc_just_obc", "data": "def calc_just_obc():\n\tif len(my_obc_table) <= 0:\n\t\treturn True\n\t\n\t\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'], \n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor()\n\texcept MySQLdb.Error, e:\n\t\tmsg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1]\t\t\t  \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\t\t\n\tfor one_sds in ins_conf.obc_to_db.values():\n\t\tfor one_column in xrange(1, one_sds['columns'] + 1):\n\t\t\tdb_field = one_sds['db_field']\n\t\t\tif one_sds['columns'] is not 1:\n\t\t\t\tdb_field += str(one_column)\n\t\t\t\n\t\t\tcalc_sql = common.get_calc_daily_sql(db_field, my_obc_table,\n\t\t\t\t\t\t\t\t\t\t\t\t one_sds['fill_value'],\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_prefix_sql,\n\t\t\t\t\t\t\t\t\t\t\t\t  conf.calc_daily_subsql,\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_postfix_sql)\n\t\t\tcommon.debug(my_log, log_tag, time_tag + calc_sql)\n\t\t\ttry:\n\t\t\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\n\t\t\t\tcur.execute(calc_sql)\n\t\t\t\tret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n\t\t\t\tconn.select_db(conf.db_setting['stat_db'])\n\t\t\t\tdata = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault = 0)\n\t\t\t\tsql_data = [db_field, ret[0][0] ]\n\t\t\t\tsql_data.extend(data)\n\t\t\t\tcur.execute(daily_sql % tuple(sql_data))\n\t\t\t\tconn.commit()\n\t\t\texcept MySQLdb.Error, e:\n\t\t\t\tmsg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t\t\t+ ']: ' + e.args[1]\t\t\t  \n\t\t\t\tcommon.warning(my_log, log_tag, time_tag + msg)\n\tif(ins!='mwri'):   \n\t\tfor one_sds in ins_conf.calc_to_db.values():\n\t\t\tfor one_column in xrange(1, one_sds['columns'] + 1):\n\t\t\t\tdb_field = one_sds['db_field']\n\t\t\t\tif one_sds['columns'] is not 1:\n\t\t\t\t\tdb_field += str(one_column)\n\t\t\t\n\t\t\t\tcalc_sql = common.get_calc_daily_sql(db_field, my_calculate_table,\n\t\t\t\t\t\t\t\t\t\t\t\t one_sds['fill_value'],\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_prefix_sql,\n\t\t\t\t\t\t\t\t\t\t\t\t  conf.calc_daily_subsql,\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_postfix_sql)\n\t\t\t\tcommon.debug(my_log, log_tag, time_tag + calc_sql)\n\t\t\t\ttry:\n\t\t\t\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\n\t\t\t\t\tcur.execute(calc_sql)\n\t\t\t\t\tret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n\t\t\t\t\tconn.select_db(conf.db_setting['stat_db'])\n\t\t\t\t\tdata = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault = 0)\n\t\t\t\t\tsql_data = [db_field, ret[0][0] ]\n\t\t\t\t\tsql_data.extend(data)\n\t\t\t\t\tcur.execute(daily_sql % tuple(sql_data))\n\t\t\t\t\tconn.commit()\n\t\t\t\texcept MySQLdb.Error, e:\n\t\t\t\t\tmsg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t\t\t+ ']: ' + e.args[1]\t\t\t  \n\t\t\t\t\tcommon.warning(my_log, log_tag, time_tag + msg)\n\n\ttry:\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\tmsg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1]\t\t\t  \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\n\treturn True\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import shutil", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "from datetime import timedelta", "from multiprocessing import Pool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "calc_one_channel", "data": "def calc_one_channel(channel):\n\tif len(my_channel_table) <= 0:\n\t\treturn True\n\t\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor()\n\texcept MySQLdb.Error, e:\n\t\tmsg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n\t\t\t+ str(e.args[0]) + ']: ' + e.args[1]\t\t\t  \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\t\t\n\tfor one_sds in ins_conf.obc_3dim_to_calc.values():\n\t\tfor one_column in xrange(1, one_sds['columns'] + 1):\n\t\t\tdb_field = one_sds['db_field']\n\t\t\tif one_sds['columns'] is not 1:\n\t\t\t\tdb_field += str(one_column)\n\t\t\t\n\t\t\tcalc_sql = common.get_calc_daily_channel_sql(channel,\n\t\t\t\t\t\t\t\t\t\t\t\t db_field, my_channel_table,\n\t\t\t\t\t\t\t\t\t\t\t\t one_sds['fill_value'],\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_prefix_sql,\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_channel_subsql,\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_postfix_sql)\n\t\t\tcommon.debug(my_log, log_tag, time_tag + calc_sql)\n\t\t\ttry:\n\t\t\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\n\t\t\t\tcur.execute(calc_sql)\n\t\t\t\tret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n\t\t\t\tconn.select_db(conf.db_setting['stat_db'])\n\t\t\t\tdata = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault = 0)\n\t\t\t\tsql_data = [db_field, channel, ret[0][0] ]\n\t\t\t\tsql_data.extend(data)\n\t\t\t\tcur.execute(daily_channel_sql % tuple(sql_data))\n\t\t\t\tconn.commit()\n\t\t\texcept MySQLdb.Error, e:\n\t\t\t\tmsg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n\t\t\t\t\t+ str(e.args[0]) + ']: ' + e.args[1]\t\t\t  \n\t\t\t\tcommon.warning(my_log, log_tag, time_tag + msg)\n\n\t#try:\n\t#\tcur.close()\n\t#\tconn.close()\n\t#except MySQLdb.Error, e:\n\t#\tmsg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n\t#\t\t+ str(e.args[0]) + ']: ' + e.args[1]\t\t\t  \n\t#\tcommon.err(my_log, log_tag, time_tag + msg)\n\t#\treturn False\n\t\n\n\t\n\tcalc_daily_prefix_sql = 'select count(value), avg(value), max(value), min(value), ' \\\n\t\t\t\t\t\t\t'STDDEV_POP(value) from ('\n\tcalc_daily_subsql = 'select value from %s where type= \\'%s\\' and value!=%s'\n\tcalc_daily_channel_subsql = 'select value from %s where channel=%s and type= \\'%s\\' and value !=%s'\n\tcalc_daily_postfix_sql = ') as total'\n\n\tif(ins=='iras'):\n\t\tfor one_sds in ins_conf.calc_3dim_to_db.values():\n\t\t\tfor one_column in xrange(1, one_sds['columns'] + 1):\n\t\t\t\tdb_field = one_sds['db_field']\n\t\t\t\t\n\t\t\t\tif one_sds['columns'] is not 1:\n\t\t\t\t\tdb_field += str(one_column)\n\t\t\t\tcalc_sql = calc_daily_channel_sql(channel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t db_field, my_calc_channel_table,\n\t\t\t\t\t\t\t\t\t\t\t\t\t one_sds['fill_value'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t calc_daily_prefix_sql,\n\t\t\t\t\t\t\t\t\t\t\t\t\t calc_daily_channel_subsql,\n\t\t\t\t\t\t\t\t\t\t\t\t\t calc_daily_postfix_sql)\n\t\t\t\tprint calc_sql\n\t\t\t\tcommon.debug(my_log, log_tag, time_tag + calc_sql)\n\t\t\t\ttry:\n\t\t\t\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\n\t\t\t\t\tcur.execute(calc_sql)\n\t\t\t\t\tret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n\t\t\t\t\tconn.select_db(conf.db_setting['stat_db'])\n\t\t\t\t\tdata = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault = 0)\n\t\t\t\t\tsql_data = [db_field, channel, ret[0][0] ]\n\t\t\t\t\tsql_data.extend(data)\n\t\t\t\t\tcur.execute(daily_channel_sql % tuple(sql_data))\n\t\t\t\t\t\n\t\t\t\t\tconn.commit()\n\t\t\t\texcept MySQLdb.Error, e:\n\t\t\t\t\tmsg = 'calc_one_calc_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n\t\t\t\t\t\t+ str(e.args[0]) + ']: ' + e.args[1]\t\t\t  \n\t\t\t\t\tcommon.warning(my_log, log_tag, time_tag + msg)\n\t\t\t#print'channel table list'\n\t\t\t#print calc_sql\n\n\t\ttry:\n\t\t\tcur.close()\n\t\t\tconn.close()\n\t\texcept MySQLdb.Error, e:\n\t\t\tmsg = 'calc_one_calc_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n\t\t\t\t+ str(e.args[0]) + ']: ' + e.args[1]  \n\t\t\tprint msg\t\t\t\n\t\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\t\treturn False\n\n\treturn True\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import shutil", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "from datetime import timedelta", "from multiprocessing import Pool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "calc_daily_channel_sql", "data": "def calc_daily_channel_sql(channel, field, tables, fill_value, \n\t\t\t\t\t\t\t\tprefix_sql, subsql, postfix_sql):\n\n\tprefix ='select count(value), avg(value), max(value), min(value), ' \\\n\t\t\t\t\t\t\t'STDDEV_POP(value) from ('\n\tsubsql_total=''\n\tfor idx, one_table in enumerate(tables):\n\t\tif idx == 0:\n\t\t\tsubsql_total =  subsql%(one_table,channel,field,fill_value) + subsql_total\n\t\telse:\n\t\t\tsubsql_total =  subsql%(one_table,channel,field,fill_value) + ' union all ' +subsql_total\n\n\treturn prefix + subsql_total + postfix_sql\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import shutil", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "from datetime import timedelta", "from multiprocessing import Pool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "calc_daily", "data": "def calc_daily(input):\n\tprint input\n\tif input == 'just_obc':\n\t\treturn calc_just_obc()\n\telse:\n\t\treturn calc_one_channel(input)\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import shutil", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "from datetime import timedelta", "from multiprocessing import Pool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}], [{"term": "def", "name": "test_calculator_label", "data": "def test_calculator_label():\n\tfrom ase.calculators.calculator import Calculator\n\n\tcalc = Calculator()\n\tassert calc.directory == '.'\n\tassert calc.prefix is None\n\tassert calc.label is None\n\n\tcalc.label = 'dir/pref'\n\tassert calc.directory == 'dir'\n\tassert calc.prefix == 'pref'\n\tassert calc.label == 'dir/pref'\n\n\tcalc.label = 'dir2/'\n\tassert calc.directory == 'dir2'\n\tassert calc.prefix is None\n\tassert calc.label == 'dir2/'\n\n\tcalc.label = 'hello'\n\tassert calc.directory == '.'\n\tassert calc.prefix == 'hello'\n\tassert calc.label == 'hello'\n\n\tcalc.label = None\n\tassert calc.label is None\n\tassert calc.prefix is None\n\tassert calc.directory == '.'\n", "description": null, "category": "math", "imports": ["\tfrom ase.calculators.calculator import Calculator"]}], [{"term": "def", "name": "test_calculate", "data": "def test_calculate():\n\tvalue = calculate('1234', '50', '10', '300')\n\tassert isinstance(value, Currency)\n\tassert value.formatted_string() == '$1,921.20'\n\n\t# using decimals as percentages\n\tassert calculate('1234', '.5', '.1', '300') == value\n\n\twith pytest.raises(PercentageOutOfRange):\n\t\tcalculate('1234', '110', '10', '300')\n\n\twith pytest.raises(PercentageOutOfRange):\n\t\tcalculate('1234', '50', '110', '300')\n\n\tassert calculate() == 0\n\n", "description": null, "category": "math", "imports": ["import os", "import pytest", "import decimal", "from jobcalc.param_types import Currency  # , DISCOUNT  # , Percentage", "from jobcalc.exceptions import PercentageOutOfRange, InvalidFormatter, \\", "from jobcalc.utils import flatten", "from jobcalc.formatters import BasicFormatter, FormulaFormatter", "from jobcalc.core import calculate, BaseCalculator, Calculator, Context, \\"]}, {"term": "class", "name": "Test_BaseCalculator", "data": "class Test_BaseCalculator(object):\n\n\t@classmethod\n\tdef setup_class(cls):\n\t\tos.environ['DEBUG'] = 'true'\n\t\tcls.calc = BaseCalculator(['123', '456'], '50', '10', '100')\n\n\t@classmethod\n\tdef teardown_class(cls):\n\t\tdel(os.environ['DEBUG'])\n\n\tdef test_attributes(self):\n\t\tassert list(flatten(self.calc.costs)) == ['123', '456']\n\t\tassert self.calc.margins == ['50']\n\t\tassert self.calc.discounts == ['10']\n\t\tassert self.calc.deductions == ['100']\n\n\t\tassert self.calc.total().formatted_string() == '$942.20'\n\n\tdef test_costs_handle_other_calculators(self):\n\t\tcalc2 = BaseCalculator(['123', self.calc], '50', '10', '100')\n\t\tassert calc2.subtotal() == Currency('1065.2')\n\t\tassert calc2.subtotal(ignore_margins=True) == Currency('702')\n\n\t\t# class setting overrides default\n\t\tcalc2.ignore_margins = True\n\t\tassert calc2.subtotal() == Currency('702')\n\n\tdef test_things_fail_with_invalid_items(self):\n\t\tself.calc.costs.append(object())\n\n\t\twith pytest.raises(decimal.InvalidOperation):\n\t\t\tself.calc.total()\n\n\t\tself.calc.costs = self.calc.costs[:-1]\n\t\tself.calc.margins.append(object)\n\n\t\twith pytest.raises(decimal.InvalidOperation):\n\t\t\tself.calc.total()\n\n\t\tself.calc.margins = self.calc.margins[:-1]\n\n\t\tself.calc.discounts.append(object())\n\t\twith pytest.raises(decimal.InvalidOperation):\n\t\t\tself.calc.total()\n\n\t\tself.calc.discounts = self.calc.discounts[:-1]\n\n\t\tself.calc.deductions.append(object())\n\t\twith pytest.raises(decimal.InvalidOperation):\n\t\t\tself.calc.total()\n\n\t\tself.calc.deductions = self.calc.deductions[:-1]\n\n", "description": null, "category": "math", "imports": ["import os", "import pytest", "import decimal", "from jobcalc.param_types import Currency  # , DISCOUNT  # , Percentage", "from jobcalc.exceptions import PercentageOutOfRange, InvalidFormatter, \\", "from jobcalc.utils import flatten", "from jobcalc.formatters import BasicFormatter, FormulaFormatter", "from jobcalc.core import calculate, BaseCalculator, Calculator, Context, \\"]}, {"term": "class", "name": "Test_Calculator", "data": "class Test_Calculator(object):\n\n\t@classmethod\n\tdef setup_class(cls):\n\t\tos.environ['DEBUG'] = 'true'\n\n\t\tcls.calc = Calculator(\n\t\t\tcosts=['123', '456'],\n\t\t\tmargins='50',\n\t\t\tdiscounts='10',\n\t\t\tdeductions='100',\n\t\t\thours='10',\n\t\t\trate='20',\n\t\t\tformatters=BasicFormatter\n\t\t)\n\n\t@classmethod\n\tdef teardown_class(cls):\n\t\tdel(os.environ['DEBUG'])\n\n\tdef test_attributes(self):\n\t\tcalc = self.calc\n\n\t\tassert isinstance(calc.formatters, list)\n\t\tassert calc.formatters[0] == BasicFormatter\n\t\tassert calc.rate == decimal.Decimal('20')\n\t\tassert calc.hours == ['10']\n\n\tdef test_render(self):\n\t\tassert self.calc.render() == '$1,302.20'\n\n\t\told_formatters = self.calc.formatters\n\t\tself.calc.formatters = []\n\t\tassert self.calc.render() == '$1,302.20'\n\n\t\tself.calc.formatters.append([BasicFormatter, BasicFormatter])\n\t\tassert self.calc.render() == '$1,302.20\\n\\n$1,302.20'\n\t\tassert self.calc.render('\\n\\n\\n') == '$1,302.20\\n\\n\\n$1,302.20'\n\n\t\tself.calc.formatters = old_formatters\n\n\tdef test_render_fails_with_invalid_formatter(self):\n\t\told_formatters = self.calc.formatters\n\t\tself.calc.formatters = [object()]\n\n\t\twith pytest.raises(InvalidFormatter):\n\t\t\tself.calc.render()\n\n\t\tself.calc.formatters = old_formatters\n\n\tdef test_ctx_fails_with_strict_option(self):\n\t\told_rate = self.calc.rate\n\t\tself.calc.rate = 0\n\t\twith pytest.raises(HourlyRateError):\n\t\t\twith self.calc.ctx(strict=True):  # pragma: no cover\n\t\t\t\tpass\n\n\t\t# doesn't fail if strict is not ``True`` (default).\n\t\twith self.calc.ctx() as ctx:\n\t\t\tassert isinstance(ctx, Context)\n\n\t\tself.calc.rate = old_rate\n\n\tdef test_update(self):\n\t\tself.calc.update(\n\t\t\tappend=True,\n\t\t\tmargins='2.5',\n\t\t\tdiscounts='5',\n\t\t\tdeductions='200',\n\t\t\thours=('10', '20', '30'),\n\t\t\trate='30',\n\t\t\tformatters=FormulaFormatter(),\n\t\t\tdivider='/',\n\t\t\tprompt=True\n\t\t)\n\n\t\tassert self.calc.margins[-1] == '2.5'\n\t\tassert self.calc.discounts[-1] == '5'\n\t\tassert self.calc.deductions[-1] == '200'\n\t\tassert self.calc.hours[-1] == ('10', '20', '30')\n\t\tassert self.calc.rate == decimal.Decimal('30')\n\t\tassert isinstance(self.calc.formatters[-1], FormulaFormatter)\n\t\tassert self.calc.config.divider == '/'\n\n\t\tself.calc.update(\n\t\t\tappend=False,\n\t\t\thours=('20', '10')\n\t\t)\n\n\t\tassert self.calc.hours == [('20', '10')]\n\n\t\t# works with a dict as the first arg as well.\n\t\tself.calc.update({'margins': '25'})\n\t\tassert self.calc.margins[-1] == '25'\n\n\t\twith pytest.raises(TypeError):\n\t\t\t# arg1 is not a dict or None\n\t\t\tself.calc.update([])\n\n\t\tclass CustomCalc(Calculator):\n\n\t\t\tdef __init__(self, *args, someattr=None, **kwargs):\n\t\t\t\tsuper().__init__(*args, **kwargs)\n\t\t\t\tself.someattr = someattr\n\n\t\tcalc = CustomCalc(someattr='a')\n\t\tassert calc.someattr == 'a'\n\t\tcalc.update(\n\t\t\tappend=True,\n\t\t\tsomeattr='somevalue'\n\t\t)\n\t\tassert calc.someattr == 'somevalue'\n\n\tdef test_rate_does_not_change_with_invalid(self):\n\t\tself.calc.rate = decimal.Decimal('20')\n\t\tassert self.calc.rate == decimal.Decimal('20')\n\t\tself.calc.rate = None\n\t\tassert self.calc.rate == decimal.Decimal('20')\n\t\tself.calc.rate = '-1'\n\t\tassert self.calc.rate == decimal.Decimal('20')\n\n", "description": null, "category": "math", "imports": ["import os", "import pytest", "import decimal", "from jobcalc.param_types import Currency  # , DISCOUNT  # , Percentage", "from jobcalc.exceptions import PercentageOutOfRange, InvalidFormatter, \\", "from jobcalc.utils import flatten", "from jobcalc.formatters import BasicFormatter, FormulaFormatter", "from jobcalc.core import calculate, BaseCalculator, Calculator, Context, \\"]}, {"term": "class", "name": "Test_TerminalCalculator", "data": "class Test_TerminalCalculator(object):\n\n\t@classmethod\n\tdef setup_class(cls):\n\t\tos.environ['DEBUG'] = 'true'\n\t\tcls.calc = TerminalCalculator()\n\n\t@classmethod\n\tdef teardown_class(cls):\n\t\tdel(os.environ['DEBUG'])\n\n\tdef test_private_prompt_for_fails(self):\n\t\twith pytest.raises(AttributeError):\n\t\t\tself.calc._prompt_for('invalid')\n\n\tdef test_key_for_prompt(self):\n\t\t# check all the prompts.\n\t\tfor prompt in self.calc._prompts:\n\t\t\tif prompt == 'rate' or prompt == 'hours':\n\t\t\t\tassert self.calc.key_for_prompt(prompt) == prompt\n\t\t\telse:\n\t\t\t\tassert self.calc.key_for_prompt(prompt) == prompt + 's'\n\n\t\t# we can also handle if someone accidentally asks to prompt for a plural\n\t\t# version, without raising errors.\n\t\tassert self.calc.key_for_prompt('margins') == 'margins'\n\t\tassert self.calc.key_for_prompt('rates') == 'rate'\n\n\t\t# accidentally not pluralizing 'hours'\n\t\tassert self.calc.key_for_prompt('hour') == 'hours'\n\n\t\t# fail with invalid prompt.\n\t\twith pytest.raises(AttributeError):\n\t\t\tself.calc.key_for_prompt('invalid')\n\n\tdef test_prompt_for_context_manager_fails(self):\n\t\twith pytest.raises(AttributeError):\n\t\t\twith self.calc.prompt_for('invalid'):  # pragma: no cover\n\t\t\t\tpass\n\n\tdef test_normalize(self):\n\t\tassert self.calc.normalize('hours') == 'hours'\n\t\tassert self.calc.normalize('margins') == 'margin'\n\t\tassert self.calc.normalize('rate') == 'rate'\n\t\tassert self.calc.normalize('rates') == 'rate'\n\n\tdef test_is_empty(self):\n\t\tfor prompt in self.calc._prompts:\n\t\t\tassert self.calc.is_empty(prompt)\n\n\t\tconfig = self.calc.config\n\t\tconfig.default_hours = '3'\n\t\tnew_calc = TerminalCalculator(config=config)\n\n\t\tassert new_calc._hours() == decimal.Decimal('3')\n\t\tassert new_calc.is_empty('hours')\n\n\t\twith pytest.raises(AttributeError):\n\t\t\tself.calc.is_empty('invalid')\n\n\t\tself.calc.costs.append('123')\n\t\tassert not self.calc.is_empty('costs')\n", "description": null, "category": "math", "imports": ["import os", "import pytest", "import decimal", "from jobcalc.param_types import Currency  # , DISCOUNT  # , Percentage", "from jobcalc.exceptions import PercentageOutOfRange, InvalidFormatter, \\", "from jobcalc.utils import flatten", "from jobcalc.formatters import BasicFormatter, FormulaFormatter", "from jobcalc.core import calculate, BaseCalculator, Calculator, Context, \\"]}], [{"term": "def", "name": "testMockFunction", "data": "  def testMockFunction(self):\n\t@MockFunction\n\tdef calc(a, b, mult=1):\n\t  return (a + b) * mult\n\n\tself.assertTrue(*calc.CheckAndReset(0))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 1 call(s), got 0'), calc.CheckAndReset(1))\n\n\tself.assertEqual(20, calc(2, 3, mult=4))\n\tself.assertTrue(*calc.CheckAndReset(1))\n\tself.assertTrue(*calc.CheckAndReset(0))\n\n\tself.assertEqual(20, calc(2, 3, mult=4))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 0 call(s), got 1'), calc.CheckAndReset(0))\n\n\tself.assertEqual(3, calc(1, 2))\n\tself.assertEqual(0, calc(3, 4, mult=0))\n\tself.assertTrue(*calc.CheckAndReset(2))\n\tself.assertTrue(*calc.CheckAndReset(0))\n\n\tself.assertEqual(3, calc(1, 2))\n\tself.assertEqual(0, calc(3, 4, mult=0))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 3 call(s), got 2'), calc.CheckAndReset(3))\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock_function import MockFunction"]}], [{"term": "def", "name": "test_directory_and_label", "data": "def test_directory_and_label():\n\tdef normalize(path):\n\t\t\"\"\"Helper function to normalize path\"\"\"\n\t\treturn str(Path(path))\n\n\tcalc = Calculator()\n\n\tassert calc.directory == '.'\n\tassert calc.label is None\n\n\tcalc.directory = 'somedir'\n\n\tassert calc.directory == 'somedir'\n\tassert calc.label == 'somedir/'\n\n\t# We cannot redundantly specify directory\n\twith pytest.raises(ValueError):\n\t\tcalc = Calculator(directory='somedir',\n\t\t\t\t\t\t  label='anotherdir/label')\n\n\t# Test only directory in directory\n\tcalc = Calculator(directory='somedir',\n\t\t\t\t\t  label='label')\n\n\tassert calc.directory == 'somedir'\n\tassert calc.label == 'somedir/label'\n\n\twdir = '/home/somedir'\n\tcalc = Calculator(directory=wdir,\n\t\t\t\t\t  label='label')\n\n\tassert calc.directory == normalize(wdir)\n\tassert calc.label == normalize(wdir) + '/label'\n\n\t# Test we can handle pathlib directories\n\twdir = Path('/home/somedir')\n\tcalc = Calculator(directory=wdir,\n\t\t\t\t\t  label='label')\n\tassert calc.directory == normalize(wdir)\n\tassert calc.label == normalize(wdir) + '/label'\n\n\twith pytest.raises(ValueError):\n\t\tcalc = Calculator(directory=wdir,\n\t\t\t\t\t\t  label='somedir/label')\n\n\t# Passing in empty directories with directories in label should be OK\n\tfor wdir in ['somedir', '/home/directory']:\n\t\tlabel = wdir + '/label'\n\t\texpected_label = normalize(wdir) + '/label'\n\t\tcalc = Calculator(directory='', label=label)\n\t\tassert calc.label == expected_label\n\t\tassert calc.directory == normalize(wdir)\n\n\t\tcalc = Calculator(directory='.', label=label)\n\t\tassert calc.label == expected_label\n\t\tassert calc.directory == normalize(wdir)\n\n", "description": "Helper function to normalize path", "category": "math", "imports": ["from pathlib import Path", "import pytest", "from ase.calculators.calculator import Calculator"]}, {"term": "def", "name": "test_deprecated_get_spin_polarized", "data": "def test_deprecated_get_spin_polarized():\n\tcalc = Calculator()\n\twith pytest.warns(FutureWarning):\n\t\tspinpol = calc.get_spin_polarized()\n\tassert spinpol is False\n", "description": null, "category": "math", "imports": ["from pathlib import Path", "import pytest", "from ase.calculators.calculator import Calculator"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "class", "name": "TestCorDimCalculateHeviside", "data": "class TestCorDimCalculateHeviside(unittest.TestCase, ConfigTest):\n\tdef setUp(self):\n\t\tself.corDim = CorDim()\n\n\tdef test_calc_heviside_0(self):\n\t\tr = self.corDim.calc_heviside(10, 20)\n\t\tself.assertEqual(0, r, msg='heviside equals 0 for all negative differences')\n\n\tdef test_calc_heviside_1(self):\n\t\tr = self.corDim.calc_heviside(20, 10)\n\t\tself.assertEqual(1, r, msg='heviside equals 1 for all positive differences')\n\n\tdef test_calc_heviside_2(self):\n\t\tr = self.corDim.calc_heviside(-10, -11)\n\t\tself.assertEqual(1, r, msg='heviside equals 1 for all positive differences')\n\n\tdef test_calc_heviside_3(self):\n\t\tr = self.corDim.calc_heviside(-10, -1)\n\t\tself.assertEqual(0, r, msg='heviside equals 0 for all negative differences')\n\n", "description": null, "category": "math", "imports": ["import unittest", "from unittest.mock import patch", "from src.core.cordim import CorDim", "from tests.unit.config_test import ConfigTest"]}, {"term": "class", "name": "TestCorDimCalculateAttractor", "data": "class TestCorDimCalculateAttractor(unittest.TestCase, ConfigTest):\n\tdef setUp(self):\n\t\tself.corDim = CorDim()\n\n\tdef test_calc_attractor_0(self):\n\t\tr = self.corDim.calc_attractor(10, 20)\n\t\tself.assertAlmostEqual(0.76862, r, places=4, msg='normal attractor fails')\n\n\tdef test_calc_attractor_1(self):\n\t\tr = self.corDim.calc_attractor(0, 20)\n\t\tself.assertAlmostEqual(0.3338, r, places=4, msg='attractor for zero cor func')\n\n\tdef test_calc_attractor_2(self):\n\t\tr = self.corDim.calc_attractor(10, 0)\n\t\tself.assertAlmostEqual(2.3026, r, places=4, msg='attractor for zero radius')\n\n\tdef test_calc_attractor_3(self):\n\t\tr = self.corDim.calc_attractor(0, 0)\n\t\tself.assertEqual(1, r, msg='attractor for zero radius and zero cor func')\n\n", "description": null, "category": "math", "imports": ["import unittest", "from unittest.mock import patch", "from src.core.cordim import CorDim", "from tests.unit.config_test import ConfigTest"]}, {"term": "class", "name": "TestCorDimCalculateCor", "data": "class TestCorDimCalculateCor(unittest.TestCase, ConfigTest):\n\tdef setUp(self):\n\t\tself.corDim = CorDim()\n\n\t@patch('src.core.apen.ApEn.calculate_distance')\n\t@patch('src.core.cordim.CorDim.calc_heviside')\n\tdef test_calc_cor_func_0(self, mock_cordim_calc_haviside, mock_apen_calc_distance):\n\t\tmock_apen_calc_distance.return_value = 0.3\n\t\tmock_cordim_calc_haviside.return_value=0.4\n\t\tr = self.corDim.calc_cor_func([600,], 5)\n\t\tmock_apen_calc_distance.assert_called_with(600, 600)\n\t\tmock_cordim_calc_haviside.assert_called_with(5, 0.3)\n\t\tself.assertAlmostEqual(0.4, r, places=4, msg='calc cor fails for normal case')\n\n\t@patch('src.core.apen.ApEn.calculate_distance')\n\t@patch('src.core.cordim.CorDim.calc_heviside')\n\tdef test_calc_cor_func_1(self, mock_cordim_calc_haviside, mock_apen_calc_distance):\n\t\tr = self.corDim.calc_cor_func([], 5)\n\t\tself.assertEqual(0, r, msg='calc cor fails for empty sequence')\n\n", "description": null, "category": "math", "imports": ["import unittest", "from unittest.mock import patch", "from src.core.cordim import CorDim", "from tests.unit.config_test import ConfigTest"]}], [{"term": "def", "name": "calculations", "data": "def calculations():\n\tfor file in multiple_files:\n\t#\t file2 = file.split(\"\\\\\")[1]\n\t\tst.text(f'Calculating for {file.name}')\n\t#\t file = cv.imread(file, 0)\n\n\t\timg = Image.open(file)\n\t\timg = ImageOps.grayscale(img)\n\t\timg = np.asarray(img)\n\t\tx, y = haziness_mean_std(img, N, s)\n\t\tvalues.append([file.name, round(x, 4), round(y, 4)])\n\n\n\t\t# Calculate other metrics\n\t\tif calc_rms:\n\t\t\trms_list.append(RMS(img))\n\t#\t if calc_Weber:\n\t#\t\t Weber_list.append(Weber(img))\n\t\tif calc_Michelson:\n\t\t\tMichelson_list.append(Michelson(img))\n\t#\t if calc_Rizzi:\n\t#\t\t Rizzi_list.append(Rizzi(img))\n\t\tif calc_HS:\n\t\t\tHS_list.append(HS(img))\n", "description": null, "category": "math", "imports": ["import streamlit as st", "import numpy as np", "import cv2 as cv", "import glob", "from functions import *", "import pandas as pd", "import os", "from PIL import Image, ImageOps", "import matplotlib.pyplot as plt", "# import libraries", "# import tkinter as tk", "# from tkinter import filedialog"]}], [{"term": "def", "name": "calculations", "data": "def calculations():\n\tfor file in multiple_files:\n\t#\t file2 = file.split(\"\\\\\")[1]\n\t\tst.text(f'Calculating for {file.name}')\n\t#\t file = cv.imread(file, 0)\n\n\t\timg = Image.open(file)\n\t\timg = ImageOps.grayscale(img)\n\t\timg = np.asarray(img)\n\t\tx, y = haziness_mean_std(img, N, s)\n\t\tvalues.append([file.name, round(x, 4), round(y, 4)])\n\n\n\t\t# Calculate other metrics\n\t\tif calc_rms:\n\t\t\trms_list.append(RMS(img))\n\t#\t if calc_Weber:\n\t#\t\t Weber_list.append(Weber(img))\n\t\tif calc_Michelson:\n\t\t\tMichelson_list.append(Michelson(img))\n\t#\t if calc_Rizzi:\n\t#\t\t Rizzi_list.append(Rizzi(img))\n\t\tif calc_HS:\n\t\t\tHS_list.append(HS(img))\n", "description": null, "category": "math", "imports": ["import streamlit as st", "import numpy as np", "import cv2 as cv", "import glob", "from functions import *", "import pandas as pd", "import os", "from PIL import Image, ImageOps", "import matplotlib.pyplot as plt", "# import libraries", "# import tkinter as tk", "# from tkinter import filedialog"]}], [], [{"term": "def", "name": "run", "data": "def run(atoms):\n\tatoms.get_forces()\n\tprint(sorted(atoms.calc.results))\n\tfor key, value in atoms.calc.results.items():\n\t\tif isinstance(value, np.ndarray):\n\t\t\tprint(key, value.shape, value.dtype)\n\t\telse:\n\t\t\tprint(key, value)\n\n\tfor name in required_quantities:\n\t\tassert name in atoms.calc.results\n\n\treturn atoms.calc.results\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_si", "data": "def test_si(factory):\n\tatoms = bulk('Si')\n\tatoms.calc = factory.calc(nbands=4 * len(atoms), kpts=[4, 4, 4])\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_au", "data": "def test_au(factory, pps):\n\tatoms = bulk('Au')\n\tatoms.calc = factory.calc(\n\t\tpps=pps,\n\t\tnbands=10 * len(atoms),\n\t\ttsmear=0.1,\n\t\toccopt=3,\n\t\tkpts=[2, 2, 2],\n\t\tpawecutdg=6.0 * Hartree,\n\t)\n\t# Somewhat awkward to set pawecutdg also when we are not doing paw,\n\t# but it's an error to pass None as pawecutdg.\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "fe_atoms", "data": "def fe_atoms():\n\treturn bulk('Fe')\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "getkwargs", "data": "def getkwargs(**kw):\n\treturn dict(nbands=8, kpts=[2, 2, 2])\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_fe_magmom", "data": "def test_fe_magmom(factory, fe_atoms):\n\tfe_atoms.calc = factory.calc()\n\trun(fe_atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_h2o", "data": "def test_h2o(factory):\n\tatoms = molecule('H2O', vacuum=2.5)\n\tatoms.calc = factory.calc()\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_o2", "data": "def test_o2(factory):\n\tatoms = molecule('O2', vacuum=2.5)\n\tatoms.calc = factory.calc()\n\trun(atoms)\n\tmagmom = atoms.get_magnetic_moment()\n\tassert magmom == pytest.approx(2, 1e-2)\n\tprint('magmom', magmom)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_manykpts", "data": "def test_manykpts(factory):\n\tatoms = bulk('Au') * (2, 2, 2)\n\tatoms.rattle(stdev=0.01)\n\tatoms.symbols[:2] = 'Cu'\n\tatoms.calc = factory.calc(nbands=len(atoms) * 7, kpts=[8, 8, 8])\n\trun(atoms, 'manykpts')\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_manyatoms", "data": "def test_manyatoms(factory):\n\tatoms = bulk('Ne', cubic=True) * (4, 2, 2)\n\tatoms.rattle(stdev=0.01)\n\tatoms.calc = factory.calc(nbands=len(atoms) * 5)\n\trun(atoms, 'manyatoms')\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}], [{"term": "def", "name": "atoms", "data": "def atoms():\n\treturn molecule('H2', vacuum=2.0)\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_geoopt", "data": "def test_geoopt(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(label='test_H2_GOPT', print_level='LOW')\n\tatoms.calc = calc\n\n\twith BFGS(atoms, logfile=None) as gopt:\n\t\tgopt.run(fmax=1e-6)\n\n\tdist = atoms.get_distance(0, 1)\n\tdist_ref = 0.7245595\n\tassert (dist - dist_ref) / dist_ref < 1e-7\n\n\tenergy_ref = -30.7025616943\n\tenergy = atoms.get_potential_energy()\n\tassert (energy - energy_ref) / energy_ref < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_lda", "data": "def test_h2_lda(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(label='test_H2_LDA')\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -30.6989595886\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_libxc", "data": "def test_h2_libxc(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(\n\t\txc='XC_GGA_X_PBE XC_GGA_C_PBE',\n\t\tpseudo_potential=\"GTH-PBE\",\n\t\tlabel='test_H2_libxc')\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -31.591716529642\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_ls", "data": "def test_h2_ls(cp2k_factory, atoms):\n\tinp = \"\"\"&FORCE_EVAL\n\t\t\t   &DFT\n\t\t\t\t &QS\n\t\t\t\t   LS_SCF ON\n\t\t\t\t &END QS\n\t\t\t   &END DFT\n\t\t\t &END FORCE_EVAL\"\"\"\n\tcalc = cp2k_factory.calc(label='test_H2_LS', inp=inp)\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -30.6989581747\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 5e-7\n\n", "description": "&FORCE_EVAL\n\t\t\t   &DFT\n\t\t\t\t &QS\n\t\t\t\t   LS_SCF ON\n\t\t\t\t &END QS\n\t\t\t   &END DFT\n\t\t\t &END FORCE_EVAL", "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_pbe", "data": "def test_h2_pbe(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(xc='PBE', label='test_H2_PBE')\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -31.5917284949\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_md", "data": "def test_md(cp2k_factory):\n\tcalc = cp2k_factory.calc(label='test_H2_MD')\n\tpositions = [(0, 0, 0), (0, 0, 0.7245595)]\n\tatoms = Atoms('HH', positions=positions, calculator=calc)\n\tatoms.center(vacuum=2.0)\n\n\tMaxwellBoltzmannDistribution(atoms, temperature_K=0.5 * 300,\n\t\t\t\t\t\t\t\t force_temp=True)\n\tenergy_start = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n\twith VelocityVerlet(atoms, 0.5 * units.fs) as dyn:\n\t\tdyn.run(20)\n\n\tenergy_end = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n\tassert abs(energy_start - energy_end) < 1e-4\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_o2", "data": "def test_o2(cp2k_factory):\n\tcalc = cp2k_factory.calc(\n\t\tlabel='test_O2', uks=True, cutoff=150 * units.Rydberg,\n\t\tbasis_set=\"SZV-MOLOPT-SR-GTH\")\n\to2 = molecule('O2', calculator=calc)\n\to2.center(vacuum=2.0)\n\tenergy = o2.get_potential_energy()\n\tenergy_ref = -861.057011375\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_restart", "data": "def test_restart(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc()\n\tatoms.calc = calc\n\tatoms.get_potential_energy()\n\tcalc.write('test_restart')  # write a restart\n\tcalc2 = cp2k_factory.calc(restart='test_restart')  # load a restart\n\tassert not calc2.calculation_required(atoms, ['energy'])\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_unknown_keywords", "data": "def test_unknown_keywords(cp2k_factory):\n\twith pytest.raises(CalculatorSetupError):\n\t\tcp2k_factory.calc(dummy_nonexistent_keyword='hello')\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}], [{"term": "def", "name": "calc_settings", "data": "def calc_settings():\n\t\"\"\"Some simple fast calculation settings\"\"\"\n\treturn dict(xc='lda',\n\t\t\t\tprec='Low',\n\t\t\t\talgo='Fast',\n\t\t\t\tsetups='minimal',\n\t\t\t\tismear=0,\n\t\t\t\tnelm=1,\n\t\t\t\tsigma=0.1,\n\t\t\t\tistart=0,\n\t\t\t\tibrion=5,\n\t\t\t\tnfree=2,\n\t\t\t\tpotim=0.05,\n\t\t\t\tgamma=True,\n\t\t\t\ttxt=\"-\",\n\t\t\t\tlwave=False,\n\t\t\t\tlcharg=False)\n\n", "description": "Some simple fast calculation settings", "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.constraints import FixAtoms"]}, {"term": "def", "name": "test_vasp_freq", "data": "def test_vasp_freq(factory, atoms_nh3, calc_settings):\n\t\"\"\"\n\tRun some VASP tests to ensure that the frequency aspects of the\n\tcalculator work. This is conditional on the existence of the\n\tVASP_COMMAND or VASP_SCRIPT environment variables\n\n\tTests read_vib_freq and get_vibrations against each other.\n\t\"\"\"\n\tcalc = factory.calc(**calc_settings)\n\tmol = atoms_nh3\n\t# one constraint\n\tc = FixAtoms(indices=[atom.index for atom in mol if atom.symbol == 'N'])\n\tmol.set_constraint(c)\n\tmol.calc = calc\n\ten = mol.get_potential_energy()\n\tassert isinstance(en, float)\n\n\tn_free = 3 * (len(mol) - 1)  # one constraint\n\n\te, i_e = calc.read_vib_freq()\n\ti_e = [complex(0, x) for x in i_e]\n\tassert len(e) + len(i_e) == n_free\n\tassert i_e\n\toutcar_data = i_e[-1::-1] + e[-1::-1]\n\n\tvib_obj = calc.get_vibrations()\n\tvib_data = vib_obj.get_energies() * 1000  # to meV\n\tnp.testing.assert_allclose(vib_data, outcar_data, rtol=1e-6)\n\t# Cleanup\n\tcalc.clean()\n", "description": "\n\tRun some VASP tests to ensure that the frequency aspects of the\n\tcalculator work. This is conditional on the existence of the\n\tVASP_COMMAND or VASP_SCRIPT environment variables\n\n\tTests read_vib_freq and get_vibrations against each other.\n\t", "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.constraints import FixAtoms"]}], [{"term": "def", "name": "signal_handler", "data": "def signal_handler(signum, frame):\n\tmsg = 'FAILED`recv signal ' + str(signum) + '. exit now.'\n\tcommon.info(my_log, log_tag, time_tag + msg)\n\n\tif os.path.isfile(my_pidfile):\n\t\tos.remove(my_pidfile)\n\t\n\tsys.exit(0)\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import shutil", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "from datetime import timedelta", "from multiprocessing import Pool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "calc_just_obc", "data": "def calc_just_obc():\n\tif len(my_obc_table) <= 0:\n\t\treturn True\n\t\n\t\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'], \n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor()\n\texcept MySQLdb.Error, e:\n\t\tmsg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1]\t\t\t  \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\t\t\n\tfor one_sds in ins_conf.obc_to_db.values():\n\t\tfor one_column in xrange(1, one_sds['columns'] + 1):\n\t\t\tdb_field = one_sds['db_field']\n\t\t\tif one_sds['columns'] is not 1:\n\t\t\t\tdb_field += str(one_column)\n\t\t\t\n\t\t\tcalc_sql = common.get_calc_daily_sql(db_field, my_obc_table,\n\t\t\t\t\t\t\t\t\t\t\t\t one_sds['fill_value'],\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_prefix_sql,\n\t\t\t\t\t\t\t\t\t\t\t\t  conf.calc_daily_subsql,\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_postfix_sql)\n\t\t\tcommon.debug(my_log, log_tag, time_tag + calc_sql)\n\t\t\ttry:\n\t\t\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\n\t\t\t\tcur.execute(calc_sql)\n\t\t\t\tret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n\t\t\t\tconn.select_db(conf.db_setting['stat_db'])\n\t\t\t\tdata = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault = 0)\n\t\t\t\tsql_data = [db_field, ret[0][0] ]\n\t\t\t\tsql_data.extend(data)\n\t\t\t\tcur.execute(daily_sql % tuple(sql_data))\n\t\t\t\tconn.commit()\n\t\t\texcept MySQLdb.Error, e:\n\t\t\t\tmsg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t\t\t+ ']: ' + e.args[1]\t\t\t  \n\t\t\t\tcommon.warning(my_log, log_tag, time_tag + msg)\n\tif(ins!='mwri'):   \n\t\tfor one_sds in ins_conf.calc_to_db.values():\n\t\t\tfor one_column in xrange(1, one_sds['columns'] + 1):\n\t\t\t\tdb_field = one_sds['db_field']\n\t\t\t\tif one_sds['columns'] is not 1:\n\t\t\t\t\tdb_field += str(one_column)\n\t\t\t\n\t\t\t\tcalc_sql = common.get_calc_daily_sql(db_field, my_calculate_table,\n\t\t\t\t\t\t\t\t\t\t\t\t one_sds['fill_value'],\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_prefix_sql,\n\t\t\t\t\t\t\t\t\t\t\t\t  conf.calc_daily_subsql,\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_postfix_sql)\n\t\t\t\tcommon.debug(my_log, log_tag, time_tag + calc_sql)\n\t\t\t\ttry:\n\t\t\t\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\n\t\t\t\t\tcur.execute(calc_sql)\n\t\t\t\t\tret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n\t\t\t\t\tconn.select_db(conf.db_setting['stat_db'])\n\t\t\t\t\tdata = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault = 0)\n\t\t\t\t\tsql_data = [db_field, ret[0][0] ]\n\t\t\t\t\tsql_data.extend(data)\n\t\t\t\t\tcur.execute(daily_sql % tuple(sql_data))\n\t\t\t\t\tconn.commit()\n\t\t\t\texcept MySQLdb.Error, e:\n\t\t\t\t\tmsg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t\t\t+ ']: ' + e.args[1]\t\t\t  \n\t\t\t\t\tcommon.warning(my_log, log_tag, time_tag + msg)\n\n\ttry:\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\tmsg = 'calc_just_obc`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1]\t\t\t  \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\n\treturn True\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import shutil", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "from datetime import timedelta", "from multiprocessing import Pool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "calc_one_channel", "data": "def calc_one_channel(channel):\n\tif len(my_channel_table) <= 0:\n\t\treturn True\n\t\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor()\n\texcept MySQLdb.Error, e:\n\t\tmsg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n\t\t\t+ str(e.args[0]) + ']: ' + e.args[1]\t\t\t  \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\t\t\n\tfor one_sds in ins_conf.obc_3dim_to_db.values():\n\t\tfor one_column in xrange(1, one_sds['columns'] + 1):\n\t\t\tdb_field = one_sds['db_field']\n\t\t\tif one_sds['columns'] is not 1:\n\t\t\t\tdb_field += str(one_column)\n\t\t\t\n\t\t\tcalc_sql = common.get_calc_daily_channel_sql(channel,\n\t\t\t\t\t\t\t\t\t\t\t\t db_field, my_channel_table,\n\t\t\t\t\t\t\t\t\t\t\t\t one_sds['fill_value'],\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_prefix_sql,\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_channel_subsql,\n\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_postfix_sql)\n\t\t\tcommon.debug(my_log, log_tag, time_tag + calc_sql)\n\t\t\ttry:\n\t\t\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\n\t\t\t\tcur.execute(calc_sql)\n\t\t\t\tret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n\t\t\t\tconn.select_db(conf.db_setting['stat_db'])\n\t\t\t\tdata = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault = 0)\n\t\t\t\tsql_data = [db_field, channel, ret[0][0] ]\n\t\t\t\tsql_data.extend(data)\n\t\t\t\tcur.execute(daily_channel_sql % tuple(sql_data))\n\t\t\t\tconn.commit()\n\t\t\texcept MySQLdb.Error, e:\n\t\t\t\tmsg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n\t\t\t\t\t+ str(e.args[0]) + ']: ' + e.args[1]\t\t\t  \n\t\t\t\tcommon.warning(my_log, log_tag, time_tag + msg)\n\n\t#try:\n\t#\tcur.close()\n\t#\tconn.close()\n\t#except MySQLdb.Error, e:\n\t#\tmsg = 'calc_one_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n\t#\t\t+ str(e.args[0]) + ']: ' + e.args[1]\t\t\t  \n\t#\tcommon.err(my_log, log_tag, time_tag + msg)\n\t#\treturn False\n\n\tif(ins=='mwhs'):\n\t\tfor one_sds in ins_conf.calc_3dim_to_db.values():\n\t\t\tfor one_column in xrange(1, one_sds['columns'] + 1):\n\t\t\t\tdb_field = one_sds['db_field']\n\t\t\t\tif one_sds['columns'] is not 1:\n\t\t\t\t\tdb_field += str(one_column)\n\t\t\t\n\t\t\t\tcalc_sql = common.get_calc_daily_channel_sql(channel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t db_field, my_calc_channel_table,\n\t\t\t\t\t\t\t\t\t\t\t\t\t one_sds['fill_value'],\n\t\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_prefix_sql,\n\t\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_channel_subsql,\n\t\t\t\t\t\t\t\t\t\t\t\t\t conf.calc_daily_postfix_sql)\n\t\t\t\tcommon.debug(my_log, log_tag, time_tag + calc_sql)\n\t\t\t\ttry:\n\t\t\t\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\n\t\t\t\t\tcur.execute(calc_sql)\n\t\t\t\t\tret = cur.fetchall() # count(), min(), max(), STDDEV_POP()\n\t\t\t\t\tconn.select_db(conf.db_setting['stat_db'])\n\t\t\t\t\tdata = common.get_data_with_default(ret[0][1:], one_sds['factor'],\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault = 0)\n\t\t\t\t\tsql_data = [db_field, channel, ret[0][0] ]\n\t\t\t\t\tsql_data.extend(data)\n\t\t\t\t\tcur.execute(daily_channel_sql % tuple(sql_data))\n\t\t\t\t\tconn.commit()\n\t\t\t\texcept MySQLdb.Error, e:\n\t\t\t\t\tmsg = 'calc_one_calc_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n\t\t\t\t\t\t+ str(e.args[0]) + ']: ' + e.args[1]\t\t\t  \n\t\t\t\t\tcommon.warning(my_log, log_tag, time_tag + msg)\n\t\t\t#print'channel table list'\n\t\t\t#print calc_sql\n\n\t\ttry:\n\t\t\tcur.close()\n\t\t\tconn.close()\n\t\texcept MySQLdb.Error, e:\n\t\t\tmsg = 'calc_one_calc_channel ' + str(channel) + '`Mysql Fatal Error[' \\\n\t\t\t\t+ str(e.args[0]) + ']: ' + e.args[1]  \n\t\t\tprint msg\t\t\t\n\t\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\t\treturn False\n\t\n\n\t\n\n\treturn True\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import shutil", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "from datetime import timedelta", "from multiprocessing import Pool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "calc_daily", "data": "def calc_daily(input):\n\tif input == 'just_obc':\n\t\treturn calc_just_obc()\n\telse:\n\t\treturn calc_one_channel(input)\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import shutil", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "from datetime import timedelta", "from multiprocessing import Pool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}], [{"term": "class", "name": "Calc", "data": "class Calc(int):\r\n\tdef __mul__(self,im):\r\n\t\treturn Calc(int(self)*im)\r\n\tdef __truediv__(self,im):\r\n\t\treturn Calc(int(self)+im)\r\n\tdef __sub__(self,im):\r\n\t\treturn Calc(int(self)*im)\r\n\t\t\r\n", "description": null, "category": "math", "imports": ["import re\r"]}, {"term": "def", "name": "evalA", "data": "def evalA(exp):\r\n\texp = re.sub(r\"(\\d+)\", r\"Calc(\\1)\", exp)\r\n\texp = exp.replace(\"+\", \"/\")\r\n\treturn eval(exp,{},{\"Calc\":Calc})\r\n", "description": null, "category": "math", "imports": ["import re\r"]}, {"term": "def", "name": "evalB", "data": "def evalB(exp):\r\n\texp = re.sub(r\"(\\d+)\", r\"Calc(\\1)\", exp)\r\n\texp = exp.replace(\"+\", \"/\")\r\n\texp = exp.replace(\"*\", \"-\")\r\n\treturn eval(exp,{},{\"Calc\":Calc})\r\n", "description": null, "category": "math", "imports": ["import re\r"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "Atoms_fcc_Ni_with_H_at_center", "data": "def Atoms_fcc_Ni_with_H_at_center():\n\tatoms = bulk(\"Ni\", cubic=True)\n\tatoms += Atom(\"H\", position=atoms.cell.diagonal() / 2)\n\treturn atoms\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "lammps_data_file_Fe", "data": "def lammps_data_file_Fe(datadir):\n\treturn datadir / \"lammpslib_simple_input.data\"\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "calc_params_Fe", "data": "def calc_params_Fe(lammps_data_file_Fe):\n\tcalc_params = {}\n\tcalc_params[\"lammps_header\"] = [\n\t\t\"units\t\t   real\",\n\t\t\"atom_style\t  full\",\n\t\t\"boundary\t\tp p p\",\n\t\t\"box tilt\t\tlarge\",\n\t\t\"pair_style\t  lj/cut/coul/long 12.500\",\n\t\t\"bond_style\t  harmonic\",\n\t\t\"angle_style\t harmonic\",\n\t\t\"kspace_style\tewald 0.0001\",\n\t\t\"kspace_modify   gewald 0.01\",\n\t\tf\"read_data\t  {lammps_data_file_Fe}\",\n\t]\n\tcalc_params[\"lmpcmds\"] = []\n\tcalc_params[\"atom_types\"] = {\"Fe\": 1}\n\tcalc_params[\"create_atoms\"] = False\n\tcalc_params[\"create_box\"] = False\n\tcalc_params[\"boundary\"] = False\n\tcalc_params[\"log_file\"] = \"test.log\"\n\tcalc_params[\"keep_alive\"] = True\n\treturn calc_params\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "Atoms_Fe", "data": "def Atoms_Fe(lammps_data_file_Fe):\n\tAtoms_Fe = ase.io.read(\n\t\tlammps_data_file_Fe,\n\t\tformat=\"lammps-data\",\n\t\tZ_of_type={1: 26},\n\t\tunits=\"real\",\n\t)\n\treturn Atoms_Fe\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_lammpslib_simple", "data": "def test_lammpslib_simple(\n\tfactory,\n\tcalc_params_NiH,\n\tAtoms_fcc_Ni_with_H_at_center,\n\tcalc_params_Fe,\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}], [{"term": "def", "name": "rng", "data": "def rng():\n\treturn np.random.RandomState(0)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "_base_calculator_gpwfile", "data": "def _base_calculator_gpwfile(tmp_path_factory, factories):\n\t\"\"\"\n\tGeneric method to cache calculator in a file on disk.\n\t\"\"\"\n\tdef __base_calculator_gpwfile(atoms, filename,\n\t\t\t\t\t\t\t\t  nbands, gpts=gpts,\n\t\t\t\t\t\t\t\t  kpts=(Nk, Nk, Nk)):\n\t\tfactories.require('gpaw')\n\t\timport gpaw\n\t\tgpw_path = tmp_path_factory.mktemp('sub') / filename\n\t\tcalc = gpaw.GPAW(\n\t\t\tgpts=gpts,\n\t\t\tnbands=nbands,\n\t\t\tkpts={'size': kpts, 'gamma': True},\n\t\t\tsymmetry='off',\n\t\t\ttxt=None)\n\t\tatoms.calc = calc\n\t\tatoms.get_potential_energy()\n\t\tcalc.write(gpw_path, mode='all')\n\t\treturn gpw_path\n\treturn __base_calculator_gpwfile\n\n", "description": "\n\tGeneric method to cache calculator in a file on disk.\n\t", "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "_h2_calculator_gpwfile", "data": "def _h2_calculator_gpwfile(_base_calculator_gpwfile):\n\tatoms = molecule('H2', pbc=True)\n\tatoms.center(vacuum=3.)\n\tgpw_path = _base_calculator_gpwfile(\n\t\tatoms=atoms,\n\t\tfilename='wan_h2.gpw',\n\t\tnbands=4\n\t)\n\treturn gpw_path\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "h2_calculator", "data": "def h2_calculator(_h2_calculator_gpwfile):\n\timport gpaw\n\treturn gpaw.GPAW(_h2_calculator_gpwfile, txt=None)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "_si_calculator_gpwfile", "data": "def _si_calculator_gpwfile(_base_calculator_gpwfile):\n\tatoms = bulk('Si')\n\tgpw_path = _base_calculator_gpwfile(\n\t\tatoms=atoms,\n\t\tfilename='wan_si.gpw',\n\t\tnbands=8\n\t)\n\treturn gpw_path\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "si_calculator", "data": "def si_calculator(_si_calculator_gpwfile):\n\timport gpaw\n\treturn gpaw.GPAW(_si_calculator_gpwfile, txt=None)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "_ti_calculator_gpwfile", "data": "def _ti_calculator_gpwfile(_base_calculator_gpwfile):\n\tatoms = bulk('Ti', crystalstructure='hcp')\n\tgpw_path = _base_calculator_gpwfile(\n\t\tatoms=atoms,\n\t\tfilename='wan_ti.gpw',\n\t\tnbands=None\n\t)\n\treturn gpw_path\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "ti_calculator", "data": "def ti_calculator(_ti_calculator_gpwfile):\n\timport gpaw\n\treturn gpaw.GPAW(_ti_calculator_gpwfile, txt=None)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "wan", "data": "def wan(rng, h2_calculator):\n\tdef _wan(\n\t\tatoms=None,\n\t\tcalc=None,\n\t\tnwannier=2,\n\t\tfixedstates=None,\n\t\tfixedenergy=None,\n\t\tinitialwannier='bloch',\n\t\tfunctional='std',\n\t\tkpts=None,\n\t\tfile=None,\n\t\trng=rng,\n\t\tfull_calc=False,\n\t\tstd_calc=True,\n\t):\n\t\t\"\"\"\n\t\tGenerate a Wannier object.\n\n\t\tfull_calc: the provided calculator has a converged calculation\n\t\tstd_calc: the default H2 calculator object is used\n\t\t\"\"\"\n\t\t# If the calculator, or some fundamental parameters, are provided\n\t\t# we clearly do not want a default calculator\n\t\tif calc is not None or kpts is not None or atoms is not None:\n\t\t\tstd_calc = False\n\t\t\t# Default value for kpts, if we need to generate atoms/calc\n\t\t\tif kpts is None:\n\t\t\t\tkpts = (Nk, Nk, Nk)\n\n\t\tif std_calc:\n\t\t\tcalc = h2_calculator\n\t\t\tfull_calc = True\n\t\telif atoms is None and not full_calc:\n\t\t\tpbc = (np.array(kpts) > 1).any()\n\t\t\tatoms = molecule('H2', pbc=pbc)\n\t\t\tatoms.center(vacuum=3.)\n\n\t\tif calc is None:\n\t\t\tgpaw = pytest.importorskip('gpaw')\n\t\t\tcalc = gpaw.GPAW(\n\t\t\t\tgpts=gpts,\n\t\t\t\tnbands=nwannier,\n\t\t\t\tkpts=kpts,\n\t\t\t\tsymmetry='off',\n\t\t\t\ttxt=None\n\t\t\t)\n\n\t\tif not full_calc:\n\t\t\tatoms.calc = calc\n\t\t\tatoms.get_potential_energy()\n\n\t\treturn Wannier(\n\t\t\tnwannier=nwannier,\n\t\t\tfixedstates=fixedstates,\n\t\t\tfixedenergy=fixedenergy,\n\t\t\tcalc=calc,\n\t\t\tinitialwannier=initialwannier,\n\t\t\tfile=None,\n\t\t\tfunctional=functional,\n\t\t\trng=rng,\n\t\t)\n\treturn _wan\n\n", "description": "\n\t\tGenerate a Wannier object.\n\n\t\tfull_calc: the provided calculator has a converged calculation\n\t\tstd_calc: the default H2 calculator object is used\n\t\t", "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "bravais_lattices", "data": "def bravais_lattices():\n\treturn [CUB(1), FCC(1), BCC(1), TET(1, 2), BCT(1, 2),\n\t\t\tORC(1, 2, 3), ORCF(1, 2, 3), ORCI(1, 2, 3),\n\t\t\tORCC(1, 2, 3), HEX(1, 2), RHL(1, 110),\n\t\t\tMCL(1, 2, 3, 70), MCLC(1, 2, 3, 70),\n\t\t\tTRI(1, 2, 3, 60, 70, 80), OBL(1, 2, 70),\n\t\t\tHEX2D(1), RECT(1, 2), CRECT(1, 70), SQR(1),\n\t\t\tLINE(1)]\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "class", "name": "classParaboloid:", "data": "class Paraboloid:\n\n\tdef __init__(self, pos=(10., 10., 10.), shift=1.):\n\t\tself.pos = np.array(pos, dtype=complex)\n\t\tself.shift = shift\n\n\tdef get_gradients(self):\n\t\treturn 2 * self.pos\n\n\tdef step(self, dF, updaterot=True, updatecoeff=True):\n\t\tself.pos -= dF\n\n\tdef get_functional_value(self):\n\t\treturn np.sum(self.pos**2) + self.shift\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "unitarity_error", "data": "def unitarity_error(matrix):\n\treturn np.abs(dagger(matrix) @ matrix - np.eye(len(matrix))).max()\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "orthogonality_error", "data": "def orthogonality_error(matrix):\n\terrors = []\n\tfor i in range(len(matrix)):\n\t\tfor j in range(i + 1, len(matrix)):\n\t\t\terrors.append(np.abs(dagger(matrix[i]) @ matrix[j]))\n\treturn np.max(errors)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "normalization_error", "data": "def normalization_error(matrix):\n\told_matrix = matrix.copy()\n\tnormalize(matrix)\n\treturn np.abs(matrix - old_matrix).max()\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_gram_schmidt", "data": "def test_gram_schmidt(rng):\n\tmatrix = rng.random((4, 4))\n\tassert unitarity_error(matrix) > 1\n\tgram_schmidt(matrix)\n\tassert unitarity_error(matrix) < 1e-12\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_lowdin", "data": "def test_lowdin(rng):\n\tmatrix = rng.random((4, 4))\n\tassert unitarity_error(matrix) > 1\n\tlowdin(matrix)\n\tassert unitarity_error(matrix) < 1e-12\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_random_orthogonal_matrix", "data": "def test_random_orthogonal_matrix(rng):\n\tdim = 4\n\tmatrix = random_orthogonal_matrix(dim, rng=rng, real=True)\n\tassert matrix.shape[0] == matrix.shape[1]\n\tassert unitarity_error(matrix) < 1e-12\n\tmatrix = random_orthogonal_matrix(dim, rng=rng, real=False)\n\tassert matrix.shape[0] == matrix.shape[1]\n\tassert unitarity_error(matrix) < 1e-12\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_neighbor_k_search", "data": "def test_neighbor_k_search():\n\tkpt_kc = monkhorst_pack((4, 4, 4))\n\tGdir_dc = [[1, 0, 0], [0, 1, 0], [0, 0, 1],\n\t\t\t   [1, 1, 0], [1, 0, 1], [0, 1, 1]]\n\ttol = 1e-4\n\tfor d, Gdir_c in enumerate(Gdir_dc):\n\t\tfor k, k_c in enumerate(kpt_kc):\n\t\t\tkk, k0 = neighbor_k_search(k_c, Gdir_c, kpt_kc, tol=tol)\n\t\t\tassert np.linalg.norm(kpt_kc[kk] - k_c - Gdir_c + k0) < tol\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_calculate_weights", "data": "def test_calculate_weights(lat):\n\t# Equation from Berghold et al. PRB v61 n15 (2000)\n\ttol = 1e-5\n\tcell = lat.tocell()\n\tg = cell @ cell.T\n\tw, G = calculate_weights(cell, normalize=False)\n\n\terrors = []\n\tfor i in range(3):\n\t\tfor j in range(3):\n\t\t\terrors.append(np.abs((w * G[:, i] @ G[:, j]) - g[i, j]))\n\n\tassert np.max(errors) < tol\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_steepest_descent", "data": "def test_steepest_descent():\n\ttol = 1e-6\n\tstep = 0.1\n\tfunc = Paraboloid(pos=np.array([10, 10, 10], dtype=float), shift=1.)\n\tsteepest_descent(func=func, step=step, tolerance=tol)\n\tassert func.get_functional_value() == pytest.approx(1, abs=1e-5)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_md_min", "data": "def test_md_min():\n\ttol = 1e-8\n\tstep = 0.1\n\tfunc = Paraboloid(pos=np.array([10, 10, 10], dtype=complex), shift=1.)\n\tmd_min(func=func, step=step, tolerance=tol,\n\t\t   max_iter=1e6)\n\tassert func.get_functional_value() == pytest.approx(1, abs=1e-5)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_rotation_from_projection", "data": "def test_rotation_from_projection(rng):\n\tproj_nw = rng.random((6, 4))\n\tassert unitarity_error(proj_nw[:int(min(proj_nw.shape))]) > 1\n\tU_ww, C_ul = rotation_from_projection(proj_nw, fixed=2, ortho=True)\n\tassert unitarity_error(U_ww) < 1e-10, 'U_ww not unitary'\n\tassert orthogonality_error(C_ul.T) < 1e-10, 'C_ul columns not orthogonal'\n\tassert normalization_error(C_ul) < 1e-10, 'C_ul not normalized'\n\tU_ww, C_ul = rotation_from_projection(proj_nw, fixed=2, ortho=False)\n\tassert normalization_error(U_ww) < 1e-10, 'U_ww not normalized'\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_save", "data": "def test_save(tmpdir, wan):\n\twanf = wan(nwannier=4, fixedstates=2, initialwannier='bloch')\n\tjsonfile = tmpdir.join('wanf.json')\n\tf1 = wanf.get_functional_value()\n\twanf.save(jsonfile)\n\twanf.initialize(file=jsonfile, initialwannier='bloch')\n\tassert pytest.approx(f1) == wanf.get_functional_value()\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_radii", "data": "def test_get_radii(lat, wan):\n\t# Sanity check, the Wannier functions' spread should always be positive.\n\t# Also, make sure that the method does not fail for any lattice.\n\tif ((lat.tocell() == FCC(a=1).tocell()).all() or\n\t\t\t(lat.tocell() == ORCF(a=1, b=2, c=3).tocell()).all()):\n\t\tpytest.skip(\"Lattices not supported by this function,\"\n\t\t\t\t\t\" use get_spreads() instead.\")\n\tatoms = molecule('H2', pbc=True)\n\tatoms.cell = lat.tocell()\n\tatoms.center(vacuum=3.)\n\twanf = wan(nwannier=4, fixedstates=2, atoms=atoms, initialwannier='bloch')\n\tassert all(wanf.get_radii() > 0)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_spreads", "data": "def test_get_spreads(lat, wan):\n\t# Sanity check, the Wannier functions' spread should always be positive.\n\t# Also, make sure that the method does not fail for any lattice.\n\tatoms = molecule('H2', pbc=True)\n\tatoms.cell = lat.tocell()\n\tatoms.center(vacuum=3.)\n\twanf = wan(nwannier=4, fixedstates=2, atoms=atoms, initialwannier='bloch')\n\tassert all(wanf.get_spreads() > 0)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_functional_value", "data": "def test_get_functional_value(fun, wan):\n\t# Only testing if the functional scales with the number of functions\n\twan1 = wan(nwannier=3, functional=fun)\n\tf1 = wan1.get_functional_value()\n\twan2 = wan(nwannier=4)\n\tf2 = wan2.get_functional_value()\n\tassert f1 < f2\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_centers", "data": "def test_get_centers(factory):\n\t# Rough test on the position of the Wannier functions' centers\n\tgpaw = pytest.importorskip('gpaw')\n\tcalc = gpaw.GPAW(gpts=(32, 32, 32), nbands=4, txt=None)\n\tatoms = molecule('H2', calculator=calc)\n\tatoms.center(vacuum=3.)\n\tatoms.get_potential_energy()\n\twanf = Wannier(nwannier=2, calc=calc, initialwannier='bloch')\n\tcenters = wanf.get_centers()\n\tcom = atoms.get_center_of_mass()\n\tassert np.abs(centers - [com, com]).max() < 1e-4\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_write_cube_default", "data": "def test_write_cube_default(wan, h2_calculator, testdir):\n\t# Chek the value saved in the CUBE file and the atoms object.\n\t# The default saved value is the absolute value of the Wannier function,\n\t# and the supercell is repeated per the number of k-points in each\n\t# direction.\n\tatoms = h2_calculator.atoms\n\twanf = wan(calc=h2_calculator, full_calc=True)\n\tindex = 0\n\n\t# It returns some errors when using file objects, so we use a string\n\tcubefilename = 'wanf.cube'\n\twanf.write_cube(index, cubefilename)\n\twith open(cubefilename, mode='r') as inputfile:\n\t\tcontent = read_cube(inputfile)\n\tassert pytest.approx(content['atoms'].cell.array) == atoms.cell.array * 2\n\tassert pytest.approx(content['data']) == abs(wanf.get_function(index))\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_write_cube_angle", "data": "def test_write_cube_angle(wan, testdir):\n\t# Check that the complex phase is correctly saved to the CUBE file, together\n\t# with the right atoms object.\n\tatoms = molecule('H2')\n\tatoms.center(vacuum=3.)\n\twanf = wan(atoms=atoms, kpts=(1, 1, 1))\n\tindex = 0\n\n\t# It returns some errors when using file objects, so we use a string\n\tcubefilename = 'wanf.cube'\n\twanf.write_cube(index, cubefilename, angle=True)\n\twith open(cubefilename, mode='r') as inputfile:\n\t\tcontent = read_cube(inputfile)\n\tassert pytest.approx(content['atoms'].cell.array) == atoms.cell.array\n\tassert pytest.approx(content['data']) == np.angle(wanf.get_function(index))\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_write_cube_repeat", "data": "def test_write_cube_repeat(wan, testdir):\n\t# Check that the repeated supercell and Wannier functions are correctly\n\t# saved to the CUBE file, together with the right atoms object.\n\tatoms = molecule('H2')\n\tatoms.center(vacuum=3.)\n\twanf = wan(atoms=atoms, kpts=(1, 1, 1))\n\tindex = 0\n\trepetition = [4, 4, 4]\n\n\t# It returns some errors when using file objects, so we use simple filename\n\tcubefilename = 'wanf.cube'\n\twanf.write_cube(index, cubefilename, repeat=repetition)\n\n\twith open(cubefilename, mode='r') as inputfile:\n\t\tcontent = read_cube(inputfile)\n\tassert pytest.approx(content['atoms'].cell.array) == \\\n\t\t(atoms * repetition).cell.array\n\tassert pytest.approx(content['data']) == \\\n\t\tabs(wanf.get_function(index, repetition))\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_localize", "data": "def test_localize(wan):\n\twanf = wan(initialwannier='random')\n\tfvalue = wanf.get_functional_value()\n\twanf.localize()\n\tassert wanf.get_functional_value() > fvalue\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_spectral_weight_bloch", "data": "def test_get_spectral_weight_bloch(wan):\n\tnwannier = 4\n\twanf = wan(initialwannier='bloch', nwannier=nwannier)\n\tfor i in range(nwannier):\n\t\tassert wanf.get_spectral_weight(i)[:, i].sum() == pytest.approx(1)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_spectral_weight_random", "data": "def test_get_spectral_weight_random(wan, rng):\n\tnwannier = 4\n\twanf = wan(initialwannier='random', nwannier=nwannier, rng=rng)\n\tfor i in range(nwannier):\n\t\tassert wanf.get_spectral_weight(i).sum() == pytest.approx(1)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_pdos", "data": "def test_get_pdos(wan):\n\tnwannier = 4\n\tgpaw = pytest.importorskip('gpaw')\n\tcalc = gpaw.GPAW(gpts=(16, 16, 16), nbands=nwannier, txt=None)\n\tatoms = molecule('H2')\n\tatoms.center(vacuum=3.)\n\tatoms.calc = calc\n\tatoms.get_potential_energy()\n\twanf = wan(atoms=atoms, calc=calc,\n\t\t\t   nwannier=nwannier, initialwannier='bloch')\n\teig_n = calc.get_eigenvalues()\n\tfor i in range(nwannier):\n\t\tpdos_n = wanf.get_pdos(w=i, energies=eig_n, width=0.001)\n\t\tassert pdos_n[i] != pytest.approx(0)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_translate", "data": "def test_translate(wan, h2_calculator):\n\tnwannier = 2\n\tcalc = h2_calculator\n\tatoms = calc.get_atoms()\n\twanf = wan(nwannier=nwannier, initialwannier='bloch',\n\t\t\t   calc=calc, full_calc=True)\n\twanf.translate_all_to_cell(cell=[0, 0, 0])\n\tc0_w = wanf.get_centers()\n\tfor i in range(nwannier):\n\t\tc2_w = np.delete(wanf.get_centers(), i, 0)\n\t\twanf.translate(w=i, R=[1, 1, 1])\n\t\tc1_w = wanf.get_centers()\n\t\tassert np.linalg.norm(c1_w[i] - c0_w[i]) == \\\n\t\t\tpytest.approx(np.linalg.norm(atoms.cell.array.diagonal()))\n\t\tc1_w = np.delete(c1_w, i, 0)\n\t\tassert c1_w == pytest.approx(c2_w)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_translate_to_cell", "data": "def test_translate_to_cell(wan, h2_calculator):\n\tnwannier = 2\n\tcalc = h2_calculator\n\tatoms = calc.get_atoms()\n\twanf = wan(nwannier=nwannier, initialwannier='bloch',\n\t\t\t   calc=calc, full_calc=True)\n\tfor i in range(nwannier):\n\t\twanf.translate_to_cell(w=i, cell=[0, 0, 0])\n\t\tc0_w = wanf.get_centers()\n\t\tassert (c0_w[i] < atoms.cell.array.diagonal()).all()\n\t\twanf.translate_to_cell(w=i, cell=[1, 1, 1])\n\t\tc1_w = wanf.get_centers()\n\t\tassert (c1_w[i] > atoms.cell.array.diagonal()).all()\n\t\tassert np.linalg.norm(c1_w[i] - c0_w[i]) == \\\n\t\t\tpytest.approx(np.linalg.norm(atoms.cell.array.diagonal()))\n\t\tc0_w = np.delete(c0_w, i, 0)\n\t\tc1_w = np.delete(c1_w, i, 0)\n\t\tassert c0_w == pytest.approx(c1_w)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_translate_all_to_cell", "data": "def test_translate_all_to_cell(wan, h2_calculator):\n\tnwannier = 2\n\tcalc = h2_calculator\n\tatoms = calc.get_atoms()\n\twanf = wan(nwannier=nwannier, initialwannier='bloch',\n\t\t\t   calc=calc, full_calc=True)\n\twanf.translate_all_to_cell(cell=[0, 0, 0])\n\tc0_w = wanf.get_centers()\n\tassert (c0_w < atoms.cell.array.diagonal()).all()\n\twanf.translate_all_to_cell(cell=[1, 1, 1])\n\tc1_w = wanf.get_centers()\n\tassert (c1_w > atoms.cell.array.diagonal()).all()\n\tfor i in range(nwannier):\n\t\tassert np.linalg.norm(c1_w[i] - c0_w[i]) == \\\n\t\t\tpytest.approx(np.linalg.norm(atoms.cell.array.diagonal()))\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_distances", "data": "def test_distances(wan, h2_calculator):\n\tnwannier = 2\n\tcalc = h2_calculator\n\tatoms = calc.get_atoms()\n\twanf = wan(nwannier=nwannier, initialwannier='bloch')\n\tcent_w = wanf.get_centers()\n\tdist_ww = wanf.distances([0, 0, 0])\n\tdist1_ww = wanf.distances([1, 1, 1])\n\tfor i in range(nwannier):\n\t\tassert dist_ww[i, i] == pytest.approx(0)\n\t\tassert dist1_ww[i, i] == pytest.approx(np.linalg.norm(atoms.cell.array))\n\t\tfor j in range(i + 1, nwannier):\n\t\t\tassert dist_ww[i, j] == dist_ww[j, i]\n\t\t\tassert dist_ww[i, j] == \\\n\t\t\t\tpytest.approx(np.linalg.norm(cent_w[i] - cent_w[j]))\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_hopping_bloch", "data": "def test_get_hopping_bloch(wan):\n\tnwannier = 4\n\twanf = wan(nwannier=nwannier, initialwannier='bloch')\n\thop0_ww = wanf.get_hopping([0, 0, 0])\n\thop1_ww = wanf.get_hopping([1, 1, 1])\n\tfor i in range(nwannier):\n\t\tassert hop0_ww[i, i] != 0\n\t\tassert hop1_ww[i, i] != 0\n\t\tfor j in range(i + 1, nwannier):\n\t\t\tassert hop0_ww[i, j] == 0\n\t\t\tassert hop1_ww[i, j] == 0\n\t\t\tassert hop0_ww[i, j] == hop0_ww[j, i]\n\t\t\tassert hop1_ww[i, j] == hop1_ww[j, i]\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_hopping_random", "data": "def test_get_hopping_random(wan, rng):\n\tnwannier = 4\n\twanf = wan(nwannier=nwannier, initialwannier='random')\n\thop0_ww = wanf.get_hopping([0, 0, 0])\n\thop1_ww = wanf.get_hopping([1, 1, 1])\n\tfor i in range(nwannier):\n\t\tfor j in range(i + 1, nwannier):\n\t\t\tassert np.abs(hop0_ww[i, j]) == pytest.approx(np.abs(hop0_ww[j, i]))\n\t\t\tassert np.abs(hop1_ww[i, j]) == pytest.approx(np.abs(hop1_ww[j, i]))\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_hamiltonian_bloch", "data": "def test_get_hamiltonian_bloch(wan):\n\tnwannier = 4\n\tatoms = molecule('H2', pbc=True)\n\tatoms.center(vacuum=3.)\n\tkpts = (2, 2, 2)\n\tnumber_kpts = kpts[0] * kpts[1] * kpts[2]\n\twanf = wan(atoms=atoms, kpts=kpts,\n\t\t\t   nwannier=nwannier, initialwannier='bloch')\n\tfor k in range(number_kpts):\n\t\tH_ww = wanf.get_hamiltonian(k=k)\n\t\tfor i in range(nwannier):\n\t\t\tassert H_ww[i, i] != 0\n\t\t\tfor j in range(i + 1, nwannier):\n\t\t\t\tassert H_ww[i, j] == 0\n\t\t\t\tassert H_ww[i, j] == pytest.approx(H_ww[j, i])\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_hamiltonian_random", "data": "def test_get_hamiltonian_random(wan, rng):\n\tnwannier = 4\n\tatoms = molecule('H2', pbc=True)\n\tatoms.center(vacuum=3.)\n\tkpts = (2, 2, 2)\n\tnumber_kpts = kpts[0] * kpts[1] * kpts[2]\n\twanf = wan(atoms=atoms, kpts=kpts, rng=rng,\n\t\t\t   nwannier=nwannier, initialwannier='random')\n\tfor k in range(number_kpts):\n\t\tH_ww = wanf.get_hamiltonian(k=k)\n\t\tfor i in range(nwannier):\n\t\t\tfor j in range(i + 1, nwannier):\n\t\t\t\tassert np.abs(H_ww[i, j]) == pytest.approx(np.abs(H_ww[j, i]))\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_hamiltonian_kpoint", "data": "def test_get_hamiltonian_kpoint(wan, rng, h2_calculator):\n\tnwannier = 4\n\tcalc = h2_calculator\n\tatoms = calc.get_atoms()\n\twanf = wan(nwannier=nwannier, initialwannier='random')\n\tkpts = atoms.cell.bandpath(density=50).cartesian_kpts()\n\tfor kpt_c in kpts:\n\t\tH_ww = wanf.get_hamiltonian_kpoint(kpt_c=kpt_c)\n\t\tfor i in range(nwannier):\n\t\t\tfor j in range(i + 1, nwannier):\n\t\t\t\tassert np.abs(H_ww[i, j]) == pytest.approx(np.abs(H_ww[j, i]))\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_function", "data": "def test_get_function(wan):\n\tnwannier = 2\n\tgpts_np = np.array(gpts)\n\twanf = wan(nwannier=nwannier, initialwannier='bloch')\n\tassert (wanf.get_function(index=[0, 0]) == 0).all()\n\tassert wanf.get_function(index=[0, 1]) + wanf.get_function(index=[1, 0]) \\\n\t\t== pytest.approx(wanf.get_function(index=[1, 1]))\n\tfor i in range(nwannier):\n\t\tassert (gpts_np * Nk == wanf.get_function(index=i).shape).all()\n\t\tassert (gpts_np * [1, 2, 3] ==\n\t\t\t\twanf.get_function(index=i, repeat=[1, 2, 3]).shape).all()\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_gradients", "data": "def test_get_gradients(fun, wan, rng):\n\twanf = wan(nwannier=4, fixedstates=2, kpts=(1, 1, 1),\n\t\t\t   initialwannier='bloch', functional=fun)\n\t# create an anti-hermitian array/matrix\n\tstep = rng.random(wanf.get_gradients().size) + \\\n\t\t1.j * rng.random(wanf.get_gradients().size)\n\tstep *= 1e-8\n\tstep -= dagger(step)\n\tf1 = wanf.get_functional_value()\n\twanf.step(step)\n\tf2 = wanf.get_functional_value()\n\tassert (np.abs((f2 - f1) / step).ravel() -\n\t\t\tnp.abs(wanf.get_gradients())).max() < 1e-4\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_initialwannier", "data": "def test_initialwannier(init, wan, ti_calculator):\n\t# dummy check to run the module with different initialwannier methods\n\twanf = wan(calc=ti_calculator, full_calc=True,\n\t\t\t   initialwannier=init, nwannier=14, fixedstates=12)\n\tassert wanf.get_functional_value() > 0\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_nwannier_auto", "data": "def test_nwannier_auto(wan, ti_calculator):\n\t\"\"\" Test 'auto' value for parameter 'nwannier'. \"\"\"\n\tpartial_wan = partial(\n\t\twan,\n\t\tcalc=ti_calculator,\n\t\tfull_calc=True,\n\t\tinitialwannier='bloch',\n\t\tnwannier='auto'\n\t)\n\n\t# Check default value\n\twanf = partial_wan()\n\tassert wanf.nwannier == 15\n\n\t# Check value setting fixedenergy\n\twanf = partial_wan(fixedenergy=0)\n\tassert wanf.nwannier == 15\n\twanf = partial_wan(fixedenergy=5)\n\tassert wanf.nwannier == 18\n\n\t# Check value setting fixedstates\n\tnumber_kpts = Nk**3\n\tlist_fixedstates = [14] * number_kpts\n\tlist_fixedstates[Nk] = 18\n\twanf = partial_wan(fixedstates=list_fixedstates)\n\tassert wanf.nwannier == 18\n\n", "description": " Test 'auto' value for parameter 'nwannier'. ", "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_arbitrary_s_orbitals", "data": "def test_arbitrary_s_orbitals(rng):\n\tatoms = Atoms('3H', positions=[[0, 0, 0],\n\t\t\t\t\t\t\t\t   [1, 1.5, 1],\n\t\t\t\t\t\t\t\t   [2, 3, 0]])\n\torbs = arbitrary_s_orbitals(atoms, 10, rng)\n\n\tatoms.append('H')\n\ts_pos = atoms.get_scaled_positions()\n\tfor orb in orbs:\n\t\t# Test if they are actually s-orbitals\n\t\tassert orb[1] == 0\n\n\t\t# Read random position\n\t\tx, y, z = orb[0]\n\t\ts_pos[-1] = [x, y, z]\n\t\tatoms.set_scaled_positions(s_pos)\n\n\t\t# Use dummy H atom to measure distance from any other atom\n\t\tdists = atoms.get_distances(\n\t\t\ta=-1,\n\t\t\tindices=range(atoms.get_global_number_of_atoms() - 1))\n\n\t\t# Test that the s-orbital is close to at least one atom\n\t\tassert (dists < 1.5).any()\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_init_orbitals_h2", "data": "def test_init_orbitals_h2(rng):\n\t# Check that the initial orbitals for H2 are as many as requested and they\n\t# are all s-orbitals (l=0).\n\tatoms = molecule('H2')\n\tatoms.center(vacuum=3.)\n\tntot = 2\n\torbs = init_orbitals(atoms=atoms, ntot=ntot, rng=rng)\n\tangular_momenta = [orb[1] for orb in orbs]\n\tassert sum([l_ * 2 + 1 for l_ in angular_momenta]) == ntot\n\tassert angular_momenta == [0] * ntot\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_init_orbitals_ti", "data": "def test_init_orbitals_ti(rng):\n\t# Check that the initial orbitals for Ti bulk are as many as requested and\n\t# there are both s-orbitals (l=0) and d-orbitals (l=2).\n\tatoms = bulk('Ti')\n\tntot = 14\n\torbs = init_orbitals(atoms=atoms, ntot=ntot, rng=rng)\n\tangular_momenta = [orb[1] for orb in orbs]\n\tassert sum([l_ * 2 + 1 for l_ in angular_momenta]) == ntot\n\tassert 0 in angular_momenta\n\tassert 2 in angular_momenta\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_search_for_gamma_point", "data": "def test_search_for_gamma_point():\n\tlist_with_gamma = [[-1.0, -1.0, -1.0],\n\t\t\t\t\t   [0.0, 0.0, 0.0],\n\t\t\t\t\t   [0.1, 0.0, 0.0],\n\t\t\t\t\t   [1.5, 2.5, 0.5]]\n\tgamma_idx = search_for_gamma_point(list_with_gamma)\n\tassert gamma_idx == 1\n\n\tlist_without_gamma = [[-1.0, -1.0, -1.0],\n\t\t\t\t\t\t  [0.1, 0.0, 0.0],\n\t\t\t\t\t\t  [1.5, 2.5, 0.5]]\n\tgamma_idx = search_for_gamma_point(list_without_gamma)\n\tassert gamma_idx is None\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_scdm", "data": "def test_scdm(ti_calculator):\n\tcalc = ti_calculator\n\tNw = 14\n\tps = calc.get_pseudo_wave_function(band=Nw, kpt=0, spin=0)\n\tNg = ps.size\n\tkpt_kc = calc.get_bz_k_points()\n\tnumber_kpts = len(kpt_kc)\n\tnbands = calc.get_number_of_bands()\n\tpseudo_nkG = np.zeros((nbands, number_kpts, Ng), dtype=np.complex128)\n\tfor k in range(number_kpts):\n\t\tfor n in range(nbands):\n\t\t\tpseudo_nkG[n, k] = calc.get_pseudo_wave_function(\n\t\t\t\tband=n, kpt=k, spin=0).ravel()\n\tfixed_k = [Nw - 2] * number_kpts\n\tC_kul, U_kww = scdm(pseudo_nkG, kpts=kpt_kc,\n\t\t\t\t\t\tfixed_k=fixed_k, Nw=Nw)\n\tfor k in range(number_kpts):\n\t\tassert unitarity_error(U_kww[k]) < 1e-10, 'U_ww not unitary'\n\t\tassert orthogonality_error(C_kul[k].T) < 1e-10, \\\n\t\t\t'C_ul columns not orthogonal'\n\t\tassert normalization_error(C_kul[k]) < 1e-10, 'C_ul not normalized'\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_get_optimal_nwannier", "data": "def test_get_optimal_nwannier(wan, si_calculator):\n\t\"\"\" Test method to compute the optimal 'nwannier' value. \"\"\"\n\n\twanf = wan(calc=si_calculator, full_calc=True,\n\t\t\t   initialwannier='bloch', nwannier='auto', fixedenergy=1)\n\n\t# Test with default parameters\n\topt_nw = wanf.get_optimal_nwannier()\n\tassert opt_nw == 7\n\n\t# Test with non-default parameters.\n\t# This is mostly to test that is does actually support this parameters,\n\t# it's not really testing the actual result.\n\topt_nw = wanf.get_optimal_nwannier(nwrange=10)\n\tassert opt_nw == 7\n\topt_nw = wanf.get_optimal_nwannier(tolerance=1e-2)\n\tassert opt_nw == 8\n\n\t# This should give same result since the initialwannier does not include\n\t# randomness.\n\topt_nw = wanf.get_optimal_nwannier(random_reps=10)\n\tassert opt_nw == 7\n\n\t# Test with random repetitions, just test if it runs.\n\twanf = wan(calc=si_calculator, full_calc=True,\n\t\t\t   initialwannier='orbitals', nwannier='auto', fixedenergy=0)\n\topt_nw = wanf.get_optimal_nwannier(random_reps=10)\n\tassert opt_nw >= 0\n\n", "description": " Test method to compute the optimal 'nwannier' value. ", "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}, {"term": "def", "name": "test_spread_contributions", "data": "def test_spread_contributions(wan):\n\t# Only a test on a constant value to make sure it does not deviate too much\n\twan1 = wan()\n\ttest_values_w = wan1._spread_contributions()\n\tref_values_w = [2.28535569, 0.04660427]\n\tassert test_values_w == pytest.approx(ref_values_w, abs=1e-4)\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from functools import partial", "from ase import Atoms", "from ase.transport.tools import dagger, normalize", "from ase.dft.kpoints import monkhorst_pack", "from ase.build import molecule, bulk", "from ase.io.cube import read_cube", "from ase.lattice import CUB, FCC, BCC, TET, BCT, ORC, ORCF, ORCI, ORCC, HEX, \\", "from ase.dft.wannier import gram_schmidt, lowdin, \\", "from ase.dft.wannierstate import random_orthogonal_matrix", "\t\timport gpaw", "\timport gpaw", "\timport gpaw", "\timport gpaw", "\t\t\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')", "\tgpaw = pytest.importorskip('gpaw')"]}], [{"term": "def", "name": "signal_handler", "data": "def signal_handler(signum, frame):\n\tmsg = 'FAILED`recv signal ' + str(signum) + '. exit now.'\n\tcommon.info(my_log, log_tag, inputdate + msg)\n\n\tif os.path.isfile(my_pidfile):\n\t\tos.remove(my_pidfile)\n\t\n\tsys.exit(0)\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_one_channel", "data": "def draw_one_channel():\n\t\n\tif len(channel_table_1month) <= 0:\n\t\treturn True\n   \n\tif len(Calc_channel_table_1month) <= 0:\n\t\treturn True\n\t\n\tprint\"just channel\"\n\t  \n\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor(MySQLdb.cursors.DictCursor)\n\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])  \n\t\t\n\t\t\n\t\t\n\t\tfor index,item in enumerate(channel_table_1month):\n\t\t\t\n\t\t\ttmpfile1month = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS() \\\n\t\t\t+ '.ch' + '.1month' \n\t\t\tsql_1month = 'select * from '+item[0]+ conf.export_txt%(tmpfile1month + '.txt')\n\t\t\tcur.execute(sql_1month)\n\t\t\ttmphdf = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS()+'.HDF'\n\t\t\tprint tmphdf\n\t\t\tdata = open(tmpfile1month+'.txt').read() \n\t\t\tif len(data)==0:\n\t\t\t\tprint \"empty table\"+item[0]\n\t\t\t\tcontinue\n\t\t\thfile = h5.File(tmphdf, 'w')\n\t\t\tdata_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n\t\t\t\n\t\t\thfile.create_dataset('id', data = (data_1month[:, 0]).astype(numpy.int))\n\t\t\thfile.create_dataset('channel', data = (data_1month[:, 1]).astype(numpy.int))\n\t\t\thfile.create_dataset('scln', data = (data_1month[:, 2]).astype(numpy.int))\n\t\t\thfile.create_dataset('ymdhms', data = (data_1month[:, 3]).astype(numpy.str))\n\t\t\thfile.create_dataset('cal_coef1', data = (data_1month[:, 4]).astype(numpy.int))\n\t\t\thfile.create_dataset('cal_coef2', data = (data_1month[:, 5]).astype(numpy.int))\n\t\t\thfile.create_dataset('cal_coef3', data = (data_1month[:, 6]).astype(numpy.int))\n\t\t\t\n\t\t\thfile.close()\n\t\t\t\n\t\tfor index,item in enumerate(Calc_channel_table_1month):\n\t\t\ttmpfile1month_calc = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS() \\\n\t\t\t+ '.ch' + '.1month_calc'\n\t\t\tsql_1month_calc = 'select * from '+item[0]+ conf.export_txt%(tmpfile1month_calc + '.txt')\n\t\t\tcur.execute(sql_1month_calc)\n\t\t\ttmphdf = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS()+'.HDF'\n\t\t\tprint tmphdf\n\t\t\tdata = open(tmpfile1month_calc+'.txt').read() \n\t\t\tif len(data)==0:\n\t\t\t\tprint \"empty table\"+item[0]\n\t\t\t\tcontinue\n\t\t\thfile = h5.File(tmphdf, 'w')\n\t\t\tdata_1month_calc = numpy.loadtxt(tmpfile1month_calc + '.txt', dtype='str', delimiter=',')\n\t\t\t\n\t\t\thfile.create_dataset('id', data = data_1month_calc[:, 0].astype(numpy.int))\n\t\t\thfile.create_dataset('channel', data = data_1month_calc[:, 1].astype(numpy.int))\n\t\t\thfile.create_dataset('scln', data = data_1month_calc[:, 2].astype(numpy.int))\n\t\t\thfile.create_dataset('ymdhms', data = data_1month_calc[:, 3].astype(numpy.str))\n\t\t\thfile.create_dataset('gain', data = data_1month_calc[:, 4].astype(numpy.int))\n\t\t\thfile.create_dataset('agc', data = data_1month_calc[:, 5].astype(numpy.int))\n\t\t\thfile.create_dataset('SPBB1', data = data_1month_calc[:, 6].astype(numpy.int))\n\t\t\thfile.create_dataset('SPBB2', data = data_1month_calc[:, 7].astype(numpy.int))\n\t\t\t\n\t\t\thfile.close()\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\t\n\t\t\n\t\t#cur.execute(sql_1month)\n\t\t#print Calc_channel_table_3day\n\t\t#print \"-------------------------------------\"\n\t\t#print sql_1month_calc\n\t\t\n\t\t#cur.execute(sql_1month_calc)\n\t\t\n\t\tbegin_data = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\t# do NOT exit in thread!! To avoid zombie process.\n\t\tmsg = 'draw obc 3-dim ch'  + ' png`Mysql Fatal Error[' \\\n\t\t\t+ str(e.args[0]) + ']: ' + e.args[1]\t\t\t  \n\t\tcommon.err(my_log, log_tag, inputdate + msg)\n\t\treturn False\n\n\t\n\t\n\t#hfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n\t#ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n\t#hfile.create_dataset(\"time_1month_channel_calc\", data = ymdh_arr.astype(numpy.int32)) \n\t#ret = create_obc_hdf('1month',hfile,data_1month_calc, ins_conf.calc_3dim_to_db.values())\n\t#if not ret:\n\t#\treturn False\n\t\n\t#ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n\t#hfile.create_dataset(\"time_3day_channel_calc\", data = ymdh_arr.astype(numpy.int32))\t \n\t#ret = create_obc_hdf('3day',hfile,data_3day_calc, ins_conf.calc_3dim_to_db.values())\n\t#if not ret:\n\t#\treturn False\n\n\n\t\n\t#return \n\t\n\n\n\t# like: FY3C_MWTS_20140303_0259_TO_20140428_1159_12H_CH01_[PRT|INS_TEMP|...]\n\t\n\t\n\treturn True\n\n\n\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_just_obc", "data": "def draw_just_obc():\n\t\n\tif len(obc_table_1month) <= 0:\n\t\treturn True\n\t\n\tif len(Calc_table_1month) <= 0:\n\t\treturn True\n\t\n\tprint\"just obc\"\n\t#begin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + obc_table_3day[0] \\\n\t\t\t\t#+ \" limit 1\"   \n\t\n\t\n\t#sql_1month = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n\t#\t\t\t\t\t\t\t obc_table_1month, conf.obc_select_prefix_sql) \\\n\t#  + conf.export_txt%(tmpfile1month + '.txt')\n\t\t\n\n\n\t\n\t  \n\t\n\t\n\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor(MySQLdb.cursors.DictCursor)\n\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\t\n\t\t\n\t\tfor index,item in enumerate(obc_table_1month):\n\t\t\ttmpfile1month = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS() +'.1month' +'.obc'\n\t\t\tsql_1month = 'select * from '+item[0]+ conf.export_txt%(tmpfile1month + '.txt')\n\t\t\tcur.execute(sql_1month)\n\t\t\ttmphdf = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS()+'.OBC.HDF'\n\t\t\tprint tmphdf\n\t\t\tdata = open(tmpfile1month+'.txt').read() \n\t\t\tif len(data)==0:\n\t\t\t\tprint \"empty table\"+item[0]\n\t\t\t\tcontinue\n\t\t\thfile = h5.File(tmphdf, 'w')\n\t\t\t\n\t\t\tdata_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n\t\t\t\n\t\t\thfile.create_dataset('id', data = data_1month[:, 0].astype(numpy.int))\n\t\t\thfile.create_dataset('scln', data = data_1month[:, 1].astype(numpy.int))\n\t\t\thfile.create_dataset('ymdhms', data = data_1month[:, 2].astype(numpy.str))\n\t\t\thfile.create_dataset('ins_temp1', data = data_1month[:, 3].astype(numpy.int))\n\t\t\thfile.create_dataset('ins_temp2', data = data_1month[:, 4].astype(numpy.int))\n\t\t\thfile.create_dataset('prt_avg1', data = data_1month[:, 5].astype(numpy.int))\n\t\t\thfile.create_dataset('prt_avg2', data = data_1month[:, 6].astype(numpy.int))\n\t\t\thfile.create_dataset('cold_ang', data = data_1month[:, 7].astype(numpy.int))\n\t\t\thfile.create_dataset('hot_ang', data = data_1month[:, 8].astype(numpy.int))\n\t\t\thfile.create_dataset('pixviewangle1', data = data_1month[:, 9].astype(numpy.int))\n\t\t\thfile.create_dataset('pixviewangle2', data = data_1month[:, 10].astype(numpy.int))\n\t\t\t\n\t\t\thfile.close()\n\t\t\t\n\t\tfor index,item in enumerate(Calc_table_1month):\n\t\t\ttmpfile1month_calc = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS() +'.1month.calc' +'.obc'\n\t\t\tsql_1month_calc = 'select * from '+item[0]+ conf.export_txt%(tmpfile1month_calc + '.txt')\n\t\t\tcur.execute(sql_1month_calc)\n\t\t\ttmphdf = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS()+'.OBC.HDF'\n\t\t\tprint tmphdf\n\t\t\tdata = open(tmpfile1month_calc+'.txt').read() \n\t\t\tif len(data)==0:\n\t\t\t\tprint \"empty table\"+item[0]\n\t\t\t\tcontinue\n\t\t\thfile = h5.File(tmphdf, 'w')\n\t\t\tdata_1month_calc = numpy.loadtxt(tmpfile1month_calc + '.txt', dtype='str', delimiter=',')\n\t\t\t\n\t\t\thfile.create_dataset('id', data = data_1month_calc[:, 0].astype(numpy.int))\n\t\t\thfile.create_dataset('scln', data = data_1month_calc[:, 1].astype(numpy.int))\n\t\t\thfile.create_dataset('ymdhms', data = data_1month_calc[:, 2].astype(numpy.str))\n\t\t\thfile.create_dataset('digital_control_u', data = data_1month_calc[:, 3].astype(numpy.int))\n\t\t\thfile.create_dataset('cell_control_u', data = data_1month_calc[:, 4].astype(numpy.int))\n\t\t\thfile.create_dataset('motor_temp_1', data = data_1month_calc[:, 5].astype(numpy.int))\n\t\t\thfile.create_dataset('motor_temp_2', data = data_1month_calc[:, 6].astype(numpy.int))\n\t\t\thfile.create_dataset('antenna_mask_temp_1', data = data_1month_calc[:, 7].astype(numpy.int))\n\t\t\thfile.create_dataset('antenna_mask_temp_2', data = data_1month_calc[:, 8].astype(numpy.int))\n\t\t\thfile.create_dataset('fet_118_amp_temp', data = data_1month_calc[:, 9].astype(numpy.int))\n\t\t\thfile.create_dataset('fet_183_amp_temp', data = data_1month_calc[:, 10].astype(numpy.int))\n\t\t\thfile.create_dataset('scan_prd', data = data_1month_calc[:, 11].astype(numpy.int))\n\t\t\t\n\t\t\thfile.close()\n\t\t\n\t\t\n\t\t#cur.execute(begin_sql_3day)\n\t\tbegin_data = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\t# do NOT exit in thread!! To avoid zombie process.\n\t\t#print sql_3day\n\t\t#print \"------------------\"\n\t\t#print sql_1month\n\t\t#print \"------------------\"\n\t\t#print sql_3day_calc\n\t\t#print \"------------------\"\n\t\t#print sql_1month_calc\n\t\t#print \"------------------\"\n\t\t#print begin_sql_3day\n\t\t#print \"------------------\"\n\t\tmsg = '??draw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1] \n\t\tprint msg\t\t\t \n\t\tcommon.err(my_log, log_tag, inputdate + msg)\n\t\treturn False\n\t\n \n   \n\n\t\n\t\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_t639", "data": "def draw_t639():\n\t\n\tif len(T639) <= 0:\n\t\treturn True\n\t\n\t\n\t\n\tprint\"just t639\"\n\t#begin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + obc_table_3day[0] \\\n\t\t\t\t#+ \" limit 1\"   \n\t\n\t\n\t#sql_1month = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n\t#\t\t\t\t\t\t\t obc_table_1month, conf.obc_select_prefix_sql) \\\n\t#  + conf.export_txt%(tmpfile1month + '.txt')\n\t\t\n\n\n\t\n\t  \n\t\n\t\n\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor(MySQLdb.cursors.DictCursor)\n\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\t\n\t\t\n\t\tfor index,item in enumerate(T639):\n\t\t\ttmpfile1month = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS() +'.1month' +'.obc'\n\t\t\tsql_1month = 'select * from '+item[0]+ conf.export_txt%(tmpfile1month + '.txt')\n\t\t\tcur.execute(sql_1month)\n\t\t\ttmphdf = '/assimilation/fymonitor/DATA/TMP/test/' + item[0] + '.' + common.utc_YmdHMS()+'.HDF'\n\t\t\tprint tmphdf\n\t\t\tdata = open(tmpfile1month+'.txt').read() \n\t\t\tif len(data)==0:\n\t\t\t\tprint \"empty table\"+item[0]\n\t\t\t\tcontinue\n\t\t\thfile = h5.File(tmphdf, 'w')\n\t\t\tprint tmpfile1month + '.txt'\n\t\t\tdata_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n\t\t\t\n\t\t\thfile.create_dataset('id', data = data_1month[:, 0].astype(numpy.int))\n\t\t\thfile.create_dataset('scln', data = data_1month[:, 1].astype(numpy.int))\n\t\t\thfile.create_dataset('scpt', data = data_1month[:, 2].astype(numpy.int))\n\t\t\thfile.create_dataset('ymdhms', data = data_1month[:, 3].astype(numpy.str))\n\t\t\thfile.create_dataset('obt_direct', data = data_1month[:, 4].astype(numpy.str))\n\t\t\thfile.create_dataset('lat', data = data_1month[:, 5].astype(numpy.int))\n\t\t\thfile.create_dataset('lon', data = data_1month[:, 6].astype(numpy.int))\n\t\t\thfile.create_dataset('sen_zen', data = data_1month[:, 7].astype(numpy.int))\n\t\t\thfile.create_dataset('sen_az', data = data_1month[:, 8].astype(numpy.int))\n\t\t\thfile.create_dataset('landsea', data = data_1month[:, 9].astype(numpy.int))\n\t\t\thfile.create_dataset('dem', data = data_1month[:, 10].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt1', data = data_1month[:, 11].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt2', data = data_1month[:, 12].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt3', data = data_1month[:, 13].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt4', data = data_1month[:, 14].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt5', data = data_1month[:, 15].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt6', data = data_1month[:, 16].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt7', data = data_1month[:, 17].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt8', data = data_1month[:, 18].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt9', data = data_1month[:, 19].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt10', data = data_1month[:, 20].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt11', data = data_1month[:, 21].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt12', data = data_1month[:, 22].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt13', data = data_1month[:, 23].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt14', data = data_1month[:, 24].astype(numpy.int))\n\t\t\thfile.create_dataset('obs_bt15', data = data_1month[:, 25].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt1', data = data_1month[:, 26].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt2', data = data_1month[:, 27].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt3', data = data_1month[:, 28].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt4', data = data_1month[:, 29].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt5', data = data_1month[:, 30].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt6', data = data_1month[:, 31].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt7', data = data_1month[:, 32].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt8', data = data_1month[:, 33].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt9', data = data_1month[:, 34].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt10', data = data_1month[:, 35].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt11', data = data_1month[:, 36].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt12', data = data_1month[:, 37].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt13', data = data_1month[:, 38].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt14', data = data_1month[:, 39].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_bt15', data = data_1month[:, 40].astype(numpy.int))\n\t\t\thfile.create_dataset('rttov_nwp_begin_t', data = data_1month[:, 37].astype(numpy.double))\n\t\t\thfile.create_dataset('rttov_nwp_begin_coef', data = data_1month[:, 38].astype(numpy.float))\n\t\t\thfile.create_dataset('rttov_nwp_end_t', data = data_1month[:, 39].astype(numpy.double))\n\t\t\thfile.create_dataset('rttov_nwp_end_coef', data = data_1month[:, 40].astype(numpy.float))\n\t\t\thfile.create_dataset('crtm_bt1', data = data_1month[:, 26].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt2', data = data_1month[:, 27].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt3', data = data_1month[:, 28].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt4', data = data_1month[:, 29].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt5', data = data_1month[:, 30].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt6', data = data_1month[:, 31].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt7', data = data_1month[:, 32].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt8', data = data_1month[:, 33].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt9', data = data_1month[:, 34].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt10', data = data_1month[:, 35].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt11', data = data_1month[:, 36].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt12', data = data_1month[:, 37].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt13', data = data_1month[:, 38].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt14', data = data_1month[:, 39].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_bt15', data = data_1month[:, 40].astype(numpy.int))\n\t\t\thfile.create_dataset('crtm_nwp_begin_t', data = data_1month[:, 41].astype(numpy.double))\n\t\t\thfile.create_dataset('crtm_nwp_begin_coef', data = data_1month[:, 42].astype(numpy.float))\n\t\t\thfile.create_dataset('crtm_nwp_end_t', data = data_1month[:, 43].astype(numpy.double))\n\t\t\thfile.create_dataset('crtm_nwp_end_coef', data = data_1month[:, 44].astype(numpy.float))\n\t\t\t\n\t\t\t\n\t\t\thfile.close()\n\t\t\t\n\t\t\n\t\t\n\t\t\n\t\t#cur.execute(begin_sql_3day)\n\t\tbegin_data = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\t# do NOT exit in thread!! To avoid zombie process.\n\t\t#print sql_3day\n\t\t#print \"------------------\"\n\t\t#print sql_1month\n\t\t#print \"------------------\"\n\t\t#print sql_3day_calc\n\t\t#print \"------------------\"\n\t\t#print sql_1month_calc\n\t\t#print \"------------------\"\n\t\t#print begin_sql_3day\n\t\t#print \"------------------\"\n\t\tmsg = '??draw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1] \n\t\tprint msg\t\t\t \n\t\tcommon.err(my_log, log_tag, inputdate + msg)\n\t\treturn False\n\t\n \n   \n\n\t\n\t\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_obc", "data": "def draw_obc():\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "main", "data": "def main():\n\t#global my_channel_table\n\t#global my_Calc_channel_table\n\t#global my_obc_table\n\t#global my_Calc_table\n\tglobal Calc_table_1month \n\tglobal obc_table_1month\n\tglobal channel_table_1month\n\tglobal Calc_channel_table_1month\n\tglobal T639\n\t\n\tcommon.wt_file(my_pidfile, str(pid))\n\tcommon.info(my_log, log_tag, inputdate + 'program start')\n\n\t# register signal function.\n\tsignal.signal(signal.SIGTERM, signal_handler)   \n\tsignal.signal(signal.SIGINT, signal_handler)\t  \n\t\n\t# check ps result, kill previous same program, avoiding hang.\n\t# we do NOT grep --date=2014-04-27-18 for convenience.\n\tcmd = conf.ps + ' -elf | ' + conf.grep + ' ' + conf.bin_path + ' | ' \\\n\t\t+ conf.grep + ' -v grep | ' + conf.grep + ' -v tail | ' + conf.grep \\\n\t\t+ ' -v bash | ' + conf.grep + ' ' + fname + ' | ' + conf.grep \\\n\t\t+ \" '\\-\\-sat=\" + sat + \"' | \" + conf.grep + \" '\\-\\-ins=\" + ins \\\n\t\t+ \"' | \" + conf.grep + \" '\\-\\-span=\" + hour_span + \"' | \" \\\n\t\t+ conf.awk + \" '{print $4}'\"\n\t(status, value) = commands.getstatusoutput(cmd)\n\tpid_list = value.split()\n\tfor one_pid in pid_list:\n\t\tif int(one_pid) != pid:\n\t\t\tmsg = 'more then one prog find, kill old same prog[' + one_pid + ']'\n\t\t\tcommon.err(my_log, log_tag, inputdate + msg)\n\t\t\tcmd = conf.kill + ' -kill ' + one_pid\n\t\t\tcommands.getstatusoutput(cmd)\n\t\n\t#get the correct tables. we MUST get table name from INFO db, not show tables!!\n\t\"\"\"\n\tWe MUST create fy3b-mwts table's info, for easy time search\n\talso, there is a BUG... ...\n\t\"\"\"\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor()\n\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\n\t\tcur.execute(\"show tables like '%\"+inputdate+\"%';\") # the result is already sorted by ascii.\n\t\t#print \"show tables like '%\"+inputdate+\"%'\"\n\t\tall_tables = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\tmsg = 'Mysql Fatal Error[' + str(e.args[0])+']: '+e.args[1] \n\t\tcommon.err(my_log, log_tag, inputdate + msg)\n\t\tsys.exit(3)\n\t\t\n\t# ignore L1B table.\n\t#print all_tables\n\tall_obc_table = [ x for x in all_tables if 'OBCXX_MS' in x[0] ]\n\tT639=[ x for x in all_tables if '015KM_MS' in x[0] ]\n\tCalc_tag = 'OBCXX_MS_CALC'\n\tCalc_channel_tag='OBCXX_MS_CALC_'\n\t\n\tCalc_table = [ x for x in all_obc_table if Calc_tag in x[0]]\n\tCalc_channel_table=[ x for x in Calc_table if Calc_channel_tag in x[0]]\n\t\n\tCalc_channel_table_1month=Calc_channel_table\n\t\n\tCalc_table =[ x for x in Calc_table if Calc_channel_tag not in x[0]]\n\t\n\tCalc_table_1month=Calc_table\n\t\n\tchannel_tag = 'OBCXX_MS_' + str(ins_conf.channels)\n\tchannel_table = [ x for x in all_obc_table if channel_tag in x[0]]\n\tchannel_table=list(set(channel_table).difference(set(Calc_table)).difference(set(Calc_channel_table)))\n\t\n\tchannel_table_1month=channel_table\n\t\n\tobc_table = list(set(all_obc_table).difference(set(Calc_table)).difference(set(channel_table)).difference(set(Calc_channel_table))) #return in all_obc_table but no in channel_table\n\t#print obc_table\n\t#print \"-------------------------\"\n\t#print Calc_table\n\t#print \"-------------------------\"\n\t#print channel_table\n\t#print \"-------------------------\"\n\t#print Calc_channel_table\n\tobc_table_1month=obc_table\n\t\n\n\n\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tprint \"-------------------------\"\n\tprint obc_table_1month\n\t#print \"-------------------------\"\n\t#print Calc_table_1month\n\t#print \"-------------------------\"\n\t#print channel_table_1month\n\t#print \"-------------------------\"\n\t#print Calc_channel_table_1month\n\t\t\t\t\n\t\t\t\t\n", "description": "\n\tWe MUST create fy3b-mwts table's info, for easy time search\n\talso, there is a BUG... ...\n\t", "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}], [{"term": "def", "name": "systems", "data": "def systems():\n\tyield bulk('Si')\n\tatoms = bulk('Fe')\n\tatoms.set_initial_magnetic_moments([1.0])\n\tyield atoms\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_elk_bulk", "data": "def test_elk_bulk(factory, atoms):\n\tcalc = factory.calc()\n\tatoms.calc = calc\n\tspinpol = atoms.get_initial_magnetic_moments().any()\n\tprops = atoms.get_properties(['energy', 'forces'])\n\tenergy = props['energy']\n\n\t# Need more thorough tests.\n\tif str(atoms.symbols) == 'Si2':\n\t\tassert energy == pytest.approx(-15729.719246, abs=0.1)\n\t\tassert atoms.get_potential_energy() == pytest.approx(energy)\n\n\t# Since this is FileIO we tend to just load everything there is:\n\texpected_props = {\n\t\t'energy', 'free_energy', 'forces', 'ibz_kpoints',\n\t\t'eigenvalues', 'occupations'\n\t}\n\n\tassert expected_props < set(props)\n\n\t# TODO move to unittest based on random numbers\n\t# This really belongs in a test of the calculator method mixin\n\tassert calc.get_fermi_level() == props['fermi_level']\n\tassert calc.get_ibz_k_points() == pytest.approx(props['ibz_kpoints'])\n\tassert calc.get_k_point_weights() == pytest.approx(props['kpoint_weights'])\n\n\tx = slice(None)\n\tassert calc.get_eigenvalues(x, x) == pytest.approx(props['eigenvalues'])\n\tassert calc.get_occupation_numbers(x, x) == pytest.approx(\n\t\tprops['occupations'])\n\tassert calc.get_spin_polarized() == spinpol\n\tassert calc.get_number_of_spins() == 1 + int(spinpol)\n\tassert calc.get_number_of_bands() == props['nbands']\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}], [{"term": "def", "name": "test_turbomole_au13", "data": "def test_turbomole_au13():\n\tsurfaces = [(1, 0, 0), (1, 1, 0), (1, 1, 1)]\n\tlayers = [1, 2, 1]\n\tatoms = FaceCenteredCubic('Au', surfaces, layers, latticeconstant=4.08)\n\n\tparams = {\n\t\t'title': 'Au13-',\n\t\t'task': 'energy',\n\t\t'basis set name': 'def2-SV(P)',\n\t\t'total charge': -1,\n\t\t'multiplicity': 1,\n\t\t'use dft': True,\n\t\t'density functional': 'pbe',\n\t\t'use resolution of identity': True,\n\t\t'ri memory': 1000,\n\t\t'use fermi smearing': True,\n\t\t'fermi initial temperature': 500.,\n\t\t'fermi final temperature': 100.,\n\t\t'fermi annealing factor': 0.9,\n\t\t'fermi homo-lumo gap criterion': 0.09,\n\t\t'fermi stopping criterion': 0.002,\n\t\t'scf energy convergence': 1.e-4,\n\t\t'scf iterations': 250\n\t}\n\n\tcalc = Turbomole(**params)\n\tatoms.calc = calc\n\tcalc.calculate(atoms)\n\n\t# use the get_property() method\n\tassert np.isclose(calc.get_property('energy'), -48044.567169, atol=1e-4)\n\tdipole = calc.get_property('dipole')\n\tdipole_ref = [1.68659890e-09, 1.17584764e-09, -1.45238506e-09]\n\tassert np.allclose(dipole, dipole_ref, rtol=0.01)\n\n\t# test restart\n\n\tparams = {\n\t\t'task': 'gradient',\n\t\t'scf energy convergence': 1.e-6\n\t}\n\n\tcalc = Turbomole(restart=True, **params)\n\tassert calc.converged\n\tcalc.calculate()\n\n\tassert np.isclose(calc.get_property('energy'), -48044.567179, atol=1e-5)\n\tforce = np.linalg.norm(calc.get_property('forces'))\n\tforce_ref = 0.27110367946343794\n\tassert np.isclose(force, force_ref, rtol=0.01)\n\tdipole = calc.get_property('dipole')\n\tdipole_ref = [5.97945377e-09, 2.72637920e-09, -3.68399945e-09]\n\tassert np.allclose(dipole, dipole_ref, rtol=0.01)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.cluster.cubic import FaceCenteredCubic", "from ase.calculators.turbomole import Turbomole"]}], [{"term": "def", "name": "run", "data": "def run(atoms):\n\tatoms.get_forces()\n\tprint(sorted(atoms.calc.results))\n\tfor key, value in atoms.calc.results.items():\n\t\tif isinstance(value, np.ndarray):\n\t\t\tprint(key, value.shape, value.dtype)\n\t\telse:\n\t\t\tprint(key, value)\n\n\tfor name in required_quantities:\n\t\tassert name in atoms.calc.results\n\n\treturn atoms.calc.results\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_si", "data": "def test_si(factory):\n\tatoms = bulk('Si')\n\tatoms.calc = factory.calc(nbands=4 * len(atoms), kpts=[4, 4, 4])\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_au", "data": "def test_au(factory, pps):\n\tatoms = bulk('Au')\n\tatoms.calc = factory.calc(\n\t\tpps=pps,\n\t\tnbands=10 * len(atoms),\n\t\ttsmear=0.1,\n\t\toccopt=3,\n\t\tkpts=[2, 2, 2],\n\t\tpawecutdg=6.0 * Hartree,\n\t)\n\t# Somewhat awkward to set pawecutdg also when we are not doing paw,\n\t# but it's an error to pass None as pawecutdg.\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "fe_atoms", "data": "def fe_atoms(abinit_factory):\n\tatoms = bulk('Fe')\n\tatoms.set_initial_magnetic_moments([1])\n\tcalc = abinit_factory.calc(nbands=8,\n\t\t\t\t\t\t\t   kpts=[2, 2, 2])\n\tatoms.calc = calc\n\treturn atoms\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_fe_fixed_magmom", "data": "def test_fe_fixed_magmom(fe_atoms):\n\tfe_atoms.calc.set(spinmagntarget=2.3)\n\trun(fe_atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_fe_any_magmom", "data": "def test_fe_any_magmom(fe_atoms):\n\tfe_atoms.calc.set(occopt=7)\n\trun(fe_atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_h2o", "data": "def test_h2o(factory):\n\tatoms = molecule('H2O', vacuum=2.5)\n\tatoms.calc = factory.calc(nbands=8)\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_o2", "data": "def test_o2(factory):\n\tatoms = molecule('O2', vacuum=2.5)\n\tatoms.calc = factory.calc(nbands=8, occopt=7)\n\trun(atoms)\n\tmagmom = atoms.get_magnetic_moment()\n\tassert magmom == pytest.approx(2, 1e-2)\n\tprint('magmom', magmom)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_manykpts", "data": "def test_manykpts(factory):\n\tatoms = bulk('Au') * (2, 2, 2)\n\tatoms.rattle(stdev=0.01)\n\tatoms.symbols[:2] = 'Cu'\n\tatoms.calc = factory.calc(nbands=len(atoms) * 7, kpts=[8, 8, 8])\n\trun(atoms, 'manykpts')\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_manyatoms", "data": "def test_manyatoms(factory):\n\tatoms = bulk('Ne', cubic=True) * (4, 2, 2)\n\tatoms.rattle(stdev=0.01)\n\tatoms.calc = factory.calc(nbands=len(atoms) * 5)\n\trun(atoms, 'manyatoms')\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "get_health", "data": "def get_health(_hit_dice, f):\n\thd = hit_dice_regex.findall(_hit_dice.lower())\n\tdice = []\n\tnums = []\n\tfor i in hd:\n\t\tif 'd' in i:\n\t\t\tdie = i.split('d')\n\t\t\tif die[0] in ('', '+', '-'):\n\t\t\t\tdie[0] = die[0] + '1'\n\t\t\tdice.append(list(map(int, die)))\n\t\telse:\n\t\t\tnums.append(int(i))\n\tnums.extend(f(dice))\n\tprint('The monster has ' + str(sum(nums)) + ' hit points.')\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "calc_average_health", "data": "def calc_average_health(dice):  # 1/2 die value rounded down for every roll\n\treturn list(map(__calc_average_health, dice))\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "__calc_average_health", "data": "def __calc_average_health(die):\n\tavg_health = math.floor((die[1] / 2) * die[0])\n\treturn avg_health\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "calc_max", "data": "def calc_max(dice):  # Max die value for every roll.\n\treturn list(map(__calc_max, dice))\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "__calc_max", "data": "def __calc_max(die):\n\tmax_health = die[0] * die[1]\n\treturn max_health\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "calc_min", "data": "def calc_min(dice):  # Min die value for every roll.\n\treturn list(map(__calc_min, dice))\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "__calc_min", "data": "def __calc_min(die):\n\tmin_health = die[0]\n\treturn min_health\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "calc_pc_average", "data": "def calc_pc_average(dice):  # Max die value for first HD, 1/2 die value rounded down for every other roll.\n\treturn __calc_pc_rules(dice, calc_average_health)\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "__calc_pc_rules", "data": "def __calc_pc_rules(dice, f):\n\tavg_pc = [dice[0][1]]\n\tdice[0][0] -= 1\n\tavg_pc.append(sum(f(dice)))\n\treturn avg_pc\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "calc_pc_roll_health", "data": "def calc_pc_roll_health(dice):  # Max die value for first HD, randomly rolled for every other roll.\n\treturn __calc_pc_rules(dice, calc_random_health)\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "calc_pc_suggested_health", "data": "def calc_pc_suggested_health(dice):  # Max die value for first HD, (1/2)+1 die value rounded down for every other roll.\n\treturn __calc_pc_rules(dice, calc_suggested_health)\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "calc_random_health", "data": "def calc_random_health(dice):  # Random rolls.\n\treturn list(map(__calc_random_health, dice))\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "__calc_random_health", "data": "def __calc_random_health(die):\n\trand = random.randint(1, die[1])\n\treturn rand\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "calc_suggested_health", "data": "def calc_suggested_health(dice):  # (1/2)+1 die value rounded down for every roll.\n\treturn list(map(__calc_suggested_health, dice))\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}, {"term": "def", "name": "__calc_suggested_health", "data": "def __calc_suggested_health(die):\n\tsuggested_health = math.floor((((die[1]) / 2) + 1) * die[0])\n\treturn suggested_health\n\n", "description": null, "category": "math", "imports": ["import math", "import random", "import re"]}], [{"term": "class", "name": "Test", "data": "class Test(unittest.TestCase):\n\tdef test_get_statistic(self):\n\t\tself.assertEqual(gridpp.get_statistic(\"mean\"), gridpp.Mean)\n\t\tself.assertEqual(gridpp.get_statistic(\"min\"), gridpp.Min)\n\t\tself.assertEqual(gridpp.get_statistic(\"max\"), gridpp.Max)\n\t\tself.assertEqual(gridpp.get_statistic(\"median\"), gridpp.Median)\n\t\tself.assertEqual(gridpp.get_statistic(\"quantile\"), gridpp.Quantile)\n\t\tself.assertEqual(gridpp.get_statistic(\"std\"), gridpp.Std)\n\t\tself.assertEqual(gridpp.get_statistic(\"sum\"), gridpp.Sum)\n\n\tdef test_unknown_statistic(self):\n\t\tself.assertEqual(gridpp.get_statistic(\"mean1\"), gridpp.Unknown)\n\n\t\"\"\" Check that it doesn't cause any errors \"\"\"\n\tdef test_version(self):\n\t\tgridpp.version()\n\n\tdef test_clock(self):\n\t\ttime = gridpp.clock()\n\t\tself.assertTrue(time > 0)\n\n\tdef test_is_valid(self):\n\t\tself.assertTrue(gridpp.is_valid(1))\n\t\tself.assertTrue(gridpp.is_valid(-1))\n\t\tself.assertTrue(gridpp.is_valid(-999))  # Check that the old missing value indicator is valid now\n\t\tself.assertFalse(gridpp.is_valid(np.nan))\n\n\tdef test_calc_statistic_mean(self):\n\t\tself.assertEqual(gridpp.calc_statistic([0, 1, 2], gridpp.Mean), 1)\n\t\tself.assertEqual(gridpp.calc_statistic([0, 1, np.nan], gridpp.Mean), 0.5)\n\t\tself.assertEqual(gridpp.calc_statistic([np.nan, 1, np.nan], gridpp.Mean), 1)\n\t\tself.assertTrue(np.isnan(gridpp.calc_statistic([np.nan, np.nan, np.nan], gridpp.Mean)))\n\t\tself.assertTrue(np.isnan(gridpp.calc_statistic([], gridpp.Mean)))\n\n\tdef test_calc_statistic_count(self):\n\t\tself.assertEqual(gridpp.calc_statistic([0, 1, 2], gridpp.Count), 3)\n\t\tself.assertEqual(gridpp.calc_statistic([0, 1, np.nan], gridpp.Count), 2)\n\t\tself.assertEqual(gridpp.calc_statistic([np.nan, 1, np.nan], gridpp.Count), 1)\n\t\tself.assertEqual(gridpp.calc_statistic([np.nan, np.nan, np.nan], gridpp.Count), 0)\n\t\tself.assertEqual(gridpp.calc_statistic([], gridpp.Count), 0)\n\n\tdef test_calc_statistic_sum(self):\n\t\tself.assertEqual(gridpp.calc_statistic([0, 1, 2], gridpp.Sum), 3)\n\t\tself.assertEqual(gridpp.calc_statistic([0, 1, np.nan], gridpp.Sum), 1)\n\t\tself.assertEqual(gridpp.calc_statistic([np.nan, 1, np.nan], gridpp.Sum), 1)\n\t\tself.assertTrue(np.isnan(gridpp.calc_statistic([np.nan, np.nan, np.nan], gridpp.Sum)))\n\t\tself.assertTrue(np.isnan(gridpp.calc_statistic([], gridpp.Sum)))\n\n\tdef test_calc_quantile(self):\n\t\tself.assertTrue(np.isnan(gridpp.calc_quantile([], 0)))\n\t\tself.assertEqual(gridpp.calc_quantile([0, 1, 2], 0), 0)\n\t\tself.assertEqual(gridpp.calc_quantile([0, 1, 2], 0.5), 1)\n\t\tself.assertEqual(gridpp.calc_quantile([0, 1, 2], 1), 2)\n\t\tself.assertEqual(gridpp.calc_quantile([0, np.nan, 2], 1), 2)\n\t\tself.assertEqual(gridpp.calc_quantile([0, np.nan, 2], 0), 0)\n\t\tself.assertEqual(gridpp.calc_quantile([0, np.nan, 2], 0.5), 1)\n\t\tfor quantile in [0, 0.5, 1]:\n\t\t\tself.assertTrue(np.isnan(gridpp.calc_quantile([np.nan, np.nan, np.nan], quantile)))\n\t\t\tself.assertTrue(np.isnan(gridpp.calc_quantile([np.nan], quantile)))\n\t\t# BUG: This should work:\n\t\t# self.assertTrue(np.isnan(gridpp.calc_quantile([], 0.5)))\n\n\t\tself.assertEqual(gridpp.calc_quantile([[0, 1, 2]], 0), [0])\n\t\tself.assertEqual(gridpp.calc_quantile([[0, 1, 2]], 0.5), [1])\n\t\tself.assertEqual(gridpp.calc_quantile([[0, 1, 2]], 1), [2])\n\t\tself.assertEqual(gridpp.calc_quantile([[0, np.nan, 2]], 1), [2])\n\t\tself.assertEqual(gridpp.calc_quantile([[0, np.nan, 2]], 0), [0])\n\t\tself.assertEqual(gridpp.calc_quantile([[0, np.nan, 2]], 0.5), [1])\n\t\tquantile_of_nan_list = gridpp.calc_quantile([[np.nan, np.nan, np.nan]], 0.5)\n\t\tself.assertEqual(len(quantile_of_nan_list), 1)\n\t\tself.assertTrue(np.isnan(quantile_of_nan_list[0]))\n\n\tdef test_calc_quantile_invalid_argument(self):\n\t\tquantiles = [1.1, -0.1]\n\t\tfor quantile in quantiles:\n\t\t\twith self.assertRaises(Exception) as e:\n\t\t\t\tgridpp.calc_quantile([0, 1, 2], quantile)\n\t\tself.assertTrue(np.isnan(gridpp.calc_quantile([0, 1, 2], np.nan)))\n\n\tdef test_num_missing_values(self):\n\t\tself.assertEqual(gridpp.num_missing_values([[0, np.nan, 1, np.nan]]), 2)\n\t\tself.assertEqual(gridpp.num_missing_values([[np.nan, np.nan]]), 2)\n\t\tself.assertEqual(gridpp.num_missing_values([[0, 0, 1, 1]]), 0)\n\t\tself.assertEqual(gridpp.num_missing_values([[0, np.nan], [1, np.nan]]), 2)\n\t\tself.assertEqual(gridpp.num_missing_values([[np.nan, np.nan], [np.nan, np.nan]]), 4)\n\t\tself.assertEqual(gridpp.num_missing_values([[0, 0], [1, 1]]), 0)\n\t\tself.assertEqual(gridpp.num_missing_values([[]]), 0)\n\n\tdef test_calc_statistics_2d(self):\n\t\tvalues = np.reshape(np.arange(9), [3, 3])\n\t\toutput = gridpp.calc_statistic(values, gridpp.Mean)\n\t\tnp.testing.assert_array_almost_equal(output, [1, 4, 7])\n\n\tdef test_warning(self):\n\t\tgridpp.warning(\"test\")\n\n\tdef test_error(self):\n\t\twith self.assertRaises(Exception) as e:\n\t\t\tgridpp.error(\"test\")\n\n\tdef test_not_implemented_error(self):\n\t\twith self.assertRaises(Exception) as e:\n\t\t\tgridpp.not_implemented_error(\"test\")\n\n\tdef test_get_index(self):\n\t\tself.assertEqual(2, gridpp.get_lower_index(1, [0, 0, 1, 1]))\n\t\tself.assertEqual(3, gridpp.get_upper_index(1, [0, 0, 1, 1]))\n\t\tself.assertEqual(0, gridpp.get_lower_index(0, [0, 0, 1, 1]))\n\t\tself.assertEqual(1, gridpp.get_upper_index(0, [0, 0, 1, 1]))\n\tdef test_compatible_size_grid_vec2(self):\n\t\tlons, lats = np.meshgrid([0, 10, 20, 30], [30, 40, 50])\n\t\tgrid = gridpp.Grid(lats, lons)  # 3 x 4\n\t\tself.assertFalse(gridpp.compatible_size(grid, np.zeros([2, 4])))\n\t\tself.assertTrue(gridpp.compatible_size(grid, np.zeros([3, 4])))\n\n\tdef test_compatible_size_grid_vec3(self):\n\t\tlons, lats = np.meshgrid([0, 10, 20, 30], [30, 40, 50])\n\t\tgrid = gridpp.Grid(lats, lons)  # 3 x 4\n\t\tself.assertFalse(gridpp.compatible_size(grid, np.zeros([3, 2, 4])))\n\t\tself.assertTrue(gridpp.compatible_size(grid, np.zeros([3, 3, 4])))\n\n\tdef test_compatible_size_points_vec(self):\n\t\tpoints = gridpp.Points([0, 1, 2], [0, 1, 2])\n\t\tself.assertTrue(gridpp.compatible_size(points, [0, 0, 0]))\n\n\tdef test_compatible_size_points_vec2(self):\n\t\tpoints = gridpp.Points([0, 1, 2], [0, 1, 2])\n\t\tself.assertTrue(gridpp.compatible_size(points, np.zeros([1, 3])))\n\t\tself.assertTrue(gridpp.compatible_size(points, np.zeros([2, 3])))\n\n", "description": " Check that it doesn't cause any errors ", "category": "math", "imports": ["from __future__ import print_function", "import unittest", "import gridpp", "import numpy as np"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "calc", "data": "def calc(v):\n\tdef _inner_calc(val='='):\n\t\tif val == '=':\n\t\t\treturn _inner_calc.res\n\t\tif(val == '+') or (val == '-'):\n\t\t\t_inner_calc.op = val\n\t\telse:\n\t\t\tif(_inner_calc.op == '+'):\n\t\t\t\t_inner_calc.res += int(val)\n\t\t\telse:\n\t\t\t\t_inner_calc.res -= int(val)\n\t\treturn _inner_calc\n\tif(v == '+') or (v == '-'):\n\t\t_inner_calc.res = 0\n\t\t_inner_calc.op = v\n\telse:\n\t\t_inner_calc.res = int(v)\n\treturn _inner_calc\n\n", "description": null, "category": "math", "imports": []}, {"term": "def", "name": "calculator", "data": "def calculator(v):\n\tdef _inner_calc(val='='):\n\t\tif val == '=':\n\t\t\treturn parseCalculation(_inner_calc.v)\n\t\t_inner_calc.v += val\n\t\treturn _inner_calc\n\t_inner_calc.v = v  # save value\n\treturn _inner_calc\n", "description": null, "category": "math", "imports": []}, {"term": "def", "name": "parseCalculation", "data": "def parseCalculation(s):\n\tres = 0\n\top = '+'\n\tfor x in s:\n\t\tif(x == '+') or (x == '-'):\n\t\t\top = x\n\t\telse:\n\t\t\tif(op == '+'):\n\t\t\t\tres += int(x)\n\t\t\telse:\n\t\t\t\tres -= int(x)\n\treturn res\n", "description": null, "category": "math", "imports": []}], [{"term": "def", "name": "calcContainer", "data": "def calcContainer(parent=None):\n\tfrm = Frame(parent)\n\tfrm.pack(expand=YES, fill=BOTH)\n\tLabel(frm, text='Calc Container').pack(side=TOP)\n\tCalcGui(frm)\n\tLabel(frm, text='Calc Container').pack(side=BOTTOM)\n\treturn frm\n", "description": null, "category": "math", "imports": ["from tkinter import *", "from calculator import CalcGui", "\timport sys"]}, {"term": "class", "name": "calcSubclass", "data": "class calcSubclass(CalcGui):\n\tdef makeWidgets(self, fg, bg, font):\n\t\tLabel(self, text='Calc Subclass').pack(side=TOP)\n\t\tLabel(self, text='Calc Subclass').pack(side=BOTTOM)\n\t\tCalcGui.makeWidgets(self, fg, bg, font)\n\t\t#Label(self, text='Calc Subclass').pack(side=BOTTOM)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "from calculator import CalcGui", "\timport sys"]}], [{"term": "def", "name": "test_h2dft_old", "data": "def test_h2dft_old(name):\n\tfactory = ObsoleteFactoryWrapper(name)\n\trun(factory)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "test_h2dft", "data": "def test_h2dft(factory):\n\trun(factory)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "run", "data": "def run(factory):\n\tname = factory.name\n\tcalc = factory.calc(label=name, xc='LDA')\n\th2 = molecule('H2', calculator=calc)\n\th2.center(vacuum=2.0)\n\te2 = h2.get_potential_energy()\n\tcalc.set(xc='PBE')\n\te2pbe = h2.get_potential_energy()\n\th1 = h2.copy()\n\tdel h1[1]\n\th1.set_initial_magnetic_moments([1])\n\th1.calc = calc\n\te1pbe = h1.get_potential_energy()\n\tcalc.set(xc='LDA')\n\te1 = h1.get_potential_energy()\n\ttry:\n\t\tm1 = h1.get_magnetic_moment()\n\texcept NotImplementedError:\n\t\tpass\n\telse:\n\t\tprint(m1)\n\tprint(2 * e1 - e2)\n\tprint(2 * e1pbe - e2pbe)\n\tprint(e1, e2, e1pbe, e2pbe)\n\tcalc = factory.calc(restart=name)\n\tprint(calc.parameters, calc.results, calc.atoms)\n\tassert not calc.calculation_required(h1, ['energy'])\n\th1 = calc.get_atoms()\n\tprint(h1.get_potential_energy())\n\tlabel = 'dir/' + name + '-h1'\n\tcalc = factory.calc(label=label, atoms=h1, xc='LDA')\n\tprint(h1.get_potential_energy())\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}], [{"term": "class", "name": "classCalculatorInputs:", "data": "class CalculatorInputs:\n\tdef __init__(self, name, parameters=None):\n\t\tself.name = name\n\t\tif parameters is None:\n\t\t\tparameters = {}\n\t\tself.parameters = parameters\n\n\tdef __repr__(self):\n\t\tcls = type(self)\n\t\treturn '{}({}, {})'.format(cls.__name__,\n\t\t\t\t\t\t\t\t   self.name, self.parameters)\n\n\tdef calc(self):\n\t\tcls = get_calculator_class(self.name)\n\t\treturn cls(**self.parameters)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.calculators.calculator import get_calculator_class", "from ase.units import Ry", "from ase.utils import workdir"]}, {"term": "def", "name": "inputs", "data": "def inputs(name, **parameters):\n\treturn CalculatorInputs(name, parameters)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.calculators.calculator import get_calculator_class", "from ase.units import Ry", "from ase.utils import workdir"]}, {"term": "def", "name": "_calculate", "data": "def _calculate(code, name):\n\tatoms = molecule(name)\n\tatoms.center(vacuum=3.5)\n\twith workdir('test-{}'.format(name), mkdir=True):\n\t\tatoms.calc = code.calc()\n\t\treturn atoms.get_potential_energy()\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.calculators.calculator import get_calculator_class", "from ase.units import Ry", "from ase.utils import workdir"]}, {"term": "def", "name": "test_ch4", "data": "def test_ch4(tmp_path, spec):\n\t# XXX Convert to string since pytest can sometimes gives us tmp_path\n\t# as a pathlib2 path.\n\twith workdir(str(tmp_path), mkdir=True):\n\t\te_ch4 = _calculate(spec, 'CH4')\n\t\te_c2h2 = _calculate(spec, 'C2H2')\n\t\te_h2 = _calculate(spec, 'H2')\n\t\tenergy = e_ch4 - 0.5 * e_c2h2 - 1.5 * e_h2\n\t\tprint(energy)\n\t\tref_energy = -2.8\n\t\tassert abs(energy - ref_energy) < 0.3\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.calculators.calculator import get_calculator_class", "from ase.units import Ry", "from ase.utils import workdir"]}, {"term": "def", "name": "test_ch4_reaction", "data": "def test_ch4_reaction(factory):\n\te_ch4 = _calculate(factory, 'CH4')\n\te_c2h2 = _calculate(factory, 'C2H2')\n\te_h2 = _calculate(factory, 'H2')\n\tenergy = e_ch4 - 0.5 * e_c2h2 - 1.5 * e_h2\n\tprint(energy)\n\tref_energy = -2.8\n\tassert abs(energy - ref_energy) < 0.3\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.calculators.calculator import get_calculator_class", "from ase.units import Ry", "from ase.utils import workdir"]}], [{"term": "def", "name": "lobby", "data": "def lobby(calc, zapros=None, args1=None, args2=None, args3=None, argvtest=None,\n\t\t  uberargs=None):\n\t# \u043d\u0430\u0447\u0430\u043b\u043e \u0445\u044b\n\thelpme = \"\"\"\u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u044d\u0442\u043e\u0439 \u043f\u0440\u0435\u043a\u0440\u0430\u0441\u043d\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b:\n\t\t\t \u2022  \u041e\u0447\u0438\u0441\u0442\u0438\u0442\u044c | clear\n\t\t\t \u2022  \u041a\u0430\u043b\u044c\u043a\u0443\u043b\u044f\u0442\u043e\u0440 | calc\n\t\t\t \u2022  \u0428\u0430\u043d\u0441\u044b\n\t\t\t \u2022  \u0414\u0430\u0442\u0430 | data\n\t\t\t \u2022  \u0427\u0438\u0441\u043b\u043e\n\t\t\t \u2022  \u0423\u0434\u0430\u043b\u0438\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435\n\t\t\t \u2022  \u0420\u0430\u0431\u043e\u0442\u0430 | job\n\t\t\t \u2022  \u041f\u0440\u043e\u0444\u0438\u043b\u044c\n\t\t\t \u2022  \u041c\u0430\u0433\u0430\u0437\u0438\u043d\n\t\t\t \u2022  \u0423\u0440\u043e\u0432\u0435\u043d\u044c\n\t\t\t \u2022  \u041f\u043e\u0433\u043e\u0434\u0430\n\t\t\t \u2022  \u041a\u0443\u0440\u0441\n\t\t\t \u2022  \u0425\u0435\u043b\u043f\n\t\t\t \u2022  \u0411\u043e\u043c\u0431\u0430\n\t\t\t \u2022  \u041f\u0440\u0435\u0444\u0438\u043a\u0441\n\t\t\t \u2022  \u041c\u043e\u043d\u0435\u0442\u0430\n\t\t\t \u2022  \u041a\u043e\u043d\u0444\u0438\u0433\n\t\t\t\t(\u0432\u0441\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u044e\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0440\u0438 \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \"\u0412\u044b\u0445\u043e\u0434\"!) \"\"\"\n\ttry:\n\t\tif not zapros:\n\t\t\tprint(\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439,\", calc.name)\n\t\t\ttime.sleep(1)\n\t\t\tprint(helpme)\n\n\t\twhile True:\n\t\t\tif zapros == None:\n\t\t\t\tenter = input(\"{}, \u0432\u0430\u0448 \u0437\u0430\u043f\u0440\u043e\u0441: \".format(calc.name))\n\t\t\t\tenter = enter.lower()\n\t\t\t\targs1 = None\n\t\t\t\targs2 = None\n\t\t\t\targs3 = None\n\t\t\t\tuberargs = None\n\t\t\t\tif not enter:\n\t\t\t\t\tcontinue\n\t\t\t\tzapros = enter.split()[0]\n\t\t\t\ttry:\n\t\t\t\t\tuberargs = enter.split()[1:]\n\t\t\t\t\tuberargs = \" \".join(uberargs)\n\t\t\t\t\targs1 = enter.split()[1]\n\t\t\t\t\targs2 = enter.split()[2]\n\t\t\t\t\targs3 = enter.split()[3]\n\t\t\t\texcept IndexError:\n\t\t\t\t\tNone\n\t\t\tif zapros == \"\u043a\u0430\u043b\u044c\u043a\u0443\u043b\u044f\u0442\u043e\u0440\" or zapros == \"calc\":\n\t\t\t\tcalc.calcc(args1, args2, args3)\n\t\t\telif zapros == \"\u0448\u0430\u043d\u0441\u044b\":\n\t\t\t\tcalc.chance(uberargs)\n\t\t\telif zapros == \"\u0434\u0430\u0442\u0430\" or zapros == \"data\":\n\t\t\t\tcalc.date(args1)\n\t\t\telif zapros == \"\u0447\u0438\u0441\u043b\u043e\":\n\t\t\t\tcalc.randomn(args1, args2)\n\t\t\telif zapros == \"\u0443\u0434\u0430\u043b\u0438\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435\":\n\t\t\t\tdelete()\n\t\t\telif zapros == \"\u0440\u0430\u0431\u043e\u0442\u0430\" or zapros == \"job\":\n\t\t\t\tcalc.jobmain()\n\t\t\telif zapros == \"\u043f\u0440\u043e\u0444\u0438\u043b\u044c\":\n\t\t\t\tcalc.profile()\n\t\t\telif zapros == \"\u043c\u0430\u0433\u0430\u0437\u0438\u043d\" or zapros == \"shop\":\n\t\t\t\tcalc.shopping()\n\t\t\telif zapros == \"\u0443\u0440\u043e\u0432\u0435\u043d\u044c\" or zapros == \"lvl\":\n\t\t\t\tcalc.levelup()\n\t\t\telif zapros == \"\u043f\u043e\u0433\u043e\u0434\u0430\" or zapros == \"weather\":\n\t\t\t\tcalc.weather(args1)\n\t\t\telif zapros == \"\u043a\u0443\u0440\u0441\":\n\t\t\t\tcalc.valute()\n\t\t\telif zapros == \"\u0443\u0434\u0430\u0447\u0430\":\n\t\t\t\tcalc.luck()\n\t\t\telif zapros == \"\u043e\u0447\u0438\u0441\u0442\u0438\u0442\u044c\" or zapros == \"clear\":\n\t\t\t\tclrclear()\n\t\t\telif zapros == \"\u0445\u0435\u043b\u043f\" or zapros == \"help\":\n\t\t\t\tprint(helpme)\n\t\t\telif zapros == \"\u043c\u0430\u0439\u043d\u043a\u0440\u0430\u0444\u0442\":\n\t\t\t\tcalc.secret()\n\t\t\telif zapros == \"\u0431\u043e\u043c\u0431\u0430\":\n\t\t\t\tcalc.bomb()\n\t\t\telif zapros == \"\u0432\u044b\u0445\u043e\u0434\" or zapros == \"exit\":\n\t\t\t\texit(calc)\n\t\t\telif zapros == \"\u043f\u0440\u0435\u0444\u0438\u043a\u0441\":\n\t\t\t\tcalc.prefix(uberargs)\n\t\t\telif zapros == \"\u043c\u043e\u043d\u0435\u0442\u0430\":\n\t\t\t\tcalc.orelireshka()\n\t\t\telif zapros == \"\u043a\u043e\u043d\u0444\u0438\u0433\":\n\t\t\t\tprint(\"\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e \u0432\u044b\u0440\u0435\u0437\u0430\u043b \u0438\u0437 \u043a\u0430\u043b\u044c\u043a\u0443\u043b\u044f\u0442\u043e\u0440\u0430\")\n\t\t\telse:\n\t\t\t\tprint(\"\u041d\u0435 \u043f\u043e\u043d\u0438\u043c\u0430\u044e!\")\n\t\t\tif argvtest:\n\t\t\t\tsys.exit()\n\t\t\tzapros = None\n", "description": "\u0424\u0443\u043d\u043a\u0446\u0438\u0438 \u044d\u0442\u043e\u0439 \u043f\u0440\u0435\u043a\u0440\u0430\u0441\u043d\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b:\n\t\t\t \u2022  \u041e\u0447\u0438\u0441\u0442\u0438\u0442\u044c | clear\n\t\t\t \u2022  \u041a\u0430\u043b\u044c\u043a\u0443\u043b\u044f\u0442\u043e\u0440 | calc\n\t\t\t \u2022  \u0428\u0430\u043d\u0441\u044b\n\t\t\t \u2022  \u0414\u0430\u0442\u0430 | data\n\t\t\t \u2022  \u0427\u0438\u0441\u043b\u043e\n\t\t\t \u2022  \u0423\u0434\u0430\u043b\u0438\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435\n\t\t\t \u2022  \u0420\u0430\u0431\u043e\u0442\u0430 | job\n\t\t\t \u2022  \u041f\u0440\u043e\u0444\u0438\u043b\u044c\n\t\t\t \u2022  \u041c\u0430\u0433\u0430\u0437\u0438\u043d\n\t\t\t \u2022  \u0423\u0440\u043e\u0432\u0435\u043d\u044c\n\t\t\t \u2022  \u041f\u043e\u0433\u043e\u0434\u0430\n\t\t\t \u2022  \u041a\u0443\u0440\u0441\n\t\t\t \u2022  \u0425\u0435\u043b\u043f\n\t\t\t \u2022  \u0411\u043e\u043c\u0431\u0430\n\t\t\t \u2022  \u041f\u0440\u0435\u0444\u0438\u043a\u0441\n\t\t\t \u2022  \u041c\u043e\u043d\u0435\u0442\u0430\n\t\t\t \u2022  \u041a\u043e\u043d\u0444\u0438\u0433\n\t\t\t\t(\u0432\u0441\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u044e\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0440\u0438 \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u044b \"\u0412\u044b\u0445\u043e\u0434\"!) ", "category": "math", "imports": ["import shelve", "import sys", "import os.path", "from util import *", "from economy import Main", "from economygame import Main"]}, {"term": "def", "name": "run", "data": "def run():\n\tif sys.platform == \"win32\":\n\t\tmemory = os.path.isfile(\"log.dat\")\n\telse:\n\t\tmemory = os.path.isfile(\"log\")\n\tjsontest = os.path.isfile(\"log.json\")\n\tif all([memory, jsontest]):\n\t\twith shelve.open(\"log\") as stat:\n\t\t\tcalc = stat[\"\u043a\u0430\u043b\u043a\"]\n\t\twith open(\"log.json\", \"r\") as stat:\n\t\t\tsetting = json.load(stat)\n\telse:\n\t\tcalc = Main()\n\t\tsetting = {\"timesleep\": 1}\n\t\twith open(\"log.json\", \"w\") as stat:\n\t\t\tjson.dump(setting, stat)\n\t\tcalc.login()\n\t\twith shelve.open(\"log\") as stat:\n\t\t\tstat[\"\u043a\u0430\u043b\u043a\"] = calc\n\t\tprint(calc.name + \", \u043d\u0430\u0448 \u0430\u0433\u0435\u043d\u0442 \u0444\u0441\u0431 \u0443\u0436\u0435 \u0432\u044b\u0441\u043b\u0430\u043d \u043a \u0432\u0430\u043c \")\n\tkey = None\n\targs1 = None\n\targs2 = None\n\targs3 = None\n\targvtest = False\n\tuberargs = None\n\ttry:\n\t\tuberargs = sys.argv[1:]\n\t\tuberargs = \" \".join(uberargs)\n\t\tkey = sys.argv[1]\n\t\targs1 = sys.argv[2]\n\t\targs2 = sys.argv[3]\n\t\targs3 = sys.argv[4]\n\texcept IndexError:\n\t\tNone\n\tif key == os.path.basename(__file__):\n\t\tkey = None\n\tif key:\n\t\targvtest = True\n\tlobby(calc, key, args1, args2, args3, argvtest, uberargs)\n\n", "description": null, "category": "math", "imports": ["import shelve", "import sys", "import os.path", "from util import *", "from economy import Main", "from economygame import Main"]}], [], [], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\r\n\tudB.del_key(\"calc\")\r\n\tif e.client._bot:\r\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\r\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\r\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\r\n\tawait e.delete()\r\n\r\n", "description": null, "category": "math", "imports": ["import re\r", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\r"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\r\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\r\n\tawait e.answer([calc])\r\n\r\n", "description": null, "category": "math", "imports": ["import re\r", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\r"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\r\n\tx = (e.data_match.group(1)).decode()\r\n\tuser = e.query.user_id\r\n\tget = None\r\n\tif x == \"AC\":\r\n\t\tif CALC.get(user):\r\n\t\t\tCALC.pop(user)\r\n\t\tawait e.edit(\r\n\t\t\tget_string(\"calc_1\"),\r\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\r\n\t\t)\r\n\telif x == \"C\":\r\n\t\tif CALC.get(user):\r\n\t\t\tCALC.pop(user)\r\n\t\tawait e.answer(\"cleared\")\r\n\telif x == \"\u232b\":\r\n\t\tif CALC.get(user):\r\n\t\t\tget = CALC[user]\r\n\t\tif get:\r\n\t\t\tCALC.update({user: get[:-1]})\r\n\t\t\tawait e.answer(str(get[:-1]))\r\n\telif x == \"%\":\r\n\t\tif CALC.get(user):\r\n\t\t\tget = CALC[user]\r\n\t\tif get:\r\n\t\t\tCALC.update({user: get + \"/100\"})\r\n\t\t\tawait e.answer(str(get + \"/100\"))\r\n\telif x == \"\u00f7\":\r\n\t\tif CALC.get(user):\r\n\t\t\tget = CALC[user]\r\n\t\tif get:\r\n\t\t\tCALC.update({user: get + \"/\"})\r\n\t\t\tawait e.answer(str(get + \"/\"))\r\n\telif x == \"x\":\r\n\t\tif CALC.get(user):\r\n\t\t\tget = CALC[user]\r\n\t\tif get:\r\n\t\t\tCALC.update({user: get + \"*\"})\r\n\t\t\tawait e.answer(str(get + \"*\"))\r\n\telif x == \"=\":\r\n\t\tif CALC.get(user):\r\n\t\t\tget = CALC[user]\r\n\t\tif get:\r\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\r\n\t\t\t\tget = get[:-1]\r\n\t\t\tout = eval(get)\r\n\t\t\ttry:\r\n\t\t\t\tnum = float(out)\r\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\r\n\t\t\texcept BaseException:\r\n\t\t\t\tCALC.pop(user)\r\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\r\n\t\tawait e.answer(\"None\")\r\n\telse:\r\n\t\tif CALC.get(user):\r\n\t\t\tget = CALC[user]\r\n\t\tif get:\r\n\t\t\tCALC.update({user: get + x})\r\n\t\t\treturn await e.answer(str(get + x))\r\n\t\tCALC.update({user: x})\r\n\t\tawait e.answer(str(x))\r\n\r\n", "description": null, "category": "math", "imports": ["import re\r", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\r"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\r\n\tm = [\r\n\t\t\"AC\",\r\n\t\t\"C\",\r\n\t\t\"\u232b\",\r\n\t\t\"%\",\r\n\t\t\"7\",\r\n\t\t\"8\",\r\n\t\t\"9\",\r\n\t\t\"+\",\r\n\t\t\"4\",\r\n\t\t\"5\",\r\n\t\t\"6\",\r\n\t\t\"-\",\r\n\t\t\"1\",\r\n\t\t\"2\",\r\n\t\t\"3\",\r\n\t\t\"x\",\r\n\t\t\"00\",\r\n\t\t\"0\",\r\n\t\t\".\",\r\n\t\t\"\u00f7\",\r\n\t]\r\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\r\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\r\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\r\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst) #null\r\n", "description": null, "category": "math", "imports": ["import re\r", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd\r"]}], [{"term": "class", "name": "stat_calc", "data": "class stat_calc():\n\tdef hp_calculator(calc_HP, calc_IV, calc_EV, calc_Level):\n\t\tcalc_total = ((2 * calc_HP + calc_IV + (calc_EV / 4)) * calc_Level/100) + calc_Level + 10\n\t\treturn calc_total\n\t\n\tdef attack_calculator(calc_Attack, calc_IV, calc_EV, calc_Level, calc_nature):\n\t\tif calc_nature > 0 or calc_nature < 5:\n\t\t\tnature_stat = 1.1\n\t\telif calc_nature == 5 or calc_nature == 10 or calc_nature == 15 or calc_nature == 20:\n\t\t\tnature_stat = 0.9\n\t\telse :\n\t\t\tnature_stat = 1\n\t\tcalc_total = (((2 * calc_Attack + calc_IV + (calc_EV / 4)) * calc_Level / 100) + 5) * nature_stat\n\t\treturn calc_total\n\n\tdef defense_calculator(calc_defense, calc_IV, calc_EV, calc_Level, calc_nature):\n\t\tif calc_nature == 5 or calc_nature == 7 or calc_nature == 8 or calc_nature == 9:\n\t\t\tnature_stat = 1.1\n\t\telif calc_nature == 1 or calc_nature == 11 or calc_nature == 16 or calc_nature == 21:\n\t\t\tnature_stat = 0.9\n\t\telse :\n\t\t\tnature_stat = 1\n\t\tcalc_total = (((2 * calc_defense + calc_IV + (calc_EV / 4)) * calc_Level / 100) + 5) * nature_stat\n\t\treturn calc_total\n\n\tdef SpAttack_calculator(calc_SpAttack, calc_IV, calc_EV, calc_Level, calc_nature):\n\t\tif calc_nature == 15 or calc_nature == 16 or calc_nature == 17 or calc_nature == 19:\n\t\t\tnature_stat = 1.1\n\t\telif calc_nature == 3 or calc_nature == 8 or calc_nature == 13 or calc_nature == 23:\n\t\t\tnature_stat = 0.9\n\t\telse :\n\t\t\tnature_stat = 1\n\t\tcalc_total = (((2 * calc_SpAttack + calc_IV + (calc_EV / 4)) * calc_Level / 100) + 5) * nature_stat\n\t\treturn calc_total\n\t\n\tdef SpDefense_calculator(calc_SpDefense, calc_IV, calc_EV, calc_Level, calc_nature):\n\t\tif calc_nature == 20 or calc_nature == 21 or calc_nature == 22 or calc_nature == 23:\n\t\t\tnature_stat = 1.1\n\t\telif calc_nature == 4 or calc_nature == 9 or calc_nature == 14 or calc_nature == 19:\n\t\t\tnature_stat = 0.9\n\t\telse :\n\t\t\tnature_stat = 1\n\t\tcalc_total = (((2 * calc_SpDefense + calc_IV + (calc_EV / 4)) * calc_Level / 100) + 5) * nature_stat\n\t\treturn calc_total\n\n\tdef Speed_calculator(calc_Speed, calc_IV, calc_EV, calc_Level, calc_nature):\n\t\tif calc_nature == 10 or calc_nature == 11 or calc_nature == 13 or calc_nature == 14:\n\t\t\tnature_stat = 1.1\n\t\telif calc_nature == 2 or calc_nature == 7 or calc_nature == 17 or calc_nature == 22:\n\t\t\tnature_stat = 0.9\n\t\telse :\n\t\t\tnature_stat = 1\n\t\tcalc_total = (((2 * calc_Speed + calc_IV + (calc_EV / 4)) * calc_Level / 100) + 5) * nature_stat\n", "description": null, "category": "math", "imports": ["from sympy import Ordinal"]}], [{"term": "class", "name": "Test_tmp", "data": "class Test_tmp(unittest.TestCase):\n\tdef setUp(self):\n\t\tpass\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "class", "name": "Test_r1_linear_comb", "data": "class Test_r1_linear_comb(unittest.TestCase):\n\tdef setUp(self):\n\t\tpass\n\n\tdef test_size(self):\n\n\t\tfor (m, fs) in zip([1, 2], [LC_STOs(), LC_GTOs()]): \n\t\t\tfs.add(1.1, 2, 1.3-0.2j)\n\t\t\tfs.add(0.1, 1, 1.2-0.2j)\n\t\t\tfs.add(0.2, 3, 1.4-0.1j)\n\t\t\tself.assertEqual(3, fs.size())\n\n\tdef test_getter(self):\n\t\tfor (m, fs) in zip([1, 2], [LC_STOs(), LC_GTOs()]): \n\t\t\tfs.add(1.1, 2, 1.3-0.2j)\n\t\t\tfs.add(0.1, 1, 1.2-0.2j)\n\t\t\tfs.add(0.2, 3, 1.4-0.1j)\n\t\t\tself.assertAlmostEqual(1.1, fs.c(0))\n\t\t\tself.assertAlmostEqual(1.2-0.2j, fs.z(1))\n\t\t\tself.assertEqual(3, fs.n(2))\n\t\t\n\tdef test_conj(self):\n\t\t\n\t\tr = 1.4\n\t\tc0 = 1.1; n0 = 1; z0 = 0.35; \n\t\tc1 = 1.2; n1 = 2; z1 = 0.3; \n\n\t\tfor (m, fs) in zip([1,2], [LC_STOs(), LC_GTOs()]): \n\t\t\tfs.add(c0, n0, z0)\n\t\t\tfs.add(c1, n1, z1)\n\t\t\ty = fs.at_r([r])[0]\n\t\t\tself.assertAlmostEqual(y,\n\t\t\t\t\t\t\t\t   c0 * r**n0 * np.exp(-z0**m)+\n\t\t\t\t\t\t\t\t   c1 * r**n1 * np.exp(-z1**m))\n\n\tdef test_clone(self):\n\t\t\n\t\tr = 1.4\n\t\tc0 = 1.1; n0 = 1; z0 = 0.35; \n\t\tc1 = 1.2; n1 = 2; z1 = 0.3; \n\n\t\tfor (m, fs) in zip([1,2], [LC_STOs(), LC_GTOs()]): \n\t\t\tfs.add(c0, n0, z0)\n\t\t\tfs.add(c1, n1, z1)\n\t\t\t\n\t\t\tfs2 = fs.clone()\n\t\t\tfs.add(1.1, 2, 3.3)\n\t\t\tself.assertEqual(2, fs2.size())\n\n\tdef test_conj(self):\n\t\t\n\t\tr = 1.4\n\t\tc0 = 1.1; n0 = 1; z0 = 0.35; \n\t\tc1 = 1.2; n1 = 2; z1 = 0.3; \n\n\t\tfor (m, fs) in zip([1,2], [LC_STOs(), LC_GTOs()]): \n\t\t\tfs.add(c0, n0, z0)\n\t\t\tfs.add(c1, n1, z1)\n\t\t\tc_fs = fs.conj()\n\t\t\ty = fs.at_r([r])[0]\n\t\t\tcy= c_fs.at_r([r])[0]\n\t\t\tself.assertAlmostEqual(y.conjugate(), cy)\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "class", "name": "Test_gto", "data": "class Test_gto(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tgtos = GTOs()\n\t\tgtos.add(1, 1.1)\n\t\tgtos.add(2, 1.4)\n\t\tgtos.add(3, [1.2, 1.3-0.1j])\n\n\t\tg1 = LC_GTOs()\n\t\tg1.add(1.1, 5, 1.3)\n\t\tg1.add(0.1, 6, 1.4)\n\t\tgtos.add(g1)\n\n\t\tgtos.setup()\n\t\tself.gtos = gtos\n\n\t\tr = Symbol('r')\n\t\tself.r = r\n\t\tfs = [r**1*exp(-1.1*r**2),\n\t\t\t  r**2*exp(-1.4*r**2),\n\t\t\t  r**3*exp(-1.2*r**2),\n\t\t\t  r**3*exp(-(1.3-0.1j)*r**2),\n\t\t\t  1.1*r**5*exp(-1.3*r**2)+0.1*r**6*exp(-1.4*r**2)]\n\t\tself.fs = fs\n\t\t\"\"\"\n\t\tfs = [lambda r: r\t * np.exp(-1.1*r*r),\n\t\t\t  lambda r: r*r   * np.exp(-1.4*r*r),\n\t\t\t  lambda r: r*r*r * np.exp(-1.2*r*r),\n\t\t\t  lambda r: r*r*r * np.exp(-(1.3-0.1j)*r*r),\n\t\t\t  lambda r: 1.1*r**5*np.exp(-1.3*r*r) + \n\t\t\t  0.1*r**6*np.exp(-1.4*r*r)]\n\t\tself.fs = fs\n\t\t\"\"\"\n\t\n\tdef test_size(self):\n\n\t\tgtos = self.gtos\n\t\tself.assertEqual(5, gtos.size())\n\t\tself.assertFalse(gtos.is_prim_all())\n\n\t\tgtos = GTOs()\n\t\tgtos.add(2, 1.1)\n\t\tgtos.add(2, 1.1)\n\t\tgtos.add(3, [1.2, 1.3-0.1j])\n\t\tgtos.setup()\n\t\tself.assertEqual(4, gtos.size())\n\t\tself.assertTrue(gtos.is_prim_all())\n\n\tdef test_accessor(self):\n\n\t\tgtos = self.gtos\n\t\tself.assertEqual(2, gtos.basis(1).n(0))\n\t\tself.assertEqual(6, gtos.basis(4).n(1))\n\t\tbasis_i = gtos.basis(0).clone()\n\t\tbasis_i.set_z(0, 1.3)\n\t\tgtos.replace(0, basis_i)\n\t\tself.assertAlmostEqual(1.3, gtos.basis(0).z(0))\n\t\t\n\tdef test_clone(self):\n\t\tg = self.gtos.clone()\n\t\tself.gtos.add(2, 3.0)\n\t\tself.gtos.add(2, 3.0)\n\t\tself.gtos.add(2, 3.0)\n\t\tself.assertEqual(5, g.size())\n\n\tdef test_conj(self):\n\t\tcg = self.gtos.conj()\n\t\tself.assertAlmostEqual(1.3+0.1j, cg.basis(3).z(0))\n\t\t\n\tdef _test_raise(self):\n\t\tg = GTOs()\n\t\tg.add(2, 1.1)\n\t\tself.assertRaises(RuntimeError, calc_rm_mat(g, 0, g))\n\n\tdef test_at_r(self):\n\t\tn1 = 2; z1 = 1.0\n\t\tn2 = 2; z2 = 1.5\n\t\t\n\t\tg = GTOs()\n\t\tg.add(n1, z1)\n\t\tg.add(n2, z2)\n\t\tg.setup()\n\t\t\n\t\tc1 = g.basis(0).c(0)\n\t\tc2 = g.basis(1).c(0)\n\t\t\n\t\td1 = 1.1\n\t\td2 = 1.2\n\t\t\n\t\tr = 2.5\n\n\t\tself.assertAlmostEqual(d1*c1*(r**n1)*np.exp(-z1*r*r)+\n\t\t\t\t\t\t\t   d2*c2*(r**n2)*np.exp(-z2*r*r),\n\t\t\t\t\t\t\t   g.at_r([r], [d1, d2])[0])\n\t\t\n\tdef test_hydrogen_atom(self):\n\t\tg =  GTOs()\n\t\tg.add(1, [2.5**n for n in range(-5,5)])\n\t\tg.setup()\n\t\ts = calc_rm_mat(g,0,g)\n\t\th = -0.5 * calc_d2_mat(g, g) - calc_rm_mat(g, -1, g)\n\t\t(val,vec) =  eig(h, s)\n\t\tindex = 5\n\t\tene = val[index]\n\t\tc   = vec[:,index]\n\t\tself.assertAlmostEqual(-0.5, val[5], places=3)\n\n\t\t## normalization\n\t\tnterm = 1.0/np.sqrt(np.dot(c, np.dot(s, c)))\n\t\tc1 = -nterm * c\n\t\tr0 = 2.5\n\t\ty_calc = g.at_r([r0], c1)[0]\n\t\ty_ref  = 2.0 * r0 * np.exp(-r0)\n\t\tself.assertAlmostEqual(y_ref, y_calc, places=4)\n\n\tdef test_hydrogen_atom_p(self):\n\t\tg =  GTOs()\n\t\tg.add(2, [2.5**n for n in range(-5,5)])\n\t\tg.setup()\n\t\ts = calc_rm_mat(g, 0, g)\n\t\th = -0.5 * calc_d2_mat(g,g) + calc_rm_mat(g,-2,g) - calc_rm_mat(g,-1,g)\n\t\t(val,vec) =  eig(h, s)\n\t\tself.assertAlmostEqual(-0.125, val[6], places=3)\n", "description": "\n\t\tfs = [lambda r: r\t * np.exp(-1.1*r*r),\n\t\t\t  lambda r: r*r   * np.exp(-1.4*r*r),\n\t\t\t  lambda r: r*r*r * np.exp(-1.2*r*r),\n\t\t\t  lambda r: r*r*r * np.exp(-(1.3-0.1j)*r*r),\n\t\t\t  lambda r: 1.1*r**5*np.exp(-1.3*r*r) + \n\t\t\t  0.1*r**6*np.exp(-1.4*r*r)]\n\t\tself.fs = fs\n\t\t", "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "class", "name": "Test_sto", "data": "class Test_sto(unittest.TestCase):\n\tdef setUp(self):\n\t\tpass\n\n\tdef test_accessor(self):\n\t\ts2 = LC_STOs().add(1.2, 2, 1.1).add(1.1, 3, 1.4)\n\t\tfs = STOs().add(1, 2.0).add_not_normal(1.1, 2, 3.0).add(s2).setup()\n\t\tself.assertTrue(fs.is_prim(0))\n\t\tself.assertTrue(fs.is_prim(1))\n\t\tself.assertFalse(fs.is_prim(2))\n\t\t\n\t\tself.assertTrue(fs.has_coef(0))\n\t\tself.assertTrue(fs.has_coef(1))\n\t\tself.assertTrue(fs.has_coef(2))\n\n\t\tself.assertTrue(fs.is_normal(0))\n\t\tself.assertFalse(fs.is_normal(1))\n\t\tself.assertTrue(fs.is_normal(2))\t\t\n\n\t\tfs = STOs().add(2, 1.1)\n\t\tself.assertFalse(fs.has_coef(0))\n\t\t\n\tdef test_int_sto(self):\n\t\tz = 2.3\n\t\tfor n in [0, 1, 3]:\n\t\t\tf = lambda r: r**n * np.exp(-z*r)\n\t\t\tnume, err = quad(f, 0, 15.0)\n\t\t\tself.assertAlmostEqual(nume, sto_int(n, z))\n\n\tdef test_calc_vec(self):\n\n\t\tstos = STOs()\n\t\tstos.add(1, 1.1)\n\t\tstos.add(2, 1.2)\n\t\tstos.setup()\n\n\t\tsto1 = LC_STOs()\n\t\tsto1.add(2.0, 2, 1.0)\n\t\t\n\t\tvec = calc_vec(stos, sto1)\n\t\tself.assertEqual(2, len(vec))\n\n\tdef test_hydrogen(self):\n\t\ts = STOs()\n\t\ts.add(2, 0.5)\n\t\ts.setup()\n\t\t\n\t\th = -0.5 * calc_d2_mat(s,s) + calc_rm_mat(s,-2,s) - calc_rm_mat(s,-1,s)\n\t\tself.assertAlmostEqual(-0.125, h[0,0])\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "class", "name": "Test_matele", "data": "class Test_matele(unittest.TestCase):\n\tdef setUp(self):\n\t\tpass\n\n\tdef test_sto_gto(self):\n\t\tfor n in [0,1,2,3,4,5]:\n\t\t\ts = STOs().add_not_normal(2.0, n, 1.2).setup()\n\t\t\tg = GTOs().add_not_normal(1.1, 0, 1.1).setup()\n\t\t\tele = calc_rm_mat(s, 0, g)[0, 0]\n\t\t\tsg = lambda x: x**n*2.0*1.1*np.exp(-1.2*x-1.1*x*x)\n\t\t\t(ref, err) = quad(sg, 0, 10.0)\n\t\t\tself.assertAlmostEqual(ref, ele)\n\t\n\tdef test_mat(self):\n\t\ts = STOs().add_not_normal(2.0, 3, 1.2-0.3j).setup()\n\t\tg = GTOs().add_not_normal(1.3, 2, 1.1-0.1j).setup()\n\n\t\tr2_s_lc = LC_STOs().add(2.0, 5, 1.2-0.3j)\n\t\tr2_g_lc = LC_GTOs().add(1.3, 4, 1.1-0.1j)\n\t\t\n\t\ts2s_calc = calc_rm_mat(s, 2, s)[0, 0]\n\t\tg2g_calc = calc_rm_mat(g, 2, g)[0, 0]\n\t\tsDs_calc = calc_d2_mat(s, s)[0, 0]\n\t\tgDg_calc = calc_d2_mat(g, g)[0, 0]\n\n\t\ts2s2 = calc_vec(s, r2_s_lc)[0]\n\t\tg2g2 = calc_vec(g, r2_g_lc)[0]\n\n\t\t## see support/int_exp.py\n\t\ts2s_ref = -27.5296456055511 + 37.4411871137165j\n\t\tg2g_ref = 0.16651663387627 + 0.0546850960763247j\n\t\tsDs_ref = -0.526917955926652 - 1.46206690245985j\n\t\tgDg_ref = -0.395454606004856 - 0.0541117842324456j\n\n\t\tself.assertAlmostEqual(s2s_ref, s2s_calc)\n\t\tself.assertAlmostEqual(g2g_ref, g2g_calc)\n\t\tself.assertAlmostEqual(sDs_ref, sDs_calc)\n\t\tself.assertAlmostEqual(gDg_ref, gDg_calc)\n\n\t\tself.assertAlmostEqual(g2g_ref, g2g2)\n\t\tself.assertAlmostEqual(s2s_ref, s2s2)\n\n\tdef test_mat2(self):\n\t\ts = STOs().add_not_normal(2.2, 3, 1.1).setup()\n\t\tg = GTOs().add_not_normal(1.3, 2, 1.2).setup()\n\t\t\n\t\ts2s_calc = calc_rm_mat(s, 2, s)[0, 0]\n\t\tg2g_calc = calc_rm_mat(g, 2, g)[0, 0]\n\t\ts2g_calc = calc_rm_mat(s, 2, g)[0, 0]\n\t\tsDs_calc = calc_d2_mat(s, s)[0, 0]\n\t\tgDg_calc = calc_d2_mat(g, g)[0, 0]\n\t\tsDg_calc = calc_d2_mat(s, g)[0, 0]\n\n\t\t## see support/int_exp.py\n\t\ts2s_ref= 161.644807242673\n\t\tg2g_ref= 0.131127436620057\n\t\ts2g_ref= 0.663645309086432\n\t\tsDs_ref= -3.38091660405710\n\t\tgDg_ref= -0.352470549634713\n\t\tsDg_ref= 0.208872645967760\n\n\t\tself.assertAlmostEqual(s2s_ref, s2s_calc)\n\t\tself.assertAlmostEqual(g2g_ref, g2g_calc)\n\t\tself.assertAlmostEqual(s2g_ref, s2g_calc)\n\t\tself.assertAlmostEqual(sDs_ref, sDs_calc)\n\t\tself.assertAlmostEqual(gDg_ref, gDg_calc)\n\t\tself.assertAlmostEqual(sDg_ref, sDg_calc)\n\t\t\n\tdef test_stv(self):\n\t\ts = STOs().add(3, 1.1).add(2, 0.3-0.1j).setup()\n\t\tdriv = LC_STOs().add(1.1, 2, 1.0)\n\t\topt_green = OptGreen_SSS(driv, s, driv, 1, 1.0)\n\t\topt_green.calc_S0_L00_R0()\n\t\tprint opt_green.L00()\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "def", "name": "test_vartrans", "data": "def test_vartrans(utest, f_xs, var, y0s, label):\n\n\t## -- basic test --\n\tutest.assertEqual(var.Ny, len(y0s))\n\n\t## -- identity test --\n\tx0s = var.xis(y0s)\n\ty0s_2 = var.yks(x0s)\n\tfor i in range(var.Ny):\n\t\tmsg = \"{0},{1},{2},{3}\".format(label,i,y0s_2[i], y0s[i])\n\t\tutest.assertAlmostEqual(y0s_2[i], y0s[i], msg=msg)\n\t\t\n\n\tdf_x0s = ngrad(f_xs, x0s, 0.0001, method='c1')\n\tddf_x0s= nhess(f_xs, x0s, 0.0001, method='c1')\n\n\tf_ys  = lambda ys: f_xs(var.xis(ys))\t\t\n\tdf_y0s = ngrad(f_ys, y0s, 0.0001, method='c1')\n\tddf_y0s= nhess(f_ys, y0s, 0.0001, method='c1')\n\n\t## -- gradient --\n\tref  = df_y0s\n\tcalc = var.dF_dyk(df_x0s, x0s)\n\tfor i in range(var.Ny):\n\t\tmsg = \"i = {0}\\nref  = {1}\\ncalc = {2}\\n\".format(i, ref[i], calc[i])\n\t\tutest.assertAlmostEqual(ref[i], calc[i], msg=msg)\n\n\t## -- hessian --\n\tref  = ddf_y0s\n\tcalc = var.d2F_dykdyl(df_x0s, ddf_x0s, x0s)\n\tfor i in range(var.Ny):\n\t\tfor j in range(var.Ny):\n\t\t\tmsg = \"Hessian transpose test\\n\"\n\t\t\tmsg +=\"label = {0}\\n\".format(label)\n\t\t\tmsg +=\"(i,j) = ({0},{1})\\n\".format(i, j)\n\t\t\tmsg +=\"H(i,j) = {0}\\n\".format(calc[j,i])\n\t\t\tmsg +=\"H(j,i) = {0}\\n\".format(calc[i,j])\t\t\t\n\t\t\tutest.assertAlmostEqual(calc[j,i], calc[i,j], msg=msg)\n\t\t\t\n\t\t\tmsg = \"error on Hessian test\\n\"\n\t\t\tmsg +=\"label = {0}\\n\".format(label)\n\t\t\tmsg +=\"(i,j) = ({0},{1})\\n\".format(i, j)\n\t\t\tmsg +=\"ref  = {0}\\n\".format(ref[i, j])\n\t\t\tmsg +=\"calc = {0}\\n\".format(calc[i,j])\n\t\t\tutest.assertAlmostEqual(ref[i,j], calc[i,j], msg=msg)\n\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "class", "name": "Test_VarTrans", "data": "class Test_VarTrans(unittest.TestCase):\n\tdef setUp(self):\n\t\tpass\n\n\n\n\tdef test_log(self):\n\t\ty0s = [-1.1]\n\t\tvar = VarTransLog()\n\t\tf  = lambda xs: np.sin(2*xs[0])\t\t\n\t\ttest_vartrans(self, f, var, y0s, \"log\")\n\n\tdef test_id(self):\n\t\ty0s = [0.2]\n\t\tvar = VarTransId()\n\t\tf  = lambda xs: np.sin(2*xs[0])\n\t\ttest_vartrans(self, f, var, y0s, \"id\")\n\n\tdef test_shift(self):\n\n\t\ty0s = [0.1]\n\t\ta0s = [0.3, 1.2, 0.1]\n\t\tvar = VarTransShift(a0s)\n\t\tf_xs  = lambda xs: np.sin(xs[0]*xs[1]) + np.exp(xs[1]+xs[2]*xs[0])\n\t\ttest_vartrans(self, f_xs, var, y0s, \"shift\")\n\n\tdef test_scale(self):\n\t\ty0s = [1.1]\n\t\ta0s = [0.3, 1.2, 0.8]\n\t\tvar = VarTransScale(a0s)\n\t\tf_xs  = lambda xs: np.sin(xs[0]*xs[1]) + np.exp(xs[1]+xs[2]*xs[0])\n\t\ttest_vartrans(self, f_xs, var, y0s, \"scale\")\n\n\tdef test_geometric(self):\n\t\t\n\t\tvar = VarTransGeometric(4)\n\t\tf_xs = lambda x: np.sin(x[0]+x[1]) * np.cos(x[2] * x[3])\n\t\ty0s = [0.3, 1.4]\n\t\ttest_vartrans(self, f_xs, var, y0s, \"geometric\")\n\n\tdef test_comb(self):\n\n\t\ta0s = [0.2,0.3]\n\t\ty0s = [1.1, -0.1]\n\t\tvar = VarTransComb([([0,1], VarTransShift(a0s)),\n\t\t\t\t\t\t\t([2],   VarTransLog())])\n\t\tf_xs  = lambda xs: np.sin(xs[0]*xs[1]+xs[2]) * np.exp(xs[1]+xs[2])\n\t\ttest_vartrans(self, f_xs, var, y0s, \"comb1\")\n\n\t\ty0s = [-0.1, 1.1]\n\t\tvar = VarTransComb([([2],   VarTransLog()),\n\t\t\t\t\t\t\t([0,1], VarTransShift(a0s))])\n\t\ttest_vartrans(self, f_xs, var, y0s, \"comb2\")\n\n\tdef test_comb_mid(self):\n\t\ty0s = [-0.2, 1.5, 0.1]\n\t\tvar = VarTransComb([( [0],\t VarTransLog()),\n\t\t\t\t\t\t\t( [1,2,3], VarTransGeometric(3))])\n\t\tf_xs  = lambda xs: np.sin(xs[0]*xs[1]+xs[2]) * np.exp(xs[1]+xs[2]+xs[3])\n\t\ttest_vartrans(self, f_xs, var, y0s, \"comb_mid_2\")\n\t\t\n\t\ty0s = [-0.2, 1.5, 0.1]\n\t\tvar = VarTransComb([([0,1,2], VarTransGeometric(3)),\n\t\t\t\t\t\t\t([3],\t VarTransLog())])\n\t\tf_xs  = lambda xs: np.sin(xs[0]*xs[1]+xs[2]*xs[3]) * np.exp(xs[1]+xs[2]+xs[3])\n\t\ttest_vartrans(self, f_xs, var, y0s, \"comb_mid_1\")\n\t\t\n\t\ty0s = [-0.2, 1.5, 0.1]\n\t\tvar = VarTransComb([([1,2,3], VarTransGeometric(3)),\n\t\t\t\t\t\t\t([0],\t VarTransLog())])\n\t\tf_xs  = lambda xs: np.sin(xs[0]*xs[1]+xs[2]) * np.exp(xs[1]+xs[2]+xs[3])\n\t\ttest_vartrans(self, f_xs, var, y0s, \"comb_mid_2\")\n\n\tdef test_comb_big(self):\n\n\t\tvar = VarTransComb([\n\t\t\t([0,1,2],   VarTransShift([0.2, 0.3, 0.4])),\n\t\t\t([3],\t   VarTransLog()),\n\t\t\t([4],\t   VarTransId() ),\n\t\t\t([5,6,7,8], VarTransGeometric(4))])\n\t\ty0s = [0.01, -0.1, 0.4, 1.1, 1.5]\n\n\t\tf_xs  = lambda xs: (np.sin(sum(xs))\n\t\t\t\t\t\t\t+np.exp(xs[1]+xs[2]*xs[3])\n\t\t\t\t\t\t\t+np.cos(xs[4]+xs[5]*xs[6])\n\t\t\t\t\t\t\t+np.log(xs[7]+xs[8]*xs[0]))\n\t\ttest_vartrans(self, f_xs, var, y0s, \"comb_big\")\n\n\t\t#print var\n\n\tdef test_comb_raise(self):\n\t\ta0s = [0.2,0.3]\n\t\ty0s = [1.1, -0.1]\n\t\tself.assertRaises(lambda : VarTransComb([[0,3], [2]],\n\t\t\t\t\t\t   [VarTransShift(a0s), VarTransLog()]))\n\t\tself.assertRaises(lambda : VarTransComb([[0], [2]],\n\t\t\t\t\t\t   [VarTransShift(a0s), VarTransLog()]))\t\t\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "class", "name": "Test_green", "data": "class Test_green(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tpass\n\n\tdef assertVecAlmostEqual(self, a, b, places=5):\n\t\tself.assertEqual(len(a), len(b))\n\t\tfor i in range(len(a)):\n\t\t\tself.assertAlmostEqual(a[i], b[i], places=places)\n\n\tdef assertVarEqual(self, a, b):\n\t\tself.assertAlmostEqual(a.Nx, b.Nx)\n\t\tself.assertAlmostEqual(a.Ny, b.Ny)\n\t\tyks = [0.1*(i+1)*(i+1) for i in range(a.Ny)]\n\t\txa = a.xis(yks)\n\t\txb = b.xis(yks)\n\t\tfor i in range(a.Ny):\n\t\t\tmsg = \"\"\"\n\t\t\tError on {0}\n\t\t\ta = {1}\n\t\t\tb = {2}\n\t\t\t\"\"\".format(i, a, b)\n\t\t\tself.assertAlmostEqual(xa[i], xb[i], msg = msg)\n\t\t\n\tdef test_alpha(self):\n\n\t\t## from calc/stoh/l_5/res.d\n\t\tss = STOs()\n\n\t\tss.add(2, 0.9965751177-0.0013743026j)\n\t\tss.add(2, 1.0030366528-0.2836728004j)\n\t\tss.add(2, 0.8462928140-0.6952686244j)\n\t\tss.add(2, 0.4818046345-1.0023929406j)\n\t\tss.add(2, 0.1412093744-1.0662761427j)\n\t\tss.setup()\n\n\t\tdriv = LC_STOs()\n\t\tdriv.add(2.0, 2, 1.0)\n\t\t\n\t\tene = 0.5\n\n\t\ts = calc_rm_mat(ss, 0,  ss)\n\t\td2= calc_d2_mat(ss,\t ss)\n\t\tr2= calc_rm_mat(ss, -2, ss)\n\t\tr1= calc_rm_mat(ss, -1, ss)\n\t\tlmat = (  s * ene\n\t\t\t\t  + d2* 0.5\n\t\t\t\t  + r2* (-1.0)\n\t\t\t\t  + r1)\n\t\tmvec = calc_vec(ss, driv)\n\t\tcs = solve(lmat, mvec)\n\t\talpha = np.dot(cs, mvec)\n\t\tw = ene + 0.5\n\t\tref = 1.88562800720386-0.362705406693342j\n\t\tself.assertAlmostEqual(3.0*ref, alpha)\n\n\tdef test_deriv_one(self):\n\n\t\tfor (name, create) in [(\"STO\", STOs), (\"GTO\", GTOs)]:\n\t\t\tn0 = 3\n\t\t\tc0 = [1.1]\n\t\t\tr0 = [2.5]\n\t\t\tz0 = [1.1]\n\t\t\t\n\t\t\tcalc = lambda zs: create().add(3, zs[0]).setup().at_r(r0, c0)[0]\n\n\t\t\tstos = create()\n\t\t\tstos.add(n0, z0)\n\t\t\tstos.setup()\n\t\t\t\n\t\t\tdstos = one_deriv(stos, [True])\n\t\t\tcalc_dy = dstos.at_r(r0, c0)[0]\n\t\t\tref_dy  = num_pd_c1(calc, z0, 0.0001, 0)\t\t\n\t\t\tself.assertAlmostEqual(ref_dy, calc_dy)\n\n\t\t\tddstos = two_deriv(stos, [True])\n\t\t\tcalc_ddy = ddstos.at_r(r0, c0)[0]\n\t\t\tref_ddy  = num_pd2(calc, z0, 0.0001, 0, 0, method=\"c1\")\n\t\t\tmsg = \"Basis={0}, second derivative\\nref = {1}\\ncalc= {2}\\n\".format(name, ref_ddy, calc_ddy)\n\t\t\t\n\t\t\tself.assertAlmostEqual(ref_ddy, calc_ddy, msg=msg)\n\n\tdef test_deriv_three(self):\n\t\tz0 = 0.52\n\t\tr0 = 2.6\n\t\tc0 = 1.2\n\t\t#basis= lambda z: GTOs().add(3, [1.1, z, 3.3]).setup()\n\t\tbasis= lambda z: GTOs().add(3, 1.1).add(3, z).add(4, 3.3).setup()\n\n\t\tds = one_deriv(basis(z0), [False, True, False])\n\t\tself.assertEqual(1, ds.size())\n\n\t\tcalc = lambda z: basis(z).at_r(r0, [0,c0,0])\n\t\tref_dy  = num_pd(calc, [z0], 0.0001, 0, method='c1')\n\t\tcalc_dy = ds.at_r(r0, [c0])\n\t\tself.assertAlmostEqual(ref_dy, calc_dy)\n\t\t\n\tdef test_grad_one(self):\n\t\tz0 = [1.3-0.2j]\n\t\th_pi = H_Photoionization('1s->kp', \"length\")\n\t\tbasis  = STOs().add(2, z0).setup()\n\t\tw = 1.0\n\t\tcalc_green = lambda z: vgh_green_h_pi(h_pi, basis, [True])(w)(z)[0]\n\t\t(val, calc_grad, calc_hess) = vgh_green_h_pi(h_pi, basis, [True])(w)(z0)\n\t\tref_grad = num_pd(calc_green,  z0, 0.0001, 0,\tmethod='c1')\n\t\tref_hess = num_pd2(calc_green, z0, 0.0001, 0, 0, method='c1')\n\t\tself.assertAlmostEqual(calc_grad[0],   ref_grad)\n\t\tself.assertAlmostEqual(calc_hess[0,0], ref_hess, places=6)\n\n\tdef test_opt_index(self):\n\t\tself.assertEqual([],\t get_opt_index([False, False]))\n\t\tself.assertEqual([0, 1], get_opt_index([True, True]))\n\t\tself.assertEqual([1, 3], get_opt_index([False, True, False, True]))\n\t\tself.assertEqual([0, 2], get_opt_index([True, False, True]))\n\n\tdef test_gh_two(self):\n\n\t\tz0 = [1.3-0.2j, 0.5-0.9j]\n\t\topt = [True, True]\n\t\th_pi = H_Photoionization('1s->kp', \"length\")\n\t\tbasis  = STOs().add(2, z0).setup()\n\t\tw = 1.0\n\t\tcalc_green = lambda z: vgh_green_h_pi(h_pi, basis, opt)(w)(z)[0]\n\t\t\n\t\t(val, calc_grad, calc_hess) = vgh_green_h_pi(h_pi, basis, opt)(w)(z0)\n\t\tref_grad = ngrad(calc_green, z0, 0.0001, method='c1')\n\t\tref_hess = nhess(calc_green, z0, 0.0001, method='c1')\n\t\tfor i in range(2):\n\t\t\tself.assertAlmostEqual(ref_grad[i], calc_grad[i])\n\t\t\tfor j in range(2):\n\t\t\t\tself.assertAlmostEqual(ref_hess[i,j],\n\t\t\t\t\t\t\t\t\t   calc_hess[i,j], places=6)\n\t\t\t\t\n\tdef test_gh_two_of_three_easy(self):\n\t\tzs0 = [1.3-0.1j, 2.3-0.5j]\n\t\tz2 = 0.4-0.4j\n\t\topt = [True, True, False]\n\t\th_pi = H_Photoionization('1s->kp', \"velocity\")\n\t\tbasis = STOs().add(2, 1.0).add(2,1.0).add(2,z2).setup()\n\t\tw = 0.9\n\t\t\n\t\tcalc_green = lambda z: vgh_green_h_pi(h_pi, basis, opt)(w)(z)[0]\n\n\t\t(v, calc_g, calc_h) = vgh_green_h_pi(h_pi, basis, opt)(w)(zs0)\n\t\tref_g = ngrad(calc_green, zs0, 0.0001, method='c1')\n\t\tref_h = nhess(calc_green, zs0, 0.0001, method='c1')\n\t\tfor i in range(2):\n\t\t\tself.assertAlmostEqual(ref_g[i], calc_g[i], places=5)\n\t\t\tfor j in range(2):\n\t\t\t\tmsg = \"ref= {0}\\ncalc={1}\\n(i,j)=({2},{3})\".format(ref_h[i,j],calc_h[i,j],i,j)\n\t\t\t\tself.assertAlmostEqual(ref_h[i,j], calc_h[i,j], places=5, msg=msg)\n\n\tdef test_gh_one_of_two(self):\n\t\tzs = [1.3-0.1j, 2.3-0.5j]\n\t\th_pi = H_Photoionization('1s->kp', \"velocity\")\n\t\tbasis = STOs().add(2, zs).setup()\n\t\tw = 1.1\n\n\t\t(v, calc_g, calc_h) = vgh_green_h_pi(h_pi, basis, [False, True])(w)([zs[1]])\n\t\t(v, full_g, full_h) = vgh_green_h_pi(h_pi, basis, [True,  True])(w)(zs)\n\n\t\tself.assertAlmostEqual(full_g[1], calc_g[0], places=5)\n\t\tself.assertAlmostEqual(full_h[1,1], calc_h[0,0], places=5)\n\t\t\t\t\n\tdef test_grad_two_of_three(self):\n\t\topt_zs0 = [1.3-0.1j, 2.3-0.5j]\n\t\tz1 = 0.4-0.4j\n\t\tzs_all = [opt_zs0[0], z1, opt_zs0[1]]\n\t\topt = [True,\t  False,  True]\n\t\th_pi = H_Photoionization('1s->kp', \"velocity\")\n\t\tbasis =  STOs().add(2, 1.0).add(2,z1).add(2, 1.0).setup()\n\t\tw = 1.0\n\t\tcalc_green = lambda z: vgh_green_h_pi(h_pi, basis, opt)(w)(z)[0]\n\n\t\t(v, calc_g, calc_h) = vgh_green_h_pi(h_pi, basis, opt)(w)(opt_zs0)\n\t\t(v, full_g, full_h) = vgh_green_h_pi(h_pi, basis, [True,True,True])(w)(zs_all)\n\t\tref_g = ngrad(calc_green, opt_zs0, 0.0001, method='c1')\n\t\tref_h = nhess(calc_green, opt_zs0, 0.0001, method='c1')\n\n\t\tself.assertAlmostEqual(full_h[0,0], calc_h[0,0], places=5)\n\t\tself.assertAlmostEqual(full_h[0,2], calc_h[0,1], places=5)\n\t\tself.assertAlmostEqual(full_h[2,0], calc_h[1,0], places=5)\n\t\tself.assertAlmostEqual(full_h[2,2], calc_h[1,1], places=5)\n\t\t\n\t\tfor i in range(2):\n\t\t\tself.assertAlmostEqual(ref_g[i], calc_g[i], places=5)\t\t\t\n\t\t\tfor j in range(2):\n\t\t\t\tmsg = \"ref= {0}\\ncalc={1}\\n(i,j)=({2},{3})\".format(ref_h[i,j],calc_h[i,j],i,j)\n\t\t\t\tself.assertAlmostEqual(ref_h[i,j], calc_h[i,j], places=5, msg=msg)\n\n\tdef test_vgh_log(self):\n\t\topt_log_zs0 = [-2.0-0.3j, -1.0-0.1j]\n\t\topt = [True, True]\n\t\th_pi = H_Photoionization('1s->kp', \"velocity\")\n\t\tbasis =  GTOs().add(2, 1.0).add(2, 1.0).setup()\n\t\tw = 1.0\n\n\t\tvgh = vgh_log(vgh_green_h_pi(h_pi, basis, opt))(w)\n\t\tcalc_green = lambda log_zs: vgh(log_zs)[0]\n\n\t\t(v, calc_g, calc_h) = vgh(opt_log_zs0)\n\t\tref_g = ngrad(calc_green, opt_log_zs0, 0.0001, method='c1')\n\t\tref_h = nhess(calc_green, opt_log_zs0, 0.0001, method='c1')\n\n\t\tself.assertAlmostEqual(ref_g[0],   calc_g[0],   places=5)\n\t\tself.assertAlmostEqual(ref_g[1],   calc_g[1],   places=5)\n\t\tself.assertAlmostEqual(ref_h[0,0], calc_h[0,0], places=5)\n\t\tself.assertAlmostEqual(ref_h[0,1], calc_h[0,1], places=5)\t\t\n\t\tself.assertAlmostEqual(ref_h[1,0], calc_h[1,0], places=5)\n\t\tself.assertAlmostEqual(ref_h[1,1], calc_h[1,1], places=5)\n\t\t\n\tdef test_opt_one(self):\n\t\th_pi = H_Photoionization('1s->kp', \"velocity\")\n\t\tz0s = [0.6-0.6j]\n\t\topt = [True for z in z0s]\n\t\tbasis = STOs().add(2, z0s).setup()\n\t\tw = 1.0\n\t\t\n\t\tres = newton(vgh_green_h_pi(h_pi, basis, opt)(w), z0s)\n\n\t\t## see calc/stoh/v_1/res.d\n\t\tself.assertTrue(res.success)\n\t\tself.assertAlmostEqual(1.0255886472-0.6955918398j, res.x[0])\n\t\tself.assertAlmostEqual((0.361600808054165-0.371221793708147j)*3, res.val)\n\n\tdef test_opt_one_log(self):\n\t\t\n\t\th_pi = H_Photoionization('1s->kp', \"velocity\")\n\t\tvar = VarTransComb([([0], VarTransLog())])\n\t\ty0s = [np.log(0.6-0.6j)]\n\t\tx0s = var.xis(y0s)\n\t\topt = [True for z in y0s]\n\t\t\n\t\tw = 1.0\n\t\t\n\t\tbasis = STOs().add(2, x0s[0]).setup()\n\t\tvgh_w_x = vgh_green_h_pi(h_pi, basis, opt)\n\t\tvgh_y = vgh_var(vgh_w_x, var)\n\t\t\n\t\tres = newton(vgh_y(w), y0s)\n\n\t\t## see calc/stoh/v_1/res.d\n\t\tself.assertTrue(res.success)\n\t\tself.assertAlmostEqual(1.0255886472-0.6955918398j, var.xis(res.x)[0])\n\t\tself.assertAlmostEqual((0.361600808054165-0.371221793708147j)*3, res.val)\n\t\n\tdef test_opt_three(self):\n\t\th_pi = H_Photoionization('1s->kp', \"length\")\n\t\tzs_opt = [0.9797019427  -0.0125136315j,\n\t\t\t\t  0.8771210224  -0.6400667900j,\n\t\t\t\t  0.3008012645  -1.0095895471j]\n\t\tz0s = [z0 + 0.01 for z0 in zs_opt]\n\t\topt = [True for z in z0s]\n\t\tbasis = STOs().add(2, z0s).setup()\n\t\tw = 0.9\n\t\tres = newton(vgh_green_h_pi(h_pi, basis, opt)(w),\n\t\t\t\t\t z0s,\n", "description": "\n\t\t\tError on {0}\n\t\t\ta = {1}\n\t\t\tb = {2}\n\t\t\t", "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "def", "name": "ftest_h_pi_read_info", "data": "\tdef test_h_pi_read_info(self):\n\t\tbasis_info = [(\"id\",   True,  2, 0.6-0.4j),\n\t\t\t\t\t  (\"id\",   True,  2, 0.2-0.7j),\n\t\t\t\t\t  (\"log\",  True,  2, np.log(1.1)),\n\t\t\t\t\t  (\"log\",  False, 2, np.log(2.3)),\n\t\t\t\t\t  (\"geo\",  True,  2, 3, 0.1, 2.5),\n\t\t\t\t\t  (\"shift\",True,  2, [0.15, 0.25], 0.1)]\n\n\t\tref_us = (STOs()\n\t\t\t\t  .add(2, 0.6-0.4j)\n\t\t\t\t  .add(2, 0.2-0.7j)\n\t\t\t\t  .add(2, 1.1)\n\t\t\t\t  .add(2, 2.3)\n\t\t\t\t  .add(2, 0.1)\n\t\t\t\t  .add(2, 0.1*2.5)\n\t\t\t\t  .add(2, 0.1*2.5*2.5)\n\t\t\t\t  .add(2, 0.15+0.1)\n\t\t\t\t  .add(2, 0.25+0.1)\n\t\t\t\t  .setup())\n\n\t\tref_var = VarTransComb([ ([0], VarTransId()),\n\t\t\t\t\t\t\t\t ([1], VarTransId()),\n\t\t\t\t\t\t\t\t ([2], VarTransLog()),\n\t\t\t\t\t\t\t\t ([3,4,5], VarTransGeometric(3)),\n\t\t\t\t\t\t\t\t ([6,7], VarTransShift([0.15, 2.5]))])\n\n\t\tref_opt_list = [True, True, True, False,\n\t\t\t\t\t\tTrue, True, True,\n\t\t\t\t\t\tTrue, True]\n\n\t\tref_y0s = [0.6-0.4j, 0.2-0.7j, np.log(1.1), 0.1, 2.5, 0.1]\n\n\t\t(base_us, opt_list, var, y0s) = h_pi_read_info(\"STO\", basis_info)\n\t\tc0 = [0.1 * (i+1) for i in range(ref_us.size())]\n\t\tr0 = [1.1]\n\t\tself.assertAlmostEqual(ref_us.at_r(r0, c0)[0], base_us.at_r(r0, c0)[0])\n\t\tself.assertEqual(ref_opt_list, opt_list)\n\t\tself.assertVecAlmostEqual(ref_y0s, y0s)\n\t\tself.assertVarEqual(ref_var, var)\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "def", "name": "ftest_opt_interface", "data": "\tdef test_opt_interface(self):\n\n\t\topt_main(\n\t\t\tbasis_type = 'STO',\n\t\t\tbasis_info = [(\"id\",   True,  2, 0.6-0.4j)],\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "class", "name": "Test_r1gtos", "data": "class Test_r1gtos(unittest.TestCase):\n\tdef setUp(self):\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "def", "name": "ftest_size", "data": "\tdef test_size(self):\n\t\tself.assertEqual(5, self.gtos.size_prim())\n\t\tself.assertEqual(4, self.gtos.size_basis())\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "def", "name": "ftest_param", "data": "\tdef test_param(self):\n\t\tself.assertEqual(2, self.gtos.n_prim(0))\n\t\tself.assertEqual(3, self.gtos.n_prim(1))\n\t\tself.assertEqual(3, self.gtos.n_prim(2))\n\t\tself.assertEqual(1, self.gtos.n_prim(3))\n\t\tself.assertEqual(4, self.gtos.n_prim(4))\n\n\t\tself.assertEqual(1.1, self.gtos.z_prim(0))\n\t\tself.assertEqual(1.2, self.gtos.z_prim(1))\n\t\tself.assertEqual(1.3-0.1j, self.gtos.z_prim(2))\n\t\tself.assertEqual(1.5, self.gtos.z_prim(3))\n\t\tself.assertEqual(1.4, self.gtos.z_prim(4))\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "def", "name": "ftest_set_conj", "data": "\tdef test_set_conj(self):\n\t\tcg = self.gtos.conj()\n\t\tself.assertAlmostEqual(1.1, cg.z(0))\n\t\tself.assertAlmostEqual(1.3+0.1j, cg.z(2))\n\t\t(s, t, v) = cg.calc_mat_stv(self.gtos, 1)\n\t\tstos = R1STOs(); \n\t\tstos.add(1.1, 2, 1.2)\n\t\tv1 = cg.calc_mat_sto(self.gtos, stos)\n\t\tprint v1\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "def", "name": "ftest_matrix", "data": "\tdef test_matrix(self):\n\t\t(s,t,v) = self.gtos.calc_mat_stv(1)\n\t\tself.assertAlmostEqual(1.0, s[0, 0])\n\t\tself.assertAlmostEqual(1.0, s[1, 1])\n\n\t\ts2 = MatrixXc.Zero(1, 1)\n\t\tt2 = MatrixXc.Zero(1, 1)\n\t\tv2 = MatrixXc.Zero(1, 1)\n\t\tself.gtos.calc_mat_stv(1, s2, t2, v2)\n\t\tself.assertAlmostEqual(t2[0, 1], t[0, 1])\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "def", "name": "ftest_vector", "data": "\tdef test_vector(self):\n\t\tstos = R1STOs()\n\t\tstos.add(1.1, 2, 1.2)\n\t\tstos.add(1.1-0.2j, 3, 1.3)\n\t\tm = self.gtos.calc_vec_sto(stos)\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "def", "name": "ftest_print", "data": "\tdef test_print(self):\n\t\ts = R1STO(1.0, 2, 1.1)\n\t\tprint s\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "def", "name": "ftest_at_r", "data": "\tdef test_at_r(self):\n\t\tgs = R1GTOs()\n\t\tgs.add(2, 1.2)\n\t\tgs.normalize()\n\t\tprint gs.at_r([1.3], [1.1])[0]\n\t\tprint gs.deriv_at_r([1.3], [1.1])[0]\n\t\tprint gs.deriv_2_at_r([1.3], [1.1])[0]\n\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}, {"term": "class", "name": "Test_Opt", "data": "class Test_Opt(unittest.TestCase):\n\tdef setUp(self):\n\t\tpass\n\n\tdef test_opt(self):\n\t\tsto = R1STOs()\n\t\tsto.add(2, 1.1)\n\t\tdriv = DrivSTO(sto)\n\t\t\n\t\top = OpCoulomb(1, 0.5)\n\t\t\n\t\tzs = [0.2-0.1j, 0.8-0.5j]\n\t\tgs = R1GTOs()\n\t\tgs.add(2, zs)\n\t\tgs.normalize()\n\n\t\ttarget = OptAlpha(driv, op, gs)\n\n\t\toptimizer = OptNewton(100, 10.0**(-5), target, 0)\n\t\tres = optimizer.optimize(zs)\n\t\t\n\t\tself.assertTrue(res.conv_q)\n\n\tdef test_opt_partial(self):\n\t\tsto = R1STOs(); sto.add(2, 1.0)\n\t\tdriv = DrivSTO(sto);\n\t\top   = OpCoulomb(1, 0.5)\n\n\t\tzs = [0.2-0.1j, 0.8-0.5j]\n\t\tgs = R1GTOs(); gs.add(2, zs); gs.normalize()\n\t\ttarget = OptAlphaPartial(driv, op, gs, [1])\n\t\t\n\t\toptimizer = OptNewton(100, 10.0**(-5), target, 0)\n\t\tres = optimizer.optimize([zs[1]])\n\t\t\n\t\tself.assertTrue(res.conv_q)\n\n\tdef test_opt_alpha_shift(self):\n\t\tgs = R1GTOs()\n\t\tzs = [0.463925,\n\t\t\t  1.202518,\n\t\t\t  3.379649,\n\t\t\t  10.6072,\n\t\t\t  38.65163,\n\t\t\t  173.5822,\n\t\t\t  1170.498,\n\t\t\t  0.16934112166516593,\n\t\t\t  0.08989389391311804,\n\t\t\t  0.055610873913491725,\n\t\t\t  0.03776599632952126,\n\t\t\t  0.02731159914174668,\n\t\t\t  0.020665855224060142,\n\t\t\t  0.016180602421004654,\n\t\t\t  0.013011569667967734]\n\t\tgs.add(2, zs)\n\t\tgs.normalize()\n\t\t\n\t\tsto = R1STOs()\n\t\tsto.add(2.0, 2, 1.0)\n\t\tdriv = DrivSTO(sto)\n\t\t\n\t\top = OpCoulomb(1, 0.5)\n\n\t\topt_idx = [7, 8, 9, 10, 11, 12, 13, 14];\n\t\ttarget = OptAlphaShift(driv, op, gs, opt_idx)\n\t\toptimizer = OptNewton(100, 10**(-5), target, 0)\n\t\tres = optimizer.optimize(-0.02j)\n\t\t\n\t\tself.assertTrue(res.conv_q)\n\t\tshift_ref = -0.00293368-0.0204361j\n\t\tself.assertAlmostEqual(shift_ref, res.zs[0], places=4);\n\t\talpha_ref = -5.6568937518988989+1.0882823480377297j\n\t\tself.assertAlmostEqual(alpha_ref, res.val)\n", "description": null, "category": "math", "imports": ["import sys", "import numpy as np", "from scipy.integrate import quad", "from scipy.linalg import eig, solve", "from sympy import Symbol, oo, diff, integrate, exp, sqrt", "from r1basis import *", "from opt_green import *", "from nnewton import *", "import unittest"]}], [{"term": "def", "name": "assert_water_is_relaxed", "data": "def assert_water_is_relaxed(atoms):\n\tforces = atoms.get_forces()\n\tassert np.allclose(np.zeros(forces.shape), forces)\n\tassert np.allclose(ref_energy, atoms.get_potential_energy())\n\tassert np.allclose(atoms.get_angle(1, 0, 2), ref_atoms.get_angle(1, 0, 2))\n\tassert np.allclose(atoms.get_distance(0, 1), ref_atoms.get_distance(0, 1))\n\tassert np.allclose(atoms.get_distance(0, 2), ref_atoms.get_distance(0, 2))\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_array_almost_equal", "from ase import Atoms", "from ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator", "from ase.calculators.calculator import CalculatorSetupError, CalculationFailed", "from ase.calculators.emt import EMT", "from ase.optimize import BFGS", "from ase.vibrations import Vibrations", "from ase.units import fs", "import pytest", "\tfrom ase.geometry.geometry import get_distances_derivatives", "\tfrom ase.calculators.mixing import MixedCalculator", "\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,", "\tfrom ase.md.andersen import Andersen"]}, {"term": "def", "name": "run_optimize", "data": "def run_optimize(atoms):\n\topt = BFGS(atoms)\n\topt.run(fmax=1e-9)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_array_almost_equal", "from ase import Atoms", "from ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator", "from ase.calculators.calculator import CalculatorSetupError, CalculationFailed", "from ase.calculators.emt import EMT", "from ase.optimize import BFGS", "from ase.vibrations import Vibrations", "from ase.units import fs", "import pytest", "\tfrom ase.geometry.geometry import get_distances_derivatives", "\tfrom ase.calculators.mixing import MixedCalculator", "\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,", "\tfrom ase.md.andersen import Andersen"]}, {"term": "def", "name": "test_cartesians", "data": "def test_cartesians():\n\t\"\"\"In Cartesian coordinates the first 6 trash eigenvalues (translations and\n\trotations) can be slightly different from zero; hence set them to zero\n\tusing an increased parameter zero_thresh.\n\t\"\"\"\n\tzero_thresh = 0.06  # set eigvals to zero if abs(eigenvalue) < zero_thresh\n\thff = HarmonicForceField(ref_atoms=ref_atoms, ref_energy=ref_energy,\n\t\t\t\t\t\t\t hessian_x=hessian_x, zero_thresh=zero_thresh)\n\tassert np.allclose(hff.hessian_q, hff.hessian_x)\n\tatoms = ref_atoms.copy()\n\tatoms.calc = HarmonicCalculator(hff)\n\tassert_water_is_relaxed(atoms)  # atoms has not been distorted\n\trun_optimize(atoms)\t\t\t # nothing should happen\n\tassert_water_is_relaxed(atoms)  # atoms should still be relaxed\n\tatoms.set_distance(0, 1, 3.5)   # now distort atoms along axis, no rotation\n\trun_optimize(atoms)\t\t\t # optimization should recover original\n\tassert_water_is_relaxed(atoms)\t# relaxed geometry\n\n\twith pytest.raises(AssertionError):\n\t\tatoms.rattle()\t\t\t\t  # relaxation should fail to recover the\n\t\tatoms.rotate(90, 'x')\t\t   # original geometry of the atoms,\n\t\trun_optimize(atoms)\t\t\t # because Cartesian coordinates are\n\t\tassert_water_is_relaxed(atoms)  # not rotationally invariant.\n\n", "description": "In Cartesian coordinates the first 6 trash eigenvalues (translations and\n\trotations) can be slightly different from zero; hence set them to zero\n\tusing an increased parameter zero_thresh.\n\t", "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_array_almost_equal", "from ase import Atoms", "from ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator", "from ase.calculators.calculator import CalculatorSetupError, CalculationFailed", "from ase.calculators.emt import EMT", "from ase.optimize import BFGS", "from ase.vibrations import Vibrations", "from ase.units import fs", "import pytest", "\tfrom ase.geometry.geometry import get_distances_derivatives", "\tfrom ase.calculators.mixing import MixedCalculator", "\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,", "\tfrom ase.md.andersen import Andersen"]}, {"term": "def", "name": "test_constraints_with_cartesians", "data": "def test_constraints_with_cartesians():\n\t\"\"\"Project out forces along x-component of H-atom (index 0 in the q-vector\n\twith the Cartesian coordinates (here: x=q)). A change in the x-component of\n\tthe H-atom should not result in restoring forces, when they were projected\n\tout from the Hessian matrix.\n\t\"\"\"\n\tdef test_forces(calc):\n\t\tatoms = ref_atoms.copy()\n\t\tatoms.calc = calc\n\t\tpos = ref_pos.copy()\n\t\tpos[0, 0] *= 2\n\t\tatoms.set_positions(pos)\n\t\trun_optimize(atoms)  # (no) restoring force along distorted x-component\n\t\txdiff = atoms.get_positions() - ref_pos\n\t\treturn all(xdiff[xdiff != 0] == pos[0, 0] / 2)\n\n\tzero_thresh = 0.06  # set eigvals to zero if abs(eigenvalue) < zero_thresh\n\tparameters = {'ref_atoms': ref_atoms, 'ref_energy': ref_energy,\n\t\t\t\t  'hessian_x': hessian_x, 'zero_thresh': zero_thresh}\n\thff = HarmonicForceField(**parameters)\n\tcalc = HarmonicCalculator(hff)\n\tassert not test_forces(calc)  # restoring force along distorted x-component\n\n\tparameters['constrained_q'] = [0]  # project out the coordinate with index 0\n\thff = HarmonicForceField(**parameters)\n\tcalc = HarmonicCalculator(hff)\n\tassert test_forces(calc)  # no restoring force along distorted x-component\n\n", "description": "Project out forces along x-component of H-atom (index 0 in the q-vector\n\twith the Cartesian coordinates (here: x=q)). A change in the x-component of\n\tthe H-atom should not result in restoring forces, when they were projected\n\tout from the Hessian matrix.\n\t", "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_array_almost_equal", "from ase import Atoms", "from ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator", "from ase.calculators.calculator import CalculatorSetupError, CalculationFailed", "from ase.calculators.emt import EMT", "from ase.optimize import BFGS", "from ase.vibrations import Vibrations", "from ase.units import fs", "import pytest", "\tfrom ase.geometry.geometry import get_distances_derivatives", "\tfrom ase.calculators.mixing import MixedCalculator", "\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,", "\tfrom ase.md.andersen import Andersen"]}, {"term": "def", "name": "setup_water", "data": "def setup_water(calc):\n\tatoms = ref_atoms.copy()\n\tatoms.calc = calc\n\tassert_water_is_relaxed(atoms)\n\tatoms.rattle(0.3)\n\tatoms.rotate(160, 'x')\n\tassert not np.allclose(ref_energy, atoms.get_potential_energy())\n\treturn atoms\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_array_almost_equal", "from ase import Atoms", "from ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator", "from ase.calculators.calculator import CalculatorSetupError, CalculationFailed", "from ase.calculators.emt import EMT", "from ase.optimize import BFGS", "from ase.vibrations import Vibrations", "from ase.units import fs", "import pytest", "\tfrom ase.geometry.geometry import get_distances_derivatives", "\tfrom ase.calculators.mixing import MixedCalculator", "\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,", "\tfrom ase.md.andersen import Andersen"]}, {"term": "def", "name": "water_get_q_from_x", "data": "def water_get_q_from_x(atoms):\n\t\"\"\"Simple internal coordinates to describe water with three distances.\"\"\"\n\tq_vec = [atoms.get_distance(i, j) for i, j in dist_defs]\n\treturn np.asarray(q_vec)\n\n", "description": "Simple internal coordinates to describe water with three distances.", "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_array_almost_equal", "from ase import Atoms", "from ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator", "from ase.calculators.calculator import CalculatorSetupError, CalculationFailed", "from ase.calculators.emt import EMT", "from ase.optimize import BFGS", "from ase.vibrations import Vibrations", "from ase.units import fs", "import pytest", "\tfrom ase.geometry.geometry import get_distances_derivatives", "\tfrom ase.calculators.mixing import MixedCalculator", "\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,", "\tfrom ase.md.andersen import Andersen"]}, {"term": "def", "name": "water_get_jacobian", "data": "def water_get_jacobian(atoms):\n\t\"\"\"Function to return the Jacobian for the water molecule described by\n\tthree distances.\"\"\"\n\tfrom ase.geometry.geometry import get_distances_derivatives\n\tpos = atoms.get_positions()\n\tdist_vecs = [pos[j] - pos[i] for i, j in dist_defs]\n\tderivs = get_distances_derivatives(dist_vecs)\n\tjac = []\n\tfor i, defin in enumerate(dist_defs):\n\t\tdqi_dxj = np.zeros(ref_pos.shape)\n\t\tfor j, deriv in enumerate(derivs[i]):\n\t\t\tdqi_dxj[defin[j]] = deriv\n\t\tjac.append(dqi_dxj.flatten())\n", "description": "Function to return the Jacobian for the water molecule described by\n\tthree distances.", "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_array_almost_equal", "from ase import Atoms", "from ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator", "from ase.calculators.calculator import CalculatorSetupError, CalculationFailed", "from ase.calculators.emt import EMT", "from ase.optimize import BFGS", "from ase.vibrations import Vibrations", "from ase.units import fs", "import pytest", "\tfrom ase.geometry.geometry import get_distances_derivatives", "\tfrom ase.calculators.mixing import MixedCalculator", "\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,", "\tfrom ase.md.andersen import Andersen"]}, {"term": "def", "name": "test_raise_Errors", "data": "def test_raise_Errors():\n\twith pytest.raises(CalculatorSetupError):\n\t\tHarmonicForceField(ref_atoms=ref_atoms, hessian_x=hessian_x,\n\t\t\t\t\t\t   get_q_from_x=lambda x: x)\n\twith pytest.raises(CalculatorSetupError):\n\t\tHarmonicForceField(ref_atoms=ref_atoms, hessian_x=hessian_x,\n\t\t\t\t\t\t   variable_orientation=True)\n\twith pytest.raises(CalculatorSetupError):\n\t\tHarmonicForceField(ref_atoms=ref_atoms, hessian_x=hessian_x,\n\t\t\t\t\t\t   cartesian=False)\n\twith pytest.raises(CalculationFailed):\n\t\thff = HarmonicForceField(ref_atoms=ref_atoms, ref_energy=ref_energy,\n\t\t\t\t\t\t\t\t hessian_x=hessian_x,\n\t\t\t\t\t\t\t\t get_q_from_x=water_get_q_from_x,\n\t\t\t\t\t\t\t\t get_jacobian=lambda x: np.ones((3, 9)),\n\t\t\t\t\t\t\t\t cartesian=True, variable_orientation=True)\n\t\tcalc = HarmonicCalculator(hff)\n\t\tsetup_water(calc)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_array_almost_equal", "from ase import Atoms", "from ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator", "from ase.calculators.calculator import CalculatorSetupError, CalculationFailed", "from ase.calculators.emt import EMT", "from ase.optimize import BFGS", "from ase.vibrations import Vibrations", "from ase.units import fs", "import pytest", "\tfrom ase.geometry.geometry import get_distances_derivatives", "\tfrom ase.calculators.mixing import MixedCalculator", "\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,", "\tfrom ase.md.andersen import Andersen"]}, {"term": "def", "name": "test_internals", "data": "def test_internals():\n\tparameters = {'ref_atoms': ref_atoms, 'ref_energy': ref_energy,\n\t\t\t\t  'hessian_x': hessian_x, 'get_q_from_x': water_get_q_from_x,\n\t\t\t\t  'get_jacobian': water_get_jacobian, 'cartesian': False}\n\thff = HarmonicForceField(**parameters)  # calculation in internals\n\tcalc = HarmonicCalculator(hff)\n\tatoms = setup_water(calc)  # distorted copy of ref_atoms\n\trun_optimize(atoms)\t\t# recover original configuration\n\tassert_water_is_relaxed(atoms)\n\n\tparameters['cartesian'] = True  # calculation in Cartesian Coordinates\n\thff = HarmonicForceField(**parameters)\n\tcalc = HarmonicCalculator(hff)\n\tatoms = setup_water(calc)\t   # 'variable_orientation' not set to True!\n\t# but water has rotational degrees of freedom\n\trun_optimize(atoms)\n\twith pytest.raises(AssertionError):  # hence forces were incorrect\n\t\tassert_water_is_relaxed(atoms)   # original configuration not recovered\n\n\tparameters['variable_orientation'] = True\n\thff = HarmonicForceField(**parameters)\n\tcalc = HarmonicCalculator(hff)\n\tatoms = setup_water(calc)\n\trun_optimize(atoms)\n\tassert_water_is_relaxed(atoms)  # relaxation succeeded despite rotation\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_array_almost_equal", "from ase import Atoms", "from ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator", "from ase.calculators.calculator import CalculatorSetupError, CalculationFailed", "from ase.calculators.emt import EMT", "from ase.optimize import BFGS", "from ase.vibrations import Vibrations", "from ase.units import fs", "import pytest", "\tfrom ase.geometry.geometry import get_distances_derivatives", "\tfrom ase.calculators.mixing import MixedCalculator", "\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,", "\tfrom ase.md.andersen import Andersen"]}, {"term": "def", "name": "test_compatible_with_ase_vibrations", "data": "def test_compatible_with_ase_vibrations():\n\tatoms = ref_atoms.copy()\n\tatoms.calc = EMT()\n\trun_optimize(atoms)\n\topt_atoms = atoms.copy()\n\topt_energy = atoms.get_potential_energy()\n\tvib = Vibrations(atoms, nfree=2)\n\tvib.run()\n\tenergies = vib.get_energies()\n\tvib_data = vib.get_vibrations()\n\thessian_2d = vib_data.get_hessian_2d()\n\tvib.clean()\n\n\thff = HarmonicForceField(ref_atoms=opt_atoms, ref_energy=opt_energy,\n\t\t\t\t\t\t\t hessian_x=hessian_2d)\n\tcalc_harmonic = HarmonicCalculator(hff)\n\tatoms = ref_atoms.copy()\n\tatoms.calc = calc_harmonic\n\tvib = Vibrations(atoms, nfree=4, delta=1e-5)\n\tvib.run()\n\tassert np.allclose(energies, vib.get_energies())\n\tvib.clean()\n\thff = HarmonicForceField(ref_atoms=ref_atoms, ref_energy=ref_energy,\n\t\t\t\t\t\t\t hessian_x=hessian_2d,\n\t\t\t\t\t\t\t get_q_from_x=water_get_q_from_x,\n\t\t\t\t\t\t\t get_jacobian=water_get_jacobian, cartesian=True)\n\tcalc_harmonic = HarmonicCalculator(hff)\n\tatoms = ref_atoms.copy()\n\tatoms.calc = calc_harmonic\n\tvib = Vibrations(atoms, nfree=4, delta=1e-5)\n\tvib.run()  # 3 transl and 3 rot are removed by internal coordinates\n\tassert_array_almost_equal(energies[-3:], vib.get_energies()[-3:], decimal=2)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_array_almost_equal", "from ase import Atoms", "from ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator", "from ase.calculators.calculator import CalculatorSetupError, CalculationFailed", "from ase.calculators.emt import EMT", "from ase.optimize import BFGS", "from ase.vibrations import Vibrations", "from ase.units import fs", "import pytest", "\tfrom ase.geometry.geometry import get_distances_derivatives", "\tfrom ase.calculators.mixing import MixedCalculator", "\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,", "\tfrom ase.md.andersen import Andersen"]}, {"term": "def", "name": "test_thermodynamic_integration", "data": "def test_thermodynamic_integration():\n\tfrom ase.calculators.mixing import MixedCalculator\n\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,\n\t\t\t\t\t\t\t\t\t\t\t Stationary, ZeroRotation)\n\tfrom ase.md.andersen import Andersen\n\tparameters = {'ref_atoms': ref_atoms, 'ref_energy': ref_energy,\n\t\t\t\t  'hessian_x': hessian_x, 'get_q_from_x': water_get_q_from_x,\n\t\t\t\t  'get_jacobian': water_get_jacobian, 'cartesian': True,\n\t\t\t\t  'variable_orientation': True}\n\thff_1 = HarmonicForceField(**parameters)\n\tcalc_harmonic_1 = HarmonicCalculator(hff_1)\n\tparameters['cartesian'] = False\n\thff_0 = HarmonicForceField(**parameters)\n\tcalc_harmonic_0 = HarmonicCalculator(hff_0)\n\tediffs = {}  # collect energy difference for varying lambda coupling\n\tlambs = [0.00, 0.25, 0.50, 0.75, 1.00]  # integration grid\n\tfor lamb in lambs:\n\t\tediffs[lamb] = []\n\t\tcalc_linearCombi = MixedCalculator(calc_harmonic_0, calc_harmonic_1,\n\t\t\t\t\t\t\t\t\t\t   1 - lamb, lamb)\n\t\tatoms = ref_atoms.copy()\n\t\tatoms.calc = calc_linearCombi\n\t\tMaxwellBoltzmannDistribution(atoms, temperature_K=300, force_temp=True)\n\t\tStationary(atoms)\n\t\tZeroRotation(atoms)\n\t\twith Andersen(atoms, 0.5 * fs, temperature_K=300, andersen_prob=0.05,\n\t\t\t\t\t  fixcm=False) as dyn:\n\t\t\tfor _ in dyn.irun(50):  # should be much longer for production runs\n\t\t\t\te0, e1 = calc_linearCombi.get_energy_contributions(atoms)\n\t\t\t\tediffs[lamb].append(float(e1) - float(e0))\n\t\t\tediffs[lamb] = np.mean(ediffs[lamb])\n\tdA = np.trapz([ediffs[lamb] for lamb in lambs], x=lambs)  # anharm. corr.\n\tassert -0.005 < dA < 0.005  # the MD run is to short for convergence\n\tif dA == 0.0:\n\t\traise ValueError('there is most likely something wrong, but it could '\n\t\t\t\t\t\t 'also be sheer coincidence')\n", "description": null, "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_array_almost_equal", "from ase import Atoms", "from ase.calculators.harmonic import HarmonicForceField, HarmonicCalculator", "from ase.calculators.calculator import CalculatorSetupError, CalculationFailed", "from ase.calculators.emt import EMT", "from ase.optimize import BFGS", "from ase.vibrations import Vibrations", "from ase.units import fs", "import pytest", "\tfrom ase.geometry.geometry import get_distances_derivatives", "\tfrom ase.calculators.mixing import MixedCalculator", "\tfrom ase.md.velocitydistribution import (MaxwellBoltzmannDistribution,", "\tfrom ase.md.andersen import Andersen"]}], [{"term": "def", "name": "DEF_RES", "data": "def DEF_RES(basic_RES,RES_Dec = 0,enemy = 93,player = 90):\n\t\"\u9632\u5fa1\u6297\u6027\u4e58\u533a\u8ba1\u7b97\"\n\tRES = basic_RES - RES_Dec\n\tif(RES<=0):\n\t\treturn (100.0+player)/(200.0+enemy+player)*(1-RES/2)\n", "description": null, "category": "math", "imports": ["import buff"]}], [{"term": "def", "name": "system", "data": "def system():\n\treturn bulk('Al', 'fcc', a=4.5, cubic=True)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_net_charge", "data": "def test_vasp_net_charge(factory, system):\n\t\"\"\"\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied net charge (via the deprecated net_charge parameter) works\n\tcorrectly. This is conditional on the existence of the VASP_COMMAND or\n\tVASP_SCRIPT environment variables.\n\n\tThis is mainly a slightly reduced duplicate of the vasp_charge test, but with\n\tflipped signs and with checks that ensure FutureWarning is emitted.\n\n\tShould be removed along with the net_charge parameter itself at some point.\n\t\"\"\"\n\n\t# Dummy calculation to let VASP determine default number of electrons\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False)\n\tcalc.calculate(system)\n\tdefault_nelect_from_vasp = calc.get_number_of_electrons()\n\tassert default_nelect_from_vasp == 12\n\n\t# Compare VASP's output nelect from before + net charge to default nelect\n\t# determined by us + net charge\n\twith pytest.warns(FutureWarning):\n\t\tnet_charge = -2\n\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\tnet_charge=net_charge)\n\t\tcalc.initialize(system)\n\t\tcalc.write_input(system)\n\t\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] == default_nelect_from_vasp + net_charge\n\n\t# Test that conflicts between explicitly given nelect and net charge are\n\t# detected\n\twith pytest.raises(ValueError):\n\t\twith pytest.warns(FutureWarning):\n\t\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\t\tnelect=default_nelect_from_vasp + net_charge +\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tnet_charge=net_charge)\n\t\t\tcalc.calculate(system)\n\n\t# Test that conflicts between charge and net_charge are detected\n\twith pytest.raises(ValueError):\n\t\twith pytest.warns(FutureWarning):\n\t\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\t\tcharge=-net_charge - 1,\n\t\t\t\t\t\t\t\tnet_charge=net_charge)\n\t\t\tcalc.calculate(system)\n\n\t# Test that nothing is written if net charge is 0 and nelect not given\n\twith pytest.warns(FutureWarning):\n\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\tnet_charge=0)\n\t\tcalc.initialize(system)\n\t\tcalc.write_input(system)\n\t\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] is None\n", "description": "\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied net charge (via the deprecated net_charge parameter) works\n\tcorrectly. This is conditional on the existence of the VASP_COMMAND or\n\tVASP_SCRIPT environment variables.\n\n\tThis is mainly a slightly reduced duplicate of the vasp_charge test, but with\n\tflipped signs and with checks that ensure FutureWarning is emitted.\n\n\tShould be removed along with the net_charge parameter itself at some point.\n\t", "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}], [{"term": "def", "name": "testMockFunction", "data": "  def testMockFunction(self):\n\t@MockFunction\n\tdef calc(a, b, mult=1):\n\t  return (a + b) * mult\n\n\tself.assertTrue(*calc.CheckAndReset(0))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 1 call(s), got 0'), calc.CheckAndReset(1))\n\n\tself.assertEqual(20, calc(2, 3, mult=4))\n\tself.assertTrue(*calc.CheckAndReset(1))\n\tself.assertTrue(*calc.CheckAndReset(0))\n\n\tself.assertEqual(20, calc(2, 3, mult=4))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 0 call(s), got 1'), calc.CheckAndReset(0))\n\n\tself.assertEqual(3, calc(1, 2))\n\tself.assertEqual(0, calc(3, 4, mult=0))\n\tself.assertTrue(*calc.CheckAndReset(2))\n\tself.assertTrue(*calc.CheckAndReset(0))\n\n\tself.assertEqual(3, calc(1, 2))\n\tself.assertEqual(0, calc(3, 4, mult=0))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 3 call(s), got 2'), calc.CheckAndReset(3))\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock_function import MockFunction"]}], [{"term": "class", "name": "TestCalc", "data": "class TestCalc(unittest.TestCase):\n\t\n\tdef test_add_valid(self):\n\t\tself.assertEqual(calc.add(10,5),15)\n\t\tself.assertEqual(calc.add(-1,1),0)\n\t\tself.assertEqual(calc.add(-1,-1),-2)\n\n\tdef test_sub_valid(self):\n\t\tself.assertEqual(calc.subtract(10,5),5)\n\t\tself.assertEqual(calc.subtract(-1,1),-2)\n\t\tself.assertEqual(calc.subtract(-1,-1),0)\n\n\tdef test_multiply_valid(self):\n\t\tself.assertEqual(calc.multiply(10,5),50)\n\t\tself.assertEqual(calc.multiply(-1,1),-1)\n\t\tself.assertEqual(calc.multiply(-1,-1),1)\n\n\tdef test_divide_valid(self):\n\t\tself.assertEqual(calc.divide(10,5),2)\n\t\tself.assertEqual(calc.divide(-1,1),-1)\n\t\tself.assertEqual(calc.divide(-1,-1),1)\n\t\tself.assertEqual(calc.divide(5,2),2.5)\n\n\tdef test_divide_exception(self):\n\t\tself.assertRaises(ValueError,calc.divide,10,0)\n\t\twith self.assertRaises(ValueError):\n", "description": null, "category": "math", "imports": ["import unittest", "from unittesting.func import calc"]}], [{"term": "def", "name": "test_calculator_label", "data": "def test_calculator_label():\n\tfrom ase.calculators.calculator import Calculator\n\n\tcalc = Calculator()\n\tassert calc.directory == '.'\n\tassert calc.prefix is None\n\tassert calc.label is None\n\n\tcalc.label = 'dir/pref'\n\tassert calc.directory == 'dir'\n\tassert calc.prefix == 'pref'\n\tassert calc.label == 'dir/pref'\n\n\tcalc.label = 'dir2/'\n\tassert calc.directory == 'dir2'\n\tassert calc.prefix is None\n\tassert calc.label == 'dir2/'\n\n\tcalc.label = 'hello'\n\tassert calc.directory == '.'\n\tassert calc.prefix == 'hello'\n\tassert calc.label == 'hello'\n\n\tcalc.label = None\n\tassert calc.label is None\n\tassert calc.prefix is None\n\tassert calc.directory == '.'\n", "description": null, "category": "math", "imports": ["\tfrom ase.calculators.calculator import Calculator"]}], [{"term": "def", "name": "calc_orrsommerfeld", "data": "def calc_orrsommerfeld(alpha=None,R=None,N=None,*args,**kwargs):\n\tvarargin = calc_orrsommerfeld.varargin\n\tnargin = calc_orrsommerfeld.nargin\n\n\t# Matlab script to find global eigenvalues for Poiseuille flow\n\t\n", "description": null, "category": "math", "imports": ["from smop.core import *", "import numpy as np", "import scipy.linalg", "import matplotlib"]}], [{"term": "def", "name": "test_deolhonoimposto_inicio", "data": "def test_deolhonoimposto_inicio():\n\tcalc = DeOlhoNoImposto()\n\tassert calc.carga_federal().is_zero()\n\tassert calc.carga_federal_nacional().is_zero()\n\tassert calc.carga_federal_importado().is_zero()\n\tassert calc.carga_estadual().is_zero()\n\tassert calc.carga_municipal().is_zero()\n\tassert calc.total_tributos().is_zero()\n\tassert calc.total().is_zero()\n\tassert calc.percentual_sobre_total().is_zero()\n\n", "description": null, "category": "math", "imports": ["from decimal import Decimal", "import pytest", "import requests", "from ibptws.calculadoras import DeOlhoNoImposto", "from ibptws.calculadoras import CEM", "\tassert calc.carga_federal_importado().is_zero()", "\tassert calc.carga_federal_importado() == carga_fed_imp", "\tassert calc.carga_federal_importado().is_zero()", "\t\t\t# importado\t4,8% : 0,24", "\t\t\t# importado   5,41% : 0,83855", "\t\t\t# importado   6,18% : 0,45114", "\t\t\t# importado  14,05% : 14,05", "\t\t\t# importado  14,05% : 80,895685", "\tassert calc.carga_federal_importado() == carga_fed_imp", "\tassert calc.carga_federal_importado().is_zero()"]}, {"term": "def", "name": "test_deolhonoimposto_um_item", "data": "def test_deolhonoimposto_um_item(monkeypatch):\n\tdef mockreturn(endpoint, params={}):\n\t\treturn pytest.instancia_resp_sucesso_produto\n\tmonkeypatch.setattr(requests, 'get', mockreturn)\n\t\n\tvalor = Decimal('10') # subtotal do produto\n\t\n\t# os valores das al\u00edquotas retornadas est\u00e3o em conftest.py\n\tcarga_fed_nac = valor * (Decimal('4.2') / CEM)\n\tcarga_fed_imp = valor * (Decimal('4.8') / CEM)\n\tcarga_estadual = valor * (Decimal('18') / CEM)\n\t\n\tcalc = DeOlhoNoImposto()\n\tcalc.produto('12340101', 0, valor)\n\t\n\tassert calc.total() == valor, 'Total nao confere com o valor do unico item'\n\tassert calc.total() > calc.total_tributos(), 'Soma dos valores dos '\\\n\t\t\t'itens menor ou igual ao valor total dos tributos'\n\t\t\t\n\tassert calc.carga_federal_nacional() == carga_fed_nac\n\tassert calc.carga_federal_importado() == carga_fed_imp\n\tassert calc.carga_federal() == carga_fed_nac + carga_fed_imp\n\tassert calc.carga_estadual() == carga_estadual\n\tassert calc.carga_municipal().is_zero()\n\t\n\tassert calc.total_tributos() == sum([\n\t\t\tcarga_fed_nac, carga_fed_imp, carga_estadual,])\n\t\n\tassert calc.total() == valor\n\t\n\t# testa o reinicio da calculadora\n\tcalc.reiniciar()\n\tassert calc.carga_federal().is_zero()\n\tassert calc.carga_federal_nacional().is_zero()\n\tassert calc.carga_federal_importado().is_zero()\n\tassert calc.carga_estadual().is_zero()\n\tassert calc.carga_municipal().is_zero()\n\tassert calc.total_tributos().is_zero()\n\tassert calc.total().is_zero()\n\tassert calc.percentual_sobre_total().is_zero()\n\n", "description": null, "category": "math", "imports": ["from decimal import Decimal", "import pytest", "import requests", "from ibptws.calculadoras import DeOlhoNoImposto", "from ibptws.calculadoras import CEM", "\tassert calc.carga_federal_importado().is_zero()", "\tassert calc.carga_federal_importado() == carga_fed_imp", "\tassert calc.carga_federal_importado().is_zero()", "\t\t\t# importado\t4,8% : 0,24", "\t\t\t# importado   5,41% : 0,83855", "\t\t\t# importado   6,18% : 0,45114", "\t\t\t# importado  14,05% : 14,05", "\t\t\t# importado  14,05% : 80,895685", "\tassert calc.carga_federal_importado() == carga_fed_imp", "\tassert calc.carga_federal_importado().is_zero()"]}, {"term": "def", "name": "test_deolhonoimposto_multiplos_itens", "data": "def test_deolhonoimposto_multiplos_itens(monkeypatch):\n\tdef mockreturn(endpoint, params={}):\n\t\tdados = {\n\t\t\t\t'12340101': pytest.instancia_resp_sucesso_produto,\n\t\t\t\t'12340202': pytest.instancia_resp_sucesso_produto_alt_a,\n\t\t\t\t'12340303': pytest.instancia_resp_sucesso_produto_alt_b,\n\t\t\t\t'0123': pytest.instancia_resp_sucesso_servico,\n\t\t\t\t'0124': pytest.instancia_resp_sucesso_servico_alt_a,}\n\t\treturn dados.get(params.get('codigo'))\n\tmonkeypatch.setattr(requests, 'get', mockreturn)\n\t\n\tcalc = DeOlhoNoImposto()\n\n\tcalc.produto('12340101', 0, Decimal('5.00'))\n\t\t\t# nacional\t 4,2% : 0,21\n\t\t\t# importado\t4,8% : 0,24\n\t\t\t# estadual\t  18% : 0,9\n\t\t\t# muncipal\t   0% : 0\t\t  total tributos: 1,35\n\t\t\t\n\tcalc.produto('12340202', 0, Decimal('15.50'))\n\t\t\t# nacional\t 4,2% : 0,651\n\t\t\t# importado   5,41% : 0,83855\n\t\t\t# estadual\t   0% : 0\n\t\t\t# muncipal\t   0% : 0\t\t  total tributos: 1,48955\n\t\t\t\n\tcalc.produto('12340303', 0, Decimal('7.30'))\n\t\t\t# nacional\t 4,2% : 0,3066\n\t\t\t# importado   6,18% : 0,45114\n\t\t\t# estadual\t  12% : 0,876\n\t\t\t# muncipal\t   0% : 0\t\t  total tributos: 1,63374\n\t\t\t\n\tcalc.servico('0123', Decimal('100'))\n\t\t\t# nacional   13,45% : 13,45\n\t\t\t# importado  14,05% : 14,05\n\t\t\t# estadual\t   0% :  0\n\t\t\t# muncipal\t4,33% :  4,33\t  total tributos: 31,83\n\t\t\t\n\tcalc.servico('0124', Decimal('575.77'))\n\t\t\t# nacional   13,45% : 77,441065\n\t\t\t# importado  14,05% : 80,895685\n\t\t\t# estadual\t   0% :  0\n\t\t\t# muncipal\t3,55% : 20,439835  total tributos: 178,776585\n\t\n\t# total (soma dos valores dos itens) : R$ 703,57\n\t# valor total dos tributos\t\t   : R$ 215,079875\n\t# % total dos tributos sobre o valor : 30,569790497%\n\t\n\tcarga_fed_nac = sum([\n\t\t\tDecimal('0.21'),\n\t\t\tDecimal('0.651'),\n\t\t\tDecimal('0.3066'),\n\t\t\tDecimal('13.45'),\n\t\t\tDecimal('77.441065'),])\n\t\n\tcarga_fed_imp = sum([\n\t\t\tDecimal('0.24'),\n\t\t\tDecimal('0.83855'),\n\t\t\tDecimal('0.45114'), # inclui os zeros para ilustrar\n\t\t\tDecimal('14.05'),\n\t\t\tDecimal('80.895685'),])\n\t\t\t\n\tcarga_estadual = sum([\n\t\t\tDecimal('0.9'),\n\t\t\tDecimal('0'),\n\t\t\tDecimal('0.876'),\n\t\t\tDecimal('0'),\n\t\t\tDecimal('0'),])\n\t\t\t\n\tcarga_municipal = sum([\n\t\t\tDecimal('0'),\n\t\t\tDecimal('0'),\n\t\t\tDecimal('0'),\n\t\t\tDecimal('4.33'),\n\t\t\tDecimal('20.439835'),])\n\t\n\ttotal_tributos = sum([\n\t\t\tcarga_fed_nac,\n\t\t\tcarga_fed_imp,\n\t\t\tcarga_estadual,\n\t\t\tcarga_municipal,])\n\t\n\ttotal = Decimal('703.57')\n\tp_sobre_total = total_tributos / total\n\t\t\t\n\tassert calc.total() == total, 'Total nao confere com o valor do unico item'\n\tassert calc.total() > calc.total_tributos(), 'Soma dos valores dos '\\\n\t\t\t'itens menor ou igual ao valor total dos tributos'\n\t\t\t\n\tassert calc.carga_federal_nacional() == carga_fed_nac\n\tassert calc.carga_federal_importado() == carga_fed_imp\n\tassert calc.carga_federal() == carga_fed_nac + carga_fed_imp\n\tassert calc.carga_estadual() == carga_estadual\n\tassert calc.carga_municipal() == carga_municipal\n\t\n\tassert calc.total_tributos() == total_tributos\n\t\n\tassert calc.total() == total\n\tassert calc.percentual_sobre_total() == p_sobre_total\n\t\n\t# testa o reinicio da calculadora\n\tcalc.reiniciar()\n\tassert calc.carga_federal().is_zero()\n\tassert calc.carga_federal_nacional().is_zero()\n\tassert calc.carga_federal_importado().is_zero()\n\tassert calc.carga_estadual().is_zero()\n\tassert calc.carga_municipal().is_zero()\n\tassert calc.total_tributos().is_zero()\n\tassert calc.total().is_zero()\n\tassert calc.percentual_sobre_total().is_zero()\n", "description": null, "category": "math", "imports": ["from decimal import Decimal", "import pytest", "import requests", "from ibptws.calculadoras import DeOlhoNoImposto", "from ibptws.calculadoras import CEM", "\tassert calc.carga_federal_importado().is_zero()", "\tassert calc.carga_federal_importado() == carga_fed_imp", "\tassert calc.carga_federal_importado().is_zero()", "\t\t\t# importado\t4,8% : 0,24", "\t\t\t# importado   5,41% : 0,83855", "\t\t\t# importado   6,18% : 0,45114", "\t\t\t# importado  14,05% : 14,05", "\t\t\t# importado  14,05% : 80,895685", "\tassert calc.carga_federal_importado() == carga_fed_imp", "\tassert calc.carga_federal_importado().is_zero()"]}], [{"term": "def", "name": "test_al", "data": "def test_al(factory):\n\tname = factory.name\n\t# What on earth does kpts=1.0 mean?  Was failing, I changed it.  --askhl\n\t# Disabled GPAW since it was failing anyway. --askhl\n\tkpts = [2, 2, 2]\n\tcalc = factory.calc(label=name, xc='LDA', kpts=kpts)\n\tal = bulk('AlO', crystalstructure='rocksalt', a=4.5)\n\tal.calc = calc\n\te = al.get_potential_energy()\n\tcalc.set(xc='PBE', kpts=kpts)\n\tepbe = al.get_potential_energy()\n\tprint(e, epbe)\n\tcalc = factory.calc(restart=name)\n\tprint(calc.parameters, calc.results, calc.atoms)\n\tassert not calc.calculation_required(al, ['energy'])\n\tal = calc.get_atoms()\n\tprint(al.get_potential_energy())\n\tlabel = 'dir/' + name + '-2'\n\tcalc = factory.calc(label=label, atoms=al, xc='LDA', kpts=kpts)\n\tprint(al.get_potential_energy())\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}], [{"term": "def", "name": "test_directory_and_label", "data": "def test_directory_and_label():\n\tdef normalize(path):\n\t\t\"\"\"Helper function to normalize path\"\"\"\n\t\treturn str(Path(path))\n\n\tcalc = Calculator()\n\n\tassert calc.directory == '.'\n\tassert calc.label is None\n\n\tcalc.directory = 'somedir'\n\n\tassert calc.directory == 'somedir'\n\tassert calc.label == 'somedir/'\n\n\t# We cannot redundantly specify directory\n\twith pytest.raises(ValueError):\n\t\tcalc = Calculator(directory='somedir',\n\t\t\t\t\t\t  label='anotherdir/label')\n\n\t# Test only directory in directory\n\tcalc = Calculator(directory='somedir',\n\t\t\t\t\t  label='label')\n\n\tassert calc.directory == 'somedir'\n\tassert calc.label == 'somedir/label'\n\n\twdir = '/home/somedir'\n\tcalc = Calculator(directory=wdir,\n\t\t\t\t\t  label='label')\n\n\tassert calc.directory == normalize(wdir)\n\tassert calc.label == normalize(wdir) + '/label'\n\n\t# Test we can handle pathlib directories\n\twdir = Path('/home/somedir')\n\tcalc = Calculator(directory=wdir,\n\t\t\t\t\t  label='label')\n\tassert calc.directory == normalize(wdir)\n\tassert calc.label == normalize(wdir) + '/label'\n\n\twith pytest.raises(ValueError):\n\t\tcalc = Calculator(directory=wdir,\n\t\t\t\t\t\t  label='somedir/label')\n\n\t# Passing in empty directories with directories in label should be OK\n\tfor wdir in ['somedir', '/home/directory']:\n\t\tlabel = wdir + '/label'\n\t\texpected_label = normalize(wdir) + '/label'\n\t\tcalc = Calculator(directory='', label=label)\n\t\tassert calc.label == expected_label\n\t\tassert calc.directory == normalize(wdir)\n\n\t\tcalc = Calculator(directory='.', label=label)\n\t\tassert calc.label == expected_label\n\t\tassert calc.directory == normalize(wdir)\n\n", "description": "Helper function to normalize path", "category": "math", "imports": ["from pathlib import Path", "import pytest", "from ase.calculators.calculator import Calculator"]}, {"term": "def", "name": "test_deprecated_get_spin_polarized", "data": "def test_deprecated_get_spin_polarized():\n\tcalc = Calculator()\n\twith pytest.warns(FutureWarning):\n\t\tspinpol = calc.get_spin_polarized()\n\tassert spinpol is False\n", "description": null, "category": "math", "imports": ["from pathlib import Path", "import pytest", "from ase.calculators.calculator import Calculator"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "calculate", "data": "def calculate(numFaculty, numStudents, numSessions, durationSessions, classFloorArea, classHeight, county, state, infectionRate):\n\tnum_faculty = numFaculty\n\tnum_students = numStudents\n\tnum_class_periods = numSessions\n\tduration = durationSessions/60\n\tfloor_area = classFloorArea\n\theight = classHeight\n\tvolume = floor_area*height*(0.305**3)\n\tcounty = county\n\tstate = state\n\n\t# Default Values:\n\t# num_faculty = 1\n\t# num_students = 10\n\t# duration = 75/60\n\t# num_class_periods = 26\n\t# floor_area = 900\n\t# height = 10\n\n\tventilation_w_outside_air = [1, 4, 1]\n\tdecay_rate_of_virus = [0, 1.0, 1]\n\tdeposition_to_surface = [0.3, 1.5, 1]\n\tadditional_control_measures = [0, 0, 1]\n\tquanta_emission_rate_faculty = [1.5, 0.71, 1]\n\tquanta_emission_rate_student = [0.69, 0.71, 1]\n\texhalation_mask_efficiency = [0.4, 0.6, 1]\n\tinhalation_mask_efficiency = [0.3, 0.5, 1]\n\tinhalation_rate_faculty = [0.005, 0.01, 1]\n\tinhalation_rate_student = [0.005, 0.007, 1]\n\n\tif infectionRate != None:\n\t\tpercent_faculty_infectious = [infectionRate/100, 2*(infectionRate/100), 0]\n\t\tpercent_student_infectious = [infectionRate/100, 2*(infectionRate/100), 0]\n\telse:\n\t\tpercent_faculty_infectious = getCountyCases(county, state)\n\t\tpercent_student_infectious = percent_faculty_infectious\n\n\t############################\n\n\tdef randomizeAll():\n\t\trandomize(ventilation_w_outside_air)\n\t\trandomize(decay_rate_of_virus)\n\t\trandomize(deposition_to_surface)\n\t\trandomize(additional_control_measures)\n\t\trandomize(exhalation_mask_efficiency)\n\t\trandomize(inhalation_mask_efficiency)\n\t\trandomize(inhalation_rate_faculty)\n\t\trandomize(inhalation_rate_student)\n\t\trandomize(percent_faculty_infectious)\n\t\trandomize(percent_student_infectious)\n\n\t\trandomizeFromNormal(quanta_emission_rate_faculty)\n\t\trandomizeFromNormal(quanta_emission_rate_student)\n\n\tdef randomize(bounds):\n\t\tbounds[2] = bounds[0] + np.random.random_sample() * \\\n\t\t\t(bounds[1]-bounds[0])\n\n\tdef randomizeFromNormal(normdist):\n\t\tnormdist[2] = 10**np.random.normal(normdist[0], normdist[1])\n\t\t##also does the UNDO LOG\n\n\t# Q_f: quanta emission rate by infected faculty\n\t# m_out: mask exhalation efficiency\n\t# k: first order loss coefficients for ventilation , decay, deposition, and other control measures\n\t# V: volume of classroom\n\t# T: duration of each in-person class session\n\n\t# Average quanta concentration during class period if 1 faculty member is infected:\n\tdef calc_Cf(Q_f, m_out, k, V, T):\n\t\tcf = ((Q_f*(1-m_out))/(k*V))*(1-(1/(k*T))*(1-e**(-k*T)))\n\n\t\treturn cf\n\n\t# Average quanta concentration during class period if 1 student is infected:\n\tdef calc_Cs(Q_s, m_out, k, V, T):\n\t\tcs = ((Q_s*(1-m_out))/(k*V))*(1-(1/(k*T))*(1-e**(-k*T)))\n\t\treturn cs\n\n\t# Quanta inhaled by student if 1 faculty infected:\n\tdef calc_Nfs(C_f, I_s, m_in, T):\n\t\tNfs = C_f*I_s*(1-m_in)*T\n\t\treturn Nfs\n\n\t# Quanta inhaled by faculty if 1 student infected:\n\tdef calc_Nsf(C_s, I_f, m_in, T):\n\t\tNsf = C_s*I_f*(1-m_in)*T\n\t\treturn Nsf\n\n\t# Quanta inhaled by student if 1 student infected\n\tdef calc_Nss(C_s, I_s, m_in, T):\n\t\tNss = C_s*I_s*(1-m_in)*T\n\t\treturn Nss\n\n\t# Probability of 1 faculty infecting student:\n\tdef calc_pfs(f_f, N_fs):\n\t\tpfs = f_f*(1-np.exp(-N_fs))\n\t\treturn pfs\n\n\t# Probability of 1 student infecting faculty:\n\tdef calc_psf(f_s, N_sf):\n\t\tpsf = f_s*(1-np.power(e, -N_sf))\n\t\treturn psf\n\n\t# Probability of 1 student infecting student:\n\tdef calc_pss(f_s, N_ss):\n\t\tpss = f_s*(1-np.power(e, -N_ss))\n\t\treturn pss\n\n\t# Probability of faculty infection in one class session:\n\tdef calc_p1f(p_sf, N_s):\n\t\tp1f = 1-(1-p_sf)**(N_s)\n\t\treturn p1f\n\n\t# Probability of student infection in one class session:\n\tdef calc_p1s(p_ss, n_s, p_fs, n_f):\n\t\tp1s = 1-((1-p_ss)**(n_s-1)*(1-p_fs)**n_f)\n\t\treturn p1s\n\n\t# Probability of faculty infection for semester:\n\tdef calc_pf(p1_f, n_c):\n\t\tpf = 1-(1-p1_f)**n_c\n\t\treturn pf\n\n\t# Probability of student infection for semester:\n\tdef calc_ps(p1_s, n_c):\n\t\tps = 1-(1-p1_s)**n_c\n\t\treturn ps\n\n\ttrials = 10000\n\tfac_runs = np.zeros(trials)\n\tstudent_runs = np.zeros(trials)\n\tfor x in range(trials):\n\t\trandomizeAll()\n\n\t\tcf = calc_Cf(quanta_emission_rate_faculty[2], exhalation_mask_efficiency[2], (ventilation_w_outside_air[2] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  decay_rate_of_virus[2]+deposition_to_surface[2]+additional_control_measures[2]), volume, duration)\n\t\t#print(\"cf: \", cf)\n\t\tcs = calc_Cs(quanta_emission_rate_student[2], exhalation_mask_efficiency[2], (ventilation_w_outside_air[2] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdecay_rate_of_virus[2]+deposition_to_surface[2]+additional_control_measures[2]), volume, duration)\n\t\t#print(\"cs: \", cs)\n\t\tNfs = calc_Nfs(\n\t\t\tcf, inhalation_rate_student[2]*60, inhalation_mask_efficiency[2], duration)\n\t\t#print(\"Nfs: \", Nfs)\n\t\tNsf = calc_Nsf(\n\t\t\tcs, inhalation_rate_faculty[2]*60, inhalation_mask_efficiency[2], duration)\n\t\t#print(\"Nsf: \", Nsf)\n\t\tNss = calc_Nss(\n\t\t\tcs, inhalation_rate_student[2]*60, inhalation_mask_efficiency[2], duration)\n\t\t#print(\"Nss: \", Nss)\n\t\tPfs = calc_pfs(percent_faculty_infectious[2], Nfs)\n\t\t# print(\"f_f: \", percent_faculty_infectious)\n\t\t#print(\"Pfs: \", Pfs)\n\t\tPsf = calc_psf(percent_student_infectious[2], Nsf)\n\t\t#print(\"Psf: \", Psf)\n\t\tPss = calc_pss(percent_student_infectious[2], Nss)\n\t\t#print(\"Pss: \", Pss)\n\t\tP1f = calc_p1f(Psf, num_students)\n\t\t#print(\"P1f: \", P1f)\n\t\tP1s = calc_p1s(Pss, num_students, Pfs, num_faculty)\n\t\t#print(\"P1s: \", P1s)\n\t\tPf = calc_pf(P1f, num_class_periods)\n\t\t#print(\"Pf: \", Pf)\n\t\tPs = calc_ps(P1s, num_class_periods)\n\t\t#print(\"Ps: \", Ps)\n\t\tfac_runs[x] = Pf\n\t\tstudent_runs[x] = Ps\n\n\tstudent_mean = round(statistics.mean(student_runs)*100, 2)\n\tfac_mean = round(statistics.mean(fac_runs)*100, 2)\n\n\tstudent_quants_05 = np.quantile(student_runs, 0.05)\n\tstudent_quants_25 = np.quantile(student_runs, 0.25)\n\tstudent_quants_50 = np.quantile(student_runs, 0.50)\n\tstudent_quants_75 = np.quantile(student_runs, 0.75)\n\tstudent_quants_95 = np.quantile(student_runs, 0.95)\n\n\tfac_quants_05 = np.quantile(fac_runs, 0.05)\n\tfac_quants_25 = np.quantile(fac_runs, 0.25)\n\tfac_quants_50 = np.quantile(fac_runs, 0.50)\n\tfac_quants_75 = np.quantile(fac_runs, 0.75)\n\tfac_quants_95 = np.quantile(fac_runs, 0.95)\n\n\tstudentResults = {'student_quants_05': round(student_quants_05*100, 2),\n\t\t\t\t\t  'student_quants_25': round(student_quants_25*100, 2),\n\t\t\t\t\t  'student_quants_50': round(student_quants_50*100, 2),\n\t\t\t\t\t  'student_quants_75': round(student_quants_75*100, 2),\n\t\t\t\t\t  'student_quants_95': round(student_quants_95*100, 2)}\n\n\tfacultyResults = {'fac_quants_05': round(fac_quants_05*100, 2),\n\t\t\t\t\t  'fac_quants_25': round(fac_quants_25*100, 2),\n\t\t\t\t\t  'fac_quants_50': round(fac_quants_50*100, 2),\n\t\t\t\t\t  'fac_quants_75': round(fac_quants_75*100, 2),\n\t\t\t\t\t  'fac_quants_95': round(fac_quants_95*100, 2)}\n\n\n\tpercent_faculty_infectious = [percent_faculty_infectious[0]*100, percent_faculty_infectious[1]*100, 0]\n\tpercent_student_infectious = [percent_student_infectious[0]*100, percent_student_infectious[1]*100, 0]\n\n\treturn (student_mean, fac_mean, studentResults, facultyResults, percent_faculty_infectious, percent_student_infectious)\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pandas as pd", "import math", "from getCountyCases import getCountyCases", "import statistics"]}], [{"term": "def", "name": "test_variable_init_none", "data": "def test_variable_init_none():\n\tvar = Calc.Variable()\n\tassert var.type == None\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_number", "data": "def test_variable_init_number():\n\ttoken = Calc.Token('24.67', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar = Calc.Variable(token)\n\tassert var.a == 0\n\tassert var.b == 24.67\n\tassert var.type == Calc.LexType.NUMBER\n\tassert var.position == 12\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_variable", "data": "def test_variable_init_variable():\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar = Calc.Variable(token)\n\tassert var.a == 1.0\n\tassert var.b == 0.0\n\tassert var.type == Calc.LexType.VARIABLE\n\tassert var.position == 12\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_float", "data": "def test_variable_init_float():\n\ttoken = Calc.Token('24.67', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar = Calc.Variable(token)\n\tassert float(var) == 24.67\n\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar = Calc.Variable(token)\n\tvar.a = 2\n\tvar.b = 1\n\tassert float(var) == -0.5\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_neg", "data": "def test_variable_init_neg():\n\ttoken = Calc.Token('24.67', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar = Calc.Variable(token)\n\tvar = -var\n\tassert var.a == 0\n\tassert var.b == -24.67\n\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar = Calc.Variable(token)\n\tvar.a = 2\n\tvar.b = 1\n\tvar = -var\n\tassert var.a == -2\n\tassert var.b == -1\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_add", "data": "def test_variable_init_add():\n\ttoken = Calc.Token('24.67', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar1 = Calc.Variable(token)\n\ttoken = Calc.Token('10.12', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar2 = Calc.Variable(token)\n\tvar3 = var1+var2\n\tassert var3.a == 0\n\tassert var3.b == 34.79\n\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar2 = Calc.Variable(token)\n\tvar2.a = 2\n\tvar2.b = 1\n\n\tvar3 = var1+var2\n\tassert var3.a == 2\n\tassert var3.b == 25.67\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_sub", "data": "def test_variable_init_sub():\n\ttoken = Calc.Token('25.50', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar1 = Calc.Variable(token)\n\ttoken = Calc.Token('10.10', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar2 = Calc.Variable(token)\n\tvar3 = var1-var2\n\tassert var3.a == 0\n\tassert var3.b == 15.4\n\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar2 = Calc.Variable(token)\n\tvar2.a = 2\n\tvar2.b = 1\n\n\tvar3 = var1-var2\n\n\tassert var3.a == -2\n\tassert var3.b == 24.5\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_mul_var_var", "data": "def test_variable_init_mul_var_var():\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar1 = Calc.Variable(token)\n\tvar1.a = 2\n\tvar1.b = 1\n\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar2 = Calc.Variable(token)\n\tvar2.a = 2\n\tvar2.b = 1\n\n\tvar3 = var1 * var2\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_mul_num_num", "data": "def test_variable_init_mul_num_num():\n\ttoken = Calc.Token('7', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar1 = Calc.Variable(token)\n\ttoken = Calc.Token('3.1', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar2 = Calc.Variable(token)\n\tvar3 = var1*var2\n\n\tassert var3.a == 0\n\tassert var3.b == 21.7\n\tassert var3.type == Calc.LexType.NUMBER\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_mul_num_var", "data": "def test_variable_init_mul_num_var():\n\ttoken = Calc.Token('7', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar1 = Calc.Variable(token)\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar2 = Calc.Variable(token)\n\tvar2.a = 2\n\tvar2.b = 1\n\n\tvar3 = var1*var2\n\n\tassert var3.a == 14.0\n\tassert var3.b == 7.0\n\tassert var3.type == Calc.LexType.VARIABLE\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_mul_var_num", "data": "def test_variable_init_mul_var_num():\n\ttoken = Calc.Token('7', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar1 = Calc.Variable(token)\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar2 = Calc.Variable(token)\n\tvar2.a = 2\n\tvar2.b = 1\n\n\tvar3 = var2*var1\n\n\tassert var3.a == 14.0\n\tassert var3.b == 7.0\n\tassert var3.type == Calc.LexType.VARIABLE\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_div_x_var", "data": "def test_variable_init_div_x_var():\n\ttoken = Calc.Token('7', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar1 = Calc.Variable(token)\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar2 = Calc.Variable(token)\n\tvar2.a = 2\n\tvar2.b = 1\n\tvar3 = var1/var2\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_div_x_zero", "data": "def test_variable_init_div_x_zero():\n\ttoken = Calc.Token('7', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar1 = Calc.Variable(token)\n\ttoken = Calc.Token('0', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar2 = Calc.Variable(token)\n\tvar3 = var1/var2\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_div_num_num", "data": "def test_variable_init_div_num_num():\n\ttoken = Calc.Token('18', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar1 = Calc.Variable(token)\n\n\ttoken = Calc.Token('2', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar2 = Calc.Variable(token)\n\n\tvar3 = var1/var2\n\tprint(\"=%s=\" % repr(var3.a))\n\n\tassert var3.a == 0.0\n\tassert var3.b == 9.0\n\tassert var3.type == Calc.LexType.NUMBER\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_div_var_num", "data": "def test_variable_init_div_var_num():\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar1 = Calc.Variable(token)\n\tvar1.a = 10\n\tvar1.b = 14\n\n\ttoken = Calc.Token('2', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar2 = Calc.Variable(token)\n\n\tvar3 = var1/var2\n\tassert var3.a == 5.0\n\tassert var3.b == 7.0\n\tassert var3.type == Calc.LexType.VARIABLE\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_exp_num_num", "data": "def test_variable_init_exp_num_num():\n\ttoken = Calc.Token('2', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar1 = Calc.Variable(token)\n\ttoken = Calc.Token('3', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar2 = Calc.Variable(token)\n\n\tvar3 = var1**var2\n\tassert var3.a == 0.0\n\tassert var3.b == 8.0\n\tassert var3.type == Calc.LexType.NUMBER\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_exp_num_var", "data": "def test_variable_init_exp_num_var():\n\ttoken = Calc.Token('2', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar1 = Calc.Variable(token)\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar2 = Calc.Variable(token)\n\n\tvar3 = var1**var2\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}, {"term": "def", "name": "test_variable_init_exp_num_var", "data": "def test_variable_init_exp_num_var():\n\ttoken = Calc.Token('2', Calc.LexType.NUMBER, Calc.LexTag.NUMBER, 12)\n\tvar1 = Calc.Variable(token)\n\ttoken = Calc.Token('x', Calc.LexType.VARIABLE, Calc.LexTag.VARIABLE, 12)\n\tvar2 = Calc.Variable(token)\n\n\tvar3 = var2**var1\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import nose", "from nose.tools import raises", "import calculator as Calc"]}], [{"term": "def", "name": "test_adjust_negative_n2", "data": "def test_adjust_negative_n2():\n\tobvfsq = derived.calc_n2(dset1.thetao, dset1.so)\n\tadjusted = derived.adjust_negative_n2(obvfsq)\n\tassert np.allclose(adjusted.sum(), 0.50181224)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_coriolis", "data": "def test_calc_coriolis():\n\tcoriolis = derived.calc_coriolis(dset1.geolat)\n\tassert np.allclose(coriolis.sum(), 2.71050543e-20)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_dz_1", "data": "def test_calc_dz_1():\n\tdz = derived.calc_dz(dset2.z_l, dset2.z_i, dset2.deptho)\n\tassert np.allclose(dz.sum(), 1261.33383326)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_dz_2", "data": "def test_calc_dz_2():\n\tdz = derived.calc_dz(dset2.z_l, dset2.z_i, dset2.deptho, fraction=True)\n\tassert np.allclose(dz.sum(), 91.82404981)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_dz_3", "data": "def test_calc_dz_3():\n\tdeptho = dset2.deptho.copy()\n\tdeptho[4, 4] = -200.0\n\twith pytest.raises(Exception):\n\t\tderived.calc_dz(dset2.z_l, dset2.z_i, deptho)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_rho", "data": "def test_calc_rho():\n\trho = derived.calc_rho(dset1.thetao, dset1.so, dset1.z_l * 1.0e4, eos=\"Wright\")\n\tpytest.rho = rho\n\tassert np.allclose(rho.sum(), 643847.01494266)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_n2_1", "data": "def test_calc_n2_1():\n\tobvfsq = derived.calc_n2(dset1.thetao, dset1.so)\n\tassert np.allclose(obvfsq.sum(), 0.11750034)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_n2_2", "data": "def test_calc_n2_2():\n\tobvfsq = derived.calc_n2(dset1.thetao, dset1.so, adjust_negative=True)\n\tassert np.allclose(obvfsq.sum(), 0.50181224)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_pdens_1", "data": "def test_calc_pdens_1():\n\trhopot = derived.calc_pdens(dset1.thetao, dset1.so, eos=\"Wright\")\n\tassert np.allclose(rhopot.sum(), 641153.07032298)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_pdens_2", "data": "def test_calc_pdens_2():\n\trhopot = derived.calc_pdens(dset1.thetao, dset1.so, level=2000.0, eos=\"Wright\")\n\tassert np.allclose(rhopot.sum(), 646547.38808142)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_alpha", "data": "def test_calc_alpha():\n\talpha = derived.calc_alpha(dset1.thetao, dset1.so, dset1.z_l * 1.0e4, eos=\"Wright\")\n\tassert np.allclose(alpha.sum(), 0.14270076)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_beta", "data": "def test_calc_beta():\n\tbeta = derived.calc_beta(dset1.thetao, dset1.so, dset1.z_l * 1.0e4, eos=\"Wright\")\n\tassert np.allclose(beta.sum(), 0.46398704)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_masso", "data": "def test_calc_masso():\n\tmasso = derived.calc_masso(pytest.rho, dset1.volcello)\n\tpytest.masso = masso\n\tassert np.allclose(masso.sum(), 6.43066545e08)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_volo_1", "data": "def test_calc_volo_1():\n\twith pytest.raises(Exception):\n\t\tresult = derived.calc_volo(dset1.volcello)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_volo_1", "data": "def test_calc_volo_1():\n\tvolo = derived.calc_volo(dset1.volcello.isel(time=0))\n\tpytest.volo = volo\n\tassert np.allclose(volo, 125401.86252394)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_rhoga", "data": "def test_rhoga():\n\trhoga = derived.calc_rhoga(pytest.masso, pytest.volo)\n\tassert np.allclose(rhoga.sum(), 5128.04620652)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_rel_vort", "data": "def test_calc_rel_vort():\n\tresult = derived.calc_rel_vort(dset3)\n\tassert np.allclose(result.sum(), -6.92989256e-14)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_pv_1", "data": "def test_calc_pv_1():\n\tzeta = derived.calc_rel_vort(dset3)\n\tn2 = derived.calc_n2(dset1.thetao, dset1.so)\n\tpv = derived.calc_pv(zeta, dset3.Coriolis, n2, units=\"m\")\n\tassert np.allclose(pv.sum(), 1.00501238e-07)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_pv_2", "data": "def test_calc_pv_2():\n\tzeta = derived.calc_rel_vort(dset3)\n\tn2 = derived.calc_n2(dset1.thetao, dset1.so)\n\tpv = derived.calc_pv(zeta, dset3.Coriolis, n2, units=\"cm\")\n\tassert np.allclose(pv.sum(), 2515708.91532095)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_rossby_rd", "data": "def test_calc_rossby_rd():\n\tn2 = derived.calc_n2(dset1.thetao, dset1.so)\n\tdz = derived.calc_dz(dset1.z_l, dset1.z_i, dset1.deptho)\n\twave_speed = derived.calc_wave_speed(n2, dz)\n\tcoriolis = derived.calc_coriolis(dset1.geolat)\n\trossby_rd = derived.calc_rossby_rd(wave_speed, coriolis)\n\trossby_rd = xr.where(xr.ufuncs.isinf(rossby_rd), np.nan, rossby_rd)\n\tassert np.allclose(rossby_rd.sum(), 11779400.69254739)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_spice", "data": "def test_calc_spice():\n\tpi = derived.calc_spice(dset1.thetao, dset1.so)\n\tassert np.allclose(pi.sum(), 1341.51468477)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_stability_angle", "data": "def test_calc_stability_angle():\n\ttu_ang = derived.calc_stability_angle(\n\t\tdset1.thetao, dset1.so, dset1.z_l * 1.0e4, eos=\"Wright\"\n\t)\n\tassert np.allclose(tu_ang.sum(), 229.53184304)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}, {"term": "def", "name": "test_calc_wave_speed", "data": "def test_calc_wave_speed():\n\tn2 = derived.calc_n2(dset1.thetao, dset1.so)\n\tdz = derived.calc_dz(dset1.z_l, dset1.z_i, dset1.deptho)\n\twave_speed = derived.calc_wave_speed(n2, dz)\n\tassert np.allclose(wave_speed.sum(), 1423.93496635)\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "import xarray as xr", "from momlevel import derived", "from momlevel.test_data import generate_test_data", "from momlevel.test_data import generate_test_data_dz", "from momlevel.test_data import generate_test_data_uv"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(\"Error\", cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(\"Error\", cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "test_plugin_cis_instantiate", "data": "def test_plugin_cis_instantiate():\n\tAddCisFunction()\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.cis import AddCisFunction", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_cis_hook", "data": "def test_plugin_cis_hook():\n\tcalc = TestCalculator()\n\tplugin = AddCisFunction()\n\tcalc.register_plugin(plugin)\n\tassert plugin in calc.plugins\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.cis import AddCisFunction", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_cis_context_updated", "data": "def test_plugin_cis_context_updated():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(AddCisFunction())\n\tassert calc.chksym(\"cis\")\n\tassert callable(calc.getsym(\"cis\"))\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.cis import AddCisFunction", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_cis_available", "data": "def test_plugin_cis_available():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(AddCisFunction())\n\tassert callable(calc.command(\"cis\"))\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.cis import AddCisFunction", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_cis_example", "data": "def test_plugin_cis_example():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(AddCisFunction())\n\tassert calc.command(\"2*cis(pi/3)\") == calc.command(\"1+sqrt(3)*I\")\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.cis import AddCisFunction", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_cis_validate_values", "data": "def test_plugin_cis_validate_values():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(AddCisFunction())\n\tassert calc.command(\"2*cis(pi/6)\") == calc.command(\"sqrt(3)+I\")\n\tassert calc.command(\"2*cis(pi/4)\") == calc.command(\"sqrt(2)+sqrt(2)*I\")\n\tassert calc.command(\"2*cis(pi/3)\") == calc.command(\"1+sqrt(3)*I\")\n\tassert calc.command(\"cis(pi/2)\") == calc.command(\"I\")\n\tassert calc.command(\"2*cis(2*pi/3)\") == calc.command(\"-1+sqrt(3)*I\")\n\tassert calc.command(\"2*cis(3*pi/4)\") == calc.command(\"-sqrt(2)+sqrt(2)*I\")\n\tassert calc.command(\"2*cis(5*pi/6)\") == calc.command(\"-sqrt(3)+I\")\n\tassert calc.command(\"2*cis(7*pi/6)\") == calc.command(\"-sqrt(3)-I\")\n\tassert calc.command(\"2*cis(5*pi/4)\") == calc.command(\"-sqrt(2)-sqrt(2)*I\")\n\tassert calc.command(\"2*cis(4*pi/3)\") == calc.command(\"-1-sqrt(3)*I\")\n\tassert calc.command(\"cis(3*pi/2)\") == calc.command(\"-I\")\n\tassert calc.command(\"2*cis(5*pi/3)\") == calc.command(\"1-sqrt(3)*I\")\n\tassert calc.command(\"2*cis(7*pi/4)\") == calc.command(\"sqrt(2)-sqrt(2)*I\")\n\tassert calc.command(\"2*cis(11*pi/6)\") == calc.command(\"sqrt(3)-I\")\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.cis import AddCisFunction", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_cis_validate_abs", "data": "def test_plugin_cis_validate_abs():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(AddCisFunction())\n\tfor i in range(-50, 50):\n\t\tassert calc.command(f\"simplify(abs(cis({i})))\") == 1\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.cis import AddCisFunction", "from tests import TestCalculator"]}], [{"term": "def", "name": "test_version", "data": "def test_version(version, txt):\n\tassert EspressoProfile.parse_version(txt) == version\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}, {"term": "def", "name": "test_version_integration", "data": "def test_version_integration(espresso_factory):\n\tprofile = EspressoProfile([espresso_factory.executable])\n\tversion = profile.version()\n\tassert version[0].isdigit()\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}, {"term": "def", "name": "verify", "data": "def verify(calc):\n\tassert calc.get_fermi_level() is not None\n\tassert calc.get_ibz_k_points() is not None\n\tassert calc.get_eigenvalues(spin=0, kpt=0) is not None\n\tassert calc.get_number_of_spins() is not None\n\tassert calc.get_k_point_weights() is not None\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}, {"term": "def", "name": "test_main", "data": "def test_main(espresso_factory):\n\tatoms = bulk('Si')\n\tatoms.calc = espresso_factory.calc()\n\tatoms.get_potential_energy()\n\tverify(atoms.calc)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}, {"term": "def", "name": "test_smearing", "data": "def test_smearing(espresso_factory):\n\tatoms = bulk('Cu')\n\tinput_data = {'system': {'occupations': 'smearing',\n\t\t\t\t\t\t\t 'smearing': 'fermi-dirac',\n\t\t\t\t\t\t\t 'degauss': 0.02}}\n\tatoms.calc = espresso_factory.calc(input_data=input_data)\n\tatoms.get_potential_energy()\n\tverify(atoms.calc)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}, {"term": "def", "name": "test_warn_label", "data": "def test_warn_label():\n\twith pytest.warns(FutureWarning):\n\t\tEspresso(label='hello')\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}, {"term": "def", "name": "test_error_command", "data": "def test_error_command():\n\twith pytest.raises(RuntimeError):\n\t\tEspresso(command='hello')\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}], [{"term": "def", "name": "atoms", "data": "def atoms():\n\treturn molecule('H2', vacuum=2.0)\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_geoopt", "data": "def test_geoopt(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(label='test_H2_GOPT', print_level='LOW')\n\tatoms.calc = calc\n\n\tgopt = BFGS(atoms, logfile=None)\n\tgopt.run(fmax=1e-6)\n\n\tdist = atoms.get_distance(0, 1)\n\tdist_ref = 0.7245595\n\tassert (dist - dist_ref) / dist_ref < 1e-7\n\n\tenergy_ref = -30.7025616943\n\tenergy = atoms.get_potential_energy()\n\tassert (energy - energy_ref) / energy_ref < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_lda", "data": "def test_h2_lda(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(label='test_H2_LDA')\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -30.6989595886\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_libxc", "data": "def test_h2_libxc(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(\n\t\txc='XC_GGA_X_PBE XC_GGA_C_PBE',\n\t\tpseudo_potential=\"GTH-PBE\",\n\t\tlabel='test_H2_libxc')\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -31.591716529642\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_ls", "data": "def test_h2_ls(cp2k_factory, atoms):\n\tinp = \"\"\"&FORCE_EVAL\n\t\t\t   &DFT\n\t\t\t\t &QS\n\t\t\t\t   LS_SCF ON\n\t\t\t\t &END QS\n\t\t\t   &END DFT\n\t\t\t &END FORCE_EVAL\"\"\"\n\tcalc = cp2k_factory.calc(label='test_H2_LS', inp=inp)\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -30.6989581747\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 5e-7\n\n", "description": "&FORCE_EVAL\n\t\t\t   &DFT\n\t\t\t\t &QS\n\t\t\t\t   LS_SCF ON\n\t\t\t\t &END QS\n\t\t\t   &END DFT\n\t\t\t &END FORCE_EVAL", "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_h2_pbe", "data": "def test_h2_pbe(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc(xc='PBE', label='test_H2_PBE')\n\tatoms.calc = calc\n\tenergy = atoms.get_potential_energy()\n\tenergy_ref = -31.5917284949\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_md", "data": "def test_md(cp2k_factory):\n\tcalc = cp2k_factory.calc(label='test_H2_MD')\n\tpositions = [(0, 0, 0), (0, 0, 0.7245595)]\n\tatoms = Atoms('HH', positions=positions, calculator=calc)\n\tatoms.center(vacuum=2.0)\n\n\tMaxwellBoltzmannDistribution(atoms, temperature_K=0.5 * 300,\n\t\t\t\t\t\t\t\t force_temp=True)\n\tenergy_start = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n\tdyn = VelocityVerlet(atoms, 0.5 * units.fs)\n\tdyn.run(20)\n\n\tenergy_end = atoms.get_potential_energy() + atoms.get_kinetic_energy()\n\tassert abs(energy_start - energy_end) < 1e-4\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_o2", "data": "def test_o2(cp2k_factory):\n\tcalc = cp2k_factory.calc(\n\t\tlabel='test_O2', uks=True, cutoff=150 * units.Rydberg,\n\t\tbasis_set=\"SZV-MOLOPT-SR-GTH\")\n\to2 = molecule('O2', calculator=calc)\n\to2.center(vacuum=2.0)\n\tenergy = o2.get_potential_energy()\n\tenergy_ref = -861.057011375\n\tdiff = abs((energy - energy_ref) / energy_ref)\n\tassert diff < 1e-10\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_restart", "data": "def test_restart(cp2k_factory, atoms):\n\tcalc = cp2k_factory.calc()\n\tatoms.calc = calc\n\tatoms.get_potential_energy()\n\tcalc.write('test_restart')  # write a restart\n\tcalc2 = cp2k_factory.calc(restart='test_restart')  # load a restart\n\tassert not calc2.calculation_required(atoms, ['energy'])\n\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_unknown_keywords", "data": "def test_unknown_keywords(cp2k_factory):\n\twith pytest.raises(CalculatorSetupError):\n\t\tcp2k_factory.calc(dummy_nonexistent_keyword='hello')\n", "description": null, "category": "math", "imports": ["from ase.build import molecule", "from ase.optimize import BFGS", "import pytest", "from ase.calculators.calculator import CalculatorSetupError", "from ase import units", "from ase.atoms import Atoms", "from ase.md.velocitydistribution import MaxwellBoltzmannDistribution", "from ase.md.verlet import VelocityVerlet"]}], [{"term": "def", "name": "test_aims_interface", "data": "def test_aims_interface():\n\t# test the new command handling + legacy behavior\n\taims_command = 'aims.x'\n\taims_command_alternative = 'mpirun -np 4 fhiaims.x'\n\toutfilename = 'alternative_aims.out'\n\toutfilename_default = 'aims.out'\n\tcommand = '{0:s} > {1:s}'.format(aims_command, outfilename)\n\t#command_alternative = '{0:s} > {1:s}'.format(aims_command_alternative, outfilename)\n\tcommand_default = '{0:s} > {1:s}'.format(aims_command, outfilename_default)\n\tlegacy_command = 'aims.version.serial.x > aims.out'\n\tlegacy_aims_command = legacy_command.split('>')[0].strip()\n\tlegacy_outfilename = legacy_command.split('>')[-1].strip()\n\n\t# legacy behavior of empty init\n\tcalc = Aims()\n\tassert calc.command == legacy_command\n\tassert calc.outfilename == legacy_outfilename\n\tassert calc.aims_command == legacy_aims_command\n\n\t# behavior of empty init with env variable\n\tos.environ['ASE_AIMS_COMMAND'] = aims_command_alternative\n\tcalc = Aims()\n\tassert calc.command == '{0} > {1}'.format(aims_command_alternative, outfilename_default)\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command_alternative\n\n\t# legacy behavior of \"proper\" command\n\tcalc = Aims(run_command=command)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# legacy behavior of an \"improper\" command\n\tcalc = Aims(run_command=aims_command)\n\tassert calc.command == command_default\n\tassert calc.aims_command == aims_command\n\tassert calc.outfilename == outfilename_default\n\n\t# fixed \"command\"  behavior\n\tcalc = Aims(command=command)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# novel way to use aims_command, no specific outfile\n\tcalc = Aims(aims_command=aims_command)\n\tassert calc.command == command_default\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command\n\n\tcalc = Aims(aims_command=aims_command,\n\t\t\t\toutfilename=outfilename)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# # testing the setters\n\tcalc.command = command_default\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command\n\tassert calc.command == command_default\n\n\t#calc.set_aims_command(aims_command_alternative)\n\tcalc.aims_command = aims_command_alternative\n\tassert calc.aims_command == aims_command_alternative\n\tassert calc.outfilename == outfilename_default\n\tassert calc.command == '{} > {}'.format(aims_command_alternative, outfilename_default)\n\n\tcalc.outfilename = outfilename\n\tassert calc.command == '{} > {}'.format(aims_command_alternative, outfilename)\n\tassert calc.aims_command == aims_command_alternative\n\tassert calc.outfilename == outfilename\n\n\n\t# test writing files\n\ttmp_dir = tempfile.mkdtemp()\n\twater = Atoms('HOH', [(1, 0, 0), (0, 0, 0), (0, 1, 0)])\n\tcalc = Aims(xc='PBE',\n\t\t\t\toutput=['dipole'],\n\t\t\t\tsc_accuracy_etot=1e-6,\n\t\t\t\tsc_accuracy_eev=1e-3,\n\t\t\t\tsc_accuracy_rho=1e-6,\n\t\t\t\tspecies_dir=\"/data/rittmeyer/FHIaims/species_defaults/light/\",\n\t\t\t\tsc_accuracy_forces=1e-4,\n\t\t\t\tlabel=tmp_dir,\n\t\t\t\t)\n\ttry:\n\t\tcalc.prepare_input_files()\n\t\traise AssertionError\n\texcept ValueError:\n\t\tpass\n\n\tcalc.atoms = water\n\tcalc.prepare_input_files()\n\tfor f in ['control.in', 'geometry.in']:\n\t\tassert os.path.isfile(os.path.join(tmp_dir,f))\n", "description": null, "category": "math", "imports": ["import tempfile", "import os", "import pytest", "from ase.calculators.aims import Aims", "from ase import Atoms"]}], [{"term": "class", "name": "WorkbookProperties", "data": "class WorkbookProperties(Serialisable):\n\n\ttagname = \"workbookPr\"\n\n\tdate1904 = Bool(allow_none=True)\n\tdateCompatibility = Bool(allow_none=True)\n\tshowObjects = NoneSet(values=(['all', 'placeholders']))\n\tshowBorderUnselectedTables = Bool(allow_none=True)\n\tfilterPrivacy = Bool(allow_none=True)\n\tpromptedSolutions = Bool(allow_none=True)\n\tshowInkAnnotation = Bool(allow_none=True)\n\tbackupFile = Bool(allow_none=True)\n\tsaveExternalLinkValues = Bool(allow_none=True)\n\tupdateLinks = NoneSet(values=(['userSet', 'never', 'always']))\n\tcodeName = String(allow_none=True)\n\thidePivotFieldList = Bool(allow_none=True)\n\tshowPivotChartFilter = Bool(allow_none=True)\n\tallowRefreshQuery = Bool(allow_none=True)\n\tpublishItems = Bool(allow_none=True)\n\tcheckCompatibility = Bool(allow_none=True)\n\tautoCompressPictures = Bool(allow_none=True)\n\trefreshAllConnections = Bool(allow_none=True)\n\tdefaultThemeVersion = Integer(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t date1904=None,\n\t\t\t\t dateCompatibility=None,\n\t\t\t\t showObjects=None,\n\t\t\t\t showBorderUnselectedTables=None,\n\t\t\t\t filterPrivacy=None,\n\t\t\t\t promptedSolutions=None,\n\t\t\t\t showInkAnnotation=None,\n\t\t\t\t backupFile=None,\n\t\t\t\t saveExternalLinkValues=None,\n\t\t\t\t updateLinks=None,\n\t\t\t\t codeName=None,\n\t\t\t\t hidePivotFieldList=None,\n\t\t\t\t showPivotChartFilter=None,\n\t\t\t\t allowRefreshQuery=None,\n\t\t\t\t publishItems=None,\n\t\t\t\t checkCompatibility=None,\n\t\t\t\t autoCompressPictures=None,\n\t\t\t\t refreshAllConnections=None,\n\t\t\t\t defaultThemeVersion=None,\n\t\t\t\t):\n\t\tself.date1904 = date1904\n\t\tself.dateCompatibility = dateCompatibility\n\t\tself.showObjects = showObjects\n\t\tself.showBorderUnselectedTables = showBorderUnselectedTables\n\t\tself.filterPrivacy = filterPrivacy\n\t\tself.promptedSolutions = promptedSolutions\n\t\tself.showInkAnnotation = showInkAnnotation\n\t\tself.backupFile = backupFile\n\t\tself.saveExternalLinkValues = saveExternalLinkValues\n\t\tself.updateLinks = updateLinks\n\t\tself.codeName = codeName\n\t\tself.hidePivotFieldList = hidePivotFieldList\n\t\tself.showPivotChartFilter = showPivotChartFilter\n\t\tself.allowRefreshQuery = allowRefreshQuery\n\t\tself.publishItems = publishItems\n\t\tself.checkCompatibility = checkCompatibility\n\t\tself.autoCompressPictures = autoCompressPictures\n\t\tself.refreshAllConnections = refreshAllConnections\n\t\tself.defaultThemeVersion = defaultThemeVersion\n\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}, {"term": "class", "name": "CalcProperties", "data": "class CalcProperties(Serialisable):\n\n\ttagname = \"calcPr\"\n\n\tcalcId = Integer()\n\tcalcMode = NoneSet(values=(['manual', 'auto', 'autoNoTable']))\n\tfullCalcOnLoad = Bool(allow_none=True)\n\trefMode = NoneSet(values=(['A1', 'R1C1']))\n\titerate = Bool(allow_none=True)\n\titerateCount = Integer(allow_none=True)\n\titerateDelta = Float(allow_none=True)\n\tfullPrecision = Bool(allow_none=True)\n\tcalcCompleted = Bool(allow_none=True)\n\tcalcOnSave = Bool(allow_none=True)\n\tconcurrentCalc = Bool(allow_none=True)\n\tconcurrentManualCount = Integer(allow_none=True)\n\tforceFullCalc = Bool(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t calcId=124519,\n\t\t\t\t calcMode=None,\n\t\t\t\t fullCalcOnLoad=True,\n\t\t\t\t refMode=None,\n\t\t\t\t iterate=None,\n\t\t\t\t iterateCount=None,\n\t\t\t\t iterateDelta=None,\n\t\t\t\t fullPrecision=None,\n\t\t\t\t calcCompleted=None,\n\t\t\t\t calcOnSave=None,\n\t\t\t\t concurrentCalc=None,\n\t\t\t\t concurrentManualCount=None,\n\t\t\t\t forceFullCalc=None,\n\t\t\t\t):\n\t\tself.calcId = calcId\n\t\tself.calcMode = calcMode\n\t\tself.fullCalcOnLoad = fullCalcOnLoad\n\t\tself.refMode = refMode\n\t\tself.iterate = iterate\n\t\tself.iterateCount = iterateCount\n\t\tself.iterateDelta = iterateDelta\n\t\tself.fullPrecision = fullPrecision\n\t\tself.calcCompleted = calcCompleted\n\t\tself.calcOnSave = calcOnSave\n\t\tself.concurrentCalc = concurrentCalc\n\t\tself.concurrentManualCount = concurrentManualCount\n\t\tself.forceFullCalc = forceFullCalc\n\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}, {"term": "class", "name": "FileVersion", "data": "class FileVersion(Serialisable):\n\n\ttagname = \"fileVersion\"\n\n\tappName = String(allow_none=True)\n\tlastEdited = String(allow_none=True)\n\tlowestEdited = String(allow_none=True)\n\trupBuild = String(allow_none=True)\n\tcodeName = Guid(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t appName=None,\n\t\t\t\t lastEdited=None,\n\t\t\t\t lowestEdited=None,\n\t\t\t\t rupBuild=None,\n\t\t\t\t codeName=None,\n\t\t\t\t):\n\t\tself.appName = appName\n\t\tself.lastEdited = lastEdited\n\t\tself.lowestEdited = lowestEdited\n\t\tself.rupBuild = rupBuild\n\t\tself.codeName = codeName\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}], [{"term": "class", "name": "WorkbookProperties", "data": "class WorkbookProperties(Serialisable):\n\n\ttagname = \"workbookPr\"\n\n\tdate1904 = Bool(allow_none=True)\n\tdateCompatibility = Bool(allow_none=True)\n\tshowObjects = NoneSet(values=(['all', 'placeholders']))\n\tshowBorderUnselectedTables = Bool(allow_none=True)\n\tfilterPrivacy = Bool(allow_none=True)\n\tpromptedSolutions = Bool(allow_none=True)\n\tshowInkAnnotation = Bool(allow_none=True)\n\tbackupFile = Bool(allow_none=True)\n\tsaveExternalLinkValues = Bool(allow_none=True)\n\tupdateLinks = NoneSet(values=(['userSet', 'never', 'always']))\n\tcodeName = String(allow_none=True)\n\thidePivotFieldList = Bool(allow_none=True)\n\tshowPivotChartFilter = Bool(allow_none=True)\n\tallowRefreshQuery = Bool(allow_none=True)\n\tpublishItems = Bool(allow_none=True)\n\tcheckCompatibility = Bool(allow_none=True)\n\tautoCompressPictures = Bool(allow_none=True)\n\trefreshAllConnections = Bool(allow_none=True)\n\tdefaultThemeVersion = Integer(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t date1904=None,\n\t\t\t\t dateCompatibility=None,\n\t\t\t\t showObjects=None,\n\t\t\t\t showBorderUnselectedTables=None,\n\t\t\t\t filterPrivacy=None,\n\t\t\t\t promptedSolutions=None,\n\t\t\t\t showInkAnnotation=None,\n\t\t\t\t backupFile=None,\n\t\t\t\t saveExternalLinkValues=None,\n\t\t\t\t updateLinks=None,\n\t\t\t\t codeName=None,\n\t\t\t\t hidePivotFieldList=None,\n\t\t\t\t showPivotChartFilter=None,\n\t\t\t\t allowRefreshQuery=None,\n\t\t\t\t publishItems=None,\n\t\t\t\t checkCompatibility=None,\n\t\t\t\t autoCompressPictures=None,\n\t\t\t\t refreshAllConnections=None,\n\t\t\t\t defaultThemeVersion=None,\n\t\t\t\t):\n\t\tself.date1904 = date1904\n\t\tself.dateCompatibility = dateCompatibility\n\t\tself.showObjects = showObjects\n\t\tself.showBorderUnselectedTables = showBorderUnselectedTables\n\t\tself.filterPrivacy = filterPrivacy\n\t\tself.promptedSolutions = promptedSolutions\n\t\tself.showInkAnnotation = showInkAnnotation\n\t\tself.backupFile = backupFile\n\t\tself.saveExternalLinkValues = saveExternalLinkValues\n\t\tself.updateLinks = updateLinks\n\t\tself.codeName = codeName\n\t\tself.hidePivotFieldList = hidePivotFieldList\n\t\tself.showPivotChartFilter = showPivotChartFilter\n\t\tself.allowRefreshQuery = allowRefreshQuery\n\t\tself.publishItems = publishItems\n\t\tself.checkCompatibility = checkCompatibility\n\t\tself.autoCompressPictures = autoCompressPictures\n\t\tself.refreshAllConnections = refreshAllConnections\n\t\tself.defaultThemeVersion = defaultThemeVersion\n\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}, {"term": "class", "name": "CalcProperties", "data": "class CalcProperties(Serialisable):\n\n\ttagname = \"calcPr\"\n\n\tcalcId = Integer()\n\tcalcMode = NoneSet(values=(['manual', 'auto', 'autoNoTable']))\n\tfullCalcOnLoad = Bool(allow_none=True)\n\trefMode = NoneSet(values=(['A1', 'R1C1']))\n\titerate = Bool(allow_none=True)\n\titerateCount = Integer(allow_none=True)\n\titerateDelta = Float(allow_none=True)\n\tfullPrecision = Bool(allow_none=True)\n\tcalcCompleted = Bool(allow_none=True)\n\tcalcOnSave = Bool(allow_none=True)\n\tconcurrentCalc = Bool(allow_none=True)\n\tconcurrentManualCount = Integer(allow_none=True)\n\tforceFullCalc = Bool(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t calcId=124519,\n\t\t\t\t calcMode=None,\n\t\t\t\t fullCalcOnLoad=True,\n\t\t\t\t refMode=None,\n\t\t\t\t iterate=None,\n\t\t\t\t iterateCount=None,\n\t\t\t\t iterateDelta=None,\n\t\t\t\t fullPrecision=None,\n\t\t\t\t calcCompleted=None,\n\t\t\t\t calcOnSave=None,\n\t\t\t\t concurrentCalc=None,\n\t\t\t\t concurrentManualCount=None,\n\t\t\t\t forceFullCalc=None,\n\t\t\t\t):\n\t\tself.calcId = calcId\n\t\tself.calcMode = calcMode\n\t\tself.fullCalcOnLoad = fullCalcOnLoad\n\t\tself.refMode = refMode\n\t\tself.iterate = iterate\n\t\tself.iterateCount = iterateCount\n\t\tself.iterateDelta = iterateDelta\n\t\tself.fullPrecision = fullPrecision\n\t\tself.calcCompleted = calcCompleted\n\t\tself.calcOnSave = calcOnSave\n\t\tself.concurrentCalc = concurrentCalc\n\t\tself.concurrentManualCount = concurrentManualCount\n\t\tself.forceFullCalc = forceFullCalc\n\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}, {"term": "class", "name": "FileVersion", "data": "class FileVersion(Serialisable):\n\n\ttagname = \"fileVersion\"\n\n\tappName = String(allow_none=True)\n\tlastEdited = String(allow_none=True)\n\tlowestEdited = String(allow_none=True)\n\trupBuild = String(allow_none=True)\n\tcodeName = Guid(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t appName=None,\n\t\t\t\t lastEdited=None,\n\t\t\t\t lowestEdited=None,\n\t\t\t\t rupBuild=None,\n\t\t\t\t codeName=None,\n\t\t\t\t):\n\t\tself.appName = appName\n\t\tself.lastEdited = lastEdited\n\t\tself.lowestEdited = lowestEdited\n\t\tself.rupBuild = rupBuild\n\t\tself.codeName = codeName\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}], [{"term": "def", "name": "dummy", "data": "def dummy():\n\tnormal = np.random.normal(size=100000)\n\tlist1.append(np.sum(normal))\n\n", "description": null, "category": "math", "imports": ["import numba as numba", "import numpy as np", "import tensorflow as tf", "import torch", "from zfit_benchmark.timer import Timer"]}, {"term": "def", "name": "calc_np", "data": "def calc_np(x):\n\t# x = x.numpy()\n\t# dummy()\n\t# x = x * global_y.numpy()\n\t# x = zfit.run(x * global_y)\n\t# x *= var1.numpy()\n\tx_init = x\n\tlist1 = []\n\tfor i in range(n_loops):\n\t\tx = np.sqrt(np.abs(x_init))\n\t\tx = np.cos(x - 0.3)\n\t\tx = np.power(x, i + 1)\n\t\tx = np.sinh(x + 0.4)\n\t\tx = x ** 2\n\t\tx += np.random.normal(size=size)\n\t\tx /= np.mean(x)\n\t\tx = np.abs(x)\n\t\tlist1.append(x)\n\tx = np.sum(list1, axis=0)\n\tx = np.mean(np.log(x))\n\treturn x\n\n", "description": null, "category": "math", "imports": ["import numba as numba", "import numpy as np", "import tensorflow as tf", "import torch", "from zfit_benchmark.timer import Timer"]}, {"term": "def", "name": "calc_tf", "data": "def calc_tf(x):\n\tx_init = x\n\tlist1 = []\n\tfor i in tf.range(n_loops):\n\t# for i in range(n_loops):\n\t\tx = tf.sqrt(tf.abs(x_init * (tf.cast(i, dtype=tf.float64) + 1.)))\n\t\tprint(x)\n\t\tx = tf.cos(x - 0.3)\n\t\tx = tf.pow(x, tf.cast(i + 1, tf.float64))\n\t\tx = tf.sinh(x + 0.4)\n\t\t# print(\"calc_tf is being traced\")\n\t\tx = x ** 2\n\t\tx += tf.random.normal(shape=size, dtype=tf.float64)\n\t\tx /= tf.reduce_mean(x)\n\t\tx = tf.abs(x)\n\t\tlist1.append(x)\n\tx = tf.reduce_sum(x, axis=0)\n\tx = tf.reduce_mean(tf.math.log(x))\n\t# tf.py_function(dummy, [], Tout=[])\n\treturn x\n\n", "description": null, "category": "math", "imports": ["import numba as numba", "import numpy as np", "import tensorflow as tf", "import torch", "from zfit_benchmark.timer import Timer"]}, {"term": "def", "name": "calc_torch", "data": "def calc_torch(x):\n\tx_init = x\n\tlist1 = []\n\tfor i in range(n_loops):\n\t\tx = torch.sqrt(torch.abs(x_init))\n\t\tx = torch.cos(x - 0.3)\n\t\tx = torch.pow(x, i + 1)\n\t\tx = torch.sinh(x + 0.4)\n\t\tx = x ** 2\n\t\tx += torch.normal(mean=0, std=0, size=size)\n\t\tx /= torch.mean(x)\n\t\tx = torch.abs(x)\n\t\tlist1.append(x)\n\tlist1 = torch.stack(list1)\n\tx = torch.sum(list1, dim=0)\n\tx = torch.mean(torch.log(x))\n\treturn x.numpy()\n\n", "description": null, "category": "math", "imports": ["import numba as numba", "import numpy as np", "import tensorflow as tf", "import torch", "from zfit_benchmark.timer import Timer"]}, {"term": "def", "name": "calc_np_wrapped", "data": "def calc_np_wrapped(x):\n\treturn tf.py_function(calc_np, [x], Tout=tf.float32)\n\n", "description": null, "category": "math", "imports": ["import numba as numba", "import numpy as np", "import tensorflow as tf", "import torch", "from zfit_benchmark.timer import Timer"]}, {"term": "def", "name": "calc_torch_wrapped", "data": "def calc_torch_wrapped(x):\n\treturn tf.py_function(calc_torch, [x], Tout=tf.float32)\n\n", "description": null, "category": "math", "imports": ["import numba as numba", "import numpy as np", "import tensorflow as tf", "import torch", "from zfit_benchmark.timer import Timer"]}, {"term": "def", "name": "calc_np_numba", "data": "def calc_np_numba(x):\n\tfor i in range(n_loops):\n\t\tx = np.sqrt(np.abs(x))\n\t\tx = np.cos(x - 0.3)\n\t\tx = np.power(x, i)\n\t\tx = np.sinh(x + 0.4)\n\t\tx = x ** 2\n\t\tx = np.mean(np.log(x))\n\t\tx += np.random.normal(size=size)\n\treturn x\n\n", "description": null, "category": "math", "imports": ["import numba as numba", "import numpy as np", "import tensorflow as tf", "import torch", "from zfit_benchmark.timer import Timer"]}], [{"term": "class", "name": "\titisjustacoppyofaclassfromgscreenandhasbeenslighlymodified", "data": "\tit is just a coppy of a class from gscreen and has been slighly modified\n", "description": null, "category": "math", "imports": ["import gtk", "import gladevcp", "import pango", "import gobject"]}, {"term": "class", "name": "Dialogs", "data": "class Dialogs(gobject.GObject):\n\n\t__gtype_name__ = 'Dialogs'\n\n\t__gsignals__ = {\n\t\t\t\t'play_sound': (gobject.SIGNAL_RUN_FIRST, gobject.TYPE_NONE, (gobject.TYPE_STRING,)),\n\t\t\t   }\n\n\tdef __init__(self):\n\t\tgobject.GObject.__init__(self)\n\n\t# This dialog is for unlocking the system tab\n\t# The unlock code number is defined at the top of the page\n\tdef system_dialog(self, caller):\n\t\tdialog = gtk.Dialog(_(\"Enter System Unlock Code\"),\n\t\t\t\t   caller.widgets.window1,\n\t\t\t\t   gtk.DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t   (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,\n\t\t\t\t\tgtk.STOCK_OK, gtk.RESPONSE_ACCEPT))\n\t\tlabel = gtk.Label(_(\"Enter System Unlock Code\"))\n\t\tlabel.modify_font(pango.FontDescription(\"sans 20\"))\n\t\tcalc = gladevcp.Calculator()\n\t\tdialog.vbox.pack_start(label)\n\t\tdialog.vbox.add(calc)\n\t\tcalc.set_value(\"\")\n\t\tcalc.set_property(\"font\", \"sans 20\")\n\t\tcalc.set_editable(True)\n\t\tcalc.entry.connect(\"activate\", lambda w : dialog.emit(\"response\", gtk.RESPONSE_ACCEPT))\n\t\tdialog.parse_geometry(\"400x400\")\n\t\tdialog.set_decorated(True)\n\t\tdialog.show_all()\n\t\tself.emit(\"play_sound\", \"alert\")\n\t\tresponse = dialog.run()\n\t\tcode = calc.get_value()\n\t\tdialog.destroy()\n\t\tif response == gtk.RESPONSE_ACCEPT:\n\t\t\tif code == int(caller.unlock_code):\n\t\t\t\treturn True\n\t\treturn False\n\n\tdef entry_dialog(self, caller, data = None, header = _(\"Enter value\") , label = _(\"Enter the value to set\"), integer = False):\n\t\tdialog = gtk.Dialog(header,\n\t\t\t\t   caller.widgets.window1,\n\t\t\t\t   gtk.DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t   (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,\n\t\t\t\t\tgtk.STOCK_OK, gtk.RESPONSE_ACCEPT))\n\t\tlabel = gtk.Label(label)\n\t\tlabel.modify_font(pango.FontDescription(\"sans 20\"))\n\t\tcalc = gladevcp.Calculator()\n\t\tdialog.vbox.pack_start(label)\n\t\tdialog.vbox.add(calc)\n\t\tif data != None:\n\t\t\tcalc.set_value(data)\n\t\telse:\n\t\t\tcalc.set_value(\"\")\n\t\tcalc.set_property(\"font\", \"sans 20\")\n\t\tcalc.set_editable(True)\n\t\tcalc.entry.connect(\"activate\", lambda w : dialog.emit(\"response\", gtk.RESPONSE_ACCEPT))\n\t\tdialog.parse_geometry(\"400x400\")\n\t\tdialog.set_decorated(True)\n\t\tself.emit(\"play_sound\", \"alert\")\n\t\tif integer: # The user is only allowed to enter integer values, we hide some button\n\t\t\tcalc.num_pad_only(True)\n\t\t\tcalc.integer_entry_only(True)\n\t\tdialog.show_all()\n\t\tresponse = dialog.run()\n\t\tvalue = calc.get_value()\n\t\tdialog.destroy()\n\t\tif response == gtk.RESPONSE_ACCEPT:\n\t\t\tif value != None:\n\t\t\t\tif integer:\n\t\t\t\t\treturn int(value)\n\t\t\t\telse:\n\t\t\t\t\treturn float(value)\n\t\t\telse:\n\t\t\t\treturn \"ERROR\"\n\t\treturn \"CANCEL\"\n\n\t# display warning dialog\n\tdef warning_dialog(self, caller, message, secondary = None, title = _(\"Operator Message\"), sound = True):\n\t\tdialog = gtk.MessageDialog(caller.widgets.window1,\n\t\t\tgtk.DIALOG_DESTROY_WITH_PARENT,\n\t\t\tgtk.MESSAGE_INFO, gtk.BUTTONS_OK, message)\n\t\t# if there is a secondary message then the first message text is bold\n\t\tif secondary:\n\t\t\tdialog.format_secondary_text(secondary)\n\t\tdialog.show_all()\n\t\tif sound:\n\t\t\tself.emit(\"play_sound\", \"alert\")\n\t\tdialog.set_title(title)\n\t\tresponce = dialog.run()\n\t\tdialog.destroy()\n\t\treturn responce == gtk.RESPONSE_OK\n\n\tdef yesno_dialog(self, caller, message, title = _(\"Operator Message\")):\n\t\tdialog = gtk.MessageDialog(caller.widgets.window1,\n\t\t\t\t\t\t\t\t   gtk.DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t\t\t\t\t   gtk.MESSAGE_QUESTION,\n\t\t\t\t\t\t\t\t   gtk.BUTTONS_YES_NO)\n\t\tif title:\n\t\t\tdialog.set_title(str(title))\n\t\tdialog.set_markup(message)\n\t\tdialog.show_all()\n\t\tself.emit(\"play_sound\", \"alert\")\n\t\tresponce = dialog.run()\n\t\tdialog.destroy()\n\t\treturn responce == gtk.RESPONSE_YES\n\n\tdef show_user_message(self, caller, message, title = _(\"Operator Message\")):\n\t\tdialog = gtk.MessageDialog(caller.widgets.window1,\n\t\t\t\t\t\t\t\t   gtk.DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t\t\t\t\t   gtk.MESSAGE_INFO,\n\t\t\t\t\t\t\t\t   gtk.BUTTONS_OK)\n\t\tif title:\n\t\t\tdialog.set_title(str(title))\n\t\tdialog.set_markup(message)\n\t\tdialog.show_all()\n\t\tself.emit(\"play_sound\", \"alert\")\n\t\tresponce = dialog.run()\n\t\tdialog.destroy()\n\t\treturn responce == gtk.RESPONSE_OK\n\n\t# dialog for run from line\n\tdef restart_dialog(self, caller):\n\n\t\t# highlight the gcode down one line lower\n\t\t# used for run-at-line restart\n\t\tdef restart_down(widget, obj, calc):\n\t\t\tobj.widgets.gcode_view.line_down()\n\t\t\tline = int(obj.widgets.gcode_view.get_line_number())\n\t\t\tcalc.set_value(line)\n\n\t\t# highlight the gcode down one line higher\n\t\t# used for run-at-line restart\n\t\tdef restart_up(widget, obj, calc):\n\t\t\tobj.widgets.gcode_view.line_up()\n\t\t\tline = int(obj.widgets.gcode_view.get_line_number())\n\t\t\tcalc.set_value(line)\n\n\t\t# highlight the gcode of the entered line\n\t\t# used for run-at-line restart\n\t\tdef enter_button(widget, obj, calc):\n\t\t\tline = int(calc.get_value())\n\t\t\tobj.start_line = line\n\t\t\tobj.widgets.gcode_view.set_line_number(line)\n\n\t\trestart_dialog = gtk.Dialog(_(\"Restart Entry\"),\n\t\t\t\t   caller.widgets.window1, gtk.DIALOG_DESTROY_WITH_PARENT,\n\t\t\t\t   (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,\n\t\t\t\t\t gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))\n\t\tlabel = gtk.Label(_(\"Restart Entry\"))\n\t\tlabel.modify_font(pango.FontDescription(\"sans 20\"))\n\t\trestart_dialog.vbox.pack_start(label)\n\t\tcalc = gladevcp.Calculator()\n\t\trestart_dialog.vbox.add(calc)\n\t\tcalc.set_value(\"%d\" % caller.widgets.gcode_view.get_line_number())\n\t\tcalc.set_property(\"font\", \"sans 20\")\n\t\tcalc.set_editable(True)\n\t\tcalc.num_pad_only(True)\n\t\tcalc.integer_entry_only(True)\n\t\tcalc.entry.connect(\"activate\", enter_button, caller, calc)\n\t\tbox = gtk.HButtonBox()\n\t\tupbutton = gtk.Button(label = _(\"Up\"))\n\t\tbox.add(upbutton)\n\t\tenterbutton = gtk.Button(label = _(\"Enter\"))\n\t\tbox.add(enterbutton)\n\t\tdownbutton = gtk.Button(label = _(\"Down\"))\n\t\tbox.add(downbutton)\n\t\tcalc.calc_box.pack_end(box, expand = False, fill = False, padding = 0)\n\t\tupbutton.connect(\"clicked\", restart_up, caller, calc)\n\t\tdownbutton.connect(\"clicked\", restart_down, caller, calc)\n\t\tenterbutton.connect(\"clicked\", enter_button, caller, calc)\n\t\trestart_dialog.parse_geometry(\"400x400+0+0\")\n\t\trestart_dialog.show_all()\n\t\tself.emit(\"play_sound\", \"alert\")\n\t\tresult = restart_dialog.run()\n\t\trestart_dialog.destroy()\n\t\tif result == gtk.RESPONSE_REJECT:\n\t\t\tline = 0\n\t\telse:\n\t\t\tline = int(calc.get_value())\n\t\t\tif line == None:\n\t\t\t\tline = 0\n\t\tcaller.widgets.gcode_view.set_line_number(line)\n\t\tcaller.start_line = line\n", "description": null, "category": "math", "imports": ["import gtk", "import gladevcp", "import pango", "import gobject"]}], [{"term": "def", "name": "check_i_derivs", "data": "  def check_i_derivs():\n\tg_ana = trg.i_gradients\n\tc_ana = trg.i_curvatures\n\teps = 1e-6\n\tg_fin = flex.double()\n\tc_fin = flex.double()\n\tfor ih in range(i_calc.size()):\n\t  fs = []\n\t  gs = []\n\t  c_orig = i_calc[ih]\n\t  for signed_eps in [eps, -eps]:\n\t\ti_calc[ih] = c_orig + signed_eps\n\t\ttrg_eps = kwt2(\n\t\t  f_obs=f_obs, i_obs=i_obs, i_sig=i_sig,\n\t\t  f_calc=None, i_calc=i_calc, wa=wa, wb=wb)\n\t\tfs.append(trg_eps.target)\n\t\tgs.append(trg_eps.i_gradients[ih])\n\t  g_fin.append((fs[0]-fs[1])/(2*eps))\n\t  c_fin.append((gs[0]-gs[1])/(2*eps))\n\t  i_calc[ih] = c_orig\n\tassert approx_equal(g_ana, g_fin)\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cctbx.xray.targets", "from cctbx.array_family import flex", "from libtbx.test_utils import approx_equal", "from six.moves import range", "  import sys"]}, {"term": "def", "name": "check_f_derivs", "data": "  def check_f_derivs():\n\tg_ana = trg.f_gradients\n\tc_ana = trg.f_hessians\n\teps = 1e-6\n\tg_fin = flex.complex_double()\n\tc_fin = flex.vec3_double()\n\tfor ih in range(i_calc.size()):\n\t  c_orig = f_calc[ih]\n\t  g_fin_ab = []\n\t  c_fin_ab = []\n\t  for iab in [0,1]:\n\t\tfs = []\n\t\tgs = []\n\t\tfor signed_eps in [eps, -eps]:\n\t\t  if (iab == 0):\n\t\t\tf_calc[ih] = complex(c_orig.real + signed_eps, c_orig.imag)\n\t\t  else:\n\t\t\tf_calc[ih] = complex(c_orig.real, c_orig.imag + signed_eps)\n\t\t  trg_eps = kwt2(\n\t\t\tf_obs=f_obs, i_obs=i_obs, i_sig=i_sig,\n\t\t\tf_calc=f_calc, i_calc=None, wa=wa, wb=wb)\n\t\t  fs.append(trg_eps.target)\n\t\t  gs.append(trg_eps.f_gradients[ih])\n\t\tg_fin_ab.append((fs[0]-fs[1])/(2*eps))\n\t\tc_fin_ab.append((gs[0]-gs[1])/(2*eps))\n\t  g_fin.append(complex(*g_fin_ab))\n\t  assert approx_equal(c_fin_ab[0].imag, c_fin_ab[1].real)\n\t  c_fin.append((c_fin_ab[0].real, c_fin_ab[1].imag, c_fin_ab[0].imag))\n\t  f_calc[ih] = c_orig\n\tassert approx_equal(g_ana, g_fin)\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cctbx.xray.targets", "from cctbx.array_family import flex", "from libtbx.test_utils import approx_equal", "from six.moves import range", "  import sys"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "test_vasp_wdir", "data": "def test_vasp_wdir(factory, atoms_co):\n\t\"\"\"Run tests to ensure that the VASP txt and label arguments function\n\tcorrectly, i.e. correctly sets the working directories and works\n\tin that directory.\n\n\tThis is conditional on the existence of the ASE_VASP_COMMAND,\n\tVASP_COMMAND or VASP_SCRIPT environment variables\"\"\"\n\n\tdef compare_paths(path1, path2):\n\t\tassert os.path.abspath(path1) == os.path.abspath(path2)\n\n\tatoms = atoms_co  # Aliasing\n\n\tfile1 = '_vasp_dummy_str.out'\n\tfile2 = '_vasp_dummy_io.out'\n\tfile3 = '_vasp_dummy_2.out'\n\n\ttestdir = '_dummy_txt_testdir'\n\tlabel = os.path.join(testdir, 'vasp')\n\n\t# Test\n\tsettings = dict(label=label,\n\t\t\t\t\txc='PBE',\n\t\t\t\t\tprec='Low',\n\t\t\t\t\talgo='Fast',\n\t\t\t\t\tismear=0,\n\t\t\t\t\tsigma=1.,\n\t\t\t\t\tistart=0,\n\t\t\t\t\tlwave=False,\n\t\t\t\t\tlcharg=False)\n\n\t# Make 2 copies of the calculator object\n\tcalc = factory.calc(**settings)\n\tcalc2 = factory.calc(**settings)\n\n\t# Check the calculator path is the expected path\n\tcompare_paths(calc.directory, testdir)\n\n\tcalc.set(txt=file1)\n\tatoms.calc = calc\n\ten1 = atoms.get_potential_energy()\n\n\t# Check that the output files are in the correct directory\n\tfor fi in ['OUTCAR', 'CONTCAR', 'vasprun.xml']:\n\t\tfi = os.path.join(testdir, fi)\n\t\tassert os.path.isfile(fi)\n\n\t# We open file2 in our current directory, so we don't want it to write\n\t# in the label directory\n\twith open(file2, 'w') as fd:\n\t\tcalc2.set(txt=fd)\n\t\tatoms.calc = calc2\n\t\tatoms.get_potential_energy()\n\n\t# Test restarting from working directory in test directory\n\tlabel2 = os.path.join(testdir, file3)\n\tcalc2 = factory.calc(restart=label, label=label2)\n\n\t# Check the calculator path is the expected path\n\tcompare_paths(calc2.directory, testdir)\n\n\tassert not calc2.calculation_required(calc2.atoms, ['energy', 'forces'])\n\ten2 = calc2.get_potential_energy()\n\n\t# Check that the restarted calculation didn't run, i.e. write to output file\n\tassert not os.path.isfile(os.path.join(calc.directory, file3))\n\n\t# Check that we loaded energy correctly\n\tassert en1 == en2\n", "description": "Run tests to ensure that the VASP txt and label arguments function\n\tcorrectly, i.e. correctly sets the working directories and works\n\tin that directory.\n\n\tThis is conditional on the existence of the ASE_VASP_COMMAND,\n\tVASP_COMMAND or VASP_SCRIPT environment variables", "category": "math", "imports": ["import os", "import pytest"]}], [{"term": "def", "name": "test_qpsk", "data": "def test_qpsk(i, sample, prec):\n\tqpsk_const_list = [psk_4_0, psk_4_1, psk_4_2, psk_4_3,\n\t\t\t\t\t   psk_4_4, psk_4_5, psk_4_6, psk_4_7]\n\tqpsk_lut_gen_list = [sd_psk_4_0, sd_psk_4_1, sd_psk_4_2, sd_psk_4_3,\n\t\t\t\t\t\t sd_psk_4_4, sd_psk_4_5, sd_psk_4_6, sd_psk_4_7]\n\n\tconstel, code = qpsk_const_list[i]()\n\tqpsk_lut_gen = qpsk_lut_gen_list[i]\n\n\trot_sym = 1\n\tside = 2\n\twidth = 2\n\tc = digital.constellation_rect(constel, code, rot_sym,\n\t\t\t\t\t\t\t\t   side, side, width, width)\n\n\t# Get max energy/symbol in constellation\n\tconstel = c.points()\n\tEs = max([numpy.sqrt(constel_i.real**2 + constel_i.imag**2) for constel_i in constel])\n\n\t#table = soft_dec_table_generator(qpsk_lut_gen, prec, Es)\n\ttable = soft_dec_table(constel, code, prec)\n\n\tc.gen_soft_dec_lut(prec)\n\t#c.set_soft_dec_lut(table, prec)\n\n\ty_python_gen_calc = qpsk_lut_gen(sample, Es)\n\ty_python_table = calc_soft_dec_from_table(sample, table, prec, Es)\n\ty_python_raw_calc = calc_soft_dec(sample, constel, code)\n\ty_cpp_table = c.soft_decision_maker(sample)\n\ty_cpp_raw_calc = c.calc_soft_dec(sample)\n\n\treturn (y_python_gen_calc, y_python_table, y_python_raw_calc,\n\t\t\ty_cpp_table, y_cpp_raw_calc, constel, code, c)\n", "description": null, "category": "math", "imports": ["import numpy, pylab, sys", "from gnuradio import digital", "from soft_dec_lut_gen import *", "from psk_constellations import *", "from qam_constellations import *"]}, {"term": "def", "name": "test_qam16", "data": "def test_qam16(i, sample, prec):\n\tsample = sample/1\n\tqam_const_list = [qam_16_0, ]\n\tqam_lut_gen_list = [sd_qam_16_0, ]\n\n\tconstel, code = qam_const_list[i]()\n\tqam_lut_gen = qam_lut_gen_list[i]\n\n\trot_sym = 4\n\tside = 2\n\twidth = 2\n\tc = digital.constellation_rect(constel, code, rot_sym,\n\t\t\t\t\t\t\t\t   side, side, width, width)\n\n\t# Get max energy/symbol in constellation\n\tconstel = c.points()\n\tEs = max([abs(constel_i) for constel_i in constel])\n\n\t#table = soft_dec_table_generator(qam_lut_gen, prec, Es)\n\ttable = soft_dec_table(constel, code, prec, 1)\n\n\t#c.gen_soft_dec_lut(prec)\n\tc.set_soft_dec_lut(table, prec)\n\n\ty_python_gen_calc = qam_lut_gen(sample, Es)\n\ty_python_table = calc_soft_dec_from_table(sample, table, prec, Es)\n\ty_python_raw_calc = calc_soft_dec(sample, constel, code, 1)\n\ty_cpp_table = c.soft_decision_maker(sample)\n\ty_cpp_raw_calc = c.calc_soft_dec(sample)\n\n\treturn (y_python_gen_calc, y_python_table, y_python_raw_calc,\n\t\t\ty_cpp_table, y_cpp_raw_calc, constel, code, c)\n", "description": null, "category": "math", "imports": ["import numpy, pylab, sys", "from gnuradio import digital", "from soft_dec_lut_gen import *", "from psk_constellations import *", "from qam_constellations import *"]}], [{"term": "class", "name": "classTestAnswer:", "data": "class TestAnswer:\n\t@pytest.fixture(scope=\"module\")\n\tdef calc(self, loader):\n\t\treturn loader(\"precedencia.answer\").eval_calc\n\n\tdef test_exemplos_simples(self, calc):\n\t\tassert calc(\"40 + 2\") == 42.0\n\t\tassert calc(\"21 * 2\") == 42.0\n\t\tassert calc(\"50 - 8\") == 42.0\n\t\tassert calc(\"84 / 2\") == 42.0\n\t\tassert calc(\"2 ^ 3\") == 8.0\n\n\tdef test_cadeias(self, calc):\n\t\tassert calc(\"1 + 2 + 3 + 4\") == 10\n\t\tassert calc(\"10 - 3 - 2 - 1\") == 4\n\n\tdef test_agrupamentos_com_parenteses(self, calc):\n\t\tcalc(\"2 * (3 + 4)\") == 14\n\t\tcalc(\"(42)\") == 42\n\t\tcalc(\"(21 + 21) * 2\") == 42\n\n\t@pytest.mark.parametrize(\"op1,op2\", [(x, y) for x in \"+-*/^\" for y in \"+-*/^\"])\n\tdef test_todos_os_pares_de_operadores(self, op1, op2, calc):\n\t\tsrc = f\"1.0 {op1} 2.0 {op2} 3.0\"\n\t\tres = calc(src)\n\t\tpy = eval(src.replace(\"^\", \"**\"))\n\n\t\tprint(\"testing:\", src)\n\t\tassert abs(res - py) <= 1e-9, f\"{src} => {res} (esperava {py})\"\n\n", "description": null, "category": "math", "imports": ["import pytest"]}, {"term": "class", "name": "TestSubmission", "data": "class TestSubmission(TestAnswer):\n\t@pytest.fixture(scope=\"module\")\n\tdef calc(self, loader):\n\t\treturn loader(\"precedencia\").eval_calc\n", "description": null, "category": "math", "imports": ["import pytest"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "class", "name": "Parent", "data": "class Parent(object):\t\t\t   # \u0438\u0434\u0435\u043d\u0442\u0438\u0447\u043d\u043e: Parent:\t\t \u0420\u041e\u0414\u0418\u0422\u0415\u041b\u042c\u0421\u041a\u0418\u0419 \u041a\u041b\u0410\u0421\u0421\n\tdef __init__(self):\t\t\t # \u0441\u0449\u0437\u0434\u0430\u0435\u043c \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n\t\tprint('Parent inited')\n\t\tself.value = 'Parent'\t   # \u0438\u043c\u0435\u044e\u0449\u0438\u0445 \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u0443\u044e \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e Parent\n\n\tdef do(self):\t\t\t\t\t# \u043f\u0435\u0447\u0430\u0442\u0430\u0435\u043c \u0442\u0435\u043a\u0441\u0442 \u0441 \u044d\u0442\u043e\u0439 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439\n\t\tprint('Parent do(): {}'.format(self.value))\n", "description": null, "category": "math", "imports": []}, {"term": "class", "name": "Child", "data": "class Child(Parent):\t\t\t\t # \u041a\u041e\u041d\u0421\u0422\u0420\u0423\u041a\u0422\u041e\u0420 \u041d\u0410\u0421\u041b\u0415\u0414\u041d\u0418\u041a\u0410\n\tdef __init__(self):\n\t\tprint('Child inited')\n\t\tself.value = 'Child'\n", "description": null, "category": "math", "imports": []}, {"term": "class", "name": "Calc", "data": "class Calc(object):\t\t\t\t   # \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u043a\u043b\u0430\u0441\u0441\n\tdef __init__(self, number):\n\t\tself.number = number\t\t  # \u0441\u0449\u0437\u0434\u0430\u0435\u043c \u043e\u0431\u044a\u0435\u043a\u0442 \u0441 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 number\n\tdef calc_and_print(self):\n\t\tvalue = self.calc_value()\t # \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044f value \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043c\u0435\u0442\u043e\u0434\u0430 calc_value\n\t\tself.print_number(value)\t  # \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f value \u043f\u0435\u0440\u0435\u0434\u0430\u0435\u0442\u0441\u044f \u043c\u0435\u0442\u043e\u0434\u0443 print_number\n\tdef calc_value(self):\n\t\treturn self.number * 10 + 2\t\t\t\t # \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e value\n\tdef print_number(self, value_to_print):\n\t\tprint('-----')\n\t\tprint('Number is', value_to_print)\t\t  # \u043f\u0435\u0447\u0430\u0442\u0430\u0435\u043c \u0432\u0441\u0435 \u0441 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 value\n", "description": null, "category": "math", "imports": []}, {"term": "class", "name": "CalcExtraValue", "data": "class CalcExtraValue(Calc):\t\t\t\t\t\t   #  \u0421\u0449\u0437\u0434\u0430\u0435\u043c \u043a\u043b\u0430\u0441\u0441 \u043d\u0430\u0441\u043b\u0435\u0434\u043d\u0438\u043a.\n\tdef calc_value(self):\n\t\treturn self.number -100\t\t\t\t\t   # \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e number - 100\n", "description": null, "category": "math", "imports": []}, {"term": "class", "name": "Calc", "data": "class Calc(object):\n\tdef __init__(self, value):\t\t\t\t\t # \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u043c\u0435\u0442\u043e\u0434\n\t\tprint('Calc constructor is called')\n\t\tself.value = value\t\t\t\t\t\t # \u043d\u0430\u0437\u044b\u0432\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e value\n\n\tdef count(self):\n\t\treturn self.value * 8 + 9\t\t\t\t   # \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0441 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u044b\u043c\u0438 \u0430\u0440. \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f\u043c\u0438\n", "description": null, "category": "math", "imports": []}, {"term": "class", "name": "ExtendedCalc", "data": "class ExtendedCalc(Calc):\t\t\t\t\t\t   # \u043a\u043b\u0430\u0441\u0441 \u043d\u0430\u0441\u043b\u0435\u0434\u043d\u0438\u043a\u0430\n\tdef __init__(self, value, k = 1):\n\t\tsuper(). __init__(value)\t\t\t\t\t# \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u043c\u0435\u043e\u0434 __init__ \u0441 \u043f\u043e\u043c\u043e\u0449\u044c\u044e super\n\t\tprint('Extender', self.value)\t\t\t   # \u043f\u0435\u0447\u0430\u0442\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e value \u0432 \u0434\u0430\u043d\u043d\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u0438\u0437 \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u043a\u043b\u0430\u0441\u0441\u0430\n\n\t\tself.k = k\n\n\tdef count (self):\n\t\tprint('Before')\n\t\tprevious = super().count()\t\t\t\t  # \u043d\u0430\u0437\u043d\u0430\u0447\u0430\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0443\u044e \u0447\u0435\u0440\u0435\u0437 \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u0438\u0439 \u043c\u0435\u0442\u043e\u0434 cout\n\n\t\treturn -1 * self.k * previous\t\t\t\t# \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\n", "description": null, "category": "math", "imports": []}], [{"term": "class", "name": "TestsCalculatorBaseFunctionality", "data": "class TestsCalculatorBaseFunctionality(unittest.TestCase):\n\tdef test_add(self):\n\t\tcalc = Calculator(10, 20)\n\t\tresult = calc.calc_add()\n\t\tself.assertEqual(result, 30)\n\n\tdef test_diff(self):\n\t\tcalc = Calculator(100, 20)\n\t\tresult = calc.calc_diff()\n\t\tself.assertEqual(result, 80)\n\n\tdef test_prod(self):\n\t\tcalc = Calculator(10, 20)\n\t\tresult = calc.calc_prod()\n\t\tself.assertEqual(result, 200)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from unit_testing_02.calculator_v3 import Calculator"]}, {"term": "class", "name": "TestsCalculatorAddFunctionality", "data": "class TestsCalculatorAddFunctionality(unittest.TestCase):\n\tdef test_add_two_positive_numbers(self):\n\t\tcalc = Calculator(10, 20)\n\t\tresult = calc.calc_add()\n\t\tself.assertEqual(result, 30)\n\n\tdef test_add_one_positive_number_and_one_negative(self):\n\t\tcalc = Calculator(50, -90)\n\t\tresult = calc.calc_add()\n\t\tself.assertEqual(result, -40)\n\n\tdef test_add_two_negative_numbers(self):\n\t\tcalc = Calculator(-10, -20)\n\t\tresult = calc.calc_add()\n\t\tself.assertEqual(result, -30)\n\n\tdef test_add_two_positive_decimal_numbers(self):\n\t\tcalc = Calculator(10.55, 20.97)\n\t\tresult = calc.calc_add()\n\t\tself.assertEqual(result, 31.52)\n", "description": null, "category": "math", "imports": ["import unittest", "from unit_testing_02.calculator_v3 import Calculator"]}], [{"term": "def", "name": "calculate", "data": "def calculate(prompt):\n\t\"\"\"\n\tChecks if the input prompt contains certain keywords then\n\tperforms mathematical functions on the input string.\n\tThe string must follow certain rules for each equation listed below:\n\t\taddition: command - 'calculate number plus number' or\n\t\t\t\t\t\t\t'calculate number add number'\n\t\tsubtraction: command - 'calculate number minus number' or\n\t\t\t\t\t\t\t'calculate number subtract number' or\n\t\t\t\t\t\t\t'calculate number subtracted by number'\n\t\tmultiplication: command - 'calculate number times number' or\n\t\t\t\t\t\t\t\t'calculate number multiplied by number'\n\t\tdivision: command - 'calculate number divided by number' or\n\t\t\t\t\t\t\t'calculate number multiplied by number'\n\t\texponential: command - 'calculate number to the power of number' or\n\t\t\t\t\t\t\t\t'calculate number to the power number' or\n\t\t\t\t\t\t\t\t'calculate number power number'\n\t\tsquare root: command - 'calculate the square root of number'\n\t\tfactorial: command - 'calculate number factorial'\n\t\tlogarithmic: command - 'calculate log base number of number'\n\t:param prompt:\n\t:return: a tuple of the result and the formula\n\t\"\"\"\n\tif 'add' in prompt:\n\t\t\"\"\"Splits the command at 'add' then adds the 2 numbers from the prompt: 'calculate number add number'\"\"\"\n\t\tcalc_prompt = prompt.split('add')\n\t\tresult = round(float(calc_prompt[0]) + float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif '+' in prompt:\n\t\t\"\"\"Splits the command at '+' then adds the 2 numbers from the prompt: 'calculate number plus number'\"\"\"\n\t\tcalc_prompt = prompt.split('+')\n\t\tresult = round(float(calc_prompt[0]) + float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif '-' in prompt:\n\t\t\"\"\"Splits the command at '-' then subtracts the 2nd number from the 1st from the prompt: 'calculate number minus number'\"\"\"\n\t\tcalc_prompt = prompt.split('-')\n\t\tprompt = prompt.replace('-', 'minus')\n\t\tresult = round(float(calc_prompt[0]) - float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif 'subtract' in prompt:\n\t\t\"\"\"Splits the command at 'subtract' then subtracts the 2nd number from the 1st from the prompt: 'calculate number subtract number'\"\"\"\n\t\tcalc_prompt = prompt.split('subtract')\n\t\tprompt = prompt.replace('subtract', 'minus')\n\t\tresult = round(float(calc_prompt[0]) - float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif 'subtracted by' in prompt:\n\t\t\"\"\"Splits the command at 'subtracted by' then subtracts the 2nd number from the 1st from the prompt: 'calculate number subtracted by number'\"\"\"\n\t\tcalc_prompt = prompt.split('subtracted by')\n\t\tprompt = prompt.replace('subtracted by', 'minus')\n\t\tresult = round(float(calc_prompt[0]) - float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif 'times' in prompt:\n\t\t\"\"\"Splits the command at 'times' then multiplied the 2 numbers from the prompt: 'calculate number times number'\"\"\"\n\t\tcalc_prompt = prompt.split('times')\n\t\tresult = round(float(calc_prompt[0]) * float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif 'multiplied by' in prompt:\n\t\t\"\"\"Splits the command at 'multiplied by' then multiplies the 2 numbers from the prompt: 'calculate number multiplied by number'\"\"\"\n\t\tcalc_prompt = prompt.split('multiplied by')\n\t\tresult = round(float(calc_prompt[0]) * float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif '*' in prompt:\n\t\t\"\"\"Splits the command at '*' then multiplies the 2 numbers from the prompt: 'calculate number times number'\"\"\"\n\t\tcalc_prompt = prompt.split('*')\n\t\tprompt = prompt.replace('*', 'times')\n\t\tresult = round(float(calc_prompt[0]) * float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif '/' in prompt:\n\t\t\"\"\"Splits the command at '/' then divides the 1st number by the 2nd number from the prompt: 'calculate number divided by number'\"\"\"\n\t\tcalc_prompt = prompt.split('/')\n\t\tprompt = prompt.replace('/', 'divided by')\n\t\tresult = round(float(calc_prompt[0]) / float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif 'divided by' in prompt:\n\t\t\"\"\"Splits the command at 'divided by' then divides the 1st number by the 2nd number from the prompt: 'calculate number divided by number'\"\"\"\n\t\tcalc_prompt = prompt.split('divided by')\n\t\tresult = round(float(calc_prompt[0]) / float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif 'to the power of' in prompt:\n\t\t\"\"\"Splits the command at 'to the power of' then takes the 1st number to the power of the 2nd number from the prompt: 'calculate number to the power of number'\"\"\"\n\t\tcalc_prompt = prompt.split('to the power of')\n\t\tresult = round(float(calc_prompt[0]) ** float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif 'to the power' in prompt:\n\t\t\"\"\"Splits the command at 'to the power' then takes the 1st number to the power of the 2nd number from the prompt: 'calculate number to the power number'\"\"\"\n\t\tcalc_prompt = prompt.split('to the power')\n\t\tprompt = prompt.replace('to the power', 'to the power of')\n\t\tresult = round(float(calc_prompt[0]) ** float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif 'power' in prompt:\n\t\t\"\"\"Splits the command at 'power' then takes the 1st number to the power of the 2nd number from the prompt: 'calculate number power number'\"\"\"\n\t\tcalc_prompt = prompt.split('power')\n\t\tprompt = prompt.replace('power', 'to the power of')\n\t\tresult = round(float(calc_prompt[0]) ** float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif '^' in prompt:\n\t\t\"\"\"Splits the command at '^' then takes the 1st number to the power of the 2nd number from the prompt: 'calculate number to the power of number'\"\"\"\n\t\tcalc_prompt = prompt.split('^')\n\t\tprompt = prompt.replace('^', 'to the power of')\n\t\tresult = round(float(calc_prompt[0]) ** float(calc_prompt[1]), 2)\n\t\treturn (result, prompt)\n\n\tif 'the square root of' in prompt:\n\t\t\"\"\"Remove 'the square root of' from the command then takes the square root of the number from the prompt: 'calculate the square root of number'\"\"\"\n\t\tcalc_prompt = prompt.replace('the square root of', '')\n\t\tresult = round(math.sqrt(float(calc_prompt)), 2)\n\t\treturn (result, prompt)\n\n\tif 'factorial' in prompt:\n\t\t\"\"\"Removes 'factorial' from the command then takes the factorial of the number from the prompt: 'calculate number factorial'\"\"\"\n\t\tcalc_prompt = prompt.replace('factorial', '')\n\t\tresult = round(math.factorial(float(calc_prompt)), 2)\n\t\treturn (result, prompt)\n\n\tif 'log base' in prompt:\n\t\t\"\"\"Removes 'log base' and 'of' from the command then takes the log base(1st number) of the 2nd number  from the prompt: 'calculate number factorial'\"\"\"\n\t\tcalc_prompt = prompt.replace(' log base ', '').replace(' of', '')\n\t\tcalc_prompt = calc_prompt.split(' ')\n\t\tprint('calc_prompt:', calc_prompt)\n\t\tresult = round(math.log(float(calc_prompt[1]), float(calc_prompt[0])), 2)\n\t\treturn (result, prompt)\n", "description": "\n\tChecks if the input prompt contains certain keywords then\n\tperforms mathematical functions on the input string.\n\tThe string must follow certain rules for each equation listed below:\n\t\taddition: command - 'calculate number plus number' or\n\t\t\t\t\t\t\t'calculate number add number'\n\t\tsubtraction: command - 'calculate number minus number' or\n\t\t\t\t\t\t\t'calculate number subtract number' or\n\t\t\t\t\t\t\t'calculate number subtracted by number'\n\t\tmultiplication: command - 'calculate number times number' or\n\t\t\t\t\t\t\t\t'calculate number multiplied by number'\n\t\tdivision: command - 'calculate number divided by number' or\n\t\t\t\t\t\t\t'calculate number multiplied by number'\n\t\texponential: command - 'calculate number to the power of number' or\n\t\t\t\t\t\t\t\t'calculate number to the power number' or\n\t\t\t\t\t\t\t\t'calculate number power number'\n\t\tsquare root: command - 'calculate the square root of number'\n\t\tfactorial: command - 'calculate number factorial'\n\t\tlogarithmic: command - 'calculate log base number of number'\n\t:param prompt:\n\t:return: a tuple of the result and the formula\n\t", "category": "math", "imports": ["import math"]}], [], [{"term": "def", "name": "test_vasp_check_state", "data": "def test_vasp_check_state(factory, atoms_2co):\n\t\"\"\"\n\tRun tests to ensure that the VASP check_state() function call works correctly,\n\ti.e. correctly sets the working directories and works in that directory.\n\n\tThis is conditional on the existence of the VASP_COMMAND or VASP_SCRIPT\n\tenvironment variables\n\n\t\"\"\"\n\n\tatoms = atoms_2co  # aliasing\n\n\t# Test\n\tsettings = dict(xc='LDA',\n\t\t\t\t\tprec='Low',\n\t\t\t\t\talgo='Fast',\n\t\t\t\t\tismear=0,\n\t\t\t\t\tsigma=1.,\n\t\t\t\t\tistart=0,\n\t\t\t\t\tlwave=False,\n\t\t\t\t\tlcharg=False)\n\n\ts1 = atoms.get_chemical_symbols()\n\n\tcalc = factory.calc(**settings)\n\n\tatoms.calc = calc\n\n\ten1 = atoms.get_potential_energy()\n\n\t# Test JSON dumping and restarting works\n\tfi = 'json_test.json'\n\tcalc.write_json(filename=fi)\n\n\tassert os.path.isfile(fi)\n\n\tcalc2 = factory.calc()\n\tcalc2.read_json(fi)\n\tassert not calc2.calculation_required(atoms, ['energy', 'forces'])\n\ten2 = calc2.get_potential_energy()\n\tassert abs(en1 - en2) < 1e-8\n\tos.remove(fi)  # Clean up the JSON file\n\n\t# Check that the symbols remain in order (non-sorted)\n\ts2 = calc.atoms.get_chemical_symbols()\n\tassert s1 == s2\n\ts3 = sorted(s2)\n\tassert s2 != s3\n\n\t# Check that get_atoms() doesn't reset results\n\tr1 = dict(calc.results)  # Force a copy\n\tcalc.get_atoms()\n\tr2 = dict(calc.results)\n\tassert r1 == r2\n\n\t# Make a parameter change to the calculator\n\tcalc.set(sigma=0.5)\n\n\t# Check that we capture a change for float params\n\tassert calc.check_state(atoms) == ['float_params']\n\tassert calc.calculation_required(atoms, ['energy', 'forces'])\n\n\ten2 = atoms.get_potential_energy()\n\n\t# The change in sigma should result in a small change in energy\n\tassert (en1 - en2) > 1e-7\n\n\t# Now we make a change in input_params instead\n\tcalc.kpts = 2\n\n\t# Check that this requires a new calculation\n\tassert calc.check_state(atoms) == ['input_params']\n\tassert calc.calculation_required(atoms, ['energy', 'forces'])\n\n\t# Clean up\n\tcalc.clean()\n", "description": "\n\tRun tests to ensure that the VASP check_state() function call works correctly,\n\ti.e. correctly sets the working directories and works in that directory.\n\n\tThis is conditional on the existence of the VASP_COMMAND or VASP_SCRIPT\n\tenvironment variables\n\n\t", "category": "math", "imports": ["import os", "import pytest"]}], [{"term": "def", "name": "speak", "data": "def speak(audio):\r\n\tengine.say(audio)\r\n\tengine.runAndWait()\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "getvoices", "data": "def getvoices(voice):\r\n\tvoices = engine.getProperty('voices')\r\n\tif voice ==1:\r\n\t\tengine.setProperty('voice', voices[1].id)  # SELECTEAZA VOCEA\r\n\t\tspeak(\"Modul Romana activat\")\r\n\tif voice ==2:\r\n\t\tengine.setProperty('voice', voices[2].id)  # SELECTEAZA VOCEA\r\n\t\tspeak(\"English mode on\")\r\n\r\n\r\n\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "time_funct", "data": "def time_funct():\r\n\tTime = datetime.datetime.now().strftime('%I:%M:%S') # hour = I minutes = M seconds = S\r\n\tspeak(f'Ora curent\u0103 este {Time}')\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "date", "data": "def date():\r\n\tdateX = datetime.datetime.now()\r\n\tspeak(f'Data curent\u0103 este {dateX.day}/{dateX.month}/{dateX.year}')\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "greetings", "data": "def greetings():\r\n\thour = datetime.datetime.now().hour\r\n\tif hour >= 6 and hour <12:\r\n\t\tspeak('Bun\u0103 diminea\u021ba domnule!')\r\n\telif hour >= 12 and hour < 18:\r\n\t\tspeak('Bun\u0103 ziua domnule!')\r\n\telif hour >= 18 and hour < 24:\r\n\t\tspeak('Bun\u0103 seara domnule!')\r\n\telse:\r\n\t\tspeak('Cam t\u00e2rziu nu crede\u0163i domnule?')\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "send_email", "data": "def send_email(receiver, subject, content):\r\n\tserver = smtplib.SMTP('smtp.gmail.com', 587) # this is the server for the GMAIL\r\n\tserver.starttls() # transmitere securizata\r\n\tserver.login(senderemail, email_pwd)\r\n\t# server.sendmail(senderemail, to, content)\r\n\temail = EmailMessage()\r\n\temail['From'] = senderemail\r\n\temail['To'] = receiver\r\n\temail['Subject'] = subject\r\n\temail.set_content(content)\r\n\tserver.send_message(email)\r\n\tserver.close()\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "send_whatsapp", "data": "def send_whatsapp(phone_no, message):\r\n\tMessage = message\r\n\twb.open(f'https://web.whatsapp.com/send?phone={phone_no}&text={Message}')\r\n\tsleep(10)\r\n\tpyautogui.press('enter')\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "translate", "data": "def translate(word_translate): # Traducere in clipboard Google\r\n\ttranslater = Translator()\r\n\ttranslated_words = translater.translate(word_translate, dest='en')\r\n\r\n\tpyperclip.copy(translated_words.text)\r\n\tspeak('Am tradus domnule')\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "search_google", "data": "def search_google():\r\n\tspeak('Ce dori\u021bi sa caut pe gug\u0103l?')\r\n\tsearch = takeCommandMIC()\r\n\twb.open(f'https://www.google.com/search?q={search}')\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "search_trading_view", "data": "def search_trading_view():\r\n\twb.open(f'https://www.tradingview.com')\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "screen_shot", "data": "def screen_shot():\r\n\tdateX = datetime.datetime.now()\r\n\tname_img = f'./scrennshots/{dateX.strftime(\"%d.%m.%Y-\"\"%H-%M\")}.png'\r\n\timg = pyautogui.screenshot(name_img)\r\n\timg.show()\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "coin_market_cap", "data": "def coin_market_cap():\r\n\t\tcmc = CoinMarketCapAPI('575792ad-0824-4b28-84ad-a0eabc54530c')\r\n\t\tbtc = cmc.cryptocurrency_info(symbol='BTC')\r\n\t\tb = btc.data\r\n\t\tspeak('Calculez informa\u021biile, dureaz\u0103 o secund\u0103')\r\n\t\tpattern = re.compile(r'price of (Bitcoin) is (\\d+[,.]\\d{3})')\r\n\r\n\t\tmatches = pattern.finditer(b['BTC']['description'])\r\n\t\tfor match in matches:\r\n\t\t\tspeak(f\"{match.group(1)} are un pre\u021b de {match.group(2)}{' Dolari'}\")\r\n\r\n\t# Backbone for the commands\r\n\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "start_program", "data": "def start_program(): # Start up functions\r\n\tgreetings()\r\n\tspeak('Numele meu este MaximusAI \u015fi sunt aici s\u0103 v\u0103 ajut')\r\n\tremember_fileX = open('remember_data.txt', 'r', encoding='utf-8')\r\n\tfile_size = os.stat('remember_data.txt').st_size\r\n\tif file_size == 0:\r\n\t\tspeak('Nu ave\u021bi nimic programat pentru ast\u0103zi')\r\n\telse:\r\n\t\tspeak(f'Pentru ast\u0103zi ave\u021bi programate urm\u0103toarele, {remember_fileX.read()}')\r\n\r\n\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}, {"term": "def", "name": "takeCommandMIC", "data": "def takeCommandMIC():\t# Taking Orders and execute it\r\n\tr = sr.Recognizer()\r\n\twith sr.Microphone() as source:\r\n\t\tprint('Listening...')\r\n\t\tr.pause_threshold = 1\r\n\t\t# r.dynamic_energy_threshold = 3000\r\n\t\t# r.adjust_for_ambient_noise(source, duration=1.5)\r\n\t\taudio = r.listen(source)\r\n\r\n\ttry:\r\n\t\tprint('Recognizning...')\r\n\t\tquery = r.recognize_google(audio, language='ro')\r\n\t\tprint(query)\r\n\texcept Exception as e:\r\n\t\tprint(e)\r\n\t\t# speak('Repet\u0103 te rog...')\r\n\t\tquery = ''\r\n\treturn query\r\n\r\n\r\n", "description": null, "category": "math", "imports": ["import pyttsx3 # == text data into speach\r", "import speech_recognition as sr\r", "from nltk.tokenize import word_tokenize\r", "import datetime\r", "import smtplib # MAILS\r", "from pywhatkit import playonyt\r", "import wikipedia\r", "from secret import senderemail, email_pwd\r", "from email.message import EmailMessage # subject sender etc\r", "import pyautogui\r", "import webbrowser as wb\r", "from time import sleep\r", "import wikipedia as wiki\r", "from requests import get\r", "from coinmarketcapapi import CoinMarketCapAPI, CoinMarketCapAPIError\r", "import re # (REGULAR EXPRESSIONS OR REGEX)\r", "import os\r", "from decimal import Decimal\r", "import pyperclip\r", "from googletrans import Translator\r"]}], [{"term": "class", "name": "StatsModule", "data": "class StatsModule(module.Module):\n\tname = 'Stats'\n\n\tdef on_load(self):\n\t\tif 'stats' not in self.bot.config:\n\t\t\tself.bot.config['stats'] = {}\n\n\t\tkeys = [\n\t\t\t'sent',\n\t\t\t'received',\n\t\t\t'processed',\n\t\t\t'replaced',\n\t\t\t'sent_edits',\n\t\t\t'received_edits',\n\t\t\t'sent_stickers',\n\t\t\t'received_stickers',\n\t\t\t'uptime',\n\t\t\t'spambots_banned',\n\t\t\t'stickers_created'\n\t\t]\n\n\t\tfor k in keys:\n\t\t\tif k not in self.bot.config['stats']:\n\t\t\t\tself.bot.config['stats'][k] = 0\n\n\tdef on_start(self, time_us):\n\t\tself.last_time = time_us\n\n\tdef on_message(self, msg):\n\t\tif msg.from_user and msg.from_user.id == self.bot.uid:\n\t\t\tbase_stat = 'sent'\n\t\telse:\n\t\t\tbase_stat = 'received'\n\n\t\tstat = base_stat\n\t\tif msg.edit_date:\n\t\t\tstat += '_edits'\n\n\t\tself.bot.config['stats'][stat] += 1\n\n\t\tif msg.sticker:\n\t\t\tstat = base_stat + '_stickers'\n\t\t\tself.bot.config['stats'][stat] += 1\n\n\t\tself.update_uptime()\n\n\tdef on_command(self, msg, cmd_info, args):\n\t\tself.bot.config['stats']['processed'] += 1\n\n\tdef update_uptime(self):\n\t\tnow = util.time_us()\n\t\tdelta_us = now - self.last_time\n\t\tself.bot.config['stats']['uptime'] += delta_us\n\t\tself.last_time = now\n\n\tdef calc_pct(self, num1, num2):\n\t\tif not num2:\n\t\t\treturn '0'\n\n\t\treturn '{:.1f}'.format((num1 / num2) * 100).rstrip('0').rstrip('.')\n\n\tdef calc_ph(self, stat, uptime):\n\t\tup_hr = max(1, uptime) / USEC_PER_HOUR\n\t\treturn '{:.1f}'.format(stat / up_hr).rstrip('0').rstrip('.')\n\n\tdef calc_pd(self, stat, uptime):\n\t\tup_day = max(1, uptime) / USEC_PER_DAY\n\t\treturn '{:.1f}'.format(stat / up_day).rstrip('0').rstrip('.')\n\n\t@command.desc('Show chat stats (pass `reset` to reset stats)')\n\t@command.alias('stat')\n\tdef cmd_stats(self, msg, args):\n\t\tif args == \"reset\":\n\t\t\tself.bot.config['stats'] = {}\n\t\t\tself.on_load()\n\t\t\tself.on_start(util.time_us())\n\t\t\treturn '__All stats have been reset.__'\n\n\t\tself.update_uptime()\n\t\tself.bot.save_config()\n\n\t\tst = self.bot.config['stats']\n\t\tuptime = st['uptime']\n\t\tsent = st['sent']\n\t\tsent_stickers = st['sent_stickers']\n\t\trecv = st['received']\n\t\trecv_stickers = st['received_stickers']\n\t\tprocessed = st['processed']\n\t\treplaced = st['replaced']\n\t\tbanned = st['spambots_banned']\n\t\tstickers = st['stickers_created']\n\n\t\treturn f'''**Stats since last reset**:\n\t\u2022 **Total time elapsed**: {util.format_duration_us(uptime)}\n\t\u2022 **Messages received**: {recv} ({self.calc_ph(recv, uptime)}/h) \u2022 {self.calc_pct(recv_stickers, recv)}% are stickers\n\t\u2022 **Messages sent**: {sent} ({self.calc_ph(sent, uptime)}/h) \u2022 {self.calc_pct(sent_stickers, sent)}% are stickers\n\t\u2022 **Percent of total messages sent**: {self.calc_pct(sent, sent + recv)}%\n\t\u2022 **Commands processed**: {processed} ({self.calc_ph(processed, uptime)}/h) \u2022 {self.calc_pct(processed, sent)}% of sent messages\n\t\u2022 **Snippets replaced**: {replaced} ({self.calc_ph(replaced, uptime)}/h) \u2022 {self.calc_pct(replaced, sent)}% of sent messages\n\t\u2022 **Spambots banned**: {banned} ({self.calc_pd(banned, uptime)}/day)\n\t\u2022 **Stickers created**: {stickers} ({self.calc_pd(stickers, uptime)}/day)'''\n", "description": null, "category": "math", "imports": ["import command", "import module", "import util"]}], [{"term": "class", "name": "classDerivative:", "data": "class Derivative:\n\tdef __init__(self, f, h=0.0001):\n\t\tself.f = f\n\t\tself.h = float(h)\n\n\tdef __call__(self, x):\n\t\tf, h = self.f, self.h\n\t\treturn (f(x+h) - f(x-h))/(2*h)\n\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "C", "data": "def C(n, k):\n\treturn math.factorial(n)/(math.factorial(n-k)*math.factorial(k))\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "b", "data": "def b(value):\n\tres = [0]\n\tsumm = 0\n\tfor i in range(1, value):\n\t\tsumm += i\n\tfor i in range(1, value):\n\t\tres.append(i/summ)\n\treturn res\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "class", "name": "classSolver:", "data": "class Solver:\n\n\tdef __init__(self, a, infin=3):\n\t\tassert 0 < a < 1\n\t\tself.a = a\n\t\tself.inf = infin\n\t\tself.b = b(self.inf)\n\t\tself.inA = 1 - a\n\t\tself.inB = self.calc_inB()\n\t\tself.q = []\n\t\tself.ro = self.a*self.inB\n\n\tdef reload(self, a, infin=3):\n\t\tassert 0 < a < 1\n\t\tself.a = a\n\t\tself.inf = infin\n\t\tself.b = b(self.inf)\n\t\tself.inA = 1 - a\n\t\tself.inB = self.calc_inB()\n\t\tself.q = []\n\t\tself.ro = self.a*self.inB\n\n\tdef calc_inB(self):\n\t\tres = 0\n\t\tfor i in range(self.inf):\n\t\t\tres += i * self.b[i]\n\t\treturn res\n\n\tdef calc_Bi(self, i):\n\t\tres = 0\n\t\tfor j in range(i,self.inf):\n\t\t\tres += self.b[j]\n\t\treturn res\n\n\tdef calc_pwn(self, n):\n\t\tassert n >= 0\n\t\tres = 0\n\t\tfor t in range(n, self.inf):\n\t\t\tres += C(t, n)*self.a**n*self.inA**(t-n)*self.b[t]\n\t\treturn res\n\n\tdef calc_Pwz(self, z):\n\t\tres = 0\n\t\tfor n in range(self.inf):\n\t\t\tres += z**n*self.calc_pwn(n)\n\t\treturn res\n\n\tdef calc_Pwi(self, i):\n\t\tres = 0\n\t\tfor j in range(i, self.inf):\n\t\t\tres += self.calc_pwn(j)\n\t\treturn res\n\n\tdef calc_betaz(self, z):\n\t\tsumm = 0\n\t\tfor n in range(self.inf):\n\t\t\tsumm+= z**n*self.b[n]\n\t\treturn summ\n\n\tdef calc_qplusi(self, i):\n\t\twhile len(self.q)<=i:\n\t\t\tself.q.append(None)\n\t\tif self.q[i]:\n\t\t\treturn self.q[i]\n\t\telse:\n\t\t\ttmp = 0\n\t\t\tfor j in range(1, i):\n\t\t\t\ttmp += self.calc_qplusi(j)*self.calc_Pwi(i-j+1)\n\t\t\tself.q[i] = (self.calc_Pwi(i)+tmp)/self.calc_pwn(0)\n\t\t\treturn self.q[i]\n\n\tdef calc_pplusi(self, i):\n\t\tif i == 0:\n\t\t\tsumm = 0\n\t\t\tfor j in range(1,self.inf):\n\t\t\t\tsumm+=self.calc_qplusi(j)\n\t\t\treturn 1/(1+summ)\n\t\telse:\n\t\t\treturn self.calc_pplusi(0)*self.calc_qplusi(i)\n\n\tdef calc_Pplusz(self, z):\n\t\t# assert 0 < z < 1\n\t\treturn (1-z)*self.calc_Pwz(z)*(1-self.a*self.inB)/(self.calc_Pwz(z)-z)\n\n\tdef calc_phat(self, i):\n\t\tassert i>=1\n\t\tif i == 1:\n\t\t\treturn self.calc_pplusi(0) + self.calc_pplusi(1)\n\t\telse:\n\t\t\treturn self.calc_pplusi(i)\n\n\tdef calc_pi(self, i):\n\t\tif i == 0:\n\t\t\treturn self.calc_pplusi(0)\n\t\telse:\n\t\t\tsumm = 0\n\t\t\tfor n in range(0, self.inf):\n\t\t\t\tfor j in range(max(1,i-n), i+1):\n\t\t\t\t\tsumm += self.calc_phat(j)*self.calc_Bi(n+1)*C(n,i-j)*self.a**(i-j)*self.inA**(n-i+j)\n\t\t\treturn self.a*summ\n\n\tdef check_pi(self, i):\n\t\tsumm1, summ2 = 0, 0\n\t\tfor n in range(i-1, self.inf):\n\t\t\tsumm1 += self.calc_Bi(n+1)*C(n,i-1)*self.a**(i-1)*self.inA**(n-i+1)\n\t\tfor j in range(1,i+1):\n\t\t\tsumm3 = 0\n\t\t\tfor n in range(i-j,self.inf):\n\t\t\t\tself.calc_Bi(n+1)*C(n,i-j)*self.a**(i-j)*self.inA**(n-i+j)\n\t\t\tsumm2+=self.calc_pplusi(i)*summ3\n\t\treturn self.a*(self.calc_pplusi(0)*summ1+summ2)\n\n\tdef calc_Pz(self, z):\n\t\treturn (1 - self.calc_Pwz(z))*((self.calc_Pplusz(z)-self.calc_pplusi(0)) \\\n\t\t\t\t\t\t\t\t\t   +z*self.calc_pplusi(0))/(1-z)+self.calc_pplusi(0)\n\n\tdef calc_pxi(self, i):\n\t\tif i == 0:\n\t\t\treturn self.calc_pplusi(0)/self.inA\n\t\telse:\n\t\t\tsumm1, summ2, summ3, summ4 = 0, 0, 0, 0\n\t\t\tfor n in range(i,self.inf):\n\t\t\t\tsumm1 += self.calc_Bi(n+1)*C(n-1,i-1)*self.a**(i-1)*self.inA**(n-i)\n\n\t\t\tfor j in range(1,i+1):\n\t\t\t\tsumm = 0\n\t\t\t\tfor n in range(i-j+1, self.inf):\n\t\t\t\t\tsumm+= self.calc_Bi(n+1)*C(n-1,i-j)*self.a**(i-j)*self.inA**(n-i+j-1)\n\t\t\t\tsumm2+=self.calc_pplusi(j)*summ\n\n\t\t\tfor n in range(i+1, self.inf):\n\t\t\t\tsumm3 += self.b[n]*C(n-1,i)*self.a**i*self.inA**(n-i-1)\n\n\t\t\tfor j in range(1,i+2):\n\t\t\t\tsumm = 0\n\t\t\t\tfor n in range(i-j+2, self.inf):\n\t\t\t\t\tsumm += self.b[n]*C(n-1,i-j+1)*self.a**(i-j+1)*self.inA**(n-i+j-2)\n\t\t\t\tsumm4 += self.calc_pplusi(j)*summ\n\n\t\t\treturn self.a*(self.calc_pplusi(0)*summ1+summ2)+self.a*self.calc_pplusi(0)*summ3+self.a*summ4\n\n\tdef calc_Pxz(self, z):\n\t\tres = 0\n\t\tfor i in range(self.inf):\n\t\t\tres += z**i*self.calc_pxi(i)\n\t\treturn res\n\n\tdef check_Pxz(self, z):\n\t\treturn self.calc_pplusi(0)/self.inA + \\\n\tself.a*self.calc_pplusi(0)*z*\\\n\t\t\t   ((self.a*z+self.inA)-self.calc_betaz(self.a*z+self.inA))/\\\n\t\t\t   ((self.a*z+self.inA)*(1-(self.a*z+self.inA)))+\\\n\tself.a*(self.calc_Pplusz(z)-self.calc_pplusi(0))*\\\n\t\t\t   ((self.a*z+self.inA)-self.calc_betaz(self.a*z+self.inA))/\\\n\t\t\t   ((self.a*z+self.inA)*(1-(self.a*z+self.inA)))+\\\n\tself.a*self.calc_pplusi(0)*((self.calc_betaz(self.a*z+self.inA)/(self.a*z+self.inA))-\\\n\t\t\t\t\t\t\t\tself.calc_betaz(self.inA)/self.inA)+\\\n\tself.a/z*(self.calc_Pplusz(z)-self.calc_pplusi(0))*\\\n\t\t\t   (self.calc_betaz(self.a*z+self.inA)/(self.a*z+self.inA)-self.calc_betaz(self.inA)/self.inA)+\\\n\tself.a/self.inA*(self.calc_Pplusz(z)-self.calc_pplusi(0)-self.calc_pplusi(1)*z)*\\\n\t\t\t   (self.calc_betaz(self.inA)-self.b[0])\n\n\tdef calc_wn(self, n, w=[]):\n\t\tif n == 0:\n\t\t\treturn 1 - self.ro\n\t\telif n==1:\n\t\t\treturn self.a*self.calc_wn(0)/self.inA\n\t\telse:\n\t\t\twhile len(w)<=n:\n\t\t\t\tw.append(None)\n\t\t\tif w[n]:\n\t\t\t\treturn w[n]\n\t\t\telse:\n\t\t\t\tsumm = 0\n\t\t\t\tfor i in range(n-2):\n\t\t\t\t\tsumm+=self.calc_wn(i+1, w)*self.a\\\n\t\t\t\t\t\t  *self.b[n-1-i]\n\t\t\t\tw[n] = 1/self.inA*(self.calc_wn(n-1, w)*(1-self.a*self.b[1]) \\\n\t\t\t\t\t\t\t\t   - self.calc_wn(0)*self.a*self.b[n-1] - summ)\n\t\t\t\treturn w[n]\n\n\tdef calc_whatn(self, n):\n\t\tif n ==0:\n\t\t\treturn self.calc_wn(0)+self.calc_wn(1)\n\t\telse:\n\t\t\treturn self.calc_wn(n+1)\n\n\tdef calc_wz(self, z):\n\t\treturn (z-1)*(self.inA+self.a*self.calc_betaz(z))*self.calc_wn(0)/(z-self.inA-self.a*self.calc_betaz(z))\n\n\tdef calc_N1(self):\n\t\tdf = Derivative(self.calc_Pplusz)\n\t\treturn df(1)\n\n\tdef calc_N2(self):\n\t\tsumm = 0\n\t\tfor i in range(self.inf):\n\t\t\tsumm += i*self.calc_pi(i)\n\t\treturn summ\n\n\tdef calc_N3(self):\n\t\tdf = Derivative(self.calc_Pz)\n\t\treturn df(1)\n\n\tdef calc_N4(self):\n\t\tsumm = 0\n\t\tfor i in range(self.inf):\n\t\t\tsumm+=i*self.calc_pi(i)\n\t\treturn summ\n\n\tdef calc_Nx1(self):\n\t\tdf = Derivative(self.calc_Pxz)\n\t\treturn df(1)\n\n\tdef calc_Nx2(self):\n\t\tdf = Derivative(self.check_Pxz)\n\t\treturn df(1)\n\n\tdef calc_Nx3(self):\n\t\tsumm = 0\n\t\tfor i in range(self.inf):\n\t\t\tsumm += i* self.calc_pxi(i)\n\t\treturn summ\n\n\tdef calc_M1(self):\n\t\tsumm = 0\n\t\tfor i in range(self.inf):\n\t\t\tsumm += i*self.calc_wn(i)\n\t\treturn summ\n\n\tdef calc_M2(self):\n\t\tdf = Derivative(self.calc_wz)\n\t\treturn df(1)\n\n\tdef calc_M3(self):\n\t\tsumm = 0\n\t\tfor i in range(self.inf):\n\t\t\tsumm += i* self.calc_whatn(i)\n", "description": null, "category": "math", "imports": ["import math"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "TestStringMethods", "data": "class TestStringMethods(unittest.TestCase):\r\n\r\n\tdef test_basic_add(self):\r\n\t\tCalc = calculator.Calculator()\r\n\t\tself.assertEqual(Calc.Evaluate(\"1+1\"), 2)\r\n\tdef test_basic_subtract(self):\r\n\t\tCalc = calculator.Calculator()\r\n\t\tself.assertEqual(Calc.Evaluate(\"10-1\"), 9)\r\n\tdef test_basic_divide(self):\r\n\t\tCalc = calculator.Calculator()\r\n\t\tself.assertEqual(Calc.Evaluate(\"4/2\"), 2)\r\n\tdef test_basic_multiply(self):\r\n\t\tCalc = calculator.Calculator()\r\n\t\tself.assertEqual(Calc.Evaluate(\"4*2\"), 8)\r\n\tdef test_complex(self):\r\n\t\tCalc = calculator.Calculator()\r\n\t\tself.assertEqual(Calc.Evaluate(\"1+4-25+60/25*2\"), -15.2)\r\n\tdef test_complex_not_equal(self):\r\n\t\tCalc = calculator.Calculator()\r\n\t\tself.assertNotEqual(Calc.Evaluate(\"1+4-25+60/25*2\"), -15)\r\n\tdef test_divide_zero(self):\r\n\t\tCalc = calculator.Calculator()\r\n\t\tself.assertEqual(Calc.Evaluate(\"100/0\"), \"Error\")\r\n", "description": null, "category": "math", "imports": ["import unittest\r", "import calculator\r"]}], [{"term": "def", "name": "system", "data": "def system():\n\treturn bulk('Al', 'fcc', a=4.5, cubic=True)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "expected_nelect_from_vasp", "data": "def expected_nelect_from_vasp():\n\t# Expected number of electrons from the specified system\n\t# with no charge\n\treturn 12\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_charge", "data": "def test_vasp_charge(factory, system, expected_nelect_from_vasp):\n\t\"\"\"\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied charge works correctly.\n\n\tTest that the number of charge found matches the expected.\n\t\"\"\"\n\n\t# Dummy calculation to let VASP determine default number of electrons\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False)\n\tsystem.calc = calc\n\tsystem.get_potential_energy()\n\n\tdefault_nelect_from_vasp = calc.get_number_of_electrons()\n\tassert default_nelect_from_vasp == expected_nelect_from_vasp\n\n", "description": "\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied charge works correctly.\n\n\tTest that the number of charge found matches the expected.\n\t", "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_no_inputs", "data": "def test_vasp_no_inputs(system, factory):\n\t# Make sure that no nelect was written into INCAR yet (as it wasn't necessary)\n\tcalc = factory.calc()\n\tsystem.calc = calc\n\tsystem.get_potential_energy()\n\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] is None\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_minus_charge", "data": "def test_vasp_minus_charge(factory, system, expected_nelect_from_vasp):\n\t# Compare VASP's output nelect from before minus charge to default nelect\n\t# determined by us minus charge\n\tcharge = -2\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tcharge=charge)\n\tcalc.initialize(system)\n\tcalc.write_input(system)\n\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] == expected_nelect_from_vasp - charge\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_nelect_charge_conflict", "data": "def test_vasp_nelect_charge_conflict(factory, system,\n\t\t\t\t\t\t\t\t\t expected_nelect_from_vasp):\n\t# Test that conflicts between explicitly given nelect and charge are detected\n\tcharge = -2\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tnelect=expected_nelect_from_vasp - charge + 1,\n\t\t\t\t\t\tcharge=charge)\n\tsystem.calc = calc\n\twith pytest.raises(ValueError):\n\t\tsystem.get_potential_energy()\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_nelect_no_write", "data": "def test_vasp_nelect_no_write(factory, system):\n\t# Test that nothing is written if charge is 0 and nelect not given\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tcharge=0)\n\tcalc.initialize(system)\n\tcalc.write_input(system)\n\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] is None\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_nelect", "data": "def test_vasp_nelect(factory, system):\n\t# Test that explicitly given nelect still works as expected\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tnelect=15)\n\tcalc.calculate(system)\n\tassert calc.get_number_of_electrons() == 15\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}], [], [{"term": "def", "name": "calc_bin_error_stats", "data": "def calc_bin_error_stats(probs, links):\n\tauc, _, _ = calc_auc([], [], [], probs, links)\n\tkls = calc_kl_score(probs, links)\n\tcls = calc_class_score(probs, links)\n\tclassifier_error = calc_classifier_score(probs, links)\n\trmse = calc_rmse(probs, links)\n\treturn {\n\t\t\"auc\": auc,\n\t\t\"kls\": kls,\n\t\t\"cls\": cls,\n\t\t\"classifier_error\": classifier_error,\n\t\t\"rmse\": rmse,\n\t}\n", "description": null, "category": "math", "imports": ["from Utilities.CalcAUC import calc_auc", "from Utilities.CalcKLScore import calc_kl_score", "from Utilities.CalcClassScore import calc_class_score", "from Utilities.CalcClassifierScore import calc_classifier_score", "from Utilities.CalcRMSE import calc_rmse"]}], [], [{"term": "def", "name": "test_main", "data": "def test_main(factory, atoms_co):\n\n\t# simple test calculation of CO molecule\n\tco = atoms_co  # aliasing\n\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tprec='Low',\n\t\t\t\t\t\talgo='Fast',\n\t\t\t\t\t\tlorbit=11,\n\t\t\t\t\t\tismear=0,\n\t\t\t\t\t\tsigma=1.,\n\t\t\t\t\t\tnbands=12,\n\t\t\t\t\t\tistart=0,\n\t\t\t\t\t\tnelm=3,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\tldipol=True)\n\n\tco.calc = calc\n\tenergy = co.get_potential_energy()\n\tforces = co.get_forces()\n\tdipole_moment = co.get_dipole_moment()\n\n\t# check that parsing of vasprun.xml file works\n\tconf = read('vasprun.xml')\n\tassert conf.calc.parameters['kpoints_generation']\n\tassert conf.calc.parameters['sigma'] == 1.0\n\tassert conf.calc.parameters['ialgo'] == 68\n\tassert energy - conf.get_potential_energy() == 0.0\n\n\t# Check some arrays\n\tassert np.allclose(conf.get_forces(), forces)\n\tassert np.allclose(conf.get_dipole_moment(), dipole_moment, atol=1e-6)\n\n\t# Check k-point-dependent properties\n\tassert len(conf.calc.get_eigenvalues(spin=0)) >= 12\n\tassert conf.calc.get_occupation_numbers()[2] == 2\n\tassert conf.calc.get_eigenvalues(spin=1) is None\n\tkpt = conf.calc.get_kpt(0)\n\tassert kpt.weight == 1.\n\n\t# Perform a spin-polarised calculation\n\tco.calc.set(ispin=2, ibrion=-1)\n\tco.get_potential_energy()\n\tconf = read('vasprun.xml')\n\tassert len(conf.calc.get_eigenvalues(spin=1)) >= 12\n\tassert conf.calc.get_occupation_numbers(spin=1)[0] == 1.\n\n\t# Cleanup\n\tcalc.clean()\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase.io import read"]}], [{"term": "def", "name": "WorkbookProperties", "data": "def WorkbookProperties():\n\tfrom ..properties import WorkbookProperties\n\treturn WorkbookProperties\n\n", "description": null, "category": "math", "imports": ["import pytest", "from openpyxl.xml.functions import fromstring, tostring", "from openpyxl.tests.helper import compare_xml", "\tfrom ..properties import WorkbookProperties", "\tfrom ..properties import CalcProperties", "\tfrom ..properties import FileVersion"]}, {"term": "class", "name": "classTestWorkbookProperties:", "data": "class TestWorkbookProperties:\n\n\tdef test_ctor(self, WorkbookProperties):\n\t\tprops = WorkbookProperties()\n\t\txml = tostring(props.to_tree())\n\t\texpected = \"\"\"\n\t\t\n\t\t\"\"\"\n\t\tdiff = compare_xml(xml, expected)\n\t\tassert diff is None, diff\n\n\n\tdef test_from_xml(self, WorkbookProperties):\n\t\tsrc = \"\"\"\n\t\t\n\t\t\"\"\"\n\t\tnode = fromstring(src)\n\t\tprops = WorkbookProperties.from_tree(node)\n\t\tassert props == WorkbookProperties()\n\n", "description": "\n\t\t\n\t\t", "category": "math", "imports": ["import pytest", "from openpyxl.xml.functions import fromstring, tostring", "from openpyxl.tests.helper import compare_xml", "\tfrom ..properties import WorkbookProperties", "\tfrom ..properties import CalcProperties", "\tfrom ..properties import FileVersion"]}, {"term": "def", "name": "CalcProperties", "data": "def CalcProperties():\n\tfrom ..properties import CalcProperties\n\treturn CalcProperties\n\n", "description": null, "category": "math", "imports": ["import pytest", "from openpyxl.xml.functions import fromstring, tostring", "from openpyxl.tests.helper import compare_xml", "\tfrom ..properties import WorkbookProperties", "\tfrom ..properties import CalcProperties", "\tfrom ..properties import FileVersion"]}, {"term": "class", "name": "classTestCalcProperties:", "data": "class TestCalcProperties:\n\n\tdef test_ctor(self, CalcProperties):\n\t\tcalc = CalcProperties()\n\t\txml = tostring(calc.to_tree())\n\t\texpected = \"\"\"\n\t\t   \n\t\t\"\"\"\n\t\tdiff = compare_xml(xml, expected)\n\t\tassert diff is None, diff\n\n\n\tdef test_from_xml(self, CalcProperties):\n\t\tsrc = \"\"\"\n\t\t\n\t\t\"\"\"\n\t\tnode = fromstring(src)\n\t\tcalc = CalcProperties.from_tree(node)\n\t\tassert calc == CalcProperties()\n\n", "description": "\n\t\t   \n\t\t", "category": "math", "imports": ["import pytest", "from openpyxl.xml.functions import fromstring, tostring", "from openpyxl.tests.helper import compare_xml", "\tfrom ..properties import WorkbookProperties", "\tfrom ..properties import CalcProperties", "\tfrom ..properties import FileVersion"]}, {"term": "def", "name": "FileVersion", "data": "def FileVersion():\n\tfrom ..properties import FileVersion\n\treturn FileVersion\n\n", "description": null, "category": "math", "imports": ["import pytest", "from openpyxl.xml.functions import fromstring, tostring", "from openpyxl.tests.helper import compare_xml", "\tfrom ..properties import WorkbookProperties", "\tfrom ..properties import CalcProperties", "\tfrom ..properties import FileVersion"]}, {"term": "class", "name": "classTestFileVersion:", "data": "class TestFileVersion:\n\n\tdef test_ctor(self, FileVersion):\n\t\tprop = FileVersion()\n\t\txml = tostring(prop.to_tree())\n\t\texpected = \"\"\"\n\t\t\n\t\t\"\"\"\n\t\tdiff = compare_xml(xml, expected)\n\t\tassert diff is None, diff\n\n\n\tdef test_from_xml(self, FileVersion):\n\t\tsrc = \"\"\"\n\t\t\n\t\t\"\"\"\n\t\tnode = fromstring(src)\n\t\tprop = FileVersion.from_tree(node)\n\t\tassert prop == FileVersion()\n", "description": "\n\t\t\n\t\t", "category": "math", "imports": ["import pytest", "from openpyxl.xml.functions import fromstring, tostring", "from openpyxl.tests.helper import compare_xml", "\tfrom ..properties import WorkbookProperties", "\tfrom ..properties import CalcProperties", "\tfrom ..properties import FileVersion"]}], [{"term": "def", "name": "close", "data": "def close(val, reference, releps=releps, abseps=abseps):\n\tprint(val, reference)\n\tassert np.abs(val - reference) < max(np.abs(releps * reference), abseps)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "array_close", "data": "def array_close(val, reference, releps=releps, abseps=abseps):\n\tvalflat = val.flatten()\n\trefflat = reference.flatten()\n\tfor i, vali in enumerate(valflat):\n\t\tclose(vali, refflat[i], releps, abseps)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "system", "data": "def system():\n\treturn create_s22_system('Adenine-thymine_complex_stack')\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_forces", "data": "def test_forces(factory, system):\n\t# do all non-periodic calculations with Adenine-Thymine complex\n\n\t# Default is D3(zero)\n\tsystem.calc = factory.calc()\n\tclose(system.get_potential_energy(), -0.6681154466652238)\n\n\t# Only check forces once, for the default settings.\n\tf_ref = np.array(\n\t\t[[0.0088385621657399, -0.0118387210205813, -0.0143242057174889],\n\t\t [-0.0346912282737323, 0.0177797757792533, -0.0442349785529711],\n\t\t [0.0022759961575945, -0.0087458217241648, -0.0051887171699909],\n\t\t [-0.0049317224619103, -0.0215152368018880, -0.0062290998430756],\n\t\t [-0.0013032612752381, -0.0356240144088481, 0.0203401124180720],\n\t\t [-0.0110305568118348, -0.0182773178473497, -0.0023730575217145],\n\t\t [0.0036258610447203, -0.0074994162928053, -0.0144058177906650],\n\t\t [0.0005289754841564, -0.0035901842246731, -0.0103580836569947],\n\t\t [0.0051775352510856, -0.0051076755874038, -0.0103428268442285],\n\t\t [0.0011299493448658, -0.0185829345539878, -0.0087205807334006],\n\t\t [0.0128459160503721, -0.0248356605575975, 0.0007946691695359],\n\t\t [-0.0063194401470256, -0.0058117310787239, -0.0067932156139914],\n\t\t [0.0013749100498893, -0.0118259631230572, -0.0235404547526578],\n\t\t [0.0219558160992901, -0.0087512938555865, -0.0226017156485839],\n\t\t [0.0001168268736984, -0.0138384169778581, -0.0014850073023105],\n\t\t [0.0037893625607261, 0.0117649062330659, 0.0162375798918204],\n\t\t [0.0011352730068862, 0.0142002748861793, 0.0129337874676760],\n\t\t [-0.0049945288501837, 0.0073929058490670, 0.0088391871214417],\n\t\t [0.0039715118075548, 0.0186949615105239, 0.0114822052853407],\n\t\t [-0.0008003587963147, 0.0161735976004718, 0.0050357997715004],\n\t\t [-0.0033142342134453, 0.0153658921418049, -0.0026233088963388],\n\t\t [-0.0025451124688653, 0.0067994927521733, -0.0017127589489137],\n\t\t [-0.0010451311609669, 0.0067173068779992, 0.0044413725566098],\n\t\t [-0.0030829302438095, 0.0112138539867057, 0.0151213034444885],\n\t\t [0.0117240581287903, 0.0161749855643631, 0.0173269837053235],\n\t\t [-0.0025949288306356, 0.0158830629834040, 0.0155589787340858],\n\t\t [0.0083784268665834, 0.0082132824775010, 0.0090603749323848],\n\t\t [-0.0019694065480327, 0.0115576523485515, 0.0083901101633852],\n\t\t [-0.0020036820791533, 0.0109276020920431, 0.0204922407855956],\n\t\t [-0.0062424587308054, 0.0069848349714167, 0.0088791235460659]])\n\n\tarray_close(system.get_forces(), f_ref)\n\n\t# calculate numerical forces, but use very loose comparison criteria!\n\t# dftd3 doesn't print enough digits to stdout to get good convergence\n\tf_numer = numeric_forces(system, d=1e-4)\n\tarray_close(f_numer, f_ref, releps=1e-2, abseps=1e-3)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d2_old", "data": "def test_d2_old(factory, system):\n\tsystem.calc = factory.calc(old=True)\n\tclose(system.get_potential_energy(), -0.8923443424663762)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_bj", "data": "def test_d3_bj(factory, system):\n\tsystem.calc = factory.calc(damping='bj')\n\tclose(system.get_potential_energy(), -1.211193213979179)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_zerom", "data": "def test_d3_zerom(factory, system):\n\tsystem.calc = factory.calc(damping='zerom')\n\tclose(system.get_potential_energy(), -2.4574447613705717)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_bjm", "data": "def test_d3_bjm(factory, system):\n\tsystem.calc = factory.calc(damping='bjm')\n\tclose(system.get_potential_energy(), -1.4662085277005799)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_alternative_tz", "data": "def test_alternative_tz(factory, system):\n\tsystem.calc = factory.calc(tz=True)\n\tclose(system.get_potential_energy(), -0.6160295884482619)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_zero_abc", "data": "def test_d3_zero_abc(factory, system):\n\tsystem.calc = factory.calc(abc=True)\n\tclose(system.get_potential_energy(), -0.6528640090262864)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_zero_revpbe", "data": "def test_d3_zero_revpbe(factory, system):\n\tsystem.calc = factory.calc(xc='revpbe')\n\tclose(system.get_potential_energy(), -1.5274869363442936)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_bad_xc", "data": "def test_bad_xc(factory, system):\n\tsystem.calc = factory.calc(xc='does_not_exist')\n\twith pytest.raises(RuntimeError, match='Unknown DFTD3 functional name'):\n\t\tsystem.get_potential_energy()\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_custom_damping", "data": "def test_custom_damping(factory, system):\n\tsystem.calc = factory.calc(s6=1.1, sr6=1.1, s8=0.6, sr8=0.9, alpha6=13.0)\n\tclose(system.get_potential_energy(), -1.082846357973487)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_bj_abc", "data": "def test_d3_bj_abc(factory, system):\n\t# A couple of combinations, but not comprehensive\n\tsystem.calc = factory.calc(damping='bj', abc=True)\n\tclose(system.get_potential_energy(), -1.1959417763402416)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_d3_zerom_b3lyp", "data": "def test_d3_zerom_b3lyp(factory, system):\n\tsystem.calc = factory.calc(damping='zerom', xc='b3-lyp')\n\tclose(system.get_potential_energy(), -1.3369234231047677)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_diamond_stress", "data": "def test_diamond_stress(factory, system):\n\tsystem = bulk('C')\n\n\tsystem.calc = factory.calc()\n\tclose(system.get_potential_energy(), -0.2160072476277501)\n\n\t# Do one stress for the default settings\n\ts_ref = np.array([0.0182329043326,\n\t\t\t\t\t  0.0182329043326,\n\t\t\t\t\t  0.0182329043326,\n\t\t\t\t\t  -3.22757439831e-14,\n\t\t\t\t\t  -3.22766949320e-14,\n\t\t\t\t\t  -3.22766949320e-14])\n\n\tarray_close(system.get_stress(), s_ref)\n\n\t# As with numerical forces, numerical stresses will not be very well\n\t# converged due to the limited number of digits printed to stdout\n\t# by dftd3. So, use very loose comparison criteria.\n\ts_numer = numeric_stress(system, d=1e-4)\n\tarray_close(s_numer, s_ref, releps=1e-2, abseps=1e-3)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_free_energy_bug", "data": "def test_free_energy_bug(factory):\n\t# Energy and free_energy should be close to equal.\n\t# Due to a bug related to legacy free_energy property handling,\n\t# it would double-count the free energy from the DFT calculation.\n\t# This test protects against that.\n\tatoms = bulk('Au', cubic=True)\n\tatoms.rattle(stdev=0.15)\n\n\tdftd3 = factory.calc(dft=EMT())\n\tatoms.calc = dftd3\n\n\te1, e2 = [atoms.get_potential_energy(force_consistent=x)\n\t\t\t  for x in [False, True]]\n\tassert e1 == pytest.approx(e2, abs=1e-14)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "class", "name": "EMTWithMagmoms", "data": "class EMTWithMagmoms(EMT):\n\timplemented_properties = [*EMT.implemented_properties, 'magmoms']\n\n\tdef dummy_magmoms(self, atoms):\n\t\treturn 1.234 + np.arange(len(atoms))\n\n\tdef calculate(self, atoms, *args, **kwargs):\n\t\tsuper().calculate(atoms, *args, **kwargs)\n\t\tself.results['magmoms'] = self.dummy_magmoms(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}, {"term": "def", "name": "test_non_dftd3_property", "data": "def test_non_dftd3_property(factory):\n\tdft = EMTWithMagmoms()\n\tcalc = factory.calc(dft=dft)\n\n\t# Our DFTD3 calculator should advertise that it supports this property:\n\tassert 'magmoms' in calc.implemented_properties\n\n\tatoms = bulk('Au', cubic=True)\n\tatoms.calc = calc\n\tmagmoms = atoms.get_magnetic_moments()\n\tassert magmoms == pytest.approx(dft.dummy_magmoms(atoms))\n\tprint('magmoms', magmoms)\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk", "from ase.calculators.emt import EMT", "from ase.calculators.test import numeric_stress, numeric_forces"]}], [{"term": "def", "name": "calc", "data": "def calc(equation,list):\n\tequationCalc = ''.join(str(char) for char in equation)\n\n\tif len(list) == 0:\n\t\tif eval(equationCalc) == 100:\n\t\t\tprint(equationCalc)\n\telse:\n\t\tcalc(equation + ['+'] + [list[0]], list[1:])\n\t\tcalc(equation + ['-'] + [list[0]], list[1:])\n\t\tcalc(equation + [list[0]], list[1:])\n", "description": null, "category": "math", "imports": []}], [{"term": "def", "name": "atoms", "data": "def atoms():\n\tatoms = molecule('H2')\n\tatoms.positions -= atoms.positions[0]\n\tassert atoms.positions[0] == pytest.approx([0, 0, 0])\n\tatoms.pbc = 1\n\tatoms.cell = [5, 5, 6]\n\treturn atoms\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import molecule"]}, {"term": "def", "name": "test_h2_bond", "data": "def test_h2_bond(factory, atoms):\n\td0 = atoms.get_distance(0, 1)\n\tatoms.calc = factory.calc()\n\n\tX = d0 + np.linspace(-0.08, 0.08, 5)\n\tE = []\n\tF = []\n\n\tfor x in X:\n\t\tatoms.positions[1, 2] = x\n\t\te = atoms.get_potential_energy(force_consistent=True)\n\t\tf = atoms.get_forces()\n\t\tE.append(e)\n\t\tF.append(f[1, 2])\n\tE = np.array(E)\n\tF = np.array(F)\n\n\ta, b, c = np.polyfit(X, E, 2)\n\txmin = -b / (2.0 * a)\n\tfa, fb = np.polyfit(X, F, 1)\n\n\tk_from_energy = 2 * a\n\tk_from_forces = -fa\n\n\t# Not very strict for a bond length, but parameters are not consistent:\n\tassert xmin == pytest.approx(0.77, rel=0.05)\n\tassert k_from_energy == pytest.approx(k_from_forces, rel=0.05)\n\tassert k_from_energy == pytest.approx(k_refs.get(factory.name, k_ref_0),\n\t\t\t\t\t\t\t\t\t\t  rel=0.05)\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import molecule"]}], [{"term": "def", "name": "test_vanilla_vasp", "data": "def test_vanilla_vasp():\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, incar_copilot=False)\n\tassert calc.asdict() == Vasp_().asdict()\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, custodian=False, incar_copilot=False)\n\tassert calc.asdict() == Vasp_().asdict()\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, encut=None, incar_copilot=False)\n\tassert calc.asdict() == Vasp_().asdict()\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_presets", "data": "def test_presets():\n\tatoms = bulk(\"Co\") * (2, 2, 1)\n\tatoms[-1].symbol = \"Fe\"\n\n\tcalc = Vasp(atoms, preset=os.path.join(DEFAULT_CALCS_DIR, \"BulkSet\"))\n\tatoms.calc = calc\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert calc.xc.lower() == \"pbe\"\n\tassert calc.string_params[\"algo\"] == \"fast\"\n\tassert calc.exp_params[\"ediff\"] == 1e-5\n\tassert calc.float_params[\"encut\"] == 520\n\n\tcalc = Vasp(atoms, xc=\"rpbe\", preset=\"SlabSet\")\n\tassert calc.xc.lower() == \"rpbe\"\n\tassert calc.string_params[\"algo\"] == \"fast\"\n\tassert calc.exp_params[\"ediff\"] == 1e-5\n\tassert calc.float_params[\"encut\"] == 450\n\n\tcalc = Vasp(atoms, xc=\"scan\", preset=\"MPScanSet\")\n\tassert calc.xc.lower() == \"scan\"\n\tassert calc.string_params[\"algo\"] == \"all\"\n\tassert calc.exp_params[\"ediff\"] == 1e-5\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_lmaxmix", "data": "def test_lmaxmix():\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms)\n\tassert calc.int_params[\"lmaxmix\"] == 4\n\n\tatoms = bulk(\"Ce\")\n\tcalc = Vasp(atoms)\n\tassert calc.int_params[\"lmaxmix\"] == 6\n\n\tatoms = bulk(\"Cu\") * (2, 2, 2)\n\tatoms[-1].symbol = \"Ce\"\n\tcalc = Vasp(atoms)\n\tassert calc.int_params[\"lmaxmix\"] == 6\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_autodipole", "data": "def test_autodipole():\n\tatoms = bulk(\"Cu\")\n\tcom = atoms.get_center_of_mass(scaled=True)\n\tcalc = Vasp(atoms, auto_dipole=True)\n\tassert calc.bool_params[\"ldipol\"] is True\n\tassert calc.int_params[\"idipol\"] == 3\n\tassert np.array_equal(calc.list_float_params[\"dipol\"], com)\n\n\tcalc = Vasp(atoms, auto_dipole=True, idipol=2)\n\tassert calc.bool_params[\"ldipol\"] is True\n\tassert calc.int_params[\"idipol\"] == 2\n\tassert np.array_equal(calc.list_float_params[\"dipol\"], com)\n\n\tcalc = Vasp(atoms, preset=\"SlabSet\")\n\tassert calc.bool_params[\"ldipol\"] is True\n\tassert calc.int_params[\"idipol\"] == 3\n\tassert np.array_equal(calc.list_float_params[\"dipol\"], com)\n\n\tcalc = Vasp(atoms, preset=\"SlabSet\", idipol=2)\n\tassert calc.bool_params[\"ldipol\"] is True\n\tassert calc.int_params[\"idipol\"] == 2\n\tassert np.array_equal(calc.list_float_params[\"dipol\"], com)\n\n\tcalc = Vasp(atoms, auto_dipole=False, preset=\"SlabSet\", idipol=2)\n\tassert calc.bool_params[\"ldipol\"] is None\n\tassert calc.int_params[\"idipol\"] == 2\n\tassert calc.list_float_params[\"dipol\"] is None\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_kspacing", "data": "def test_kspacing():\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, kspacing=0.1, ismear=-5)\n\tassert calc.int_params[\"ismear\"] == -5\n\n\tcalc = Vasp(atoms, kspacing=100, ismear=-5)\n\tassert calc.int_params[\"ismear\"] == 0\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_magmoms", "data": "def test_magmoms():\n\tatoms = bulk(\"Mg\")\n\tcalc = Vasp(atoms)\n\tatoms.calc = calc\n\tassert atoms.has(\"initial_magmoms\") is False\n\n\tatoms = bulk(\"Mg\")\n\tatoms.set_initial_magnetic_moments([3.14] * len(atoms))\n\tcalc = Vasp(atoms)\n\tatoms.calc = calc\n\tassert atoms.get_initial_magnetic_moments().tolist() == [3.14] * len(atoms)\n\n\tatoms = bulk(\"Cu\") * (2, 2, 1)\n\tatoms[-1].symbol = \"Fe\"\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert atoms.get_initial_magnetic_moments().tolist() == [2.0] * (len(atoms) - 1) + [\n\t\t5.0\n\t]\n\n\tatoms = bulk(\"Zn\") * (2, 2, 1)\n\tatoms[-1].symbol = \"Fe\"\n\tcalc = Vasp(atoms, preset=\"BulkSet\", preset_mag_default=2.5)\n\tatoms.calc = calc\n\tassert atoms.get_initial_magnetic_moments().tolist() == [2.5] * (len(atoms) - 1) + [\n\t\t5.0\n\t]\n\n\tatoms = bulk(\"Eu\") * (2, 2, 1)\n\tatoms[-1].symbol = \"Fe\"\n\tcalc = Vasp(atoms, preset=\"SlabSet\")\n\tatoms.calc = calc\n\tassert atoms.get_initial_magnetic_moments().tolist() == [7.0] * (len(atoms) - 1) + [\n\t\t5.0\n\t]\n\n\tatoms = bulk(\"Cu\") * (2, 2, 1)\n\tatoms[-1].symbol = \"Fe\"\n\tcalc = Vasp(atoms, preset=\"MPScanSet\")\n\tatoms.calc = calc\n\tassert atoms.get_initial_magnetic_moments().tolist() == [1.0] * (len(atoms) - 1) + [\n\t\t5.0\n\t]\n\n\tatoms = bulk(\"Cu\") * (2, 2, 1)\n\tatoms[-1].symbol = \"Fe\"\n\tatoms.set_initial_magnetic_moments([3.14] * (len(atoms) - 1) + [1.0])\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert atoms.get_initial_magnetic_moments().tolist() == [3.14] * (\n\t\tlen(atoms) - 1\n\t) + [1.0]\n\n\tatoms = bulk(\"Co\") * (2, 2, 1)\n\tatoms[-1].symbol = \"Fe\"\n\tatoms.set_initial_magnetic_moments([0.0] * len(atoms))\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n\tatoms = deepcopy(ATOMS_MAG)\n\tmags = atoms.get_magnetic_moments()\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.array_equal(atoms.get_initial_magnetic_moments(), mags) is True\n\n\tatoms = deepcopy(ATOMS_MAG)\n\tcalc = Vasp(atoms, preset=\"BulkSet\", mag_cutoff=2.0)\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n\tatoms = deepcopy(ATOMS_MAG)\n\tassert atoms.get_magnetic_moments()[0] == 0.468\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert atoms.get_initial_magnetic_moments()[0] == 0.468\n\n\tatoms = deepcopy(ATOMS_NOMAG)\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\tatoms.calc.results = {\"energy\": -1.0}  # mock calculation run\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert atoms.has(\"initial_magmoms\") is True\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n\tatoms = deepcopy(ATOMS_NOMAG)\n\tcalc = SinglePointDFTCalculator(atoms, **{\"magmoms\": [0.0] * len(atoms)})\n\tatoms.calc = calc\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n\tatoms = deepcopy(ATOMS_NOMAG)\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert atoms.has(\"initial_magmoms\") is True\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\tatoms.calc.results = {\"magmoms\": [0.0] * len(atoms)}\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n\tatoms = deepcopy(ATOMS_NOMAG)\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert atoms.has(\"initial_magmoms\") is True\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\tatoms.calc.results = {\"magmoms\": [1.0] * len(atoms)}\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 1)\n\n\tatoms = deepcopy(ATOMS_NOSPIN)\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert atoms.has(\"initial_magmoms\") is True\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\tatoms.calc.results = {\"magmoms\": [1.0] * len(atoms)}\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 1)\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, preset=\"BulkSet\", copy_magmoms=False)\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 2.0)\n\tatoms.calc.results = {\"magmoms\": [3.0] * len(atoms)}\n\tcalc = Vasp(atoms, preset=\"BulkSet\", copy_magmoms=False)\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 2.0)\n\n\tatoms = bulk(\"Mg\")\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 1.0)\n\tatoms.calc.results = {\"magmoms\": [0.0] * len(atoms)}\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n\tatoms = bulk(\"Mg\")\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 1.0)\n\tatoms.calc.results = {\"magmoms\": [-0.01] * len(atoms)}\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n\tatoms = bulk(\"Mg\")\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == 1.0)\n\tatoms.calc.results = {\"magmoms\": [-5] * len(atoms)}\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert np.all(atoms.get_initial_magnetic_moments() == -5)\n\n\tatoms = deepcopy(ATOMS_MAG)\n\tmags = atoms.get_magnetic_moments()\n\tatoms = prep_next_run(atoms)\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert atoms.has(\"initial_magmoms\") is True\n\tassert atoms.get_initial_magnetic_moments().tolist() == mags.tolist()\n\n\tatoms = deepcopy(ATOMS_NOMAG)\n\tatoms = prep_next_run(atoms)\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert atoms.has(\"initial_magmoms\") is True\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n\tatoms = deepcopy(ATOMS_NOSPIN)\n\tatoms = prep_next_run(atoms)\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tassert atoms.has(\"initial_magmoms\") is True\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n\tatoms = deepcopy(ATOMS_MAG)\n\tatoms = prep_next_run(atoms)\n\tcalc = Vasp(atoms, preset=\"BulkSet\", mag_cutoff=10.0)\n\tatoms.calc = calc\n\tassert atoms.has(\"initial_magmoms\") is True\n\tassert np.all(atoms.get_initial_magnetic_moments() == 0)\n\n\tatoms = bulk(\"Mg\")\n\tcalc = Vasp(atoms)\n\tatoms.calc = calc\n\tatoms.calc.results = {\"energy\": -1.0, \"magmoms\": [0.0] * len(atoms)}\n\tatoms = prep_next_run(atoms)\n\tatoms *= (2, 2, 2)\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tnp.all(atoms.get_initial_magnetic_moments() == 0.0)\n\n\tatoms = bulk(\"Mg\")\n\tcalc = Vasp(atoms)\n\tatoms.calc = calc\n\tatoms.calc.results = {\"energy\": -1.0, \"magmoms\": [-0.02] * len(atoms)}\n\tatoms = prep_next_run(atoms)\n\tatoms *= (2, 2, 2)\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tnp.all(atoms.get_initial_magnetic_moments() == 0.0)\n\n\tatoms = bulk(\"Mg\")\n\tcalc = Vasp(atoms)\n\tatoms.calc = calc\n\tatoms.calc.results = {\"energy\": -1.0}\n\tatoms = prep_next_run(atoms)\n\tatoms *= (2, 2, 2)\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tnp.all(atoms.get_initial_magnetic_moments() == 0.0)\n\n\tatoms = bulk(\"Mg\")\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tatoms.calc.results = {\"energy\": -1.0, \"magmoms\": [3.14] * len(atoms)}\n\tatoms = prep_next_run(atoms)\n\tatoms *= (2, 2, 2)\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tatoms.calc = calc\n\tnp.all(atoms.get_initial_magnetic_moments() == 3.14)\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_unused_flags", "data": "def test_unused_flags():\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, preset=\"BulkSet\", potim=1.5, nsw=0)\n\tassert calc.int_params[\"nsw\"] == 0\n\tassert calc.exp_params[\"ediffg\"] is None\n\tassert calc.int_params[\"isif\"] is None\n\tassert calc.float_params[\"potim\"] is None\n\n\tcalc = Vasp(atoms, ldau=False, ldauprint=2)\n\tassert calc.int_params[\"ldauprint\"] is None\n\tassert calc.bool_params[\"ldau\"] is None\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_lasph", "data": "def test_lasph():\n\tatoms = bulk(\"Cu\")\n\n\tcalc = Vasp(atoms, xc=\"rpbe\")\n\tassert calc.bool_params[\"lasph\"] is None\n\n\tcalc = Vasp(atoms, xc=\"m06l\")\n\tassert calc.bool_params[\"lasph\"] is True\n\n\tcalc = Vasp(atoms, xc=\"m06l\", lasph=False)\n\tassert calc.bool_params[\"lasph\"] is True\n\n\tcalc = Vasp(atoms, xc=\"hse06\")\n\tassert calc.bool_params[\"lasph\"] is True\n\n\tcalc = Vasp(atoms, xc=\"beef-vdw\")\n\tassert calc.bool_params[\"lasph\"] is True\n\n\tcalc = Vasp(atoms, ldau_luj={\"Cu\": {\"L\": 2, \"U\": 5, \"J\": 0.0}})\n\tassert calc.bool_params[\"lasph\"] is True\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_lmaxtau", "data": "def test_lmaxtau():\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, lasph=True)\n\tassert calc.int_params[\"lmaxtau\"] is None\n\n\tatoms = bulk(\"Ce\")\n\tcalc = Vasp(atoms, lasph=True)\n\tassert calc.int_params[\"lmaxtau\"] == 8\n\n\tatoms = bulk(\"Cu\") * (2, 2, 2)\n\tatoms[-1].symbol = \"Ce\"\n\tcalc = Vasp(atoms, lasph=True)\n\tassert calc.int_params[\"lmaxtau\"] == 8\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_algo", "data": "def test_algo():\n\tatoms = bulk(\"Cu\")\n\n\tcalc = Vasp(atoms, xc=\"rpbe\")\n\tassert calc.string_params[\"algo\"] is None\n\n\tcalc = Vasp(atoms, xc=\"m06l\")\n\tassert calc.string_params[\"algo\"] == \"all\"\n\n\tcalc = Vasp(atoms, xc=\"m06l\", algo=\"fast\")\n\tassert calc.string_params[\"algo\"] == \"all\"\n\n\tcalc = Vasp(atoms, xc=\"hse06\")\n\tassert calc.string_params[\"algo\"] == \"damped\"\n\tassert calc.float_params[\"time\"] == 0.5\n\n\tatoms[0].symbol = \"H\"\n\tcalc = Vasp(atoms, xc=\"hse06\")\n\tassert calc.string_params[\"algo\"] == \"all\"\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_kpar", "data": "def test_kpar():\n\tatoms = bulk(\"Cu\")\n\n\tcalc = Vasp(atoms, kpts=[2, 2, 1], kpar=4)\n\tassert calc.int_params[\"kpar\"] == 4\n\n\tcalc = Vasp(atoms, kpar=4)\n\tassert calc.int_params[\"kpar\"] == 1\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_isym", "data": "def test_isym():\n\tatoms = bulk(\"Cu\")\n\n\tcalc = Vasp(atoms, isym=2)\n\tassert calc.int_params[\"isym\"] == 2\n\n\tcalc = Vasp(atoms, isym=0)\n\tassert calc.int_params[\"isym\"] == 0\n\n\tcalc = Vasp(atoms, xc=\"hse06\", isym=2)\n\tassert calc.int_params[\"isym\"] == 3\n\n\tcalc = Vasp(atoms, isym=2, nsw=100)\n\tassert calc.int_params[\"isym\"] == 0\n\n\tcalc = Vasp(atoms, xc=\"hse06\", isym=2, nsw=100)\n\tassert calc.int_params[\"isym\"] == 0\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_ncore", "data": "def test_ncore():\n\tatoms = bulk(\"Cu\")\n\n\tcalc = Vasp(atoms, ncore=16)\n\tassert calc.int_params[\"ncore\"] == 1\n\n\tcalc = Vasp(atoms, npar=16)\n\tassert calc.int_params[\"ncore\"] == 1\n\tassert calc.int_params[\"npar\"] is None\n\n\tatoms *= (2, 2, 2)\n\tcalc = Vasp(atoms, ncore=4)\n\tassert calc.int_params[\"ncore\"] == 4\n\n\tcalc = Vasp(atoms, ncore=4, lhfcalc=True)\n\tassert calc.int_params[\"ncore\"] == 1\n\n\tcalc = Vasp(atoms, npar=4, lhfcalc=True)\n\tassert calc.int_params[\"ncore\"] == 1\n\tassert calc.int_params[\"npar\"] is None\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_ismear", "data": "def test_ismear():\n\tatoms = bulk(\"Cu\")\n\n\tcalc = Vasp(atoms, nsw=10)\n\tassert calc.int_params[\"ismear\"] is None\n\n\tcalc = Vasp(atoms, ismear=-5, nsw=10)\n\tassert calc.int_params[\"ismear\"] == 1\n\tassert calc.float_params[\"sigma\"] == 0.1\n\n\tcalc = Vasp(atoms, ismear=-5, nsw=0)\n\tassert calc.int_params[\"ismear\"] == 0\n\n\tcalc = Vasp(atoms, kpts=(10, 10, 10), ismear=-5, nsw=0)\n\tassert calc.int_params[\"ismear\"] == -5\n\n\tcalc = Vasp(atoms, ismear=0, nsw=10)\n\tassert calc.int_params[\"ismear\"] == 0\n\n\tcalc = Vasp(atoms, nedos=3001, nsw=0)\n\tassert calc.int_params[\"ismear\"] == 0\n\n\tcalc = Vasp(atoms, ismear=-5, nedos=3001, nsw=0)\n\tassert calc.int_params[\"ismear\"] == 0\n\n\tcalc = Vasp(atoms, kpts=(10, 10, 10), nedos=3001, nsw=0)\n\tassert calc.int_params[\"ismear\"] == -5\n\n\tcalc = Vasp(atoms, auto_kpts={\"line_density\": 100}, ismear=1)\n\tassert calc.int_params[\"ismear\"] == 0\n\tassert calc.float_params[\"sigma\"] == 0.01\n\n\tcalc = Vasp(atoms, auto_kpts={\"line_density\": 100}, ismear=0, sigma=1e-3)\n\tassert calc.int_params[\"ismear\"] == 0\n\tassert calc.float_params[\"sigma\"] == 1e-3\n\n\tcalc = Vasp(atoms, auto_kpts={\"line_density\": 100}, ismear=-5)\n\tassert calc.int_params[\"ismear\"] == 0\n\n\tcalc = Vasp(atoms, kspacing=1.0, ismear=-5)\n\tassert calc.int_params[\"ismear\"] == 0\n\tassert calc.float_params[\"sigma\"] == 0.05\n\n\tcalc = Vasp(atoms, nsw=0, kspacing=1.0, ismear=1, sigma=0.1)\n\tassert calc.int_params[\"ismear\"] == 1\n\tassert calc.float_params[\"sigma\"] == 0.1\n\n\tatoms[0].symbol = \"H\"\n\tcalc = Vasp(atoms, kpts=(10, 10, 10), ismear=-5, nsw=10)\n\tassert calc.int_params[\"ismear\"] == -5\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_laechg", "data": "def test_laechg():\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, nsw=10, laechg=True)\n\tassert not calc.bool_params[\"laechg\"]\n\n\tcalc = Vasp(atoms, laechg=True)\n\tassert calc.bool_params[\"laechg\"]\n\n\tcalc = Vasp(atoms, nsw=0, laechg=True)\n\tassert calc.bool_params[\"laechg\"]\n\n\tcalc = Vasp(atoms, nsw=0, laechg=False)\n\tassert not calc.bool_params[\"laechg\"]\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_ldauprint", "data": "def test_ldauprint():\n\tatoms = bulk(\"Cu\")\n\n\tcalc = Vasp(atoms, ldau=True)\n\tassert calc.int_params[\"ldauprint\"] == 1\n\n\tcalc = Vasp(atoms, ldau=True, ldauprint=0)\n\tassert calc.int_params[\"ldauprint\"] == 1\n\n\tcalc = Vasp(atoms, ldau=False, ldauprint=1)\n\tassert calc.int_params[\"ldauprint\"] is None\n\n\tcalc = Vasp(atoms, ldau_luj={\"Cu\": {\"L\": 2, \"U\": 5, \"J\": 0.0}})\n\tassert calc.int_params[\"ldauprint\"] == 1\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_lreal", "data": "def test_lreal():\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, lreal=True, nsw=0)\n\tassert calc.special_params[\"lreal\"] is False\n\n\tcalc = Vasp(atoms, lreal=True, nsw=10)\n\tassert calc.special_params[\"lreal\"] is True\n\n\tcalc = Vasp(atoms, nsw=10)\n\tassert calc.special_params[\"lreal\"] is None\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_lorbit", "data": "def test_lorbit():\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, ispin=2)\n\tassert calc.int_params[\"lorbit\"] == 11\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, ispin=1)\n\tassert calc.int_params[\"lorbit\"] is None\n\n\tatoms = bulk(\"Cu\")\n\tatoms.set_initial_magnetic_moments([1.0] * len(atoms))\n\tcalc = Vasp(atoms)\n\tassert calc.int_params[\"lorbit\"] == 11\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_setups", "data": "def test_setups():\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, preset=\"BulkSet\")\n\tassert calc.parameters[\"setups\"][\"Cu\"] == \"\"\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, preset=\"SlabSet\")\n\tassert calc.parameters[\"setups\"][\"Ba\"] == \"_sv\"\n\tassert calc.parameters[\"setups\"][\"Cu\"] == \"\"\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, preset=\"MPScanSet\")\n\tassert calc.parameters[\"setups\"][\"Cu\"] == \"_pv\"\n\n\tatoms = bulk(\"Cu\")\n\tVasp(\n\t\tatoms,\n\t\tsetups=os.path.join(FILE_DIR, \"test_setups.yaml\"),\n\t\tpreset=\"BulkSet\",\n\t)\n\tassert calc.parameters[\"setups\"][\"Cu\"] == \"_pv\"\n\n\tatoms = bulk(\"Cu\")\n\tVasp(\n\t\tatoms,\n\t\tsetups=\"setups_pbe54_MP.yaml\",\n\t\tpreset=\"BulkSet\",\n\t)\n\tassert calc.parameters[\"setups\"][\"Cu\"] == \"_pv\"\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, setups=\"minimal\", preset=\"MPScanSet\")\n\tassert (\n\t\tisinstance(calc.parameters[\"setups\"], str)\n\t\tand calc.parameters[\"setups\"] == \"minimal\"\n\t)\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, preset=\"QMOFSet\")\n\tassert calc.parameters[\"setups\"][\"Cu\"] == \"\"\n\tassert calc.parameters[\"setups\"][\"Er\"] == \"_3\"\n\tassert calc.parameters[\"setups\"][\"Yb\"] == \"_3\"\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_kpoint_schemes", "data": "def test_kpoint_schemes():\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, kpts=[1, 1, 1], preset=\"BulkSet\")\n\tassert calc.kpts == [1, 1, 1]\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, auto_kpts={\"grid_density\": 1000}, gamma=False)\n\tassert calc.kpts == [10, 10, 10]\n\tassert calc.input_params[\"gamma\"] is False\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, auto_kpts={\"grid_density\": 1000})\n\tassert calc.kpts == [10, 10, 10]\n\tassert calc.input_params[\"gamma\"] is True\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(\n\t\tatoms,\n\t\tpreset=\"BulkSet\",\n\t\tauto_kpts={\"grid_density\": 1000},\n\t\tgamma=False,\n\t)\n\tatoms.calc = calc\n\tassert calc.kpts == [10, 10, 10]\n\tassert calc.input_params[\"gamma\"] is False\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, auto_kpts={\"grid_density\": 1000}, gamma=True)\n\tassert calc.kpts == [10, 10, 10]\n\tassert calc.input_params[\"gamma\"] is True\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, auto_kpts={\"reciprocal_density\": 100})\n\tassert calc.kpts == [12, 12, 12]\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, auto_kpts={\"max_mixed_density\": [100, 1000]})\n\tassert calc.kpts == [12, 12, 12]\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, auto_kpts={\"max_mixed_density\": [10, 1000]})\n\tassert calc.kpts == [10, 10, 10]\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, auto_kpts={\"length_density\": [50, 50, 1]})\n\tassert calc.kpts == [20, 20, 1]\n\n\tatoms = bulk(\"Cu\")\n\tcalc = Vasp(atoms, auto_kpts={\"line_density\": 100})\n\tassert calc.kpts[-1] == pytest.approx(\n\t\tnp.array([1.30537091e00, 1.11022302e-16, 1.30537091e00])\n\t)\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_constraints", "data": "def test_constraints():\n\tatoms = bulk(\"Cu\")\n\tatoms.set_constraint(FixAtoms(indices=[0]))\n\tcalc = Vasp(atoms)\n\tatoms.calc = calc\n\tassert isinstance(atoms.constraints[0], FixAtoms)\n\n\tatoms = bulk(\"Cu\") * (2, 1, 1)\n\tatoms.set_constraint(FixBondLength(0, 1))\n\twith pytest.raises(ValueError):\n\t\tcalc = Vasp(atoms)\n\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}, {"term": "def", "name": "test_bad", "data": "def test_bad():\n\tatoms = bulk(\"Cu\")\n\twith pytest.raises(ValueError):\n\t\tVasp(atoms, auto_kpts={\"max_mixed_density\": [100]})\n\n\twith pytest.raises(ValueError):\n\t\tVasp(atoms, auto_kpts={\"length_density\": [100]})\n\n\twith pytest.raises(ValueError):\n\t\tVasp(atoms, auto_kpts={\"test\": [100]})\n\n\twith pytest.warns(Warning):\n\t\tVasp(atoms, auto_kpts={\"max_mixed_density\": [1000, 100]})\n\n\twith pytest.raises(ValueError):\n\t\tVasp(atoms, preset=\"BadRelaxSet\")\n", "description": null, "category": "math", "imports": ["import os", "from copy import deepcopy", "from pathlib import Path", "import numpy as np", "import pytest", "from ase.build import bulk", "from ase.calculators.singlepoint import SinglePointDFTCalculator", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.constraints import FixAtoms, FixBondLength", "from ase.io import read", "from quacc.calculators.vasp import Vasp", "from quacc.presets import vasp as v", "from quacc.util.atoms import prep_next_run"]}], [], [{"term": "class", "name": "classGaussianDynamics:", "data": "class GaussianDynamics:\n\tcalctype = 'optimizer'\n\tdelete = ['force']\n\tkeyword: Optional[str] = None\n\tspecial_keywords: Dict[str, str] = dict()\n\n\tdef __init__(self, atoms, calc=None):\n\t\tself.atoms = atoms\n\t\tif calc is not None:\n\t\t\tself.calc = calc\n\t\telse:\n\t\t\tif self.atoms.calc is None:\n\t\t\t\traise ValueError(\"{} requires a valid Gaussian calculator \"\n\t\t\t\t\t\t\t\t \"object!\".format(self.__class__.__name__))\n\n\t\t\tself.calc = self.atoms.calc\n\n\tdef todict(self):\n\t\treturn {'type': self.calctype,\n\t\t\t\t'optimizer': self.__class__.__name__}\n\n\tdef delete_keywords(self, kwargs):\n\t\t\"\"\"removes list of keywords (delete) from kwargs\"\"\"\n\t\tfor d in self.delete:\n\t\t\tkwargs.pop(d, None)\n\n\tdef set_keywords(self, kwargs):\n\t\targs = kwargs.pop(self.keyword, [])\n\t\tif isinstance(args, str):\n\t\t\targs = [args]\n\t\telif isinstance(args, Iterable):\n\t\t\targs = list(args)\n\n\t\tfor key, template in self.special_keywords.items():\n\t\t\tif key in kwargs:\n\t\t\t\tval = kwargs.pop(key)\n\t\t\t\targs.append(template.format(val))\n\n\t\tkwargs[self.keyword] = args\n\n\tdef run(self, **kwargs):\n\t\tcalc_old = self.atoms.calc\n\t\tparams_old = copy.deepcopy(self.calc.parameters)\n\n\t\tself.delete_keywords(kwargs)\n\t\tself.delete_keywords(self.calc.parameters)\n\t\tself.set_keywords(kwargs)\n\n\t\tself.calc.set(**kwargs)\n\t\tself.atoms.calc = self.calc\n\n\t\ttry:\n\t\t\tself.atoms.get_potential_energy()\n\t\texcept OSError:\n\t\t\tconverged = False\n\t\telse:\n\t\t\tconverged = True\n\n\t\tatoms = read(self.calc.label + '.log')\n\t\tself.atoms.cell = atoms.cell\n\t\tself.atoms.positions = atoms.positions\n\n\t\tself.calc.parameters = params_old\n\t\tself.calc.reset()\n\t\tif calc_old is not None:\n\t\t\tself.atoms.calc = calc_old\n\n\t\treturn converged\n\n", "description": "removes list of keywords (delete) from kwargs", "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}, {"term": "class", "name": "GaussianOptimizer", "data": "class GaussianOptimizer(GaussianDynamics):\n\tkeyword = 'opt'\n\tspecial_keywords = {\n\t\t'fmax': '{}',\n\t\t'steps': 'maxcycle={}',\n\t}\n\n", "description": null, "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}, {"term": "class", "name": "GaussianIRC", "data": "class GaussianIRC(GaussianDynamics):\n\tkeyword = 'irc'\n\tspecial_keywords = {\n\t\t'direction': '{}',\n\t\t'steps': 'maxpoints={}',\n\t}\n\n", "description": null, "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}, {"term": "class", "name": "Gaussian", "data": "class Gaussian(FileIOCalculator):\n\timplemented_properties = ['energy', 'forces', 'dipole']\n\tcommand = 'GAUSSIAN < PREFIX.com > PREFIX.log'\n\tdiscard_results_on_any_change = True\n\n\tdef __init__(self, *args, label='Gaussian', **kwargs):\n\t\tFileIOCalculator.__init__(self, *args, label=label, **kwargs)\n\n\tdef calculate(self, *args, **kwargs):\n\t\tgaussians = ('g16', 'g09', 'g03')\n\t\tif 'GAUSSIAN' in self.command:\n\t\t\tfor gau in gaussians:\n\t\t\t\tif which(gau):\n\t\t\t\t\tself.command = self.command.replace('GAUSSIAN', gau)\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\traise EnvironmentError('Missing Gaussian executable {}'\n\t\t\t\t\t\t\t\t\t   .format(gaussians))\n\n\t\tFileIOCalculator.calculate(self, *args, **kwargs)\n\n\tdef write_input(self, atoms, properties=None, system_changes=None):\n\t\tFileIOCalculator.write_input(self, atoms, properties, system_changes)\n\t\twrite(self.label + '.com', atoms, properties=properties,\n\t\t\t  format='gaussian-in', parallel=False, **self.parameters)\n\n\tdef read_results(self):\n\t\toutput = read(self.label + '.log', format='gaussian-out')\n\t\tself.calc = output.calc\n\t\tself.results = output.calc.results\n\n\t# Method(s) defined in the old calculator, added here for\n\t# backwards compatibility\n\tdef clean(self):\n\t\tfor suffix in ['.com', '.chk', '.log']:\n\t\t\ttry:\n\t\t\t\tos.remove(os.path.join(self.directory, self.label + suffix))\n\t\t\texcept OSError:\n\t\t\t\tpass\n\n\tdef get_version(self):\n\t\traise NotImplementedError  # not sure how to do this yet\n", "description": null, "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "test_vasp2_kpoints", "data": "def test_vasp2_kpoints(require_vasp):\n\t\"\"\"\n\n\tCheck the many ways of specifying KPOINTS\n\n\t\"\"\"\n\n\timport os\n\n\tfrom ase.calculators.vasp import Vasp2 as Vasp\n\tfrom ase.build import bulk\n\tfrom ase.test.calculator.vasp import installed2 as installed\n\n\tassert installed()\n\n\n\tAl = bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\n\tdef check_kpoints_line(n, contents):\n\t\t\"\"\"Assert the contents of a line\"\"\"\n\t\twith open('KPOINTS', 'r') as f:\n\t\t\tlines = f.readlines()\n\t\t\tassert lines[n] == contents\n\n\t# Default to (1 1 1)\n\n\tcalc = Vasp(gamma=True)\n\tcalc.write_kpoints()\n\tcheck_kpoints_line(2, 'Gamma\\n')\n\tcheck_kpoints_line(3, '1 1 1 \\n')\n\tcalc.clean()\n\n\t# 3-tuple prints mesh\n\tcalc = Vasp(gamma=False, kpts=(4, 4, 4))\n\tcalc.write_kpoints()\n\tcheck_kpoints_line(2, 'Monkhorst-Pack\\n')\n\tcheck_kpoints_line(3, '4 4 4 \\n')\n\tcalc.clean()\n\n\t# Auto mode\n\tcalc = Vasp(kpts=20)\n\tcalc.write_kpoints()\n\tcheck_kpoints_line(1, '0\\n')\n\tcheck_kpoints_line(2, 'Auto\\n')\n\tcheck_kpoints_line(3, '20 \\n')\n\tcalc.clean()\n\n\t# 1-element list ok, Gamma ok\n\tcalc = Vasp(kpts=[20], gamma=True)\n\tcalc.write_kpoints()\n\tcheck_kpoints_line(1, '0\\n')\n\tcheck_kpoints_line(2, 'Auto\\n')\n\tcheck_kpoints_line(3, '20 \\n')\n\tcalc.clean()\n\n\t# KSPACING suppresses KPOINTS file\n\tcalc = Vasp(kspacing=0.23)\n\tcalc.initialize(Al)\n\tcalc.write_kpoints()\n\tcalc.write_incar(Al)\n\tassert not os.path.isfile('KPOINTS')\n\twith open('INCAR', 'r') as f:\n\t\tassert ' KSPACING = 0.230000\\n' in f.readlines()\n\tcalc.clean()\n\n\t# Negative KSPACING raises an error\n\tcalc = Vasp(kspacing=-0.5)\n\n\ttry:\n\t\tcalc.write_kpoints()\n\texcept ValueError:\n\t\tpass\n\telse:\n\t\traise AssertionError(\"Negative KSPACING did not raise ValueError\")\n\tcalc.clean()\n\n\t# Explicit weighted points with nested lists, Cartesian if not specified\n\tcalc = Vasp(\n\t\tkpts=[[0.1, 0.2, 0.3, 2], [0.0, 0.0, 0.0, 1], [0.0, 0.5, 0.5, 2]])\n\tcalc.write_kpoints()\n\n\twith open('KPOINTS.ref', 'w') as f:\n\t\tf.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n\t3 \n\tCartesian\n\t0.100000 0.200000 0.300000 2.000000 \n\t0.000000 0.000000 0.000000 1.000000 \n\t0.000000 0.500000 0.500000 2.000000 \n\t\"\"\")\n\n\tassert filecmp_ignore_whitespace('KPOINTS', 'KPOINTS.ref')\n\tos.remove('KPOINTS.ref')\n\n\t# Explicit points as list of tuples, automatic weighting = 1.\n\tcalc = Vasp(\n\t\tkpts=[(0.1, 0.2, 0.3), (0.0, 0.0, 0.0), (0.0, 0.5, 0.5)], reciprocal=True)\n\tcalc.write_kpoints()\n\n\twith open('KPOINTS.ref', 'w') as f:\n\t\tf.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n\t3 \n\tReciprocal\n\t0.100000 0.200000 0.300000 1.0 \n\t0.000000 0.000000 0.000000 1.0 \n\t0.000000 0.500000 0.500000 1.0 \n\t\"\"\")\n\n\tassert filecmp_ignore_whitespace('KPOINTS', 'KPOINTS.ref')\n\tos.remove('KPOINTS.ref')\n", "description": "\n\n\tCheck the many ways of specifying KPOINTS\n\n\t", "category": "math", "imports": ["from ase.test.calculator.vasp.filecmp_ignore_whitespace import (", "\timport os", "\tfrom ase.calculators.vasp import Vasp2 as Vasp", "\tfrom ase.build import bulk", "\tfrom ase.test.calculator.vasp import installed2 as installed"]}], [{"term": "def", "name": "test_vasp_kpoints", "data": "def test_vasp_kpoints(require_vasp):\n\t\"\"\"\n\n\tCheck the many ways of specifying KPOINTS\n\n\t\"\"\"\n\n\timport os\n\n\tfrom ase.calculators.vasp import Vasp\n\tfrom ase.build import bulk\n\tfrom ase.test.calculator.vasp import installed\n\n\tassert installed()\n\n\tAl = bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\n\tdef check_kpoints_line(n, contents):\n\t\t\"\"\"Assert the contents of a line\"\"\"\n\t\twith open('KPOINTS', 'r') as f:\n\t\t\tlines = f.readlines()\n\t\t\tassert lines[n] == contents\n\n\t# Default to (1 1 1)\n\n\tcalc = Vasp(gamma=True)\n\tcalc.write_kpoints()\n\tcheck_kpoints_line(2, 'Gamma\\n')\n\tcheck_kpoints_line(3, '1 1 1 \\n')\n\tcalc.clean()\n\n\t# 3-tuple prints mesh\n\tcalc = Vasp(gamma=False, kpts=(4, 4, 4))\n\tcalc.write_kpoints()\n\tcheck_kpoints_line(2, 'Monkhorst-Pack\\n')\n\tcheck_kpoints_line(3, '4 4 4 \\n')\n\tcalc.clean()\n\n\t# Auto mode\n\tcalc = Vasp(kpts=20)\n\tcalc.write_kpoints()\n\tcheck_kpoints_line(1, '0\\n')\n\tcheck_kpoints_line(2, 'Auto\\n')\n\tcheck_kpoints_line(3, '20 \\n')\n\tcalc.clean()\n\n\t# 1-element list ok, Gamma ok\n\tcalc = Vasp(kpts=[20], gamma=True)\n\tcalc.write_kpoints()\n\tcheck_kpoints_line(1, '0\\n')\n\tcheck_kpoints_line(2, 'Auto\\n')\n\tcheck_kpoints_line(3, '20 \\n')\n\tcalc.clean()\n\n\t# KSPACING suppresses KPOINTS file\n\tcalc = Vasp(kspacing=0.23)\n\tcalc.initialize(Al)\n\tcalc.write_kpoints()\n\tcalc.write_incar(Al)\n\tassert not os.path.isfile('KPOINTS')\n\twith open('INCAR', 'r') as f:\n\t\tassert ' KSPACING = 0.230000\\n' in f.readlines()\n\tcalc.clean()\n\n\t# Negative KSPACING raises an error\n\tcalc = Vasp(kspacing=-0.5)\n\n\ttry:\n\t\tcalc.write_kpoints()\n\texcept ValueError:\n\t\tpass\n\telse:\n\t\traise AssertionError(\"Negative KSPACING did not raise ValueError\")\n\tcalc.clean()\n\n\t# Explicit weighted points with nested lists, Cartesian if not specified\n\tcalc = Vasp(\n\t\tkpts=[[0.1, 0.2, 0.3, 2], [0.0, 0.0, 0.0, 1], [0.0, 0.5, 0.5, 2]])\n\tcalc.write_kpoints()\n\n\twith open('KPOINTS.ref', 'w') as f:\n\t\tf.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n\t3 \n\tCartesian\n\t0.100000 0.200000 0.300000 2.000000 \n\t0.000000 0.000000 0.000000 1.000000 \n\t0.000000 0.500000 0.500000 2.000000 \n\t\"\"\")\n\n\tassert filecmp_ignore_whitespace('KPOINTS', 'KPOINTS.ref')\n\tos.remove('KPOINTS.ref')\n\n\t# Explicit points as list of tuples, automatic weighting = 1.\n\tcalc = Vasp(\n\t\tkpts=[(0.1, 0.2, 0.3), (0.0, 0.0, 0.0), (0.0, 0.5, 0.5)], reciprocal=True)\n\tcalc.write_kpoints()\n\n\twith open('KPOINTS.ref', 'w') as f:\n\t\tf.write(\"\"\"KPOINTS created by Atomic Simulation Environment\n\t3 \n\tReciprocal\n\t0.100000 0.200000 0.300000 1.0 \n\t0.000000 0.000000 0.000000 1.0 \n\t0.000000 0.500000 0.500000 1.0 \n\t\"\"\")\n\n\tassert filecmp_ignore_whitespace('KPOINTS', 'KPOINTS.ref')\n\tos.remove('KPOINTS.ref')\n", "description": "\n\n\tCheck the many ways of specifying KPOINTS\n\n\t", "category": "math", "imports": ["from ase.test.calculator.vasp.filecmp_ignore_whitespace import (", "\timport os", "\tfrom ase.calculators.vasp import Vasp", "\tfrom ase.build import bulk", "\tfrom ase.test.calculator.vasp import installed"]}], [{"term": "def", "name": "calc", "data": "def calc():\n\tsource = ExcelMock()\n\tcalculator = get_calculator()\n\treturn lambda line, ws_name: calculator(line, ws_name, source)\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_SUM", "data": "def test_SUM(calc):\n\tassert calc('SUM(Sheet4!A1:B3)', 'Yet another sheet').value == 64\n\tassert calc('SUM([0]Sheet4!A1:B3)', 'Yet another sheet').value == 64\n\tassert calc('SUM(Sheet4!A1:B3) + 1', 'Yet another sheet').value == 65\n\tassert calc('SUM(Sheet4!A1:B3,A2:B3)', 'Sheet4').value == 99\n\tassert calc('SUM(Sheet4!A1:B3,SUM(A3:B3))', 'Sheet4').value == 70\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_SUMIFS", "data": "def test_SUMIFS(calc):\n\tassert calc('SUMIFS(Sheet4!A1:B3,Sheet4!A1:B3,\">4\")', 'Yet another sheet').value == 58\n\tassert calc('SUMIFS(Sheet4!A1:B3,Sheet4!A1:B3,\"13\")', 'Yet another sheet').value == 26\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_SUMIF", "data": "def test_SUMIF(calc):\n\tassert calc('SUMIF(Sheet4!A1:B3,\">4\",Sheet4!A1:B3)', 'Yet another sheet').value == 58\n\tassert calc('SUMIF(Sheet4!A1:B3,\"13\",Sheet4!A1:B3)', 'Yet another sheet').value == 26\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_MOD", "data": "def test_MOD(calc):\n\tassert calc('MOD(\\'Sheet 1\\'!B3,4)', 'Yet another sheet').value == 2\n\tassert calc('MOD(\\'Sheet 1\\'!A3,\\'Sheet 1\\'!C3)', 'Yet another sheet').value == 4\n\tassert calc('MOD(\\'Sheet 1\\'!A3,\\'Sheet 1\\'!B3 * 2)', 'Yet another sheet').value == 0\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_IF", "data": "def test_IF(calc):\n\tassert calc('IF(2>1,1,2)', 'Yet another sheet').value == 1\n\tassert calc('IF(TRUE,1,2)', 'Yet another sheet').value == 1\n\tassert calc('IF(FALSE,1,2)', 'Yet another sheet').value == 2\n\tassert calc('IF(TRUE,1,2 ** 5)', 'Yet another sheet').value == 1\n\tassert calc('IF(\\'Sheet 1\\'!A3 = 4,\\'Sheet 1\\'!C3, 0)', 'Yet another sheet').value == 8\n\n\tassert calc('IF(TRUE, 1,)', 'Yet another sheet').value == 1\n\tassert calc('IF(FALSE, 1,)', 'Yet another sheet').value == 0\n\tassert calc('CONCATENATE(IF(FALSE, 1,))', 'Yet another sheet').value == ''\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_IFS", "data": "def test_IFS(calc, prefix):\n\tassert calc(prefix + 'IFS(FALSE,1,FALSE,2,TRUE,3)', 'Yet another sheet').value == 3\n\tassert calc(prefix + 'IFS(TRUE,1,FALSE,2,TRUE,3)', 'Yet another sheet').value == 1\n\tassert calc(prefix + 'IFS(FALSE,1,TRUE,2,TRUE,3)', 'Yet another sheet').value == 2\n\n\twith pytest.raises(ValueNotAvailable):\n\t\tassert calc(prefix + 'IFS(FALSE,1,FALSE,2,FALSE,3)', 'Yet another sheet').value == 1\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_IFERROR", "data": "def test_IFERROR(calc):\n\tassert calc('IFERROR(5/0,1)', 'Yet another sheet').value == 1\n\tassert calc('IFERROR(5+6, 0)', 'Yet another sheet').value == 11\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_MAX", "data": "def test_MAX(calc):\n\tassert calc('MAX(Sheet4!A1:B3)', 'Yet another sheet').value == 16\n\tassert calc('MAX(Sheet4!A1:B3,100)', 'Yet another sheet').value == 100\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_MIN", "data": "def test_MIN(calc):\n\tassert calc('MIN(Sheet4!A1:B3)', 'Yet another sheet').value == 2\n\tassert calc('MIN(Sheet4!A1:B3,1)', 'Yet another sheet').value == 1\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_LEFT", "data": "def test_LEFT(calc):\n\tassert calc('LEFT(\"test\", 2)', 'Yet another sheet').value == 'te'\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_RIGHT", "data": "def test_RIGHT(calc):\n\tassert calc('RIGHT(\"test\", 2)', 'Yet another sheet').value == 'st'\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_MID", "data": "def test_MID(calc):\n\tassert calc('MID(\"hello\",2,2)', 'Sheet 1').value == 'el'\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_ISBLANK", "data": "def test_ISBLANK(calc):\n\tassert calc('ISBLANK(\"test\")', 'Yet another sheet').value is False\n\tassert calc('ISBLANK(\"\")', 'Yet another sheet').value is False\n\tassert calc('ISBLANK(Sheet4!AA1)', 'Yet another sheet').value is True\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_OR", "data": "def test_OR(calc):\n\tassert calc('OR(0,0,0,TRUE)', 'Yet another sheet').value is True\n\tassert calc('OR(FALSE, 0)', 'Yet another sheet').value is False\n\tassert calc('OR(FALSE, 0 + 2)', 'Yet another sheet').value is True\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_AND", "data": "def test_AND(calc):\n\tassert calc('AND(1,1,1,TRUE)', 'Yet another sheet').value is True\n\tassert calc('AND(FALSE, 0)', 'Yet another sheet').value is False\n\tassert calc('AND(TRUE, 0 + 2)', 'Yet another sheet').value is True\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_not", "data": "def test_not(calc):\n\tassert calc('NOT(1)', 'Yet another sheet').value is False\n\tassert calc('NOT(0)', 'Yet another sheet').value is True\n\tassert calc('NOT(123)', 'Yet another sheet').value is False\n\tassert calc('NOT(TRUE)', 'Yet another sheet').value is False\n\tassert calc('NOT(FALSE)', 'Yet another sheet').value is True\n\tassert calc('NOT(A1)', 'Yet another sheet').value is True\n\tassert calc('NOT(A1)', 'Sheet4').value is False\n\tassert calc('NOT(\"\")', 'Yet another sheet').value is True\n\tassert calc('NOT(NOT(\"\"))', 'Yet another sheet').value is False\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_ROUND", "data": "def test_ROUND(calc):\n\tassert calc('ROUND(2.3456, 1)', 'Yet another sheet').value == 2.3\n\tassert calc('ROUND(2, 2)', 'Yet another sheet').value == 2.0\n\tassert calc('ROUND(\"2.34567\", 2)', 'Yet another sheet').value == 2.35\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_ROUNDDOWN", "data": "def test_ROUNDDOWN(calc):\n\tassert calc('ROUNDDOWN(1.345,0)', 'Sheet 1').value == 1.0\n\tassert calc('ROUNDDOWN(1.345,1)', 'Sheet 1').value == 1.3\n\tassert calc('ROUNDDOWN(1.345,2)', 'Sheet 1').value == 1.34\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_FLOOR", "data": "def test_FLOOR(calc):\n\tassert calc('FLOOR(10,3)', 'Sheet 1').value == 9\n\tassert calc('FLOOR(16,7)', 'Sheet 1').value == 14\n\tassert calc('FLOOR(26,13)', 'Sheet 1').value == 26\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_COUNT", "data": "def test_COUNT(calc):\n\tassert calc('COUNT(1.3456, 1, \"test\")', 'Yet another sheet').value == 2\n\tassert calc('COUNT(A1:C4)', 'Sheet 1').value == 6\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_COUNTIF", "data": "def test_COUNTIF(calc):\n\tassert calc('COUNTIF(A1:C4, \">4\")', 'Sheet 1').value == 4\n\tassert calc('COUNTIF(A1:C4, \"13\")', 'Sheet4').value == 2\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_COUNTBLANK", "data": "def test_COUNTBLANK(calc):\n\tassert calc('COUNTBLANK(A1:C4)', 'Sheet 1').value == 6\n\tassert calc('COUNTBLANK(A1:B4)', 'Sheet4').value == 2\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_ABS", "data": "def test_ABS(calc):\n\tassert calc('ABS(1.32)', 'Sheet 1').value == 1.32\n\tassert calc('ABS(-42)', 'Sheet4').value == 42\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_OFFSET", "data": "def test_OFFSET(calc):\n\tassert calc('OFFSET(A1,2,1)', 'Sheet 1').value == 2\n\tassert calc('OFFSET(A1,2,1,1)', 'Sheet 1').value == 2\n\tassert calc('OFFSET(A1,B3,1)', 'Sheet 1').value == 2\n\tassert calc('SUM(OFFSET(A1,2,1,1,2))', 'Sheet 1').value == 10\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_MATCH", "data": "def test_MATCH(calc):\n\tassert calc('MATCH(13,Sheet4!A1:A3)', 'Yet another sheet').value == 1\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_AVERAGE", "data": "def test_AVERAGE(calc):\n\tassert calc('AVERAGE(Sheet4!A1:B3)', 'Yet another sheet').value == 64 / 6\n\tassert calc('AVERAGEIFS(Sheet4!A1:B3,Sheet4!A1:B3,\"13\")', 'Yet another sheet').value == 13\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_AVERAGEIFS", "data": "def test_AVERAGEIFS(calc):\n\tassert calc('AVERAGEIFS(Sheet4!A1:B3,Sheet4!A1:B3,\"13\")', 'Yet another sheet').value == 13\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_VLOOKUP", "data": "def test_VLOOKUP(calc, formula, result):\n\tassert calc(formula, 'Sheet4').value == result\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_HLOOKUP", "data": "def test_HLOOKUP(calc, formula, result):\n\tassert calc(formula, 'Sheet4').value == result\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_SEARCH", "data": "def test_SEARCH(calc):\n\tassert calc('SEARCH(\"abc\", \"abc\")', 'Yet another sheet').value == 1\n\tassert calc('SEARCH(\"abc\", \"abc\", 1)', 'Yet another sheet').value == 1\n\tassert calc('SEARCH(\"abc\", \"aabc\", 1)', 'Yet another sheet').value == 2\n\n\twith pytest.raises(ValueErrorOperand):\n\t\tassert calc('SEARCH(\"abcd\", \"abc\")', 'Yet another sheet').value\n\n\twith pytest.raises(ValueErrorOperand):\n\t\tassert calc('SEARCH(\"abcd\", \"abc\", 1)', 'Yet another sheet').value\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_SMALL", "data": "def test_SMALL(calc):\n\tassert calc('SMALL(Sheet4!A1:B3,1)', 'Yet another sheet').value == 2\n\tassert calc('SMALL(Sheet4!A1:B3,2)', 'Yet another sheet').value == 4\n\tassert calc('SMALL(Sheet4!A1:B3,4)', 'Yet another sheet').value == 13\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_LARGE", "data": "def test_LARGE(calc):\n\tassert calc('LARGE(Sheet4!A1:B3,1)', 'Yet another sheet').value == 16\n\tassert calc('LARGE(Sheet4!A1:B3,2)', 'Yet another sheet').value == 16\n\tassert calc('LARGE(Sheet4!A1:B3,4)', 'Yet another sheet').value == 13\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_COUNTIFS", "data": "def test_COUNTIFS(calc):\n\tassert calc('COUNTIFS(Sheet4!A1:B3,Sheet4!A1:B3,\">4\")', 'Yet another sheet').value == 4\n\tassert calc('COUNTIFS(Sheet4!A1:B3,Sheet4!A1:B3,\"13\")', 'Yet another sheet').value == 2\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_COUNTA", "data": "def test_COUNTA(calc):\n\tassert calc('COUNTA(Sheet4!A1:B4)', 'Yet another sheet').value == 6\n\tassert calc('COUNTA(Sheet5!A1:B4)', 'Yet another sheet').value == 5\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_CONCATENATE", "data": "def test_CONCATENATE(calc):\n\tassert calc('CONCATENATE(Sheet4!A1,Sheet4!B3,\"13\")', 'Yet another sheet').value == '13213'\n\tassert calc('CONCATENATE(\"\",Sheet4!B3,TRUE)', 'Yet another sheet').value == '2TRUE'\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_INDEX", "data": "def test_INDEX(calc):\n\tassert calc('INDEX(Sheet4!A1:A3,1)', 'Yet another sheet').value == 13  # A1\n\tassert calc('INDEX(Sheet4!A1:B3,1,2)', 'Yet another sheet').value == 16  # B1\n\tassert calc('INDEX(Sheet4!A1:A3,3)', 'Yet another sheet').value == 4  # A3\n\tassert calc('INDEX(Sheet4!A2:A3,2)', 'Yet another sheet').value == 4  # A3\n\n\tassert calc('INDEX(Sheet4!A:A,3)', 'Yet another sheet').value == 4  # A3\n\tassert calc('INDEX(Sheet4!A:A,3,1)', 'Yet another sheet').value == 4  # A3\n\tassert calc('INDEX(Sheet4!3:3,1,1)', 'Yet another sheet').value == 4  # A3\n\tassert calc('INDEX(Sheet4!3:3,1,2)', 'Yet another sheet').value == 2  # B3\n\n\twith pytest.raises(BadReference):\n\t\tassert calc('INDEX(Sheet4!A1:A3,100,1)', 'Yet another sheet').value\n\n\twith pytest.raises(BadReference):\n\t\tassert calc('INDEX(Sheet4!A1:A3,1,100)', 'Yet another sheet').value\n\n\tassert calc('INDEX(Sheet4!A1:C3,1,1)', 'Yet another sheet').value == 13\n\tassert calc('INDEX(Sheet4!A1:C3,1,3)', 'Yet another sheet').value == 18\n\n\twith pytest.raises(BadReference):\n\t\tassert calc('INDEX(Sheet4!A1:C3,1)', 'Yet another sheet').value\n\n\twith pytest.raises(BadReference):\n\t\tassert calc('INDEX(Sheet4!A1:C3,100,1)', 'Yet another sheet').value\n\n\twith pytest.raises(BadReference):\n\t\tassert calc('INDEX(Sheet4!A1:C3,1,100)', 'Yet another sheet').value\n\n\twith pytest.raises(BadReference):\n\t\tassert calc('INDEX(Sheet4!A1:C3,0,100)', 'Yet another sheet').value\n\n\twith pytest.raises(BadReference):\n\t\tassert calc('INDEX(Sheet4!A1:C3,1,0)', 'Yet another sheet').value\n\n\twith pytest.raises(BadReference):\n\t\tassert calc('INDEX(Sheet4!A:A,3,2)', 'Yet another sheet').value\n\n\twith pytest.raises(BadReference):\n\t\tassert calc('INDEX(Sheet4!1:1,2)', 'Yet another sheet').value\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_SUBSTITUTE", "data": "def test_SUBSTITUTE(calc):\n\tassert calc('SUBSTITUTE(\"123123123\",\"1\",\"22\")', 'Yet another sheet').value == '222322232223'\n\tassert calc('SUBSTITUTE(\"123123123\",\"1\",\"22\", 2)', 'Yet another sheet').value == '22232223123'\n\tassert calc('SUBSTITUTE(\"123123123\",\"1\",\"22\", -1)', 'Yet another sheet').value == '222322232223'\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_TRIM", "data": "def test_TRIM(calc):\n\tassert calc('TRIM(1)', 'Yet another sheet').value == '1'\n\tassert calc('TRIM(0)', 'Yet another sheet').value == '0'\n\tassert calc('TRIM(\"1\")', 'Yet another sheet').value == '1'\n\tassert calc('TRIM(\" 1 \")', 'Yet another sheet').value == '1'\n\tassert calc('TRIM(\" 1 1 \")', 'Yet another sheet').value == '1 1'\n\tassert calc('TRIM(\" 1\t  1 \")', 'Yet another sheet').value == '1 1'\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_LEN", "data": "def test_LEN(calc):\n\tassert calc('LEN(1)', 'Yet another sheet').value == 1\n\tassert calc('LEN(0)', 'Yet another sheet').value == 1\n\tassert calc('LEN(\"1\")', 'Yet another sheet').value == 1\n\tassert calc('LEN(\" 1 \")', 'Yet another sheet').value == 3\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_YEARFRAC", "data": "def test_YEARFRAC(calc):\n\twith pytest.raises(NumErrorOperand):\n\t\tassert calc('YEARFRAC(1, 2, 5)', 'Yet another sheet').value\n\n\t# 30U/360\n\tassert calc('YEARFRAC(43159, 43160)', 'Yet another sheet').value == 1 / 360\n\tassert calc('YEARFRAC(43405, 43465, 0)', 'Yet another sheet').value == 60 / 360\n\tassert calc('YEARFRAC(43889, 43890, 0)', 'Yet another sheet').value == 1 / 360\n\tassert calc('YEARFRAC(43889, 43891, 0)', 'Yet another sheet').value == 3 / 360\n\n\t# Actual/Actual\n\tassert calc('YEARFRAC(43889, 43890, 1)', 'Yet another sheet').value == 1 / 366\n\tassert calc('YEARFRAC(43889, 43891, 1)', 'Yet another sheet').value == 2 / 366\n\tassert calc('YEARFRAC(43523, 43524, 1)', 'Yet another sheet').value == 1 / 365\n\tassert calc('YEARFRAC(43523, 43525, 1)', 'Yet another sheet').value == 2 / 365\n\n\t# Actual/360\n\tassert calc('YEARFRAC(43889, 43890, 2)', 'Yet another sheet').value == 1 / 360\n\tassert calc('YEARFRAC(43889, 43891, 2)', 'Yet another sheet').value == 2 / 360\n\tassert calc('YEARFRAC(43523, 43524, 2)', 'Yet another sheet').value == 1 / 360\n\tassert calc('YEARFRAC(43523, 43525, 2)', 'Yet another sheet').value == 2 / 360\n\n\t# Actual/365\n\tassert calc('YEARFRAC(43889, 43890, 3)', 'Yet another sheet').value == 1 / 365\n\tassert calc('YEARFRAC(43889, 43891, 3)', 'Yet another sheet').value == 2 / 365\n\tassert calc('YEARFRAC(43523, 43524, 3)', 'Yet another sheet').value == 1 / 365\n\tassert calc('YEARFRAC(43523, 43525, 3)', 'Yet another sheet').value == 2 / 365\n\n\t# 30E/360\n\tassert calc('YEARFRAC(43159, 43160, 4)', 'Yet another sheet').value == 3 / 360\n\tassert calc('YEARFRAC(43405, 43465, 4)', 'Yet another sheet').value == 59 / 360\n\tassert calc('YEARFRAC(43889, 43890, 4)', 'Yet another sheet').value == 1 / 360\n\tassert calc('YEARFRAC(43889, 43891, 4)', 'Yet another sheet').value == 3 / 360\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_lower", "data": "def test_lower(calc):\n\twith pytest.raises(ZeroDivisionErrorOperand):\n\t\t_ = calc('LOWER(1/0)', 'Yet another sheet').value\n\n\tassert calc('LOWER(1)', 'Yet another sheet').value == '1'\n\tassert calc('LOWER(\"1\")', 'Yet another sheet').value == '1'\n\tassert calc('LOWER(\"TEST\")', 'Yet another sheet').value == 'test'\n\tassert calc('LOWER(\"test\")', 'Yet another sheet').value == 'test'\n\tassert calc('LOWER(\"TeSt %1234\")', 'Yet another sheet').value == 'test %1234'\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_upper", "data": "def test_upper(calc):\n\twith pytest.raises(ZeroDivisionErrorOperand):\n\t\t_ = calc('UPPER(1/0)', 'Yet another sheet').value\n\n\tassert calc('UPPER(1)', 'Yet another sheet').value == '1'\n\tassert calc('UPPER(\"1\")', 'Yet another sheet').value == '1'\n\tassert calc('UPPER(\"TEST\")', 'Yet another sheet').value == 'TEST'\n\tassert calc('UPPER(\"test\")', 'Yet another sheet').value == 'TEST'\n\tassert calc('UPPER(\"TeSt %1234\")', 'Yet another sheet').value == 'TEST %1234'\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_row", "data": "def test_row(calc, formula, ws, result):\n\tassert calc(formula, ws).value == result\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}, {"term": "def", "name": "test_column", "data": "def test_column(calc, formula, ws, result):\n\tassert calc(formula, ws).value == result\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function, unicode_literals", "import pytest", "from efc.rpn_builder.parser.operands import (", "from .mock import ExcelMock, get_calculator"]}], [{"term": "class", "name": "Pinhole2D", "data": "class Pinhole2D(Resolution):\n\t\"\"\"\n\tGaussian Q smearing class for SAS 2d data\n\t\"\"\"\n\n\tdef __init__(self, data=None, index=None,\n\t\t\t\t nsigma=NSIGMA, accuracy='Low', coords='polar'):\n\t\t\"\"\"\n\t\tAssumption: equally spaced bins in dq_r, dq_phi space.\n\n\t\t:param data: 2d data used to set the smearing parameters\n\t\t:param index: 1d array with len(data) to define the range\n\t\t of the calculation: elements are given as True or False\n\t\t:param nr: number of bins in dq_r-axis\n\t\t:param nphi: number of bins in dq_phi-axis\n\t\t:param coord: coordinates [string], 'polar' or 'cartesian'\n\t\t\"\"\"\n\t\t## Accuracy: Higher stands for more sampling points in both directions\n\t\t## of r and phi.\n\t\t## number of bins in r axis for over-sampling\n\t\tself.nr = NR[accuracy.lower()]\n\t\t## number of bins in phi axis for over-sampling\n\t\tself.nphi = NPHI[accuracy.lower()]\n\t\t## maximum nsigmas\n\t\tself.nsigma = nsigma\n\t\tself.coords = coords\n\t\tself._init_data(data, index)\n\n\tdef _init_data(self, data, index):\n\t\t\"\"\"\n\t\tGet qx_data, qy_data, dqx_data,dqy_data,\n\t\tand calculate phi_data=arctan(qx_data/qy_data)\n\t\t\"\"\"\n\t\t# TODO: maybe don't need to hold copy of qx,qy,dqx,dqy,data,index\n\t\t# just need q_calc and weights\n\t\tself.data = data\n\t\tself.index = index if index is not None else slice(None)\n\n\t\tself.qx_data = data.qx_data[self.index]\n\t\tself.qy_data = data.qy_data[self.index]\n\t\tself.q_data = data.q_data[self.index]\n\n\t\tdqx = getattr(data, 'dqx_data', None)\n\t\tdqy = getattr(data, 'dqy_data', None)\n\t\tif dqx is not None and dqy is not None:\n\t\t\t# Here dqx and dqy mean dq_parr and dq_perp\n\t\t\tself.dqx_data = dqx[self.index]\n\t\t\tself.dqy_data = dqy[self.index]\n\t\t\t## Remove singular points if exists\n\t\t\tself.dqx_data[self.dqx_data < SIGMA_ZERO] = SIGMA_ZERO\n\t\t\tself.dqy_data[self.dqy_data < SIGMA_ZERO] = SIGMA_ZERO\n\t\t\tqx_calc, qy_calc, weights = self._calc_res()\n\t\t\tself.q_calc = [qx_calc, qy_calc]\n\t\t\tself.q_calc_weights = weights\n\t\telse:\n\t\t\t# No resolution information\n\t\t\tself.dqx_data = self.dqy_data = None\n\t\t\tself.q_calc = [self.qx_data, self.qy_data]\n\t\t\tself.q_calc_weights = None\n\n\t\t#self.phi_data = np.arctan(self.qx_data / self.qy_data)\n\n\tdef _calc_res(self):\n\t\t\"\"\"\n\t\tOver sampling of r_nbins times phi_nbins, calculate Gaussian weights,\n\t\tthen find smeared intensity\n\t\t\"\"\"\n\t\tnr, nphi = self.nr, self.nphi\n\t\t# Total number of bins = # of bins\n\t\tnbins = nr * nphi\n\t\t# Number of bins in the dqr direction (polar coordinate of dqx and dqy)\n\t\tbin_size = self.nsigma / nr\n\t\t# in dq_r-direction times # of bins in dq_phi-direction\n\t\t# data length in the range of self.index\n\t\tnq = len(self.qx_data)\n\n\t\t# Mean values of dqr at each bins\n\t\t# starting from the half of bin size\n\t\tr = bin_size / 2.0 + np.arange(nr) * bin_size\n\t\t# mean values of qphi at each bines\n\t\tphi = np.arange(nphi)\n\t\tdphi = phi * 2.0 * pi / nphi\n\t\tdphi = dphi.repeat(nr)\n\n\t\t## Transform to polar coordinate,\n\t\t#  and set dphi at each data points ; 1d array\n\t\tdphi = dphi.repeat(nq)\n\t\tq_phi = self.qy_data / self.qx_data\n\n\t\t# Starting angle is different between polar\n\t\t#  and cartesian coordinates.\n\t\t#if self.coords != 'polar':\n\t\t#\tdphi += np.arctan( q_phi * self.dqx_data/ \\\n\t\t#\t\t\t\t  self.dqy_data).repeat(nbins).reshape(nq,\\\n\t\t#\t\t\t\t\t\t\t\tnbins).transpose().flatten()\n\n\t\t# The angle (phi) of the original q point\n\t\tq_phi = np.arctan(q_phi).repeat(nbins)\\\n\t\t\t.reshape([nq, nbins]).transpose().flatten()\n\t\t## Find Gaussian weight for each dq bins: The weight depends only\n\t\t#  on r-direction (The integration may not need)\n\t\tweight_res = (np.exp(-0.5 * (r - bin_size / 2.0)**2)  -\n\t\t\t\t\t  np.exp(-0.5 * (r + bin_size / 2.0)**2))\n\t\t# No needs of normalization here.\n\t\t#weight_res /= np.sum(weight_res)\n\t\tweight_res = weight_res.repeat(nphi).reshape(nr, nphi)\n\t\tweight_res = weight_res.transpose().flatten()\n\n\t\t## Set dr for all dq bins for averaging\n\t\tdr = r.repeat(nphi).reshape(nr, nphi).transpose().flatten()\n\t\t## Set dqr for all data points\n\t\tdqx = np.outer(dr, self.dqx_data).flatten()\n\t\tdqy = np.outer(dr, self.dqy_data).flatten()\n\n\t\tqx = self.qx_data.repeat(nbins)\\\n\t\t\t.reshape(nq, nbins).transpose().flatten()\n\t\tqy = self.qy_data.repeat(nbins)\\\n\t\t\t.reshape(nq, nbins).transpose().flatten()\n\n\t\t# The polar needs rotation by -q_phi\n\t\tif self.coords == 'polar':\n\t\t\tq_r = sqrt(qx**2 + qy**2)\n\t\t\tqx_res = ((dqx*cos(dphi) + q_r) * cos(-q_phi)\n\t\t\t\t\t  + dqy*sin(dphi) * sin(-q_phi))\n\t\t\tqy_res = (-(dqx*cos(dphi) + q_r) * sin(-q_phi)\n\t\t\t\t\t  + dqy*sin(dphi) * cos(-q_phi))\n\t\telse:\n\t\t\tqx_res = qx + dqx*cos(dphi)\n\t\t\tqy_res = qy + dqy*sin(dphi)\n\n\n\t\treturn qx_res, qy_res, weight_res\n\n\tdef apply(self, theory):\n\t\tif self.q_calc_weights is not None:\n\t\t\t# TODO: interpolate rather than recomputing all the different qx,qy\n\t\t\t# Resolution needs to be applied\n\t\t\tnq, nbins = len(self.qx_data), self.nr * self.nphi\n\t\t\t## Reshape into 2d array to use np weighted averaging\n\t\t\ttheory = np.reshape(theory, (nbins, nq))\n\t\t\t## Averaging with Gaussian weighting: normalization included.\n\t\t\tvalue = np.average(theory, axis=0, weights=self.q_calc_weights)\n\t\t\t## Return the smeared values in the range of self.index\n\t\t\treturn value\n\t\telse:\n\t\t\treturn theory\n\n", "description": "\n\tGaussian Q smearing class for SAS 2d data\n\t", "category": "math", "imports": ["from __future__ import division", "import numpy as np  # type: ignore", "from numpy import pi, cos, sin, sqrt  # type: ignore", "from . import resolution", "from .resolution import Resolution"]}, {"term": "class", "name": "Slit2D", "data": "class Slit2D(Resolution):\n\t\"\"\"\n\tSlit aperture with resolution function on an oriented sample.\n\n\t*q* points at which the data is measured.\n\n\t*qx_width* slit width in qx\n\n\t*qy_width* slit height in qy; current implementation requires a fixed\n\tqy_width for all q points.\n\n\t*q_calc* is the list of q points to calculate, or None if this\n\tshould be estimated from the *q* and *qx_width*.\n\n\t*accuracy* determines the number of *qy* points to compute for each *q*.\n\tThe values are stored in sasmodels.resolution2d.N_SLIT_PERP.  The default\n\tvalues are: %s\n\t\"\"\"\n\t__doc__ = __doc__%N_SLIT_PERP_DOC\n\tdef __init__(self, q, qx_width, qy_width=0., q_calc=None, accuracy='low'):\n\t\t# Remember what q and width was used even though we won't need them\n\t\t# after the weight matrix is constructed\n\t\tself.q, self.qx_width, self.qy_width = q, qx_width, qy_width\n\n\t\t# Allow independent resolution on each qx point even though it is not\n\t\t# needed in practice.  Set qy_width to the maximum qy width.\n\t\tif np.isscalar(qx_width):\n\t\t\tqx_width = np.ones(len(q))*qx_width\n\t\telse:\n\t\t\tqx_width = np.asarray(qx_width)\n\t\tif not np.isscalar(qy_width):\n\t\t\tqy_width = np.max(qy_width)\n\n\t\t# Build grid of qx, qy points\n\t\tif q_calc is not None:\n\t\t\tqx_calc = np.sort(q_calc)\n\t\telse:\n\t\t\tqx_calc = resolution.pinhole_extend_q(q, qx_width, nsigma=3)\n\t\tqy_min, qy_max = np.log10(np.min(q)), np.log10(qy_width)\n\t\tqy_calc = np.logspace(qy_min, qy_max, N_SLIT_PERP[accuracy])\n\t\tqy_calc = np.hstack((-qy_calc[::-1], 0, qy_calc))\n\t\tself.q_calc = [v.flatten() for v in np.meshgrid(qx_calc, qy_calc)]\n\t\tself.qx_calc, self.qy_calc = qx_calc, qy_calc\n\t\tself.nx, self.ny = len(qx_calc), len(qy_calc)\n\t\tself.dy = 2*qy_width/self.ny\n\n\t\t# Build weight matrix for resolution integration\n\t\tif np.any(qx_width > 0):\n\t\t\tself.weights = resolution.pinhole_resolution(\n\t\t\t\tqx_calc, q, np.maximum(qx_width, resolution.MINIMUM_RESOLUTION))\n\t\telif len(qx_calc) == len(q) and np.all(qx_calc == q):\n\t\t\tself.weights = None\n\t\telse:\n\t\t\traise ValueError(\"Slit2D fails with q_calc != q\")\n\n\tdef apply(self, theory):\n\t\tIq = np.trapz(theory.reshape(self.ny, self.nx), axis=0, x=self.qy_calc)\n\t\tif self.weights is not None:\n\t\t\tIq = resolution.apply_resolution_matrix(self.weights, Iq)\n\t\treturn Iq\n", "description": "\n\tSlit aperture with resolution function on an oriented sample.\n\n\t*q* points at which the data is measured.\n\n\t*qx_width* slit width in qx\n\n\t*qy_width* slit height in qy; current implementation requires a fixed\n\tqy_width for all q points.\n\n\t*q_calc* is the list of q points to calculate, or None if this\n\tshould be estimated from the *q* and *qx_width*.\n\n\t*accuracy* determines the number of *qy* points to compute for each *q*.\n\tThe values are stored in sasmodels.resolution2d.N_SLIT_PERP.  The default\n\tvalues are: %s\n\t", "category": "math", "imports": ["from __future__ import division", "import numpy as np  # type: ignore", "from numpy import pi, cos, sin, sqrt  # type: ignore", "from . import resolution", "from .resolution import Resolution"]}], [{"term": "class", "name": "ExperimentCollection", "data": "class ExperimentCollection(dict):\n\t\"\"\"\n\tExperimentCollection(experiment name list)\n\n\tAn ExperimentCollection unites a collection of experiments. For now, it's\n\tmost important function is to collect group the independent variables by\n\tCalculation to avoid wasting computer effort redoing calculations.\n\n\tIndividual experiments can be accessed via dictionary-type indexing.\n\t\"\"\"\n\tdef __init__(self, exptList = []):\n\t\tfor expt in exptList:\n\t\t\tself.AddExperiment(expt)\n\n\tdef AddExperiment(self, expt):\n\t\t\"\"\"\n\t\tLoadExperiments(experiment name list)\n\n\t\tAdds the experiments in the list to the collection\n\t\t\"\"\"\n\t\tif expt.GetName() in self:\n\t\t\traise ValueError(\"Experiment already has name %s\" \n\t\t\t\t\t\t\t % str(expt.GetName()))\n\n\t\tself[expt.GetName()] = expt\n\n\tdef GetVarsByCalc(self):\n\t\t\"\"\"\n\t\tGetIndVarsByCalc() -> dictionary\n\n\t\tReturns a dictionary of all the dependent and independent variables for \n\t\tall the calculations required to compare with the data in all the\n\t\texperiments. The dictionary is of the form: \n\t\t dictionary(calculation name) -> ordered list of unique independent\n\t\t\t\t\t\t\t\t\t\t variables\n\t\t\"\"\"\n\t\tvarsByCalc = {}\n\t\tfor expt in self.values():\n\t\t\tdata = expt.GetData()\n\n\t\t\tfor calc in data:\n\t\t\t\tvarsByCalc.setdefault(calc, {})\n\t\t\t\tfor depVar in data[calc]:\n\t\t\t\t\t# Using a set is a convenient way to make sure\n\t\t\t\t\t# independent variables aren't repeated\n\t\t\t\t\tvarsByCalc[calc].setdefault(depVar, sets.Set())\n\t\t\t\t\tvarsByCalc[calc][depVar].\\\n\t\t\t\t\t\t\tunion_update(sets.Set(data[calc][depVar].keys()))\n\n\t\t\tfor period in expt.GetPeriodChecks():\n\t\t\t\tcalc, depVar = period['calcKey'], period['depVarKey']\n\t\t\t\tstart, period = period['startTime'], period['period']\n\t\t\t\tif calc not in varsByCalc.keys():\n\t\t\t\t\tvarsByCalc[calc].setdefault(calc, {})\n\t\t\t\tif depVar not in varsByCalc[calc]:\n\t\t\t\t\tvarsByCalc[calc].setdefault(depVar, sets.Set())\n\t\t\t\tvarsByCalc[calc][depVar].union_update([start, start+2.0*period])\n\n\t\t\tfor amplitude in expt.GetAmplitudeChecks():\n\t\t\t\tcalc, depVar = amplitude['calcKey'], amplitude['depVarKey']\n\t\t\t\tstart, test, period = (amplitude['startTime'], \n\t\t\t\t\t\t\t\t\t   amplitude['testTime'], \n\t\t\t\t\t\t\t\t\t   amplitude['period'])\n\t\t\t\tif calc not in varsByCalc.keys():\n\t\t\t\t\tvarsByCalc[calc].setdefault(calc, {})\n\t\t\t\tif depVar not in varsByCalc[calc]:\n\t\t\t\t\tvarsByCalc[calc].setdefault(depVar, sets.Set())\n\t\t\t\tvarsByCalc[calc][depVar].union_update([start, start+period,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   test, test+period])\n\n\t\t\tfor data_set in expt.GetIntegralDataSets():\n\t\t\t\tcalc = data_set['calcKey']\n\t\t\t\tvarsByCalc.setdefault(data_set['calcKey'], {})\n\t\t\t\tvarsByCalc[calc][('full trajectory')] = data_set['interval']\n\n\t\t\tfor ds in expt.scaled_extrema_data:\n\t\t\t\tcalc = ds['calcKey']\n\t\t\t\tvarsByCalc.setdefault(ds['calcKey'], {})\n\t\t\t\tif ds['type'] == 'max':\n\t\t\t\t\tcalled = ds['var'] + '_maximum'\n\t\t\t\telif ds['type'] == 'min': \n\t\t\t\t\tcalled = ds['var'] + '_minimum'\n\t\t\t\tvarsByCalc[calc][called] = (ds['minTime'], ds['maxTime'])\n\t\t\t\t\n\t\t# But I convert the sets back to sorted lists before returning\n\t\tfor calc in varsByCalc:\n\t\t\tfor depVar in varsByCalc[calc]:\n\t\t\t\tvarsByCalc[calc][depVar] = list(varsByCalc[calc][depVar])\n\t\t\t\tvarsByCalc[calc][depVar].sort()\n\n\t\treturn varsByCalc\n\n\tdef GetData(self):\n\t\t\"\"\"\n\t\tGetData() -> dictionary\n\n\t\tReturns a dictionary containing all the data for the experiments. The\n\t\tdictionary is of the form:\n\t\t dictionary[expt name][calc name][dependent vars][independent vars]\n\t\t\t\t = value.\n\n\t\tNote that value may be an arbitrary object.\n\t\t\"\"\"\n\n\t\tdata = {}\n\t\tfor exptName, expt in self.items():\n\t\t\tdata[exptName] = expt.GetData()\n\t\t\n\t\treturn data\n", "description": "\n\tExperimentCollection(experiment name list)\n\n\tAn ExperimentCollection unites a collection of experiments. For now, it's\n\tmost important function is to collect group the independent variables by\n\tCalculation to avoid wasting computer effort redoing calculations.\n\n\tIndividual experiments can be accessed via dictionary-type indexing.\n\t", "category": "math", "imports": ["import logging", "import sets, copy", "import scipy", "import SloppyCell", "import SloppyCell.Utility as Utility", "import SloppyCell.KeyedList_mod as KeyedList_mod", "\timport pypar", "\tmost important function is to collect group the independent variables by", "\t\t\t# This is the integrand for the prior. Note that it's important", "\t\t\t\timport SloppyCell.misc_c"]}, {"term": "class", "name": "classExperiment:", "data": "class Experiment:\n\tdef __init__(self, name = '', data = {}, fixedScaleFactors = {},\n\t\t\t\t longName = '', shared_sf = []):\n\t\tself.SetName(name)\n\t\tself.SetData(data)\n\t\tself.SetFixedScaleFactors(fixedScaleFactors)\n\t\tself.set_shared_sf(shared_sf)\n\t\tself.periodChecks=[]\n\t\tself.amplitudeChecks=[]\n\t\tself.integral_data=[]\n\t\tself.sf_priors = {}\n\t\tself.scaled_extrema_data = []\n\n\tdef _hashable_group(self, group):\n\t\t\"\"\"\n\t\tReturn a sorted tuple of the elements of group.\n\t\t\"\"\"\n\t\tif isinstance(group, str):\n\t\t\tgroup = [group]\n\t\thash_group = sets.Set(group)\n\t\thash_group = list(hash_group)\n\t\tlist(group).sort()\n\t\thash_group = tuple(group)\n\t\treturn hash_group\n\n\tdef get_sf_groups(self):\n\t\t\"\"\"\n\t\tReturn tuples representing all the scale factors in this experiment.\n\n\t\tA tuple will contain multiple entries if several variables share a\n\t\tscale factor.\n\t\t\"\"\"\n\t\t# Get the variables measured in this experiment\n\t\tmeasuredVars = sets.Set()\n\t\tfor calcId in self.data:\n\t\t\tmeasuredVars.union_update(sets.Set(self.data[calcId].keys()))\n\t\tfor dataset in self.integral_data:\n\t\t\tmeasuredVars.union_update(sets.Set(dataset['vars']))\n\t\tfor dataset in self.scaled_extrema_data:\n\t\t\tmeasuredVars.add(dataset['var'])\n\n\t\tsf_groups = [self._hashable_group(group) for group \n\t\t\t\t\t in self.get_shared_sf()]\n\t\t# Flatten out the list of shared scale factors so we can also get\n\t\t#  the unshared ones...\n\t\tflattened = []\n\t\tfor g in sf_groups:\n\t\t\tflattened.extend(g)\n\t\t# These are variables that don't share scale factors\n\t\tunshared = [self._hashable_group(var) for var in measuredVars\n\t\t\t\t\tif var not in flattened]\n\t\tsf_groups.extend(unshared)\n\t\treturn sf_groups\n\n\tdef set_sf_prior(self, group, prior_type, prior_params=None):\n\t\t\"\"\"\n\t\tSet the type of prior to place on a given group of scalefactors.\n\n\t\tThe group contains a collection of variables that are sharing a given\n\t\tscale factor which may be just one variable. You can see what the\n\t\tcurrent groups are with expt.get_sf_groups().\n\n\t\tCurrently implemented prior types are:\n\t\t\t'uniform in sf': This is a uniform prior over scale factors. This\n\t\t\tis simplest and fastest to compute, but it tends to weight\n\t\t\tparameter sets that yield large scale factors heavily. It takes no\n\t\t\tparameters.\n\n\t\t\t'gaussian in log sf': This is a Gaussian prior over the logarithm\n\t\t\tof the scale factor. This should avoid the problem of weighting\n\t\t\tlarge factors heavily. It takes two parameters: the mean of the\n\t\t\tnormal distribution, and it's standard deviation. For example,\n\t\t\tparameters (log(3.0), log(10)), will place a prior that holds 95%\n\t\t\tof the probability between 3 / 10**2 and 3 * 10**2.\n\t\t\"\"\"\n\t\thash_group = self._hashable_group(group)\n\n\t\tif hash_group not in self.get_sf_groups():\n\t\t\traise ValueError('Unrecognized group to set scale factor prior on. '\n\t\t\t\t\t\t\t 'If it is a shared scale factor, you need to '\n\t\t\t\t\t\t\t 'specify every member of the sharing group.')\n\n\t\tavailable_types = ['uniform in sf', 'gaussian in log sf']\n\t\tif prior_type not in available_types:\n\t\t\traise ValueError('Unknown prior type %s. Available types are %s.'\n\t\t\t\t\t\t\t % (prior_type, available_types))\n\t\tself.sf_priors[hash_group] = (prior_type, prior_params)\n\n\tdef compute_sf_entropy(self, sf_group, theoryDotTheory, theoryDotData, T):\n\t\t\"\"\"\n\t\tCompute the entropy for a given scale factor.\n\t\t\"\"\"\n\t\ttry:\n\t\t\tprior_type, prior_params = self.sf_priors[sf_group]\n\t\texcept KeyError:\n\t\t\tprior_type, prior_params = 'uniform in sf', None\n\n\t\tif prior_type == 'uniform in sf':\n\t\t\tif theoryDotTheory != 0:\n\t\t\t\tentropy = scipy.log(scipy.sqrt(2*scipy.pi*T/theoryDotTheory))\n\t\t\telse:\n\t\t\t\tentropy = 0\n\t\telif prior_type == 'gaussian in log sf':\n\t\t\t# This is the integrand for the prior. Note that it's important\n\t\t\t#  that u = 0 corresponds to B_best. This ensures that the\n\t\t\t#  integration doesn't miss the (possibly sharp) peak there.\n\t\t\ttry:\n\t\t\t\timport SloppyCell.misc_c\n\t\t\t\tintegrand = SloppyCell.misc_c.log_gaussian_prior_integrand\n\t\t\texcept ImportError:\n\t\t\t\tlogger.warn('Falling back to python integrand on log gaussian '\n\t\t\t\t\t\t\t'prior integration.')\n\t\t\t\texp = scipy.exp\n\t\t\t\tdef integrand(u, ak, bk, mulB, siglB, T, B_best, lB_best):\n\t\t\t\t\tB = exp(u) * B_best\n\t\t\t\t\tlB = u + lB_best\n\t\t\t\t\tret = exp(-ak/(2*T) * (B-B_best)**2\n\t\t\t\t\t\t\t  - (lB-mulB)**2/(2 * siglB**2))\n\t\t\t\t\treturn ret\n\n\t\t\tmulB, siglB = prior_params\n\t\t\tB_best = theoryDotData/theoryDotTheory\n\t\t\tlB_best = scipy.log(B_best)\n\n\t\t\t# Often we get overflow errors in the integration, but they\n\t\t\t#  don't actually cause a problem. (exp(-inf) is still 0.) This\n\t\t\t#  prevents scipy from printing annoying error messages in this\n\t\t\t#  case.\n\t\t\tprev_err = scipy.seterr(over='ignore')\n\t\t\tint_args = (theoryDotTheory, theoryDotData, mulB, siglB, T, B_best,\n\t\t\t\t\t\tlB_best)\n\t\t\tans, temp = scipy.integrate.quad(integrand, -scipy.inf, scipy.inf, \n\t\t\t\t\t\t\t\t\t\t\t args = int_args, limit=1000)\n\t\t\tscipy.seterr(**prev_err)\n\t\t\tentropy = scipy.log(ans)\n\t\telse:\n\t\t\traise ValueError('Unrecognized prior type: %s.' % prior_type)\n\n\t\treturn entropy\n\t\t\n\tdef SetName(self, name):\n\t\tself.name = name\n\n\tdef GetName(self):\n\t\treturn self.name\n\n\tdef set_data(self, data):\n\t\tself.data = copy.copy(data)\n\n\tdef update_data(self, newData):\n\t\tself.data.update(newData)\n\n\tdef get_data(self):\n\t\treturn self.data\n\n\tdef set_fixed_sf(self, fixed_sf):\n\t\tself.fixedScaleFactors = fixed_sf\n\n\tdef set_shared_sf(self, shared_sf):\n\t\tself.shared_sf = shared_sf\n\n\tdef get_shared_sf(self):\n\t\treturn self.shared_sf\n\n\tdef get_fixed_sf(self):\n\t\treturn self.fixedScaleFactors\n\n\n\tSetData = set_data\n\tGetData = get_data\n\tUpdateData = update_data\n\tSetFixedScaleFactors = set_fixed_sf\n\tGetFixedScaleFactors = get_fixed_sf\n\n\tdef AddPeriodCheck(self, calcKey, chemical, period, sigma, startTime=0.0):\n\t\t\"\"\"\n\t\tConstrain the period of the oscillations to a value (period)\n\t\twith the error (sigma). The period is found using the maximum\n\t\tto maximum distance of the first two maxima found between\n\t\tstartTime and two periods after the startTime.\n\t\t\"\"\"\n\t\tself.periodChecks.append({'calcKey':calcKey, 'depVarKey':chemical,\n\t\t\t\t\t\t\t\t  'period': period, 'sigma': sigma, \n\t\t\t\t\t\t\t\t  'startTime': startTime})\n\n\tdef GetPeriodChecks(self):\n\t\treturn self.periodChecks\n\n\tdef AddAmplitudeCheck(self, calcKey, chemical, startTime, testTime, period,\n\t\t\t\t\t\t  sigma):\n\t\t\"\"\"\n\t\tTurn on applying a constraint that the integrated\n\t\tarea in two different parts of the plot should be the\n\t\tsame. startTime and testTime are the starting points to\n\t\tbegin the integration for the period-long each.\n\t\t\"\"\"\n\t\tself.amplitudeChecks.append({'calcKey': calcKey, 'depVarKey': chemical,\n\t\t\t\t\t\t\t\t\t 'startTime': startTime, \n\t\t\t\t\t\t\t\t\t 'testTime': testTime,\n\t\t\t\t\t\t\t\t\t 'period': period, 'sigma': sigma})\n\n\tdef GetAmplitudeChecks(self):\n\t\treturn self.amplitudeChecks\n\n\tdef GetIntegralDataSets(self):\n\t\treturn self.integral_data\n\n\tdef add_integral_data(self, calcKey, traj, uncert_traj, vars, \n\t\t\t\t\t\t  interval=None):\n\t\t\"\"\"\n\t\tAdd an integral data set to the experiment.\n\n\t\tcalcKey\t  The id of the calculation this data corresponds to\n\t\ttraj\t\t The trajectory to compare against\n\t\tuncert_traj  A trajectory of data uncertainties\n\t\tvars\t\t What variables to fit against\n\t\tinterval\t The time interval to fit over, defaults to the entire traj\n\t\t\"\"\"\n\t\ttraj.build_interpolated_traj()\n\t\tuncert_traj.build_interpolated_traj()\n\t\tif interval is None:\n\t\t\tinterval = (traj.get_times()[0], traj.get_times()[-1])\n\t\tself.integral_data.append({'calcKey': calcKey, 'trajectory': traj,\n\t\t\t\t\t\t\t\t   'uncert_traj': uncert_traj, 'vars': vars,\n\t\t\t\t\t\t\t\t   'interval': interval})\n\n\tdef add_scaled_max(self, calcKey, var, maxval, sigma, \n\t\t\t\t\t\t   minTime=None, maxTime=None):\n\t\tself.scaled_extrema_data.append({'calcKey': calcKey, 'var':var,\n\t\t\t\t\t\t\t\t\t\t 'val':maxval, 'sigma':sigma,\n\t\t\t\t\t\t\t\t\t\t 'minTime': minTime, 'maxTime':maxTime,\n\t\t\t\t\t\t\t\t\t\t 'type':'max'})\n\tdef add_scaled_min(self, calcKey, var, minval, sigma, \n\t\t\t\t\t\t   minTime=None, maxTime=None):\n\t\tself.scaled_extrema_data.append({'calcKey': calcKey, 'var':var,\n\t\t\t\t\t\t\t\t\t\t 'val':minval, 'sigma':sigma,\n\t\t\t\t\t\t\t\t\t\t 'minTime': minTime, 'maxTime':maxTime,\n\t\t\t\t\t\t\t\t\t\t 'type':'min'})\n", "description": "\n\t\tReturn a sorted tuple of the elements of group.\n\t\t", "category": "math", "imports": ["import logging", "import sets, copy", "import scipy", "import SloppyCell", "import SloppyCell.Utility as Utility", "import SloppyCell.KeyedList_mod as KeyedList_mod", "\timport pypar", "\tmost important function is to collect group the independent variables by", "\t\t\t# This is the integrand for the prior. Note that it's important", "\t\t\t\timport SloppyCell.misc_c"]}, {"term": "class", "name": "CalculationCollection", "data": "class CalculationCollection(KeyedList):\n\t\"\"\"\n\tCalculationCollection(calculation name list)\n\n\tAn CalculationCollection unites a collection of calculations. It is\n\tresponsible for generating a master list of parameters and passing each\n\tCalculation its appropriate parameters.\n\n\tIndividual calculations can be accessed via dictionary-type indexing.\n\t\n\tXXX: Note that the parameter shuffling has not been extensively tested.\n\t\"\"\"\n\n\tdef __init__(self, calcList = []):\n\t\tKeyedList.__init__(self)\n\n\t\tself.params = KeyedList()\n\t\tfor calc in calcList:\n\t\t\ttry:\n\t\t\t\tif len(calc) == 2:\n\t\t\t\t\tself.AddCalculation(calc[1])\n\t\t\t\telse:\n\t\t\t\t\traise ValueError('Incorrect form for calcList')\n\t\t\texcept:\n\t\t\t\tself.AddCalculation(calc)\n\n\tdef AddCalculation(self, calc):\n\t\t\"\"\"\n\t\tLoadCalculations(calculations name list)\n\n\t\tAdds the calculations in the list to the collection and adds their\n\t\tparameters to the parameterSet\n\t\t\"\"\"\n\t\tif calc.GetName() in self:\n\t\t\traise ValueError(\"Calculation already has name %s\" \n\t\t\t\t\t\t\t % str(calc.GetName()))\n\n\t\tself.set(calc.GetName(), calc )\n\t\tfor pName, pValue in calc.GetParameters().items():\n\t\t\tself.params.setdefault(pName, pValue)\n\n\tdef Calculate(self, varsByCalc, params = None):\n\t\t\"\"\"\n\t\tCalculate model predictions for everything in varsByCalc.\n\n\t\tvarsByCalc is a dictionary of the form:\n\t\t\tdict[calc name][dep var] = ind var\n\t\t\n\t\tThe return dictionary is of the form:\n\t\t\tdictionary[calc name][dep var][ind var] = result\n\t\t\"\"\"\n\t\tif params is not None:\n\t\t\tself.params.update(params)\n\n\t\tresults = {}\n\n\t\tcalcs_to_do = varsByCalc.keys()\n\t\t# Record which calculation each node is doing\n\t\tcalc_assigned = {}\n\t\twhile calcs_to_do:\n\t\t\t# The number of calculations to do this round. We want to use\n\t\t\t#  all the processors if possible.\n\t\t\tlen_this_block = min(SloppyCell.num_procs, len(calcs_to_do))\n\n\t\t\tfor worker in range(1, len_this_block):\n\t\t\t\tcalc = calcs_to_do.pop()\n\t\t\t\tcalc_assigned[worker] = calc\n\t\t\t\tlogger.debug('Assigning calculation %s to worker %i.'\n\t\t\t\t\t\t\t % (calc, worker))\n\t\t\t\tcommand = 'Network.calculate(net, vars, params)'\n\t\t\t\targs = {'net': self.get(calc), 'vars': varsByCalc[calc],\n\t\t\t\t\t\t'params': self.params}\n\t\t\t\tpypar.send((command, args), worker)\n\n\t\t\t# The master does his share here\n\t\t\tcalc = calcs_to_do.pop()\n\t\t\t# We use the finally statement because we want to ensure that we\n\t\t\t#  *always* wait for replies from the workers, even if the master\n\t\t\t#  encounters an exception in his evaluation.\n\t\t\ttry:\n\t\t\t\tresults[calc] = self.get(calc).calculate(varsByCalc[calc], \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t self.params)\n\t\t\tfinally:\n\t\t\t\t# Collect results from the workers\n\t\t\t\tfor worker in range(1, len_this_block):\n\t\t\t\t\tlogger.debug('Receiving result from worker %i.' % worker)\n\t\t\t\t\tresults[calc_assigned[worker]] = pypar.receive(worker)\n\t\t\t\t# If the master encounts an exception, we'll break out of the\n\t\t\t\t#  function ***here***\n\n\t\t\t# Check the results we received. If any is a SloppyCellException, \n\t\t\t#  reraise it.\n\t\t\tfor val in results.values():\n\t\t\t\tif isinstance(val, Utility.SloppyCellException):\n\t\t\t\t\traise val\n\n\t\treturn results\n\n\tdef CalculateSensitivity(self, varsByCalc, params = None):\n\t\t\"\"\"\n\t\tCalculate sensitivities for model predictions of everything in \n\t\tvarsByCalc.\n\n\t\tvarsByCalc is a dictionary of the form:\n\t\t\tdict[calc name][dep var] = ind var\n\t\t\n\t\tThe return dictionary is of the form:\n\t\t\tdictionary[calc name][dep var][ind var][param] = result\n\t\t\"\"\"\n\t\tif params is not None :\n\t\t\tself.params.update(params)\n\t\t\n\t\tcalcSensVals, calcVals = {}, {}\n\t\tfor (calcName, vars) in varsByCalc.items():\n\t\t\tcalc = self.get(calcName)\n\t\t\tvars = varsByCalc[calcName]\n\t\t\tcalcPOrder = calc.GetParameters().keys()\n\t\t\tcalc.CalculateSensitivity(varsByCalc[calcName], self.params)\n\t\t\tcalcSensVals[calcName] = calc.GetSensitivityResult(vars)\n\t\t\tcalcVals[calcName] = calc.GetResult(vars)\n\n\t\treturn calcVals, calcSensVals\n\n\tdef GetParameters(self):\n\t\t\"\"\"\n\t\tReturn a deep copy of the collections parameter KeyedList.\n\t\t\"\"\"\n\t\tself.params = KeyedList()\n\t\tfor calc in self.values():\n\t\t\tfor pName, pValue in calc.GetParameters().items():\n\t\t\t\tself.params.setdefault(pName, pValue)\n\t\treturn self.params\n", "description": "\n\tCalculationCollection(calculation name list)\n\n\tAn CalculationCollection unites a collection of calculations. It is\n\tresponsible for generating a master list of parameters and passing each\n\tCalculation its appropriate parameters.\n\n\tIndividual calculations can be accessed via dictionary-type indexing.\n\t\n\tXXX: Note that the parameter shuffling has not been extensively tested.\n\t", "category": "math", "imports": ["import logging", "import sets, copy", "import scipy", "import SloppyCell", "import SloppyCell.Utility as Utility", "import SloppyCell.KeyedList_mod as KeyedList_mod", "\timport pypar", "\tmost important function is to collect group the independent variables by", "\t\t\t# This is the integrand for the prior. Note that it's important", "\t\t\t\timport SloppyCell.misc_c"]}], [{"term": "class", "name": "classDerivative:", "data": "class Derivative:\n\tdef __init__(self, f, h=0.0001):\n\t\tself.f = f\n\t\tself.h = float(h)\n\n\tdef __call__(self, x):\n\t\tf, h = self.f, self.h\n\t\treturn (f(x+h) - f(x))/h\n\n", "description": null, "category": "math", "imports": []}, {"term": "class", "name": "classSolver:", "data": "class Solver:\n\n\tdef __init__(self, a, b, g, infin=10):\n\t\tassert 0 < a < 1 and 0 < b < 1 and 0 < g < 1\n\t\tself.a = a\n\t\tself.b = b\n\t\tself.g = g\n\t\tself.inA = 1 - a\n\t\tself.inB = 1 - b\n\t\tself.inG = 1 - g\n\t\tself.q0 = [1]\n\t\tself.q1 = [a / (self.inA * b)]\n\t\tself.rho = a / b\n\t\tself.P1 = self.rho\n\t\tself.P0 = 1 - self.rho\n\t\tself.inf = infin\n\n\tdef reload(self, a, b, g, infin=10):\n\t\tassert 0 < a < 1 and 0 < b < 1 and 0 < g < 1\n\t\tself.a = a\n\t\tself.b = b\n\t\tself.g = g\n\t\tself.inA = 1 - a\n\t\tself.inB = 1 - b\n\t\tself.inG = 1 - g\n\t\tself.q0 = [1]\n\t\tself.q1 = [a / (self.inA * b)]\n\t\tself.rho = a / b\n\t\tself.P1 = self.rho\n\t\tself.P0 = 1 - self.rho\n\t\tself.inf = infin\n\t# -------------------------1st-----------------\n\n\tdef calc_q0(self, i):\n\t\tassert i >= 0\n\t\tif len(self.q0) <= i:\n\t\t\t# for k in range(len(self.q0), i):\n\t\t\twhile len(self.q0) < i+ 1:\n\t\t\t\tself.q0.append(None)\n\t\tif self.q0[i]:\n\t\t\treturn self.q0[i]\n\t\telse:\n\t\t\tself.q0[i] = self.a * self.inB * self.inG ** i * self.calc_q1(i - 1) / (1 - self.inG ** i)\n\t\t\treturn self.q0[i]\n\n\tdef calc_q1(self, i):\n\t\tassert i >= 0\n\t\tif len(self.q1) <= i:\n\t\t\t# for k in range(len(self.q1), i):\n\t\t\twhile len(self.q1) < i + 1:\n\t\t\t\tself.q1.append(None)\n\t\tif self.q1[i]:\n\t\t\treturn self.q1[i]\n\t\telse:\n\t\t\tself.q1[i] = self.a * self.inB * (1 - self.inA * self.inG ** i) * self.calc_q1(i - 1) / (\n\t\t\t\t\t\tself.inA * self.b * (1 - self.inG ** i))\n\t\t\treturn self.q1[i]\n\n\tdef calc_p00(self):\n\t\tsumm1, summ2 = 0, 0\n\t\tfor i in range(self.inf):\n\t\t\tsumm1 += self.calc_q0(i)\n\t\tfor i in range(self.inf):\n\t\t\tsumm2 += self.calc_q1(i)\n\t\treturn 1 / (summ1 + summ2)\n\n\tdef calc_p0i(self, i):\n\t\treturn self.calc_p00() * self.calc_q0(i)\n\n\tdef calc_p1i(self, i):\n\t\treturn self.calc_p00() * self.calc_q1(i)\n\n\tdef calc_p00_check(self):\n\t\tmult = 1\n\t\tfor i in range(1, self.inf):\n\t\t\tmult *= self.inA * (self.b - self.a * self.inB * self.inG ** i) / (\n\t\t\t\t\t\tself.inA * self.b - self.a * self.inB * self.inG ** i)\n\t\treturn (1 - self.rho) * (1 / mult)\n\n\tdef calc_pxi(self, i):\n\t\tif i == 0:\n\t\t\treturn self.P0 + self.P1 * self.b\n\t\telse:\n\t\t\treturn self.calc_p1i(i - 1) * self.inB\n\n\tdef calc_vk0(self, k, n):\n\t\tassert n >= 0 and k >= 1\n\t\tif k == 1:\n\t\t\treturn self.inA * (1 - self.inG ** (n + 1) / (n + 1))\n\t\telif n == 0 and k >= 2:\n\t\t\treturn self.a * self.calc_vk1(k - 1, 0) + self.inA * self.inG * self.calc_vk0(k - 1, 0)\n\t\telse:\n\t\t\treturn self.a * self.calc_vk1(k - 1, n) + self.inA*(\n\t\t\t\tself.inG ** (n + 1) * self.calc_vk0(k - 1, n) + n * (1 - self.inG ** (n + 1)) * self.calc_vk1(k - 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  n - 1) / (\n\t\t\t\t\t\t\tn + 1))\n\n\tdef calc_vk1(self, k, n):\n\t\tassert n >= 0 and k >= 1\n\t\tif k == 1:\n\t\t\treturn self.inA * self.b * (1 - self.inG ** (n + 1) / (n + 1))\n\t\telif n == 0 and k >= 2:\n\t\t\treturn self.a * (self.inB * self.calc_vk1(k - 1, 1) + self.b * self.calc_vk1(k - 1, 0)) + \\\n\t\t\t\t   self.inA * (self.inB * self.calc_vk1(k - 1, 0) + self.b * self.inG * self.calc_vk0(k - 1, 0))\n\t\telse:\n\t\t\treturn self.a * (self.inB * self.calc_vk1(k - 1, n + 1) + self.b * self.calc_vk1(k - 1, n)) + \\\n\t\t\t\t   self.inA * (self.inB * self.calc_vk1(k - 1, n) + self.b * self.inG ** (n + 1) * self.calc_vk0(k - 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t n) + \\\n\t\t\t\t\t\t\t   n * self.b * (1 - self.inG ** (n + 1)) * self.calc_vk1(k - 1, n - 1) / (n + 1))\n\n\t# --------------------2nd-------------------------\n\n\tdef calc_P0(self, z):\n\t\t# assert 0 < z <= 1\n\t\tmult = 1\n\t\tfor i in range(1,self.inf):\n\t\t\tmult *= 1 + self.a**2*self.inB*self.inG**i*z/(self.inA*self.b - self.a*self.inB*self.inG**i*z)\n\t\treturn self.calc_p00() * mult\n\n\tdef calc_P1(self, z):\n\t\treturn self.a * self.calc_P0(z) / (self.inA*self.b -self.a*self.inB*z)\n\n\tdef calc_Q1(self):\n\t\tdf1 = Derivative(self.calc_P0)\n\t\tdf2 = Derivative(self.calc_P1)\n\t\treturn df1(1) + df2(1)\n\n\tdef calc_Q2(self):\n\t\tdf = Derivative(self.calc_P0)\n\t\treturn self.a**2*self.inB/(self.b*(self.b-self.a)) + self.b*df(1)/(self.b-self.a)\n\n\tdef calc_Q3(self):\n\t\tsum1 = 0\n\t\tsum2 = 0\n\t\tfor i in range(1,self.inf):\n\t\t\tsum1 += i*self.calc_p0i(i)\n\t\t\tsum2 += i*self.calc_p1i(i)\n\t\treturn sum1 + sum2\n\n\tdef calc_Qx0(self):\n\t\tdf1 = Derivative(self.calc_P0)\n\t\tdf2 = Derivative(self.calc_P1)\n\t\treturn (df1(1) + self.b*df2(1))/self.calc_pxi(0)\n\n\tdef calc_Qx1(self):\n\t\tdf = Derivative(self.calc_P1)\n\t\treturn self.inB*df(1)/(1-self.calc_pxi(0))\n\n\tdef calc_wk(self, k):\n\t\tassert k >= 0\n\t\tif k == 0:\n\t\t\treturn self.calc_pxi(0)\n\t\telse:\n\t\t\tsum1 = 0\n\t\t\tfor i in range(1,self.inf):\n\t\t\t\tsum1 += self.calc_pxi(i)*self.calc_vk1(k, i-1)\n\t\t\treturn sum1\n\n\tdef calc_w(self):\n\t\tsum1 = 0\n\t\tfor i in range(1, self.inf):\n\t\t\tsum2 = 0\n\t\t\tfor k in range(1, self.inf):\n\t\t\t\tsum2 += k*self.calc_vk1(k, i-1)\n\t\t\tsum1 += self.calc_pxi(i) * sum2\n\t\treturn sum1\n", "description": null, "category": "math", "imports": []}], [{"term": "class", "name": "classSpline:", "data": "class Spline:\n\t\"\"\"\n\tCubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.b, self.c, self.d, self.w = [], [], [], []\n\n\t\tself.x = x\n\t\tself.y = y\n\n\t\tself.nx = len(x)  # dimension of x\n\t\th = np.diff(x)\n\n\t\t# calc coefficient c\n\t\tself.a = [iy for iy in y]\n\n\t\t# calc coefficient c\n\t\tA = self.__calc_A(h)\n\t\tB = self.__calc_B(h)\n\t\tself.c = np.linalg.solve(A, B)\n\t\t#  print(self.c1)\n\n\t\t# calc spline coefficient b and d\n\t\tfor i in range(self.nx - 1):\n\t\t\tself.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n\t\t\ttb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n\t\t\t\t(self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n\t\t\tself.b.append(tb)\n\n\tdef calc(self, t):\n\t\t\"\"\"\n\t\tCalc position\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.a[i] + self.b[i] * dx + \\\n\t\t\tself.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n\t\treturn result\n\n\tdef calcd(self, t):\n\t\t\"\"\"\n\t\tCalc first derivative\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n\t\treturn result\n\n\tdef calcdd(self, t):\n\t\t\"\"\"\n\t\tCalc second derivative\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n\t\treturn result\n\n\tdef __search_index(self, x):\n\t\t\"\"\"\n\t\tsearch data segment index\n\t\t\"\"\"\n\t\treturn bisect.bisect(self.x, x) - 1\n\n\tdef __calc_A(self, h):\n\t\t\"\"\"\n\t\tcalc matrix A for spline coefficient c\n\t\t\"\"\"\n\t\tA = np.zeros((self.nx, self.nx))\n\t\tA[0, 0] = 1.0\n\t\tfor i in range(self.nx - 1):\n\t\t\tif i != (self.nx - 2):\n\t\t\t\tA[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n\t\t\tA[i + 1, i] = h[i]\n\t\t\tA[i, i + 1] = h[i]\n\n\t\tA[0, 1] = 0.0\n\t\tA[self.nx - 1, self.nx - 2] = 0.0\n\t\tA[self.nx - 1, self.nx - 1] = 1.0\n\t\t#  print(A)\n\t\treturn A\n\n\tdef __calc_B(self, h):\n\t\t\"\"\"\n\t\tcalc matrix B for spline coefficient c\n\t\t\"\"\"\n\t\tB = np.zeros(self.nx)\n\t\tfor i in range(self.nx - 2):\n\t\t\tB[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n\t\t\t\th[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n\t\treturn B\n\n", "description": "\n\tCubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect"]}, {"term": "class", "name": "classSpline2D:", "data": "class Spline2D:\n\t\"\"\"\n\t2D Cubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.s = self.__calc_s(x, y)\n\t\tself.sx = Spline(self.s, x)\n\t\tself.sy = Spline(self.s, y)\n\n\tdef __calc_s(self, x, y):\n\t\tdx = np.diff(x)\n\t\tdy = np.diff(y)\n\t\tself.ds = np.hypot(dx, dy)\n\t\ts = [0]\n\t\ts.extend(np.cumsum(self.ds))\n\t\treturn s\n\n\tdef calc_position(self, s):\n\t\t\"\"\"\n\t\tcalc position\n\t\t\"\"\"\n\t\tx = self.sx.calc(s)\n\t\ty = self.sy.calc(s)\n\n\t\treturn x, y\n\n\tdef calc_curvature(self, s):\n\t\t\"\"\"\n\t\tcalc curvature\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tddx = self.sx.calcdd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tddy = self.sy.calcdd(s)\n\t\tk = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n\t\treturn k\n\n\tdef calc_yaw(self, s):\n\t\t\"\"\"\n\t\tcalc yaw\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tyaw = math.atan2(dy, dx)\n\t\treturn yaw\n\n", "description": "\n\t2D Cubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect"]}, {"term": "def", "name": "calc_spline_course", "data": "def calc_spline_course(x, y, ds=0.1):\n\tsp = Spline2D(x, y)\n\ts = list(np.arange(0, sp.s[-1], ds))\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\treturn rx, ry, ryaw, rk, s\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect"]}], [{"term": "class", "name": "classSpline:", "data": "class Spline:\n\t\"\"\"\n\tCubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.b, self.c, self.d, self.w = [], [], [], []\n\n\t\tself.x = x\n\t\tself.y = y\n\n\t\tself.nx = len(x)  # dimension of x\n\t\th = np.diff(x)\n\n\t\t# calc coefficient c\n\t\tself.a = [iy for iy in y]\n\n\t\t# calc coefficient c\n\t\tA = self.__calc_A(h)\n\t\tB = self.__calc_B(h)\n\t\tself.c = np.linalg.solve(A, B)\n\t\t#  print(self.c1)\n\n\t\t# calc spline coefficient b and d\n\t\tfor i in range(self.nx - 1):\n\t\t\tself.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n\t\t\ttb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n\t\t\t\t(self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n\t\t\tself.b.append(tb)\n\n\tdef calc(self, t):\n\t\t\"\"\"\n\t\tCalc position\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.a[i] + self.b[i] * dx + \\\n\t\t\tself.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n\t\treturn result\n\n\tdef calcd(self, t):\n\t\t\"\"\"\n\t\tCalc first derivative\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n\t\treturn result\n\n\tdef calcdd(self, t):\n\t\t\"\"\"\n\t\tCalc second derivative\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n\t\treturn result\n\n\tdef __search_index(self, x):\n\t\t\"\"\"\n\t\tsearch data segment index\n\t\t\"\"\"\n\t\treturn bisect.bisect(self.x, x) - 1\n\n\tdef __calc_A(self, h):\n\t\t\"\"\"\n\t\tcalc matrix A for spline coefficient c\n\t\t\"\"\"\n\t\tA = np.zeros((self.nx, self.nx))\n\t\tA[0, 0] = 1.0\n\t\tfor i in range(self.nx - 1):\n\t\t\tif i != (self.nx - 2):\n\t\t\t\tA[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n\t\t\tA[i + 1, i] = h[i]\n\t\t\tA[i, i + 1] = h[i]\n\n\t\tA[0, 1] = 0.0\n\t\tA[self.nx - 1, self.nx - 2] = 0.0\n\t\tA[self.nx - 1, self.nx - 1] = 1.0\n\t\t#  print(A)\n\t\treturn A\n\n\tdef __calc_B(self, h):\n\t\t\"\"\"\n\t\tcalc matrix B for spline coefficient c\n\t\t\"\"\"\n\t\tB = np.zeros(self.nx)\n\t\tfor i in range(self.nx - 2):\n\t\t\tB[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n\t\t\t\th[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n\t\treturn B\n\n", "description": "\n\tCubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect"]}, {"term": "class", "name": "classSpline2D:", "data": "class Spline2D:\n\t\"\"\"\n\t2D Cubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.s = self.__calc_s(x, y)\n\t\tself.sx = Spline(self.s, x)\n\t\tself.sy = Spline(self.s, y)\n\n\tdef __calc_s(self, x, y):\n\t\tdx = np.diff(x)\n\t\tdy = np.diff(y)\n\t\tself.ds = np.hypot(dx, dy)\n\t\ts = [0]\n\t\ts.extend(np.cumsum(self.ds))\n\t\treturn s\n\n\tdef calc_position(self, s):\n\t\t\"\"\"\n\t\tcalc position\n\t\t\"\"\"\n\t\tx = self.sx.calc(s)\n\t\ty = self.sy.calc(s)\n\n\t\treturn x, y\n\n\tdef calc_curvature(self, s):\n\t\t\"\"\"\n\t\tcalc curvature\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tddx = self.sx.calcdd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tddy = self.sy.calcdd(s)\n\t\tk = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n\t\treturn k\n\n\tdef calc_yaw(self, s):\n\t\t\"\"\"\n\t\tcalc yaw\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tyaw = math.atan2(dy, dx)\n\t\treturn yaw\n\n", "description": "\n\t2D Cubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect"]}, {"term": "def", "name": "calc_spline_course", "data": "def calc_spline_course(x, y, ds=0.1):\n\tsp = Spline2D(x, y)\n\ts = list(np.arange(0, sp.s[-1], ds))\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\treturn rx, ry, ryaw, rk, s\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect"]}], [{"term": "def", "name": "test_turbomole_h2o", "data": "def test_turbomole_h2o():\n\tmol = molecule('H2O')\n\n\tparams = {\n\t\t'title': 'water',\n\t\t'task': 'geometry optimization',\n\t\t'use redundant internals': True,\n\t\t'basis set name': 'def2-SV(P)',\n\t\t'total charge': 0,\n\t\t'multiplicity': 1,\n\t\t'use dft': True,\n\t\t'density functional': 'b3-lyp',\n\t\t'use resolution of identity': True,\n\t\t'ri memory': 1000,\n\t\t'force convergence': 0.001,\n\t\t'geometry optimization iterations': 50,\n\t\t'scf iterations': 100\n\t}\n\n\tcalc = Turbomole(**params)\n\tmol.calc = calc\n\tcalc.calculate(mol)\n\tassert calc.converged\n\n\t# use the get_property() method\n\tenergy = calc.get_property('energy', mol, False)\n\tassert energy is not False\n\tassert np.isclose(energy, -2076.286138, atol=1e-5)\n\tforces = calc.get_property('forces', mol, False)\n\tassert forces is not False\n\tassert np.linalg.norm(forces) < 0.01\n\tdipole = np.linalg.norm(calc.get_property('dipole', mol, False))\n\tassert np.isclose(dipole, 0.448, rtol=0.01)\n\n\t# use the get_results() method\n\tresults = calc.get_results()\n\tprint(results['molecular orbitals'])\n\n\t# use the __getitem__() method\n\tprint(calc['results']['molecular orbitals'])\n\tprint(calc['results']['geometry optimization history'])\n\n\t# perform a normal mode calculation with the optimized structure\n\n\tparams.update({\n\t\t'task': 'normal mode analysis',\n\t\t'density convergence': 1.0e-7\n\t})\n\n\tcalc = Turbomole(**params)\n\tmol.calc = calc\n\tcalc.calculate(mol)\n\n\tspectrum = calc['results']['vibrational spectrum']\n\tfreq_ref = [0, 0, 0, 0, 0, 0, 1633, 3637, 3745]\n\tfor s in spectrum:\n\t\tfor freq, mode in zip(freq_ref, range(1, 7)):\n\t\t\tif s['mode number'] == mode:\n\t\t\t\tassert np.isclose(s['frequency']['value'], freq, rtol=0.05)\n\n\tprint(calc.todict(skip_default=False))\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.calculators.turbomole import Turbomole", "from ase.build import molecule"]}], [{"term": "class", "name": "classDerivative:", "data": "class Derivative:\n\tdef __init__(self, f, h=0.0001):\n\t\tself.f = f\n\t\tself.h = float(h)\n\n\tdef __call__(self, x):\n\t\tf, h = self.f, self.h\n\t\treturn (f(x+h) - f(x-h))/(2*h)\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "class", "name": "classDerivative12:", "data": "class Derivative12:\n\tdef __init__(self, f, h=0.0001):\n\t\tself.f = f\n\t\tself.h = float(h)\n\n\tdef __call__(self, x, m):\n\t\tf, h = self.f, self.h\n\t\treturn (f(x+h,m) - f(x-h,m))/(2*h)\n\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "C", "data": "def C(n, k):\n\treturn math.factorial(n)/(math.factorial(n-k)*math.factorial(k))\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "b", "data": "def b(value):\n\tres = [0]\n\tsumm = 0\n\tfor i in range(1, value):\n\t\tsumm += i\n\tfor i in range(1, value):\n\t\tres.append(i/summ)\n\treturn res\n\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "class", "name": "classSolver:", "data": "class Solver:\n\n\tdef __init__(self, a, infin=3, fun = b):\n\t\tassert 0 < a < 1\n\t\tself.a = a\n\t\tself.inf = infin\n\t\tself.b = fun(self.inf)\n\t\tself.inA = 1 - a\n\t\tself.inB = self.calc_inB()\n\t\tself.pk = {}\n\t\tself.pik = {}\n\t\tself.gk = {}\n\t\tself.vk = {}\n\t\tassert self.calc_beta(self.inA)>self.inA/(1+self.inA)\n\n\tdef calc_inB(self):\n\t\tsum = 0\n\t\tfor i in range(self.inf):\n\t\t\tsum+=i*self.b[i]\n\t\treturn sum\n\n\tdef calc_Bi(self, i):\n\t\tsum = 0\n\t\tfor j in range(i, self.inf):\n\t\t\tsum += self.b[j]\n\t\treturn sum\n\n\tdef calc_beta(self, z):\n\t\tsum = 0\n\t\tfor i in range(self.inf):\n\t\t\tsum += z**i*self.b[i]\n\t\treturn sum\n\n\tdef calc_pk(self, k):\n\t\tif self.pk.get(k) or self.pk.get(k)==0:\n\t\t\treturn self.pk[k]\n\t\telse:\n\t\t\tif k==0:\n\t\t\t\tself.pk[k] = 1 - (self.inA*(1-self.calc_beta(self.inA))/self.calc_beta(self.inA))\n\t\t\telif k==1:\n\t\t\t\tself.pk[k] = (1/self.calc_beta(self.inA)*(1-self.calc_beta(self.inA)))*self.calc_pk(0)\n\t\t\telse:\n\t\t\t\tself.pk[k] = (1/self.calc_beta(self.inA))*(1-self.calc_beta(self.inA))*(self.calc_pk(k-1)-self.calc_pik(1, k-1))\n\t\t\treturn self.pk[k]\n\n\tdef calc_pik(self, i, k):\n\t\tassert k>=1\n\t\tif self.pik.get((i, k)) or self.pik.get((i, k))==0:\n\t\t\treturn self.pik[(i, k)]\n\t\telse:\n\t\t\tif i==1 and k==1:\n\t\t\t\tself.pik[(i, k)] = self.a/self.inA*self.calc_pk(0)\n\t\t\telif i==1:\n\t\t\t\tself.pik[(i, k)] = self.a/self.inA*(self.calc_pk(k-1) - self.calc_pik(1, k-1))\n\t\t\telif k==1:\n\t\t\t\tsum = 0\n\t\t\t\tfor j in range(i, self.inf):\n\t\t\t\t\tsum+=self.inA**(j-i)*self.b[j]\n\t\t\t\tself.pik[(i, k)] = self.a*(self.calc_pk(0)+self.calc_pk(1))*sum\n\t\t\telse:\n\t\t\t\tsum = 0\n\t\t\t\tfor j in range(i, self.inf):\n\t\t\t\t\tsum += self.inA**(j-i)*self.b[j]\n\t\t\t\tself.pik[(i, k)] = self.a*(self.calc_pk(k-1)-self.calc_pik(1, k-1))*sum+self.a*self.calc_pk(k)*sum\n\t\t\treturn self.pik[(i, k)]\n\n\tdef calc_gk(self, k):\n\t\tif self.gk.get(k) or self.gk.get(k)==0:\n\t\t\treturn self.gk[k]\n\t\telse:\n\t\t\tif k==0:\n\t\t\t\tself.gk[k] = 0\n\t\t\telse:\n\t\t\t\tsum1, sum2 = 0, 0\n\t\t\t\tfor i in range(1, k+1):\n\t\t\t\t\tsum1 += self.inA**(i-1)*self.a*self.b[i]*self.calc_gk(k-i)\n\t\t\t\t\tsum3 = 0\n\t\t\t\t\tfor j in range(k-i+1):\n\t\t\t\t\t\tsum3 += self.calc_gk(j)*self.calc_gk(k-i-j)\n\t\t\t\t\tsum2 += self.inA**(i-1)*self.a*self.calc_Bi(i+1)*sum3\n\t\t\t\tself.gk[k] = self.inA**k*self.b[k] + sum1 + sum2\n\t\t\treturn self.gk[k]\n\n\tdef calc_vk(self, k):\n\t\tif self.vk.get(k) or self.vk.get(k)==0:\n\t\t\treturn self.vk[k]\n\t\telse:\n\t\t\tif k==0:\n\t\t\t\tself.vk[k] = 0\n\t\t\telse:\n\t\t\t\tsum1 = 0\n\t\t\t\tfor i in range(1,k+1):\n\t\t\t\t\tsum2 = 0\n\t\t\t\t\tfor j in range(k-i+1):\n\t\t\t\t\t\tsum2 += self.calc_gk(j)*self.calc_vk(k-i-j)\n\t\t\t\t\tsum1 += self.inA**(i-1)*self.a*self.calc_Bi(i+1)*sum2\n\t\t\t\tself.vk[k] = self.inA**(k-1)*self.b[k]+sum1\n\t\t\treturn self.vk[k]\n\n\tdef calc_vkm(self, k, m):\n\t\tif k==0:\n\t\t\treturn 0\n\t\telif k >= 1 and k <= m-1:\n\t\t\tsum1 = 0\n\t\t\tfor i in range(1,k+1):\n\t\t\t\tsum2 = 0\n\t\t\t\tfor j in range(0, k-i+1):\n\t\t\t\t\tsum2 += self.calc_gk(j)*self.calc_vk(k-i-j)\n\t\t\t\tsum1 += self.inA**(i-1)*self.a*sum2\n\t\t\treturn sum1\n\t\telse:\n\t\t\tsum1 = 0\n\t\t\tfor i in range(1, m):\n\t\t\t\tsum2 = 0\n\t\t\t\tfor j in range(0,k-i+1):\n\t\t\t\t\tsum2 += self.calc_gk(j)*self.calc_vk(k-i-j)\n\t\t\t\tsum1 += self.inA**(i-1)*self.a*sum2\n\t\t\treturn self.inA**(m-1) + sum1\n\n\tdef calc_N(self):\n\t\tsum1 = 0\n\t\tfor i in range(1, self.inf):\n\t\t\tsum2 = 0\n\t\t\tfor k in range(1, self.inf):\n\t\t\t\tsum2 += k*self.calc_pik(i, k)\n\t\t\tsum1 += sum2\n\t\treturn sum1\n\n\tdef calc_gamma(self, z):\n\t\tsqr = math.sqrt((1-self.inA*z)**2*(self.inA-self.a*self.calc_beta(self.inA*z))**2 \\\n\t\t\t\t\t\t- 4*self.a*(self.inA*z-self.calc_beta(self.inA*z))*self.inA*(1-self.inA*z)*self.calc_beta(self.inA*z))\n\t\treturn ((1-self.inA*z)*(self.inA-self.a*self.calc_beta(self.inA*z)) - sqr)/(2*self.a*(self.inA*z-self.calc_beta(self.inA*z)))\n\n\tdef calc_ing1(self):\n\t\tdf = Derivative(self.calc_gamma)\n\t\treturn df(1)\n\n\tdef calc_ing2(self):\n\t\tsumm=0\n\t\tfor k in range(self.inf):\n\t\t\tsumm += k*self.calc_gk(k)\n\t\treturn summ\n\n\tdef calc_vz(self, z):\n\t\treturn ((1-self.inA*z)*self.calc_beta(self.inA*z))/\\\n\t\t\t   (self.inA*(1-self.inA*z) - self.a*(self.inA*z - self.calc_beta(self.inA*z))*self.calc_gamma(z))\n\n\tdef calc_v1(self):\n\t\tdf = Derivative(self.calc_vz)\n\t\treturn df(1)\n\n\tdef calc_v2(self):\n\t\tsumm = 0\n\t\tfor i in range(self.inf):\n\t\t\tsumm += i* self.calc_vk(i)\n\t\treturn summ\n\n\tdef calc_vzm(self, z, m):\n\t\treturn ((self.inA*z)**m/self.inA)+(self.a*z/self.inA) *\\\n\t\t\t\t\t\t\t\t\t\t  (1-(self.inA*z)**(m-1))*self.calc_gamma(z)*self.calc_vz(z) /\\\n\t\t\t\t\t\t\t\t\t\t  (1-self.inA*z)\n\n\tdef calc_vhatm1(self, m):\n\t\tdf = Derivative12(self.calc_vzm)\n\t\treturn df(1, m)\n\n\tdef calc_vhatm2(self, m):\n\t\tsumm = 0\n\t\tfor i in range(self.inf):\n\t\t\tsumm += i*self.calc_vkm(i, m)\n", "description": null, "category": "math", "imports": ["import math"]}], [{"term": "def", "name": "button_click", "data": "def button_click(char):\n\tglobal calc_operator\n\tcalc_operator += str(char)\n\ttext_input.set(calc_operator)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "button_clear_all", "data": "def button_clear_all():\n\tglobal calc_operator\n\tcalc_operator = \"\"\n\ttext_input.set(\"\")\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "button_delete", "data": "def button_delete():\n\tglobal calc_operator\n\ttext = calc_operator[:-1]\n\tcalc_operator = text\n\ttext_input.set(text)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "factorial", "data": "def factorial(n):\n\tif n==0 or n==1:\n\t\treturn 1\n\telse:\n\t\treturn n*factorial(n-1)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "fact_func", "data": "def fact_func():\n\tglobal calc_operator\n\tresult = str(factorial(int(calc_operator)))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_sin", "data": "def trig_sin():\n\tglobal calc_operator\n\t# calc_operator = result\n\tres=(int(calc_operator))\n\tif (res==90):\n\t\ttext_input.set(\"1.0\")\n\telse:\n\t\tresult = str(math.sin(math.radians(int(calc_operator))))\n\t\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_cos", "data": "def trig_cos():\n\tglobal calc_operator\n\t# calc_operator = result\n\tres=(int(calc_operator))\n\tif (res==90):\n\t\ttext_input.set(\"0\")\n\telse:\n\t\tresult = str(math.cos(math.radians(int(calc_operator))))\n\t\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_tan", "data": "def trig_tan():\n\tglobal calc_operator\n\t# calc_operator = result\n\tres=(int(calc_operator))\n\tif (res==90):\n\t\ttext_input.set(\"NOT DEFINED\")\n\telif(res==0):\n\t\ttext_input.set(\"0\")\n\telif(res==45):\n\t\ttext_input.set(\"1.0\")\t\n\telse:\n\t\tresult = str(math.tan(math.radians(int(calc_operator))))\n\t\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_cot", "data": "def trig_cot():\n\tglobal calc_operator\n\t# calc_operator = result\n\tres=(int(calc_operator))\n\tif (res==90):\n\t\ttext_input.set(\"0\")\n\telif(res==0):\n\t\ttext_input.set(\"NOT DEFINED\")\n\telif(res==45):\n\t\ttext_input.set(\"1.0\")\t\n\telse:\n\t\tresult = str(1/math.tan(math.radians(int(calc_operator))))\n\t\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "square_root", "data": "def square_root():\n\tglobal calc_operator\n\tif int(calc_operator)>=0:\n\t\ttemp = str(eval(calc_operator+'**(1/2)'))\n\t\tcalc_operator = temp\n\telse:\n\t\ttemp = \"ERROR\"\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "third_root", "data": "def third_root():\n\tglobal calc_operator\n\tif int(calc_operator)>=0:\n\t\ttemp = str(eval(calc_operator+'**(1/3)'))\n\t\tcalc_operator = temp\n\telse:\n\t\ttemp = \"MATH ERROR\"\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "sign_change", "data": "def sign_change():\n\tglobal calc_operator\n\tif calc_operator[0]=='-':\n\t\ttemp = calc_operator[1:]\n\telse:\n\t\ttemp = '-'+calc_operator\n\tcalc_operator = temp\n\ttext_input.set(temp)\t\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "percent", "data": "def percent():\n\tglobal calc_operator\n\ttemp = str(eval(calc_operator+'/100'))\n\tcalc_operator = temp\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "button_equal", "data": "def button_equal():\n\tglobal calc_operator\n\ttemp_op = str(eval(calc_operator))\n\ttext_input.set(temp_op)\n\tcalc_operator = temp_op\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}], [{"term": "def", "name": "test_units", "data": "def test_units(factory):\n\t\"\"\"\n\tNote: if this test fails, plumed or ASE changed some units.\n\tIt has to be fixed in the contructor of the plumed calculator.\n\n\tIn this test is considered two atoms interacting through a potential with\n\tthe form:\n\n\t(lower wall in plumed setup)\n\tV = k (r - r0)^2\n\n\tThe values are fixed as follow:\n\n\ttime = 1 ASE time units\n\tk = 1 kJ/(mol*nm^2)\n\tr = 1 Angstrom\n\tr0 = 1.1 nm\n\n\tconsidering r in nm, V = 1 kJ/mol and the forces F(r) = 2 kJ/(mol*nm) \"\"\"\n\n\tset_plumed = [\"e: ENERGY\",\t\t\t\t\t\t # check energy units\n\t\t\t\t  \"d: DISTANCE ATOMS=1,2\",\t\t\t # check distance units\n\t\t\t\t  \"LOWER_WALLS ARG=d AT=1.1 KAPPA=1\",  # check forces recieved\n\t\t\t\t  \"DUMPMASSCHARGE FILE=mass_charge\",   # check mass and charges\n\t\t\t\t  \"PRINT ARG=e,d FILE=COLVAR\",\n\t\t\t\t  \"FLUSH STRIDE=1\"]\n\n\t# execution\n\tatoms = Atoms('CO', positions=[[0, 0, 0], [0, 0, 1]], charges=[0, 1])\n\n\ttimestep = 1\n\tcalc = IdealGas()\n\twith factory.calc(calc=calc,\n\t\t\t\t\t  input=set_plumed,\n\t\t\t\t\t  timestep=timestep,\n\t\t\t\t\t  atoms=atoms,\n\t\t\t\t\t  use_charge=True) as calc:\n\t\tener, forces = atoms.calc.compute_bias(atoms.get_positions(), 1,\n\t\t\t\t\t\t\t\t\t\t\t   atoms.get_potential_energy())\n\t\tfiles = calc.read_plumed_files()\n\n\t# the next values are in ase units\n\tase_values = {'time': 1,\n\t\t\t\t  'energy': ener,\n\t\t\t\t  'distance': 1,\n\t\t\t\t  'masses': atoms.get_masses(),\n\t\t\t\t  'charges': atoms.get_initial_charges(),\n\t\t\t\t  'forces': forces}\n\n\t# The next values are in plumed units.\n\tplumed_values = {'time': files['COLVAR'][0][-1],\n\t\t\t\t\t 'energy': files['COLVAR'][1][-1],\n\t\t\t\t\t 'distance': files['COLVAR'][2][-1],\n\t\t\t\t\t 'masses': files['mass_charge'][1],\n\t\t\t\t\t 'charges': files['mass_charge'][2],\n\t\t\t\t\t 'forces': np.array([[0, 0, -2], [0, 0, 2]])}\n\n\tassert ase_values['time'] * 1 / (1000 * units.fs) == \\\n\t\tapprox(plumed_values['time'], abs=1E-5), \\\n\t\t\"error in time units\"\n\tassert ase_values['energy'] * units.mol / units.kJ == \\\n\t\tapprox(plumed_values['energy'], abs=1E-5), \\\n\t\t\"error in energy units\"\n\tassert ase_values['distance'] * 1 / units.nm == \\\n\t\tapprox(plumed_values['distance'], abs=1E-5), \\\n\t\t\"error in distance units\"\n\tassert ase_values['forces'] * units.nm * units.mol / units.kJ == \\\n\t\tapprox(plumed_values['forces'], abs=1E-5), \\\n\t\t\"error in forces units\"\n\tassert ase_values['masses'] == approx(plumed_values['masses'],\n\t\t\t\t\t\t\t\t\t\t  abs=1E-5),\\\n\t\t\"error in masses units\"\n\tassert ase_values['charges'] == approx(plumed_values['charges'],\n\t\t\t\t\t\t\t\t\t\t   abs=1E-5),\\\n\t\t\"error in charges units\"\n\n", "description": "\n\tNote: if this test fails, plumed or ASE changed some units.\n\tIt has to be fixed in the contructor of the plumed calculator.\n\n\tIn this test is considered two atoms interacting through a potential with\n\tthe form:\n\n\t(lower wall in plumed setup)\n\tV = k (r - r0)^2\n\n\tThe values are fixed as follow:\n\n\ttime = 1 ASE time units\n\tk = 1 kJ/(mol*nm^2)\n\tr = 1 Angstrom\n\tr0 = 1.1 nm\n\n\tconsidering r in nm, V = 1 kJ/mol and the forces F(r) = 2 kJ/(mol*nm) ", "category": "math", "imports": ["from ase import Atoms", "from ase.calculators.emt import EMT", "from ase.calculators.idealgas import IdealGas", "from ase.md.verlet import VelocityVerlet", "from ase.calculators.lj import LennardJones", "import numpy as np", "from ase.io.trajectory import Trajectory", "from pytest import approx", "import pytest", "from ase.calculators.plumed import restart_from_trajectory", "from ase import units"]}, {"term": "def", "name": "test_CVs", "data": "def test_CVs(factory):\n\t\"\"\" This test calls plumed-ASE calculator for computing some CVs.\n\tMoreover, it computes those CVs directly from atoms.positions and\n\tcompares them\"\"\"\n\t# plumed setting\n\tps = 1000 * units.fs\n\tset_plumed = [f\"UNITS LENGTH=A TIME={1/ps} ENERGY={units.mol/units.kJ}\",\n\t\t\t\t  \"c1: COM ATOMS=1,2\",\n\t\t\t\t  \"c2: CENTER ATOMS=1,2\",\n\t\t\t\t  \"l: DISTANCE ATOMS=c1,c2\",\n\t\t\t\t  \"d: DISTANCE ATOMS=1,2\",\n\t\t\t\t  \"c: COORDINATION GROUPA=1 GROUPB=2 R_0=100 MM=0 NN=10\",\n\t\t\t\t  \"FLUSH STRIDE=1\",\n\t\t\t\t  \"PRINT ARG=d,c,l STRIDE=10 FILE=COLVAR_test1\"]\n\n\t# execution\n\tatoms = Atoms('CO', positions=[[0, 0, 0], [0, 0, 5]])  # CO molecule\n\t_, colvar = run(factory, [set_plumed, atoms, 5], calc=EMT(), steps=101)\n\n\t# this compares the time calculated by ASE and plumed\n\ttimeASE = np.arange(0., 501., 50)\n\ttimePlumed = colvar['COLVAR_test1'][0]\n\tassert timeASE == approx(timePlumed), \"Error in time registered by plumed\"\n\n\t# This compares the distance of atoms calculated by ASE and plumed\n\tdistASE = np.array([5., 51.338332, 141.252854, 231.167376, 321.081899,\n\t\t\t\t\t\t410.996421, 500.910943, 590.825465, 680.739987,\n\t\t\t\t\t\t770.654509, 860.569031])\n\tdistPlumed = colvar['COLVAR_test1'][1]\n\tassert distPlumed == approx(distASE), \"Error in distance\"\n\n\t# this compares the coordination number calculated by ASE and plumed\n\tCASE = np.array([1.0000e+00, 9.9873e-01, 3.0655e-02, 2.2900e-04,\n\t\t\t\t\t 9.0000e-06, 1.0000e-06, 0.0000e+00, 0.0000e+00,\n\t\t\t\t\t 0.0000e+00, 0.0000e+00, 0.0000e+00])\n\tCPlumed = colvar['COLVAR_test1'][2]\n\tassert CASE == approx(CPlumed, abs=1E-5), \"Error in coordination number\"\n\n\t# this compares the distance between center of mass and geometrical center\n\t# calculated by ASE and plumed\n\tcentersASE = np.array([0.355944, 3.654717, 10.05563, 16.456542, 22.857455,\n\t\t\t\t\t\t   29.258367, 35.65928, 42.060192, 48.461104,\n\t\t\t\t\t\t   54.862017, 61.262929])\n\n\tcentersPlumed = colvar['COLVAR_test1'][3]\n\tassert centersASE == approx(centersPlumed)\n\n", "description": " This test calls plumed-ASE calculator for computing some CVs.\n\tMoreover, it computes those CVs directly from atoms.positions and\n\tcompares them", "category": "math", "imports": ["from ase import Atoms", "from ase.calculators.emt import EMT", "from ase.calculators.idealgas import IdealGas", "from ase.md.verlet import VelocityVerlet", "from ase.calculators.lj import LennardJones", "import numpy as np", "from ase.io.trajectory import Trajectory", "from pytest import approx", "import pytest", "from ase.calculators.plumed import restart_from_trajectory", "from ase import units"]}, {"term": "def", "name": "test_metadyn", "data": "def test_metadyn(factory):\n\t\"\"\"This test computes a Metadynamics calculation,\n\tThis result is compared with the same calulation made externally\"\"\"\n\tparams = setups()\n\tatoms, _ = run(factory, params, steps=58)\n\n\tposition1 = -0.0491871\n\tposition2 = 6.73693\n\tforceWithBias = 0.28807\n\n\tassert (atoms.get_positions()[0][0] == approx(position1, abs=0.01) and\n\t\t\tatoms.get_positions()[1][0] == approx(position2, abs=0.01)), \\\n\t\t\"Error in the metadynamics simulation\"\n\tassert atoms.get_forces()[0][0] == approx(forceWithBias, abs=0.01), \\\n\t\t\"Error in the computation of Bias-forces\"\n\n", "description": "This test computes a Metadynamics calculation,\n\tThis result is compared with the same calulation made externally", "category": "math", "imports": ["from ase import Atoms", "from ase.calculators.emt import EMT", "from ase.calculators.idealgas import IdealGas", "from ase.md.verlet import VelocityVerlet", "from ase.calculators.lj import LennardJones", "import numpy as np", "from ase.io.trajectory import Trajectory", "from pytest import approx", "import pytest", "from ase.calculators.plumed import restart_from_trajectory", "from ase import units"]}, {"term": "def", "name": "test_restart", "data": "def test_restart(factory):\n\tins = setups()\n\t# first steps\n\t_, res = run(factory, ins, name='restart')\n\n\t# rest of steps with restart\n\tinput, atoms1, timestep = setups()\n\twith restart_from_trajectory('test-restart.traj',\n\t\t\t\t\t\t\t\t calc=LennardJones(epsilon=10, sigma=6),\n\t\t\t\t\t\t\t\t input=input,\n\t\t\t\t\t\t\t\t timestep=timestep,\n\t\t\t\t\t\t\t\t atoms=atoms1) as atoms1.calc:\n\t\twith VelocityVerlet(atoms1, timestep) as dyn:\n\t\t\tdyn.run(30)\n\n\t# Values computed externally\n\tposition1 = -0.0491871\n\tposition2 = 6.73693\n\tforceWithBias = 0.28807\n\n\tassert atoms1.get_forces()[0][0] == approx(forceWithBias, abs=0.01), \\\n\t\t\"Error in restart for the computation of Bias-forces\"\n\n\tassert (atoms1.get_positions()[0][0] == approx(position1, abs=0.01) and\n\t\t\tatoms1.get_positions()[1][0] == approx(position2, abs=0.01)), \\\n\t\t\"Error in the restart of metadynamics simulation\"\n\n", "description": null, "category": "math", "imports": ["from ase import Atoms", "from ase.calculators.emt import EMT", "from ase.calculators.idealgas import IdealGas", "from ase.md.verlet import VelocityVerlet", "from ase.calculators.lj import LennardJones", "import numpy as np", "from ase.io.trajectory import Trajectory", "from pytest import approx", "import pytest", "from ase.calculators.plumed import restart_from_trajectory", "from ase import units"]}, {"term": "def", "name": "test_postpro", "data": "def test_postpro(factory):\n\t# Metadynamics simulation\n\tparams = setups('direct')\n\t_, direct = run(factory, params, name='direct', steps=58)\n\n\tparams = setups('postpro')\n\t# Postpro resconstruction\n\twith factory.calc(calc=IdealGas(),\n\t\t\t\t\t  input=params[0],\n\t\t\t\t\t  atoms=params[1],\n\t\t\t\t\t  timestep=params[2]) as calc:\n\t\twith Trajectory('test-direct.traj') as traj:\n\t\t\tpostpr = calc.write_plumed_files(traj)['HILLS_postpro']\n\n\tassert postpr == approx(direct['HILLS_direct'])\n\n", "description": null, "category": "math", "imports": ["from ase import Atoms", "from ase.calculators.emt import EMT", "from ase.calculators.idealgas import IdealGas", "from ase.md.verlet import VelocityVerlet", "from ase.calculators.lj import LennardJones", "import numpy as np", "from ase.io.trajectory import Trajectory", "from pytest import approx", "import pytest", "from ase.calculators.plumed import restart_from_trajectory", "from ase import units"]}, {"term": "def", "name": "test_pbc", "data": "def test_pbc(factory):\n\tatoms = Atoms('H2')\n\tatoms.set_positions([[1, 0, 0], [11, 2, 0]])\n\n\tatoms.set_cell([[10, 0, 0], [10, 10, 0], [0, 0, 10]])\n\ttraj = [atoms]\n\n\tps = 1000 * units.fs\n\tsetup = [f\"UNITS LENGTH=A TIME={1/ps} ENERGY={units.mol/units.kJ}\",\n\t\t\t \"d: DISTANCE ATOMS=1,2\",\n\t\t\t \"PRINT ARG=d STRIDE=100 FILE=COLVAR_pbc\"]\n\n\twith factory.calc(calc=IdealGas(),\n\t\t\t\t\t  input=setup,\n\t\t\t\t\t  atoms=atoms,\n\t\t\t\t\t  timestep=1) as calc:\n\t\tdist = calc.write_plumed_files(traj)['COLVAR_pbc']\n\n\tassert dist[1] == 2., \"Error in PBC\"\n\n", "description": null, "category": "math", "imports": ["from ase import Atoms", "from ase.calculators.emt import EMT", "from ase.calculators.idealgas import IdealGas", "from ase.md.verlet import VelocityVerlet", "from ase.calculators.lj import LennardJones", "import numpy as np", "from ase.io.trajectory import Trajectory", "from pytest import approx", "import pytest", "from ase.calculators.plumed import restart_from_trajectory", "from ase import units"]}, {"term": "def", "name": "run", "data": "def run(factory, inputs, name='',\n\t\tcalc=LennardJones(epsilon=10, sigma=6),\n\t\ttraj=None, steps=29):\n\tinput, atoms, timestep = inputs\n\twith factory.calc(calc=calc,\n\t\t\t\t\t  input=input,\n\t\t\t\t\t  timestep=timestep,\n\t\t\t\t\t  atoms=atoms) as atoms.calc:\n\t\twith VelocityVerlet(atoms, timestep,\n\t\t\t\t\t\t\ttrajectory='test-{}.traj'.format(name)) as dyn:\n\t\t\tdyn.run(steps)\n\t\tres = atoms.calc.read_plumed_files()\n\treturn atoms, res\n\n", "description": null, "category": "math", "imports": ["from ase import Atoms", "from ase.calculators.emt import EMT", "from ase.calculators.idealgas import IdealGas", "from ase.md.verlet import VelocityVerlet", "from ase.calculators.lj import LennardJones", "import numpy as np", "from ase.io.trajectory import Trajectory", "from pytest import approx", "import pytest", "from ase.calculators.plumed import restart_from_trajectory", "from ase import units"]}, {"term": "def", "name": "setups", "data": "def setups(name=''):\n\tps = 1000 * units.fs\n\tset_plumed = [f\"UNITS LENGTH=A TIME={1/ps} ENERGY={units.mol/units.kJ}\",\n\t\t\t\t  \"d: DISTANCE ATOMS=1,2\",\n\t\t\t\t  \"FLUSH STRIDE=1\",\n\t\t\t\t  f\"METAD ARG=d SIGMA=0.5 HEIGHT=2 PACE=20 FILE=HILLS_{name}\"]\n\tatoms = Atoms('CO', positions=[[0, 0, 0], [6.7, 0, 0]])\n\ttimestep = 0.05\n\treturn set_plumed, atoms, timestep\n", "description": null, "category": "math", "imports": ["from ase import Atoms", "from ase.calculators.emt import EMT", "from ase.calculators.idealgas import IdealGas", "from ase.md.verlet import VelocityVerlet", "from ase.calculators.lj import LennardJones", "import numpy as np", "from ase.io.trajectory import Trajectory", "from pytest import approx", "import pytest", "from ase.calculators.plumed import restart_from_trajectory", "from ase import units"]}], [{"term": "def", "name": "calculateAdvanced", "data": "def calculateAdvanced(numFaculty, numStudents, numSessions, durationSessions, classFloorArea, classHeight, county, state, masks, facultyInfectious, studentInfectious, maskEffExhalation, maskEffInhalation, ventilationRate, addlControl, decayRate, depositionRate, facultyInhalation, studentInhalation, meanFacultyQuantaE, sdFacultyQuantaE, meanStudentQuantaE, sdStudentQuantaE):\n\tnum_faculty = numFaculty\n\tnum_students = numStudents\n\tnum_class_periods = numSessions\n\tduration = durationSessions/60\n\tfloor_area = classFloorArea\n\theight = classHeight\n\tvolume = floor_area*height*(0.305**3)\n\tcounty = county\n\tstate = state\n\n\tventilation_w_outside_air = [ventilationRate[0], ventilationRate[1], 1]\n\tdecay_rate_of_virus = [decayRate[0], decayRate[1], 1]\n\tdeposition_to_surface = [depositionRate[0], depositionRate[1], 1]\n\tadditional_control_measures = [addlControl[0], addlControl[1], 1]\n\tquanta_emission_rate_faculty = [meanFacultyQuantaE, sdFacultyQuantaE, 1]\n\tquanta_emission_rate_student = [meanStudentQuantaE, sdStudentQuantaE, 1]\n\texhalation_mask_efficiency = [maskEffExhalation[0]/100, maskEffExhalation[1]/100, 1]\n\tinhalation_mask_efficiency = [maskEffInhalation[0]/100, maskEffInhalation[1]/100, 1]\n\tinhalation_rate_faculty = [facultyInhalation[0], facultyInhalation[1], 1]\n\tinhalation_rate_student = [studentInhalation[0], studentInhalation[1], 1]\n\tpercent_faculty_infectious = [facultyInfectious[0], facultyInfectious[1], 0]\n\tpercent_student_infectious = [studentInfectious[0], studentInfectious[1], 0]\n\t# ventilation_w_outside_air = [1, 4, 1]\n\t# decay_rate_of_virus = [0, 1.0, 1]\n\t# deposition_to_surface = [0.3, 1.5, 1]\n\t# additional_control_measures = [0, 0, 1]\n\t# quanta_emission_rate_faculty = [1.5, 0.71, 1]\n\t# quanta_emission_rate_student = [0.69, 0.71, 1]\n\t# exhalation_mask_efficiency = [0.4, 0.6, 1]\n\t# inhalation_mask_efficiency = [0.3, 0.5, 1]\n\t# inhalation_rate_faculty = [0.005, 0.01, 1]\n\t# inhalation_rate_student = [0.005, 0.007, 1]\n\n\n\tpercent_faculty_infectious = getCountyCases(county, state)\n\tpercent_student_infectious = percent_faculty_infectious\n\t# percent_faculty_infectious = [0.7, 1.4, 0]\n\t# percent_student_infectious = [0.7, 1.4, 0]\n\n\t############################\n\n\tdef randomizeAll():\n\t\trandomize(ventilation_w_outside_air)\n\t\trandomize(decay_rate_of_virus)\n\t\trandomize(deposition_to_surface)\n\t\trandomize(additional_control_measures)\n\t\trandomize(exhalation_mask_efficiency)\n\t\trandomize(inhalation_mask_efficiency)\n\t\trandomize(inhalation_rate_faculty)\n\t\trandomize(inhalation_rate_student)\n\t\trandomize(percent_faculty_infectious)\n\t\trandomize(percent_student_infectious)\n\n\t\trandomizeFromNormal(quanta_emission_rate_faculty)\n\t\trandomizeFromNormal(quanta_emission_rate_student)\n\n\tdef randomize(bounds):\n\t\tbounds[2] = bounds[0] + np.random.random_sample() * \\\n\t\t\t(bounds[1]-bounds[0])\n\n\tdef randomizeFromNormal(normdist):\n\t\tnormdist[2] = 10**np.random.normal(normdist[0], normdist[1])\n\t\t##also does the UNDO LOG\n\n\t# Q_f: quanta emission rate by infected faculty\n\t# m_out: mask exhalation efficiency\n\t# k: first order loss coefficients for ventilation , decay, deposition, and other control measures\n\t# V: volume of classroom\n\t# T: duration of each in-person class session\n\n\t# Average quanta concentration during class period if 1 faculty member is infected:\n\tdef calc_Cf(Q_f, m_out, k, V, T):\n\t\tcf = ((Q_f*(1-m_out))/(k*V))*(1-(1/(k*T))*(1-e**(-k*T)))\n\n\t\treturn cf\n\n\t# Average quanta concentration during class period if 1 student is infected:\n\tdef calc_Cs(Q_s, m_out, k, V, T):\n\t\tcs = ((Q_s*(1-m_out))/(k*V))*(1-(1/(k*T))*(1-e**(-k*T)))\n\t\treturn cs\n\n\t# Quanta inhaled by student if 1 faculty infected:\n\tdef calc_Nfs(C_f, I_s, m_in, T):\n\t\tNfs = C_f*I_s*(1-m_in)*T\n\t\treturn Nfs\n\n\t# Quanta inhaled by faculty if 1 student infected:\n\tdef calc_Nsf(C_s, I_f, m_in, T):\n\t\tNsf = C_s*I_f*(1-m_in)*T\n\t\treturn Nsf\n\n\t# Quanta inhaled by student if 1 student infected\n\tdef calc_Nss(C_s, I_s, m_in, T):\n\t\tNss = C_s*I_s*(1-m_in)*T\n\t\treturn Nss\n\n\t# Probability of 1 faculty infecting student:\n\tdef calc_pfs(f_f, N_fs):\n\t\tpfs = f_f*(1-np.exp(-N_fs))\n\t\treturn pfs\n\n\t# Probability of 1 student infecting faculty:\n\tdef calc_psf(f_s, N_sf):\n\t\tpsf = f_s*(1-np.power(e, -N_sf))\n\t\treturn psf\n\n\t# Probability of 1 student infecting student:\n\tdef calc_pss(f_s, N_ss):\n\t\tpss = f_s*(1-np.power(e, -N_ss))\n\t\treturn pss\n\n\t# Probability of faculty infection in one class session:\n\tdef calc_p1f(p_sf, N_s):\n\t\tp1f = 1-(1-p_sf)**(N_s)\n\t\treturn p1f\n\n\t# Probability of student infection in one class session:\n\tdef calc_p1s(p_ss, n_s, p_fs, n_f):\n\t\tp1s = 1-((1-p_ss)**(n_s-1)*(1-p_fs)**n_f)\n\t\treturn p1s\n\n\t# Probability of faculty infection for semester:\n\tdef calc_pf(p1_f, n_c):\n\t\tpf = 1-(1-p1_f)**n_c\n\t\treturn pf\n\n\t# Probability of student infection for semester:\n\tdef calc_ps(p1_s, n_c):\n\t\tps = 1-(1-p1_s)**n_c\n\t\treturn ps\n\n\ttrials = 10000\n\tfac_runs = np.zeros(trials)\n\tstudent_runs = np.zeros(trials)\n\tfor x in range(trials):\n\t\trandomizeAll()\n\n\t\tcf = calc_Cf(quanta_emission_rate_faculty[2], exhalation_mask_efficiency[2], (ventilation_w_outside_air[2] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  decay_rate_of_virus[2]+deposition_to_surface[2]+additional_control_measures[2]), volume, duration)\n\t\t#print(\"cf: \", cf)\n\t\tcs = calc_Cs(quanta_emission_rate_student[2], exhalation_mask_efficiency[2], (ventilation_w_outside_air[2] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  decay_rate_of_virus[2]+deposition_to_surface[2]+additional_control_measures[2]), volume, duration)\n\t\t#print(\"cs: \", cs)\n\t\tNfs = calc_Nfs(\n\t\t\tcf, inhalation_rate_student[2]*60, inhalation_mask_efficiency[2], duration)\n\t\t#print(\"Nfs: \", Nfs)\n\t\tNsf = calc_Nsf(\n\t\t\tcs, inhalation_rate_faculty[2]*60, inhalation_mask_efficiency[2], duration)\n\t\t#print(\"Nsf: \", Nsf)\n\t\tNss = calc_Nss(\n\t\t\tcs, inhalation_rate_student[2]*60, inhalation_mask_efficiency[2], duration)\n\t\t#print(\"Nss: \", Nss)\n\t\tPfs = calc_pfs(percent_faculty_infectious[2], Nfs)\n\t\t# print(\"f_f: \", percent_faculty_infectious)\n\t\t#print(\"Pfs: \", Pfs)\n\t\tPsf = calc_psf(percent_student_infectious[2], Nsf)\n\t\t#print(\"Psf: \", Psf)\n\t\tPss = calc_pss(percent_student_infectious[2], Nss)\n\t\t#print(\"Pss: \", Pss)\n\t\tP1f = calc_p1f(Psf, num_students)\n\t\t#print(\"P1f: \", P1f)\n\t\tP1s = calc_p1s(Pss, num_students, Pfs, num_faculty)\n\t\t#print(\"P1s: \", P1s)\n\t\tPf = calc_pf(P1f, num_class_periods)\n\t\t#print(\"Pf: \", Pf)\n\t\tPs = calc_ps(P1s, num_class_periods)\n\t\t#print(\"Ps: \", Ps)\n\t\tfac_runs[x] = Pf\n\t\tstudent_runs[x] = Ps\n\n\tstudent_mean = round(statistics.mean(student_runs)*100, 2)\n\tfac_mean = round(statistics.mean(fac_runs)*100, 2)\n\n\tstudent_quants_05 = np.quantile(student_runs, 0.05)\n\tstudent_quants_25 = np.quantile(student_runs, 0.25)\n\tstudent_quants_50 = np.quantile(student_runs, 0.50)\n\tstudent_quants_75 = np.quantile(student_runs, 0.75)\n\tstudent_quants_95 = np.quantile(student_runs, 0.95)\n\n\tfac_quants_05 = np.quantile(fac_runs, 0.05)\n\tfac_quants_25 = np.quantile(fac_runs, 0.25)\n\tfac_quants_50 = np.quantile(fac_runs, 0.50)\n\tfac_quants_75 = np.quantile(fac_runs, 0.75)\n\tfac_quants_95 = np.quantile(fac_runs, 0.95)\n\n\tstudentResults = {'student_quants_05': round(student_quants_05*100, 2),\n\t\t\t\t\t  'student_quants_25': round(student_quants_25*100, 2),\n\t\t\t\t\t  'student_quants_50': round(student_quants_50*100, 2),\n\t\t\t\t\t  'student_quants_75': round(student_quants_75*100, 2),\n\t\t\t\t\t  'student_quants_95': round(student_quants_95*100, 2)}\n\n\tfacultyResults = {'fac_quants_05': round(fac_quants_05*100, 2),\n\t\t\t\t\t  'fac_quants_25': round(fac_quants_25*100, 2),\n\t\t\t\t\t  'fac_quants_50': round(fac_quants_50*100, 2),\n\t\t\t\t\t  'fac_quants_75': round(fac_quants_75*100, 2),\n\t\t\t\t\t  'fac_quants_95': round(fac_quants_95*100, 2)}\n\n\tpercent_faculty_infectious = [\n\t\tpercent_faculty_infectious[0]*100, percent_faculty_infectious[1]*100, 0]\n\tpercent_student_infectious = [\n\t\tpercent_student_infectious[0]*100, percent_student_infectious[1]*100, 0]\n\n\treturn (student_mean, fac_mean, studentResults, facultyResults, percent_faculty_infectious*100, percent_student_infectious*100)\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pandas as pd", "import math", "from getCountyCases import getCountyCases", "import statistics"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "calc_M0_1", "data": "def calc_M0_1(x):\n", "description": null, "category": "math", "imports": ["import numpy as np"]}], [{"term": "class", "name": "TestCalc", "data": "class TestCalc(unittest.TestCase):\r\n\r\n\tdef test_add(self):\r\n\t\tresult = calc.add(10, 5)\r\n\t\tself.assertEqual(result, 15)\r\n\t\t# to run this we need to run this command.\r\n\t\t# python -m unittest test_calc.py\r\n\tdef test_add1(self):\r\n\t\tself.assertEqual(calc.add(10, 5), 15)\r\n\t\tself.assertEqual(calc.add(100, 5), 105)\r\n\t\tself.assertEqual(calc.add(1000, 5), 1005)\r\n\t\tself.assertEqual(calc.add(10, -5), 5)\r\n\t\tself.assertEqual(calc.add(-10, -10), -20)\r\n\r\n\tdef test_sub(self):\r\n\t\tself.assertEqual(calc.sub(10, 5), 5)\r\n\t\tself.assertEqual(calc.sub(100, 5), 95)\r\n\t\tself.assertEqual(calc.sub(1000, 5), 995)\r\n\t\tself.assertEqual(calc.sub(10, -5), 15)\r\n\t\tself.assertEqual(calc.sub(-10, -10), 0)\r\n\r\n\tdef test_mul(self):\r\n\t\tself.assertEqual(calc.mul(10, 5), 50)\r\n\t\tself.assertEqual(calc.mul(100, 5), 500)\r\n\t\tself.assertEqual(calc.mul(1000, 5), 5000)\r\n\t\tself.assertEqual(calc.mul(10, -5), -50)\r\n\t\tself.assertEqual(calc.mul(-10, -10), 100)\r\n\r\n\tdef test_div(self):\r\n\t\tself.assertEqual(calc.div(10, 5), 2)\r\n\t\tself.assertEqual(calc.div(100, 5), 20)\r\n\t\tself.assertEqual(calc.div(1000, 5), 200)\r\n\t\tself.assertEqual(calc.div(10, -5), -2)\r\n\t\tself.assertEqual(calc.div(-10, -10), 1)\r\n\r\n\t\tself.assertRaises(ValueError, calc.div, 10, 0) \r\n\t\t# this is for checking exceptions\r\n\r\n\t\twith self.assertRaises(ValueError):\r\n\t\t\tcalc.div( 10, 2)\r\n\t\t# Same as the previous code but using context manager, it is the most preferred method for doing tests.\r\n\r\n", "description": null, "category": "math", "imports": ["from asyncio import exceptions\r", "import unittest\r", "from django.test import TestCase\r", "import calc\r"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "test_h2dft_old", "data": "def test_h2dft_old(name):\n\tfactory = ObsoleteFactoryWrapper(name)\n\trun(factory)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "test_h2dft", "data": "def test_h2dft(factory):\n\trun(factory)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "run", "data": "def run(factory):\n\tname = factory.name\n\tpar = required.get(name, {})\n\tcalc = factory.calc(label=name, xc='LDA', **par)\n\th2 = molecule('H2', calculator=calc)\n\th2.center(vacuum=2.0)\n\te2 = h2.get_potential_energy()\n\tcalc.set(xc='PBE')\n\te2pbe = h2.get_potential_energy()\n\th1 = h2.copy()\n\tdel h1[1]\n\th1.set_initial_magnetic_moments([1])\n\th1.calc = calc\n\te1pbe = h1.get_potential_energy()\n\tcalc.set(xc='LDA')\n\te1 = h1.get_potential_energy()\n\ttry:\n\t\tm1 = h1.get_magnetic_moment()\n\texcept NotImplementedError:\n\t\tpass\n\telse:\n\t\tprint(m1)\n\tprint(2 * e1 - e2)\n\tprint(2 * e1pbe - e2pbe)\n\tprint(e1, e2, e1pbe, e2pbe)\n\tcalc = factory.calc(restart=name)\n\tprint(calc.parameters, calc.results, calc.atoms)\n\tassert not calc.calculation_required(h1, ['energy'])\n\th1 = calc.get_atoms()\n\tprint(h1.get_potential_energy())\n\tlabel = 'dir/' + name + '-h1'\n\tcalc = factory.calc(label=label, atoms=h1, xc='LDA', **par)\n\tprint(h1.get_potential_energy())\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}], [{"term": "def", "name": "funA", "data": "def funA(calc_tax):\n\tminus=120000+200000 #320000 \u55ae\u8eab+\u6a19\u6e96\u6263\u9664\u984d+\u85aa\u8cc7\u6240\u5f97\u7279\u5225\u6263\u9664\u984d\n\tcalc_tax=calc_tax-minus \n\ttotal=0\n\tif(calc_tax<=540000):\n\t\ttotal=calc_tax*0.05\n", "description": null, "category": "math", "imports": []}], [{"term": "class", "name": "target", "data": "class target(object):\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "  from scitbx.array_family import flex", "  from scitbx.array_family import flex", "\t  from scitbx.array_family import flex"]}, {"term": "def", "name": "__init__", "data": "  def __init__(O, f_obs, f_calc=None, f_calc_abs=None, fca_sq_eps=1e-100):\n\tassert [f_calc, f_calc_abs].count(None) == 1\n\tif (f_calc is not None):\n\t  from scitbx.array_family import flex\n\t  f_calc_abs = flex.abs(f_calc)\n\tO.k, O.k_d, O.k_d2 = calc_k(f_obs, f_calc_abs)\n\tO.t, O.g, O.c = calc_t(f_obs, f_calc_abs, O.k, O.k_d, O.k_d2)\n\tO.f_calc_gradients = None\n\tO.f_calc_hessians = None\n\tif (f_calc is not None):\n\t  fca_sq = f_calc_abs**2\n\t  isel_zero = (fca_sq <= fca_sq_eps).iselection()\n\t  f_calc_abs.set_selected(isel_zero, 1)\n\t  fca_sq.set_selected(isel_zero, 1)\n\t  O.f_calc_gradients = O.g / f_calc_abs * f_calc\n\t  O.f_calc_gradients.set_selected(isel_zero, 0j)\n\t  a = flex.real(f_calc)\n\t  b = flex.imag(f_calc)\n\t  aa, bb, ab = a*a, b*b, a*b\n\t  haa = O.c * aa + O.g * bb / f_calc_abs\n\t  hbb = O.c * bb + O.g * aa / f_calc_abs\n\t  hab = (O.c - O.g / f_calc_abs) * a * b\n\t  O.f_calc_hessians = flex.vec3_double(haa, hbb, hab) / fca_sq\n\t  O.f_calc_hessians.set_selected(isel_zero, (0,0,0))\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "  from scitbx.array_family import flex", "  from scitbx.array_family import flex", "\t  from scitbx.array_family import flex"]}, {"term": "def", "name": "target_work", "data": "  def target_work(O):\n\treturn O.t\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "  from scitbx.array_family import flex", "  from scitbx.array_family import flex", "\t  from scitbx.array_family import flex"]}, {"term": "def", "name": "gradients_work", "data": "  def gradients_work(O):\n\treturn O.f_calc_gradients\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "  from scitbx.array_family import flex", "  from scitbx.array_family import flex", "\t  from scitbx.array_family import flex"]}, {"term": "def", "name": "hessians_work", "data": "  def hessians_work(O):\n\treturn O.f_calc_hessians\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "  from scitbx.array_family import flex", "  from scitbx.array_family import flex", "\t  from scitbx.array_family import flex"]}], [{"term": "def", "name": "test_plugin_output_store_instantiate", "data": "def test_plugin_output_store_instantiate():\n\tOutputStore()\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.output.store import OutputStore", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_store_hook", "data": "def test_plugin_output_store_hook():\n\tcalc = TestCalculator()\n\tplugin = OutputStore()\n\tcalc.register_plugin_and_enable(plugin)\n\tassert plugin in calc.plugins\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.output.store import OutputStore", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_store_context_updated", "data": "def test_plugin_output_store_context_updated():\n\tcalc = TestCalculator()\n\tcalc.register_plugin_and_enable(OutputStore())\n\tassert calc.chksym(\"output_store\")\n\tassert callable(calc.getsym(\"output_store\"))\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.output.store import OutputStore", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_store_available", "data": "def test_plugin_output_store_available():\n\tcalc = TestCalculator()\n\tcalc.register_plugin_and_enable(OutputStore())\n\tassert callable(calc.command(\"output_store\"))\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.output.store import OutputStore", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_store_python", "data": "def test_plugin_output_store_python(capfd):\n\tcalc = TestCalculator()\n\tplugin = OutputStore()\n\tcalc.register_plugin_and_enable(plugin)\n\tl = [None]\n\tfor i in range(20):\n\t\ts = random_str()\n\t\tcalc.command(f\"'{s}'\")\n\t\tl.append(s)\n\t\tassert \"Result\" in capfd.readouterr().out\n\t\tassert calc.context.out[-1] == s\n\tfor x in generate_test_values(4, real=True, complex=True, include_edge_cases=False):\n\t\tl.append(x)\n\t\tcalc.command(str(x))\n\t\tassert \"Result\" in capfd.readouterr().out\n\t\tassert calc.context.out[-1] == x\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.output.store import OutputStore", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_store_sympy", "data": "def test_plugin_output_store_sympy(capfd):\n\tcalc = TestCalculator()\n\tplugin = OutputStore()\n\tcalc.register_plugin_and_enable(plugin)\n\tl = [None]\n\tfor x in generate_test_values(4, sympy_objects=True, real=True, complex=True, include_edge_cases=False):\n\t\tif abs(x) < 0.00000000001:\n\t\t\tcontinue\n\t\tl.append(x)\n\t\tcalc.command(f\"sympify('{str(x)}',rational=True)\")\n\t\tassert \"Result\" in capfd.readouterr().out\n\t\tassert abs(calc.context.out[-1].evalf() - x.evalf()) < 0.0001\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.output.store import OutputStore", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_store_invalid", "data": "def test_plugin_output_store_invalid():\n\tplugin = OutputStore()\n\tcalc = TestCalculator()\n\tplugin = OutputStore()\n\tcalc.register_plugin_and_enable(plugin)\n\tfor i in range(100):\n\t\tcalc.command(\"sympify(0)\")\n\t\tcalc.command(\"sympify(1)\")\n\t\tcalc.command(f\"Symbol('{random_str()}')\")\n\tassert len(calc.context.out) == 1\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.output.store import OutputStore", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_store_duplicates", "data": "def test_plugin_output_store_duplicates(capfd):\n\tcalc = TestCalculator()\n\tplugin = OutputStore()\n\tcalc.register_plugin_and_enable(plugin)\n\tl = [None]\n\tfor i in range(20):\n\t\ts = random_str()\n\t\tcalc.command(f\"'{s}'\")\n\t\tl.append(s)\n\t\tassert \"Result\" in capfd.readouterr().out\n\t\tassert len(calc.context.out) == len(l)\n\t\tcalc.command(f\"'{s}'\")\n\t\tcalc.command(f\"'{s}'\")\n\t\tassert len(calc.context.out) == len(l)\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.output.store import OutputStore", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_store_example", "data": "def test_plugin_output_store_example(capfd):\n\tcalc = TestCalculator()\n\tplugin = OutputStore()\n\tcalc.register_plugin_and_enable(plugin)\n\tcalc.command(\"x=Symbol('x')\")\n\tr = calc.command(\"2*x\")\n\tassert \"Result\" in capfd.readouterr().out\n\tassert len(calc.context.out) == 2\n\tassert calc.context.out[1] == calc.context.out[-1] == calc.command(\"out[1]\") == calc.command(\"out[-1]\") == r\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.output.store import OutputStore", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_store_enable_switch", "data": "def test_plugin_output_store_enable_switch(capfd):\n\tcalc = TestCalculator()\n\tplugin = OutputStore()\n\tcalc.register_plugin(plugin)\n\tcalc.settings[plugin.setting_name] = False\n\n\tfor x in generate_test_values(2, False, real=True, complex=True):\n\t\tcalc.command(str(x))\n\tfor x in generate_test_values(2, True, real=True, complex=True):\n\t\tcalc.command(f\"sympify('{str(x)}')\")\n\tassert capfd.readouterr().out.count(\"Decimal\") == 0\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.output.store import OutputStore", "from tests import TestCalculator, generate_test_values, random_str"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "class", "name": "classBidirectionalBreadthFirstSearchPlanner:", "data": "class BidirectionalBreadthFirstSearchPlanner:\n\n\tdef __init__(self, ox, oy, resolution, rr):\n\t\t\"\"\"\n\t\tInitialize grid map for bfs planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t\"\"\"\n\n\t\tself.min_x, self.min_y = None, None\n\t\tself.max_x, self.max_y = None, None\n\t\tself.x_width, self.y_width, self.obstacle_map = None, None, None\n\t\tself.resolution = resolution\n\t\tself.rr = rr\n\t\tself.calc_obstacle_map(ox, oy)\n\t\tself.motion = self.get_motion_model()\n\n\tclass Node:\n\t\tdef __init__(self, x, y, cost, parent_index, parent):\n\t\t\tself.x = x  # index of grid\n\t\t\tself.y = y  # index of grid\n\t\t\tself.cost = cost\n\t\t\tself.parent_index = parent_index\n\t\t\tself.parent = parent\n\n\t\tdef __str__(self):\n\t\t\treturn str(self.x) + \",\" + str(self.y) + \",\" + str(\n\t\t\t\tself.cost) + \",\" + str(self.parent_index)\n\n\tdef planning(self, sx, sy, gx, gy):\n\t\t\"\"\"\n\t\tBidirectional Breadth First search based planning\n\n\t\tinput:\n\t\t\ts_x: start x position [m]\n\t\t\ts_y: start y position [m]\n\t\t\tgx: goal x position [m]\n\t\t\tgy: goal y position [m]\n\n\t\toutput:\n\t\t\trx: x position list of the final path\n\t\t\try: y position list of the final path\n\t\t\"\"\"\n\n\t\tstart_node = self.Node(self.calc_xy_index(sx, self.min_x),\n\t\t\t\t\t\t\t   self.calc_xy_index(sy, self.min_y), 0.0, -1,\n\t\t\t\t\t\t\t   None)\n\t\tgoal_node = self.Node(self.calc_xy_index(gx, self.min_x),\n\t\t\t\t\t\t\t  self.calc_xy_index(gy, self.min_y), 0.0, -1,\n\t\t\t\t\t\t\t  None)\n\n\t\topen_set_A, closed_set_A = dict(), dict()\n\t\topen_set_B, closed_set_B = dict(), dict()\n\t\topen_set_B[self.calc_grid_index(goal_node)] = goal_node\n\t\topen_set_A[self.calc_grid_index(start_node)] = start_node\n\n\t\tmeet_point_A, meet_point_B = None, None\n\n\t\twhile 1:\n\t\t\tif len(open_set_A) == 0:\n\t\t\t\tprint(\"Open set A is empty..\")\n\t\t\t\tbreak\n\n\t\t\tif len(open_set_B) == 0:\n\t\t\t\tprint(\"Open set B is empty\")\n\t\t\t\tbreak\n\n\t\t\tcurrent_A = open_set_A.pop(list(open_set_A.keys())[0])\n\t\t\tcurrent_B = open_set_B.pop(list(open_set_B.keys())[0])\n\n\t\t\tc_id_A = self.calc_grid_index(current_A)\n\t\t\tc_id_B = self.calc_grid_index(current_B)\n\n\t\t\tclosed_set_A[c_id_A] = current_A\n\t\t\tclosed_set_B[c_id_B] = current_B\n\n\t\t\t# show graph\n\t\t\tif show_animation:  # pragma: no cover\n\t\t\t\tplt.plot(self.calc_grid_position(current_A.x, self.min_x),\n\t\t\t\t\t\t self.calc_grid_position(current_A.y, self.min_y),\n\t\t\t\t\t\t \"xc\")\n\t\t\t\tplt.plot(self.calc_grid_position(current_B.x, self.min_x),\n\t\t\t\t\t\t self.calc_grid_position(current_B.y, self.min_y),\n\t\t\t\t\t\t \"xc\")\n\t\t\t\t# for stopping simulation with the esc key.\n\t\t\t\tplt.gcf().canvas.mpl_connect(\n\t\t\t\t\t'key_release_event',\n\t\t\t\t\tlambda event: [exit(0) if event.key == 'escape' else None])\n\t\t\t\tif len(closed_set_A.keys()) % 10 == 0:\n\t\t\t\t\tplt.pause(0.001)\n\n\t\t\tif c_id_A in closed_set_B:\n\t\t\t\tprint(\"Find goal\")\n\t\t\t\tmeet_point_A = closed_set_A[c_id_A]\n\t\t\t\tmeet_point_B = closed_set_B[c_id_A]\n\t\t\t\tbreak\n\n\t\t\telif c_id_B in closed_set_A:\n\t\t\t\tprint(\"Find goal\")\n\t\t\t\tmeet_point_A = closed_set_A[c_id_B]\n\t\t\t\tmeet_point_B = closed_set_B[c_id_B]\n\t\t\t\tbreak\n\n\t\t\t# expand_grid search grid based on motion model\n\t\t\tfor i, _ in enumerate(self.motion):\n\t\t\t\tbreakA = False\n\t\t\t\tbreakB = False\n\n\t\t\t\tnode_A = self.Node(current_A.x + self.motion[i][0],\n\t\t\t\t\t\t\t\t   current_A.y + self.motion[i][1],\n\t\t\t\t\t\t\t\t   current_A.cost + self.motion[i][2],\n\t\t\t\t\t\t\t\t   c_id_A, None)\n\t\t\t\tnode_B = self.Node(current_B.x + self.motion[i][0],\n\t\t\t\t\t\t\t\t   current_B.y + self.motion[i][1],\n\t\t\t\t\t\t\t\t   current_B.cost + self.motion[i][2],\n\t\t\t\t\t\t\t\t   c_id_B, None)\n\n\t\t\t\tn_id_A = self.calc_grid_index(node_A)\n\t\t\t\tn_id_B = self.calc_grid_index(node_B)\n\n\t\t\t\t# If the node is not safe, do nothing\n\t\t\t\tif not self.verify_node(node_A):\n\t\t\t\t\tbreakA = True\n\n\t\t\t\tif not self.verify_node(node_B):\n\t\t\t\t\tbreakB = True\n\n\t\t\t\tif (n_id_A not in closed_set_A) and \\\n\t\t\t\t\t\t(n_id_A not in open_set_A) and (not breakA):\n\t\t\t\t\tnode_A.parent = current_A\n\t\t\t\t\topen_set_A[n_id_A] = node_A\n\n\t\t\t\tif (n_id_B not in closed_set_B) and \\\n\t\t\t\t\t\t(n_id_B not in open_set_B) and (not breakB):\n\t\t\t\t\tnode_B.parent = current_B\n\t\t\t\t\topen_set_B[n_id_B] = node_B\n\n\t\trx, ry = self.calc_final_path_bidir(\n\t\t\tmeet_point_A, meet_point_B, closed_set_A, closed_set_B)\n\t\treturn rx, ry\n\n\t# takes both set and meeting nodes and calculate optimal path\n\tdef calc_final_path_bidir(self, n1, n2, setA, setB):\n\t\trxA, ryA = self.calc_final_path(n1, setA)\n\t\trxB, ryB = self.calc_final_path(n2, setB)\n\n\t\trxA.reverse()\n\t\tryA.reverse()\n\n\t\trx = rxA + rxB\n\t\try = ryA + ryB\n\n\t\treturn rx, ry\n\n\tdef calc_final_path(self, goal_node, closed_set):\n\t\t# generate final course\n\t\trx, ry = [self.calc_grid_position(goal_node.x, self.min_x)], [\n\t\t\tself.calc_grid_position(goal_node.y, self.min_y)]\n\t\tn = closed_set[goal_node.parent_index]\n\t\twhile n is not None:\n\t\t\trx.append(self.calc_grid_position(n.x, self.min_x))\n\t\t\try.append(self.calc_grid_position(n.y, self.min_y))\n\t\t\tn = n.parent\n\n\t\treturn rx, ry\n\n\tdef calc_grid_position(self, index, min_position):\n\t\t\"\"\"\n\t\tcalc grid position\n\n\t\t:param index:\n\t\t:param min_position:\n\t\t:return:\n\t\t\"\"\"\n\t\tpos = index * self.resolution + min_position\n\t\treturn pos\n\n\tdef calc_xy_index(self, position, min_pos):\n\t\treturn round((position - min_pos) / self.resolution)\n\n\tdef calc_grid_index(self, node):\n\t\treturn (node.y - self.min_y) * self.x_width + (node.x - self.min_x)\n\n\tdef verify_node(self, node):\n\t\tpx = self.calc_grid_position(node.x, self.min_x)\n\t\tpy = self.calc_grid_position(node.y, self.min_y)\n\n\t\tif px < self.min_x:\n\t\t\treturn False\n\t\telif py < self.min_y:\n\t\t\treturn False\n\t\telif px >= self.max_x:\n\t\t\treturn False\n\t\telif py >= self.max_y:\n\t\t\treturn False\n\n\t\t# collision check\n\t\tif self.obstacle_map[node.x][node.y]:\n\t\t\treturn False\n\n\t\treturn True\n\n\tdef calc_obstacle_map(self, ox, oy):\n\n\t\tself.min_x = round(min(ox))\n\t\tself.min_y = round(min(oy))\n\t\tself.max_x = round(max(ox))\n\t\tself.max_y = round(max(oy))\n\t\tprint(\"min_x:\", self.min_x)\n\t\tprint(\"min_y:\", self.min_y)\n\t\tprint(\"max_x:\", self.max_x)\n\t\tprint(\"max_y:\", self.max_y)\n\n\t\tself.x_width = round((self.max_x - self.min_x) / self.resolution)\n\t\tself.y_width = round((self.max_y - self.min_y) / self.resolution)\n\t\tprint(\"x_width:\", self.x_width)\n\t\tprint(\"y_width:\", self.y_width)\n\n\t\t# obstacle map generation\n\t\tself.obstacle_map = [[False for _ in range(self.y_width)]\n\t\t\t\t\t\t\t for _ in range(self.x_width)]\n\t\tfor ix in range(self.x_width):\n\t\t\tx = self.calc_grid_position(ix, self.min_x)\n\t\t\tfor iy in range(self.y_width):\n\t\t\t\ty = self.calc_grid_position(iy, self.min_y)\n\t\t\t\tfor iox, ioy in zip(ox, oy):\n\t\t\t\t\td = math.hypot(iox - x, ioy - y)\n\t\t\t\t\tif d <= self.rr:\n\t\t\t\t\t\tself.obstacle_map[ix][iy] = True\n\t\t\t\t\t\tbreak\n\n\t@staticmethod\n\tdef get_motion_model():\n\t\t# dx, dy, cost\n\t\tmotion = [[1, 0, 1],\n\t\t\t\t  [0, 1, 1],\n\t\t\t\t  [-1, 0, 1],\n\t\t\t\t  [0, -1, 1],\n\t\t\t\t  [-1, -1, math.sqrt(2)],\n\t\t\t\t  [-1, 1, math.sqrt(2)],\n\t\t\t\t  [1, -1, math.sqrt(2)],\n\t\t\t\t  [1, 1, math.sqrt(2)]]\n\n\t\treturn motion\n\n", "description": "\n\t\tInitialize grid map for bfs planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t", "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():\n\tprint(__file__ + \" start!!\")\n\n\t# start and goal position\n\tsx = 10.0  # [m]\n\tsy = 10.0  # [m]\n\tgx = 50.0  # [m]\n\tgy = 50.0  # [m]\n\tgrid_size = 2.0  # [m]\n\trobot_radius = 1.0  # [m]\n\n\t# set obstacle positions\n\tox, oy = [], []\n\tfor i in range(-10, 60):\n\t\tox.append(i)\n\t\toy.append(-10.0)\n\tfor i in range(-10, 60):\n\t\tox.append(60.0)\n\t\toy.append(i)\n\tfor i in range(-10, 61):\n\t\tox.append(i)\n\t\toy.append(60.0)\n\tfor i in range(-10, 61):\n\t\tox.append(-10.0)\n\t\toy.append(i)\n\tfor i in range(-10, 40):\n\t\tox.append(20.0)\n\t\toy.append(i)\n\tfor i in range(0, 40):\n\t\tox.append(40.0)\n\t\toy.append(60.0 - i)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(ox, oy, \".k\")\n\t\tplt.plot(sx, sy, \"og\")\n\t\tplt.plot(gx, gy, \"ob\")\n\t\tplt.grid(True)\n\t\tplt.axis(\"equal\")\n\n\tbi_bfs = BidirectionalBreadthFirstSearchPlanner(\n\t\tox, oy, grid_size, robot_radius)\n\trx, ry = bi_bfs.planning(sx, sy, gx, gy)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(rx, ry, \"-r\")\n\t\tplt.pause(0.01)\n\t\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}], [{"term": "def", "name": "calculate", "data": "def calculate(factory, system, **kwargs):\n\tcalc = factory.calc(**kwargs)\n\tsystem.calc = calc\n\tsystem.get_potential_energy()\n\tcalc.get_eigenvalues()\n\treturn calc\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.collections import g2", "from ase.build import bulk, graphene_nanoribbon"]}, {"term": "def", "name": "test_h2o", "data": "def test_h2o(factory):\n\tcalc = calculate(factory,\n\t\t\t\t\t g2['H2O'],\n\t\t\t\t\t OutputFormat='xcrysden',\n\t\t\t\t\t SCFCalculateDipole=True)\n\tdipole = calc.get_dipole_moment()\n\tE = calc.get_potential_energy()\n\n\tprint('dipole', dipole)\n\tprint('energy', E)\n\n\t# XXX What's with the dipole not being correct?\n\t# XXX Investigate\n\n\tassert pytest.approx(dipole, abs=0.02) == [0, 0, -0.37]\n\tdipole_err = np.abs(dipole - [0., 0., -0.37]).max()\n\tassert dipole_err < 0.02, dipole_err\n\t#energy_err = abs(-463.5944954 - E)\n\t#assert energy_err < 0.01, energy_err\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.collections import g2", "from ase.build import bulk, graphene_nanoribbon"]}, {"term": "def", "name": "test_o2", "data": "def test_o2(factory):\n\tatoms = g2['O2']\n\tatoms.center(vacuum=2.5)\n\tcalculate(factory,\n\t\t\t  atoms,\n\t\t\t  BoxShape='parallelepiped',\n\t\t\t  SpinComponents='spin_polarized',\n\t\t\t  ExtraStates=2)\n\t#magmom = calc.get_magnetic_moment()\n\t#magmoms = calc.get_magnetic_moments()\n\t#print('magmom', magmom)\n\t#print('magmoms', magmoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.collections import g2", "from ase.build import bulk, graphene_nanoribbon"]}, {"term": "def", "name": "test_si", "data": "def test_si(factory):\n\tcalc = calculate(factory,\n\t\t\t\t\t bulk('Si'),  # , orthorhombic=True),\n\t\t\t\t\t KPointsGrid=[[4, 4, 4]],\n\t\t\t\t\t KPointsUseSymmetries=True,\n\t\t\t\t\t SmearingFunction='fermi_dirac',\n\t\t\t\t\t ExtraStates=2,\n\t\t\t\t\t Smearing='0.1 * eV',\n\t\t\t\t\t ExperimentalFeatures=True,\n\t\t\t\t\t Spacing='0.45 * Angstrom')\n\teF = calc.get_fermi_level()\n\tprint('eF', eF)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.collections import g2", "from ase.build import bulk, graphene_nanoribbon"]}], [], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["from . import get_help", "import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["from . import get_help", "import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: f\"{get}/100\"})\n\t\t\tawait e.answer(str(f\"{get}/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: f\"{get}/\"})\n\t\t\tawait e.answer(str(f\"{get}/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: f\"{get}*\"})\n\t\t\tawait e.answer(str(f\"{get}*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["from . import get_help", "import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["from . import get_help", "import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "_icon_exists", "data": "def _icon_exists(name):\n\tif name == '':\n\t\treturn False\n\n\ttheme = gtk.icon_theme_get_default()\n\tinfo = theme.lookup_icon(name, 0, 0)\n\tif info:\n\t\treturn True\n\n\treturn False\n\n", "description": null, "category": "math", "imports": ["import pygtk", "import gtk", "from mathlib import MathLib", "from sugar.graphics.palette import Palette", "from sugar.graphics.menuitem import MenuItem", "from sugar.graphics.toolbutton import ToolButton", "from sugar.graphics.toggletoolbutton import ToggleToolButton", "from sugar.graphics.style import GRID_CELL_SIZE", "import logging", "from gettext import gettext as _"]}, {"term": "class", "name": "IconToolButton", "data": "class IconToolButton(ToolButton):\n\n\tdef __init__(self, icon_name, text, cb, help_cb=None, alt_html=''):\n\t\tToolButton.__init__(self)\n\n\t\tif _icon_exists(icon_name):\n\t\t\tself.set_icon(icon_name)\n\t\telse:\n\t\t\tif alt_html == '':\n\t\t\t\talt_html = icon_name\n\n\t\t\tlabel = gtk.Label()\n\t\t\tlabel.set_markup(alt_html)\n\t\t\tlabel.show()\n\t\t\tself.set_label_widget(label)\n\n\t\tself.create_palette(text, help_cb)\n\n\t\tself.connect('clicked', cb)\n\n\tdef create_palette(self, text, help_cb):\n\t\tp = Palette(text)\n\n\t\tif help_cb is not None:\n\t\t\titem = MenuItem(_('Help'), 'action-help')\n\t\t\titem.connect('activate', help_cb)\n\t\t\titem.show()\n\t\t\tp.menu.append(item)\n\n\t\tself.set_palette(p)\n\n", "description": null, "category": "math", "imports": ["import pygtk", "import gtk", "from mathlib import MathLib", "from sugar.graphics.palette import Palette", "from sugar.graphics.menuitem import MenuItem", "from sugar.graphics.toolbutton import ToolButton", "from sugar.graphics.toggletoolbutton import ToggleToolButton", "from sugar.graphics.style import GRID_CELL_SIZE", "import logging", "from gettext import gettext as _"]}, {"term": "class", "name": "IconToggleToolButton", "data": "class IconToggleToolButton(ToggleToolButton):\n\n\tdef __init__(self, items, cb, desc):\n\t\tToggleToolButton.__init__(self)\n\t\tself.items = items\n\t\tif 'icon' in items[0] and _icon_exists(items[0]['icon']):\n\t\t\tself.set_named_icon(items[0]['icon'])\n\t\telif 'html' in items[0]:\n", "description": null, "category": "math", "imports": ["import pygtk", "import gtk", "from mathlib import MathLib", "from sugar.graphics.palette import Palette", "from sugar.graphics.menuitem import MenuItem", "from sugar.graphics.toolbutton import ToolButton", "from sugar.graphics.toggletoolbutton import ToggleToolButton", "from sugar.graphics.style import GRID_CELL_SIZE", "import logging", "from gettext import gettext as _"]}, {"term": "def", "name": "ftoggle_button", "data": "\tdef toggle_button(self, w):\n\t\tself.selected = (self.selected + 1) % len(self.items)\n\t\tbut = self.items[self.selected]\n\t\tif 'icon' in but and _icon_exists(but['icon']):\n\t\t\tself.set_named_icon(but['icon'])\n\t\telif 'html' in but:\n\t\t\t_logger.info('Setting html: %s', but['html'])\n", "description": null, "category": "math", "imports": ["import pygtk", "import gtk", "from mathlib import MathLib", "from sugar.graphics.palette import Palette", "from sugar.graphics.menuitem import MenuItem", "from sugar.graphics.toolbutton import ToolButton", "from sugar.graphics.toggletoolbutton import ToggleToolButton", "from sugar.graphics.style import GRID_CELL_SIZE", "import logging", "from gettext import gettext as _"]}, {"term": "class", "name": "TextToggleToolButton", "data": "class TextToggleToolButton(gtk.ToggleToolButton):\n\n\tdef __init__(self, items, cb, desc, index=False):\n\t\tgtk.ToggleToolButton.__init__(self)\n\t\tself.items = items\n\t\tself.set_label(items[0])\n\t\tself.selected = 0\n\t\tself.connect('clicked', self.toggle_button)\n\t\tself.callback = cb\n\t\tself.index = index\n\t\tself.set_tooltip_text(desc)\n\n\tdef toggle_button(self, w):\n\t\tself.selected = (self.selected + 1) % len(self.items)\n\t\tbut = self.items[self.selected]\n\t\tself.set_label(but)\n\t\tif self.callback is not None:\n\t\t\tif self.index:\n\t\t\t\tself.callback(self.selected)\n\t\t\telse:\n\t\t\t\tself.callback(but)\n\n", "description": null, "category": "math", "imports": ["import pygtk", "import gtk", "from mathlib import MathLib", "from sugar.graphics.palette import Palette", "from sugar.graphics.menuitem import MenuItem", "from sugar.graphics.toolbutton import ToolButton", "from sugar.graphics.toggletoolbutton import ToggleToolButton", "from sugar.graphics.style import GRID_CELL_SIZE", "import logging", "from gettext import gettext as _"]}, {"term": "class", "name": "LineSeparator", "data": "class LineSeparator(gtk.SeparatorToolItem):\n\n\tdef __init__(self):\n\t\tgtk.SeparatorToolItem.__init__(self)\n\t\tself.set_draw(True)\n\n", "description": null, "category": "math", "imports": ["import pygtk", "import gtk", "from mathlib import MathLib", "from sugar.graphics.palette import Palette", "from sugar.graphics.menuitem import MenuItem", "from sugar.graphics.toolbutton import ToolButton", "from sugar.graphics.toggletoolbutton import ToggleToolButton", "from sugar.graphics.style import GRID_CELL_SIZE", "import logging", "from gettext import gettext as _"]}, {"term": "class", "name": "EditToolbar", "data": "class EditToolbar(gtk.Toolbar):\n\n\tdef __init__(self, calc):\n\t\tgtk.Toolbar.__init__(self)\n\n\t\tcopy_tool = ToolButton('edit-copy')\n\t\tcopy_tool.set_tooltip(_('Copy'))\n\t\tcopy_tool.set_accelerator(_('c'))\n\t\tcopy_tool.connect('clicked', lambda x: calc.text_copy())\n\t\tself.insert(copy_tool, -1)\n\n\t\tmenu_item = MenuItem(_('Cut'))\n\n\t\ttry:\n\t\t\tmenu_item.set_accelerator(_('x'))\n\t\texcept AttributeError:\n\t\t\tpass\n\n\t\tmenu_item.connect('activate', lambda x: calc.text_cut())\n\t\tmenu_item.show()\n\t\tcopy_tool.get_palette().menu.append(menu_item)\n\n\t\tself.insert(IconToolButton('edit-paste', _('Paste'),\n\t\t\t\t\t\t\t\t   lambda x: calc.text_paste(),\n\t\t\t\t\t\t\t\t   alt_html='Paste'), -1)\n\n\t\tself.show_all()\n\n", "description": null, "category": "math", "imports": ["import pygtk", "import gtk", "from mathlib import MathLib", "from sugar.graphics.palette import Palette", "from sugar.graphics.menuitem import MenuItem", "from sugar.graphics.toolbutton import ToolButton", "from sugar.graphics.toggletoolbutton import ToggleToolButton", "from sugar.graphics.style import GRID_CELL_SIZE", "import logging", "from gettext import gettext as _"]}, {"term": "class", "name": "AlgebraToolbar", "data": "class AlgebraToolbar(gtk.Toolbar):\n\n\tdef __init__(self, calc):\n\t\tgtk.Toolbar.__init__(self)\n\n\t\tself.insert(IconToolButton('algebra-square', _('Square'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_OP_POST, '**2'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_TEXT, 'help(square)'),\n\t\t\t\t\t\t\t\t   alt_html='x2'), -1)\n\n\t\tself.insert(IconToolButton('algebra-sqrt', _('Square root'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_FUNCTION, 'sqrt'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_TEXT, 'help(sqrt)'),\n\t\t\t\t\t\t\t\t   alt_html='\u221ax'), -1)\n\n\t\tself.insert(IconToolButton('algebra-xinv', _('Inverse'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_OP_POST, '**-1'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_TEXT, 'help(inv)'),\n\t\t\t\t\t\t\t\t   alt_html='x-1'), -1)\n\n\t\tself.insert(LineSeparator(), -1)\n\n\t\tself.insert(IconToolButton('algebra-exp', _('e to the power x'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_FUNCTION, 'exp'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_TEXT, 'help(exp)'),\n\t\t\t\t\t\t\t\t   alt_html='ex'), -1)\n\n\t\tself.insert(IconToolButton('algebra-xpowy', _('x to the power y'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_FUNCTION, 'pow'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_TEXT, 'help(pow)'),\n\t\t\t\t\t\t\t\t   alt_html='xy'), -1)\n\n\t\tself.insert(IconToolButton('algebra-ln', _('Natural logarithm'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_FUNCTION, 'ln'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_TEXT, 'help(ln)')), -1)\n\n\t\tself.insert(LineSeparator(), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'algebra-fac', _('Factorial'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'factorial'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT,\n\t\t\t\t\t\t\t\t\t\t  'help(factorial)')), -1)\n\n\t\tself.show_all()\n\n", "description": null, "category": "math", "imports": ["import pygtk", "import gtk", "from mathlib import MathLib", "from sugar.graphics.palette import Palette", "from sugar.graphics.menuitem import MenuItem", "from sugar.graphics.toolbutton import ToolButton", "from sugar.graphics.toggletoolbutton import ToggleToolButton", "from sugar.graphics.style import GRID_CELL_SIZE", "import logging", "from gettext import gettext as _"]}, {"term": "class", "name": "TrigonometryToolbar", "data": "class TrigonometryToolbar(gtk.Toolbar):\n\n\tdef __init__(self, calc):\n\t\tgtk.Toolbar.__init__(self)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'trigonometry-sin', _('Sine'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'sin'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(sin)')), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'trigonometry-cos', _('Cosine'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'cos'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(cos)')), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'trigonometry-tan', _('Tangent'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'tan'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(tan)')), -1)\n\n\t\tself.insert(LineSeparator(), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'trigonometry-asin', _('Arc sine'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'asin'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(asin)')), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'trigonometry-acos', _('Arc cosine'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'acos'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(acos)')), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'trigonometry-atan', _('Arc tangent'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'atan'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(atan)')), -1)\n\n\t\tself.insert(LineSeparator(), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'trigonometry-sinh', _('Hyperbolic sine'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'sinh'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(sinh)')), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'trigonometry-cosh', _('Hyperbolic cosine'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'cosh'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(cosh)')), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'trigonometry-tanh', _('Hyperbolic tangent'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'tanh'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(tanh)')), -1)\n\n\t\tself.show_all()\n\n", "description": null, "category": "math", "imports": ["import pygtk", "import gtk", "from mathlib import MathLib", "from sugar.graphics.palette import Palette", "from sugar.graphics.menuitem import MenuItem", "from sugar.graphics.toolbutton import ToolButton", "from sugar.graphics.toggletoolbutton import ToggleToolButton", "from sugar.graphics.style import GRID_CELL_SIZE", "import logging", "from gettext import gettext as _"]}, {"term": "class", "name": "BooleanToolbar", "data": "class BooleanToolbar(gtk.Toolbar):\n\n\tdef __init__(self, calc):\n\t\tgtk.Toolbar.__init__(self)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'boolean-and', _('Logical and'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_OP_POST, '&'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(And)')), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'boolean-or', _('Logical or'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_OP_POST, '|'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(Or)')), -1)\n", "description": null, "category": "math", "imports": ["import pygtk", "import gtk", "from mathlib import MathLib", "from sugar.graphics.palette import Palette", "from sugar.graphics.menuitem import MenuItem", "from sugar.graphics.toolbutton import ToolButton", "from sugar.graphics.toggletoolbutton import ToggleToolButton", "from sugar.graphics.style import GRID_CELL_SIZE", "import logging", "from gettext import gettext as _"]}, {"term": "class", "name": "MiscToolbar", "data": "class MiscToolbar(gtk.Toolbar):\n\n\tdef __init__(self, calc, target_toolbar=None):\n\t\tself._target_toolbar = target_toolbar\n\n\t\tgtk.Toolbar.__init__(self)\n\n\t\tself.insert(IconToolButton('constants-pi', _('Pi'),\n\t\t\t\t\t\t\t\t   lambda x: calc.button_pressed(\n\t\t\t\t\t\t\t\t\t   calc.TYPE_TEXT, 'pi'),\n\t\t\t\t\t\t\t\t   alt_html='\u03c0'), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'constants-e', _('e'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'e')), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'constants-eulersconstant', _('\u03b3'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT,\n\t\t\t\t\t\t\t\t\t\t  '0.577215664901533')), -1)\n\n\t\tself.insert(IconToolButton(\n\t\t\t'constants-goldenratio', _('\u03c6'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT,\n\t\t\t\t\t\t\t\t\t\t  '1.618033988749895')), -1)\n\n\t\tself._line_separator1 = LineSeparator()\n\t\tself._line_separator2 = LineSeparator()\n\n\t\tself._plot_button = IconToolButton(\n\t\t\t'plot', _('Plot'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_FUNCTION, 'plot'),\n\t\t\tlambda x: calc.button_pressed(calc.TYPE_TEXT, 'help(plot)'))\n\n\t\tel = [\n\t\t\t{'icon': 'format-deg', 'desc': _('Degrees'), 'html': 'deg'},\n\t\t\t{'icon': 'format-rad', 'desc': _('Radians'), 'html': 'rad'},\n\t\t]\n\t\tself._angle_button = IconToggleToolButton(\n\t\t\tel,\n\t\t\tlambda x: self.update_angle_type(x, calc),\n\t\t\t_('Degrees / Radians'))\n\t\tself.update_angle_type('deg', calc)\n\n\t\tel = [\n\t\t\t{'icon': 'format-sci', 'html': 'sci'},\n\t\t\t{'icon': 'format-exp', 'html': 'exp'},\n\t\t]\n\t\tself._format_button = IconToggleToolButton(\n\t\t\tel,\n\t\t\tlambda x: self.update_format_type(x, calc),\n\t\t\t_('Exponent / Scientific notation'))\n\n\t\tel = [\n\t\t\t{'icon': 'digits-9', 'html': '9'},\n\t\t\t{'icon': 'digits-12', 'html': '12'},\n\t\t\t{'icon': 'digits-15', 'html': '15'},\n\t\t\t{'icon': 'digits-6', 'html': '6'},\n\t\t]\n\t\tself._digits_button = IconToggleToolButton(\n\t\t\tel,\n\t\t\tlambda x: self.update_digits(x, calc),\n\t\t\t_('Number of shown digits'))\n\n\t\tel = [\n\t\t\t{'icon': 'base-10', 'html': '10'},\n\t\t\t{'icon': 'base-2', 'html': '2'},\n\t\t\t{'icon': 'base-16', 'html': '16'},\n\t\t\t{'icon': 'base-8', 'html': '8'}\n\t\t]\n\n\t\tself._base_button = IconToggleToolButton(\n\t\t\tel,\n\t\t\tlambda x: self.update_int_base(x, calc),\n\t\t\t_('Integer formatting base'))\n\n\t\tself.update_layout()\n\n\t\tself.show_all()\n\n\tdef update_layout(self):\n\t\tif gtk.gdk.screen_width() < 14 * GRID_CELL_SIZE or \\\n\t\t\t\tself._target_toolbar is None:\n\t\t\ttarget_toolbar = self\n\t\t\tif self._target_toolbar is not None:\n\t\t\t\tself._remove_buttons(self._target_toolbar)\n\t\telse:\n\t\t\ttarget_toolbar = self._target_toolbar\n\t\t\tself._remove_buttons(self)\n\n\t\ttarget_toolbar.insert(self._line_separator1, -1)\n\n\t\ttarget_toolbar.insert(self._plot_button, -1)\n\n\t\ttarget_toolbar.insert(self._line_separator2, -1)\n\n\t\ttarget_toolbar.insert(self._angle_button, -1)\n\t\ttarget_toolbar.insert(self._format_button, -1)\n\t\ttarget_toolbar.insert(self._digits_button, -1)\n\t\ttarget_toolbar.insert(self._base_button, -1)\n\n\tdef _remove_buttons(self, toolbar):\n\t\tfor item in [self._plot_button, self._line_separator1,\n\t\t\t\t\t self._line_separator2, self._angle_button,\n\t\t\t\t\t self._format_button, self._digits_button,\n\t\t\t\t\t self._base_button]:\n\t\t\ttoolbar.remove(item)\n\n\tdef update_angle_type(self, text, calc):\n\t\tvar = calc.parser.get_var('angle_scaling')\n\t\tif var is None:\n\t\t\t_logger.warning('Variable angle_scaling not defined.')\n\t\t\treturn\n\n\t\tif text == 'deg':\n\t\t\tvar.value = MathLib.ANGLE_DEG\n\t\telif text == 'rad':\n\t\t\tvar.value = MathLib.ANGLE_RAD\n\t\t_logger.debug('Angle scaling: %s', var.value)\n\n\tdef update_format_type(self, text, calc):\n\t\tif text == 'exp':\n\t\t\tcalc.ml.set_format_type(MathLib.FORMAT_EXPONENT)\n\t\telif text == 'sci':\n\t\t\tcalc.ml.set_format_type(MathLib.FORMAT_SCIENTIFIC)\n\t\t_logger.debug('Format type: %s', calc.ml.format_type)\n\n\tdef update_digits(self, text, calc):\n\t\tcalc.ml.set_digit_limit(int(text))\n\t\t_logger.debug('Digit limit: %s', calc.ml.digit_limit)\n\n\tdef update_int_base(self, text, calc):\n\t\tcalc.ml.set_integer_base(int(text))\n\t\t_logger.debug('Integer base: %s', calc.ml.integer_base)\n", "description": null, "category": "math", "imports": ["import pygtk", "import gtk", "from mathlib import MathLib", "from sugar.graphics.palette import Palette", "from sugar.graphics.menuitem import MenuItem", "from sugar.graphics.toolbutton import ToolButton", "from sugar.graphics.toggletoolbutton import ToggleToolButton", "from sugar.graphics.style import GRID_CELL_SIZE", "import logging", "from gettext import gettext as _"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [], [], [], [], [], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "class", "name": "TestCalc", "data": "class TestCalc(unittest.TestCase):\n\tdef test_add(self):\n\t\t# For example\n\t\t# result = calc.add(6,1)\n\t\t# self.assertEqual(result, 7)\n\t\tself.assertEqual(calc.add(-1,2), 1)\n\t\tself.assertEqual(calc.add(-1,-2), -3)\n\t\tself.assertEqual(calc.add(0,0), 0)\n\n\tdef test_sub(self):\n\t\tself.assertEqual(calc.sub(-1,2), -3)\n\t\tself.assertEqual(calc.sub(-1,-2), 1)\n\t\tself.assertEqual(calc.sub(0,0), 0)\n\n\tdef test_multi(self):\n\t\tself.assertEqual(calc.multi(-1,2), -2)\n\t\tself.assertEqual(calc.multi(-1,-2), 2)\n\t\tself.assertEqual(calc.multi(0,0), 0)\n\n\tdef test_divide(self):\n\t\tself.assertEqual(calc.divide(-1,2), -0.5)\n\t\tself.assertEqual(calc.divide(-1,-2), 0.5)\n\t\t\n\t\t# self.assertRaises(ValueError, calc.divide, 1, 0)\n\t\twith self.assertRaises(ValueError):\n\t\t\tcalc.divide(1, 0)\n", "description": null, "category": "math", "imports": ["import  unittest", "import calc"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "CalcListener", "data": "class CalcListener(ParseTreeListener):\n\n\t# Enter a parse tree produced by CalcParser#parse.\n\tdef enterParse(self, ctx:CalcParser.ParseContext):\n\t\tpass\n\n\t# Exit a parse tree produced by CalcParser#parse.\n\tdef exitParse(self, ctx:CalcParser.ParseContext):\n\t\tpass\n\n\n\t# Enter a parse tree produced by CalcParser#EquationExpression.\n\tdef enterEquationExpression(self, ctx:CalcParser.EquationExpressionContext):\n\t\tpass\n\n\t# Exit a parse tree produced by CalcParser#EquationExpression.\n\tdef exitEquationExpression(self, ctx:CalcParser.EquationExpressionContext):\n\t\tpass\n\n\n\t# Enter a parse tree produced by CalcParser#assignment.\n\tdef enterAssignment(self, ctx:CalcParser.AssignmentContext):\n\t\tpass\n\n\t# Exit a parse tree produced by CalcParser#assignment.\n\tdef exitAssignment(self, ctx:CalcParser.AssignmentContext):\n\t\tpass\n\n\n\t# Enter a parse tree produced by CalcParser#comment.\n\tdef enterComment(self, ctx:CalcParser.CommentContext):\n\t\tpass\n\n\t# Exit a parse tree produced by CalcParser#comment.\n\tdef exitComment(self, ctx:CalcParser.CommentContext):\n\t\tpass\n\n\n\t# Enter a parse tree produced by CalcParser#ArithmeticExpressionPow.\n\tdef enterArithmeticExpressionPow(self, ctx:CalcParser.ArithmeticExpressionPowContext):\n\t\tpass\n\n\t# Exit a parse tree produced by CalcParser#ArithmeticExpressionPow.\n\tdef exitArithmeticExpressionPow(self, ctx:CalcParser.ArithmeticExpressionPowContext):\n\t\tpass\n\n\n\t# Enter a parse tree produced by CalcParser#ArithmeticExpressionParens.\n\tdef enterArithmeticExpressionParens(self, ctx:CalcParser.ArithmeticExpressionParensContext):\n\t\tpass\n\n\t# Exit a parse tree produced by CalcParser#ArithmeticExpressionParens.\n\tdef exitArithmeticExpressionParens(self, ctx:CalcParser.ArithmeticExpressionParensContext):\n\t\tpass\n\n\n\t# Enter a parse tree produced by CalcParser#ArithmeticExpressionNumericEntity.\n\tdef enterArithmeticExpressionNumericEntity(self, ctx:CalcParser.ArithmeticExpressionNumericEntityContext):\n\t\tpass\n\n\t# Exit a parse tree produced by CalcParser#ArithmeticExpressionNumericEntity.\n\tdef exitArithmeticExpressionNumericEntity(self, ctx:CalcParser.ArithmeticExpressionNumericEntityContext):\n\t\tpass\n\n\n\t# Enter a parse tree produced by CalcParser#ArithmeticExpressionMultDiv.\n\tdef enterArithmeticExpressionMultDiv(self, ctx:CalcParser.ArithmeticExpressionMultDivContext):\n\t\tpass\n\n\t# Exit a parse tree produced by CalcParser#ArithmeticExpressionMultDiv.\n\tdef exitArithmeticExpressionMultDiv(self, ctx:CalcParser.ArithmeticExpressionMultDivContext):\n\t\tpass\n\n\n\t# Enter a parse tree produced by CalcParser#ArithmeticExpressionPlusMinus.\n\tdef enterArithmeticExpressionPlusMinus(self, ctx:CalcParser.ArithmeticExpressionPlusMinusContext):\n\t\tpass\n\n\t# Exit a parse tree produced by CalcParser#ArithmeticExpressionPlusMinus.\n\tdef exitArithmeticExpressionPlusMinus(self, ctx:CalcParser.ArithmeticExpressionPlusMinusContext):\n\t\tpass\n\n\n\t# Enter a parse tree produced by CalcParser#NumericConst.\n\tdef enterNumericConst(self, ctx:CalcParser.NumericConstContext):\n\t\tpass\n\n\t# Exit a parse tree produced by CalcParser#NumericConst.\n\tdef exitNumericConst(self, ctx:CalcParser.NumericConstContext):\n\t\tpass\n\n\n\t# Enter a parse tree produced by CalcParser#NumericVariable.\n\tdef enterNumericVariable(self, ctx:CalcParser.NumericVariableContext):\n\t\tpass\n\n\t# Exit a parse tree produced by CalcParser#NumericVariable.\n\tdef exitNumericVariable(self, ctx:CalcParser.NumericVariableContext):\n\t\tpass\n\n\n", "description": null, "category": "math", "imports": ["from antlr4 import *", "\tfrom .CalcParser import CalcParser", "\tfrom CalcParser import CalcParser"]}], [{"term": "def", "name": "add_digit", "data": "def add_digit(digit):\r\n\tvalue = calc.get()+ str(digit)\r\n\tcalc.delete(0, tk.END)\r\n\tcalc.insert(0, value)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "add_operation", "data": "def add_operation(operation):\r\n\tvalue = calc.get()\r\n\tif value[-1] in '-+/*%':\r\n\t\tvalue = value[:-1]\r\n\telif '+' in value or '-' in value or '/' in value or '*' in value:\r\n\t\tcalculate()\r\n\t\tvalue = calc.get()\r\n\tcalc.delete(0, tk.END)\r\n\tcalc.insert(0, value+operation)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "calculate", "data": "def calculate():\r\n\tvalue = calc.get()\r\n\tif value[-1] in '+-*/%':\r\n\t\tvalue = value+value[:-1]\r\n\tcalc.delete(0, tk.END)\r\n\tcalc.insert(0, eval(value))\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "clear", "data": "def clear ():\r\n\tcalc.delete(0, tk.END)\r\n\tcalc.insert(0,' ')\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "Cosinus", "data": "def Cosinus():\r\n\tvalue=calc.get()\r\n\tx=float(value)\r\n\tvalue=math.cos(x)\r\n\tcalc.delete(0,tk.END)\r\n\tcalc.insert(0,value)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "Sinus", "data": "def Sinus():\r\n\tvalue=calc.get()\r\n\tx=float(value)\r\n\tvalue=math.sin(x)\r\n\tcalc.delete(0,tk.END)\r\n\tcalc.insert(0,value)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "tan", "data": "def tan():\r\n\tvalue=calc.get()\r\n\tx=float(value)\r\n\tvalue=math.tan(x)\r\n\tcalc.delete(0,tk.END)\r\n\tcalc.insert(0,value)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "ctg", "data": "def ctg():\r\n\tvalue=calc.get()\r\n\tx=float(value)\r\n\tvalue=math.cos(x)/math.sin(x)\r\n\tcalc.delete(0,tk.END)\r\n\tcalc.insert(0,value)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "log", "data": "def log():\r\n\tvalue=calc.get()\r\n\tx=float(value)\r\n\tvalue=math.log2(x)\r\n\tcalc.delete(0,tk.END)\r\n\tcalc.insert(0,value)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "ln", "data": "def ln():\r\n\tvalue=calc.get()\r\n\tx=float(value)\r\n\tvalue=math.log10(x)\r\n\tcalc.delete(0,tk.END)\r\n\tcalc.insert(0,value)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "DK", "data": "def DK():\r\n\tvalue = calc.get()\r\n\tn = ''\r\n\tx=int(value)\r\n\twhile x > 0 :\r\n\t\t\ty = str(x % 2)\r\n\t\t\tn = y + n\r\n\t\t\tx = int(x / 2)\t\r\n\tcalc.delete(0,tk.END)\r\n\tcalc.insert(0,n)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "operation_button", "data": "def operation_button(operation):\r\n\treturn tk.Button(text=operation, bd=5, font=('Arial, 13'), fg='red',\r\n\t\t\t\t\t command=lambda: add_operation(operation))\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "calc_button", "data": "def calc_button(operation):\r\n\treturn tk.Button(text=operation, bd=5, font=('Arial, 13'), fg='red',\r\n\t\t\t\t\tcommand=calculate)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "clear_button", "data": "def clear_button(operation):\r\n\treturn tk.Button(text=operation, bd=5, font=('Arial, 13'), fg='red',\r\n\t\t\t\t\tcommand=clear)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "cos_button", "data": "def cos_button(operation):\r\n\treturn tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n\t\t\t\t\t command=Cosinus)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "sin_button", "data": "def sin_button(operation):\r\n\treturn tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n\t\t\t\t\t command=Sinus)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "tan_button", "data": "def tan_button(operation):\r\n\treturn tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n\t\t\t\t\t command=tan)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "ctg_button", "data": "def ctg_button(operation):\r\n\treturn tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n\t\t\t\t\t command=ctg)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "log_button", "data": "def log_button(operation):\r\n\treturn tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n\t\t\t\t\t command=log)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "ln_button", "data": "def ln_button(operation):\r\n\treturn tk.Button(text=operation, bd=5, font=('Arial,13'), fg='red',\r\n\t\t\t\t\t command=ln)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}, {"term": "def", "name": "dkod_button", "data": "def dkod_button(operation):\r\n\treturn tk.Button(text=operation, bd=5, font=('Arial,13'), fg='#008000',\r\n\t\t\t\t\t command=DK)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "import math\r"]}], [{"term": "def", "name": "test_read_gpaw_out", "data": "def test_read_gpaw_out(datadir):\n\t\"\"\"Test reading of gpaw text output\"\"\"\n\tfrom ase import io\n\n\t# read input\n\n\toutput_file_name = datadir / 'gpaw_expected_text_output'\n\tatoms = io.read(output_file_name)\n\n\t# test calculator\n\n\tcalc = atoms.calc\n\tassert isinstance(calc, SinglePointDFTCalculator)\n\tassert calc.name == 'vdwtkatchenko09prl'\n\tassert calc.parameters['calculator'] == 'gpaw'\n\n\tfor contribution in [\n\t\t\t'kinetic', 'potential', 'external', 'xc',\n\t\t\t'entropy (-st)', 'local']:\n\t\tassert contribution in calc.energy_contributions\n\n", "description": "Test reading of gpaw text output", "category": "math", "imports": ["from ase.calculators.singlepoint import SinglePointDFTCalculator", "\tfrom ase import io", "\tfrom ase.build import molecule", "\tfrom ase.calculators.vdwcorrection import vdWTkatchenko09prl", "\tfrom gpaw import GPAW, FermiDirac", "\tfrom gpaw.cluster import Cluster", "\tfrom gpaw.analyse.vdwradii import vdWradii", "\tfrom gpaw.analyse.hirshfeld import HirshfeldDensity, HirshfeldPartitioning"]}], [{"term": "class", "name": "classConverter:", "data": "class Converter:\n\tdef __init__(self):\n\n\t\t# formatting variables\n\t\tbackground_colour = \"light blue\"\n\n\t\t# Initialise list to hold calculation history\n\t\t# In later versions list will be populated with user calculations\n\t\tself.all_calc_list = [\"0 degrees F is -17.8 degrees C\",\n\t\t\t\t\t\t\t  \"0 degrees C is 32 degrees F\",\n\t\t\t\t\t\t\t  \"100 degrees F is 37.8 degrees C\"]\n\t\t# self_all_calc_list = []\n\n\t\t# Converter Main Screen GUI\n\t\tself.converter_frame = Frame(width=300, height=300,\n\t\t\t\t\t\t\t\t\t bg=background_colour, pady=10)\n\t\tself.converter_frame.grid()\n\n\t\t# Temperature Conversion Heading (row 0)\n\t\tself.temp_converter_label = Label(self.converter_frame,\n\t\t\t\t\t\t\t\t\t\t  text=\"Temperature Converter\",\n\t\t\t\t\t\t\t\t\t\t  font=(\"Arial\", \"16\", \"bold\"),\n\t\t\t\t\t\t\t\t\t\t  bg=background_colour,\n\t\t\t\t\t\t\t\t\t\t  padx=10, pady=10)\n\t\tself.temp_converter_label.grid(row=0)\n\n\t\t# history Button (row 1)\n\t\tself.history_button = Button(self.converter_frame, text=\"History\",\n\t\t\t\t\t\t\t\t\t font=(\"Arial\", \"14\"), padx=10, pady=10,\n\t\t\t\t\t\t\t\t\t command=lambda: self.history\n\t\t\t\t\t\t\t\t\t (self.all_calc_list))\n\t\tself.history_button.grid(row=1)\n\n\t\tif len(self.all_calc_list) == 0:\n\t\t\tself.history_button.config(state=DISABLED)\n\n\tdef history(self, calc_history):\n\t\tHistory(self, calc_history)\n\n", "description": null, "category": "math", "imports": ["from tkinter import *", "from functools import partial  # To prevent unwanted windows", "import re"]}, {"term": "class", "name": "classHistory:", "data": "class History:\n\tdef __init__(self, partner, calc_history):\n\t\tbackground = \"#f5e7b5\"  # beige\n\n\t\t# disable history button\n\t\tpartner.history_button.config(state=DISABLED)\n\n\t\t# sets up child window (ie. history box)\n\t\tself.history_box = Toplevel()\n\n\t\t# if cross pressed, closes history and 'releases' history button\n\t\tself.history_box.protocol('WM_DELETE_WINDOW',\n\t\t\t\t\t\t\t\t  partial(self.close_history, partner))\n\n\t\t# set up GUI frame\n\t\tself.history_frame = Frame(self.history_box, width=300, bg=background)\n\t\tself.history_frame.grid()\n\n\t\t# set up history heading (row 0)\n\t\tself.hist_heading = Label(self.history_frame, text=\"Calculate History\",\n\t\t\t\t\t\t\t\t  font=\"Arial 18 bold\", bg=background)\n\t\tself.hist_heading.grid(row=0)\n\n\t\t# history text (label, row 1)\n\t\tself.history_text = Label(self.history_frame,\n\t\t\t\t\t\t\t\t  text=\"Here are your most recent \"\n\t\t\t\t\t\t\t\t\t   \"calculations. Please use the export \"\n\t\t\t\t\t\t\t\t\t   \"button to create a text file of all \"\n\t\t\t\t\t\t\t\t\t   \"your calculations for this session\",\n\t\t\t\t\t\t\t\t  font=\"Arial 10 italic\", wrap=250,\n\t\t\t\t\t\t\t\t  justify=LEFT, width=40, bg=background,\n\t\t\t\t\t\t\t\t  padx=10, pady=10)\n\t\tself.history_text.grid(row=1)\n\n\t\t# History output goes here (row 2)\n\t\thistory_string = \"\"\n\t\tif len(calc_history) >= 7:\n\t\t\tfor item in range(0, 7):\n\t\t\t\thistory_string += calc_history[len(calc_history)-item-1]+\"\\n\"\n\n\t\telse:\n\t\t\tfor item in calc_history:\n\t\t\t\thistory_string += calc_history[len(calc_history) -\n\t\t\t\t\t\t\t\t\t\t\t   calc_history.index(item)-1]+\"\\n\"\n\t\t\t\tself.history_text.config(text=\"Here is your calculation \"\n\t\t\t\t\t\t\t\t\t\t\t  \"history. You can use the \"\n\t\t\t\t\t\t\t\t\t\t\t  \"export button to save this \"\n\t\t\t\t\t\t\t\t\t\t\t  \"data to a text file if desired\")\n\t\t# Label to display calculation history to user\n\t\tself.calc_label = Label(self.history_frame, text=history_string,\n\t\t\t\t\t\t\t\tbg=background, font=\"Arial 12\", justify=LEFT)\n\t\tself.calc_label.grid(row=2)\n\n\t\t# Export / Dismiss button frame\n\t\tself.export_dismiss_frame = Frame(self.history_frame)\n\t\tself.export_dismiss_frame.grid(row=3, pady=10)\n\n\t\t# Export Button\n\t\tself.export_button = Button(self.export_dismiss_frame, text=\"Export\",\n\t\t\t\t\t\t\t\t\tfont=\"Arial 12 bold\",\n\t\t\t\t\t\t\t\t\tcommand=lambda: self.export(calc_history))\n\t\tself.export_button.grid(row=0, column=0)\n\n\t\t# Dismiss Button\n\t\tself.dismiss_btn = Button(self.export_dismiss_frame, text=\"Dismiss\",\n\t\t\t\t\t\t\t\t  font=\"Arial 12 bold\",\n\t\t\t\t\t\t\t\t  command=partial(self.close_history, partner))\n\t\tself.dismiss_btn.grid(row=0, column=1)\n\n\tdef close_history(self, partner):\n\t\t# Put history button back to normal...\n\t\tpartner.history_button.config(state=NORMAL)\n\t\tself.history_box.destroy()\n\n\tdef export(self, calc_history):\n\t\tExport(self, calc_history)\n\n", "description": null, "category": "math", "imports": ["from tkinter import *", "from functools import partial  # To prevent unwanted windows", "import re"]}, {"term": "class", "name": "classExport:", "data": "class Export:\n\tdef __init__(self, partner, calc_history):\n\t\tprint(calc_history)  # for testing purposes\n\n\t\tbackground = \"#f5e7b5\"  # beige\n\n\t\t# disable export button\n\t\tpartner.export_button.config(state=DISABLED)\n\n\t\t# sets up child window (ie. export box)\n\t\tself.export_box = Toplevel()\n\n\t\t# if cross pressed, closes export and 'releases' export button\n\t\tself.export_box.protocol('WM_DELETE_WINDOW', partial(self.close_export,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t partner))\n\n\t\t# set up GUI frame\n\t\tself.export_frame = Frame(self.export_box, width=300, bg=background)\n\t\tself.export_frame.grid()\n\n\t\t# set up export heading (row 0)\n\t\tself.export_heading = Label(self.export_frame,\n\t\t\t\t\t\t\t\t\ttext=\"Export instructions\",\n\t\t\t\t\t\t\t\t\tfont=\"Arial 10 bold\", bg=background)\n\t\tself.export_heading.grid(row=0)\n\n\t\t# Export text (label, row 1)\n\t\tself.export_text = Label(self.export_frame,\n\t\t\t\t\t\t\t\t text=\"Enter a filename in the box below and \"\n\t\t\t\t\t\t\t\t\t  \"press the Save button to save your \"\n\t\t\t\t\t\t\t\t\t  \"calculation history to a text file.\",\n\t\t\t\t\t\t\t\t justify=CENTER, width=40, bg=background,\n\t\t\t\t\t\t\t\t wrap=250)\n\t\tself.export_text.grid(row=1)\n\n\t\t# Warning text (label, row 2)\n\t\tself.export_text = Label(self.export_frame,\n\t\t\t\t\t\t\t\t text=\"If the filename you enter below \"\n\t\t\t\t\t\t\t\t\t  \"already exists, it's contents will be \"\n\t\t\t\t\t\t\t\t\t  \"replaced with your calculation history\",\n\t\t\t\t\t\t\t\t justify=LEFT, bg=\"#ebc091\",  # orange\n\t\t\t\t\t\t\t\t font=\"Arial 10 italic\", fg=\"maroon\",\n\t\t\t\t\t\t\t\t wrap=225, padx=10, pady=5)\n\t\tself.export_text.grid(row=2, pady=10)\n\n\t\t# Filename entry box (row 3)\n\t\tself.filename_entry = Entry(self.export_frame, width=20,\n\t\t\t\t\t\t\t\t\tfont=\"Arial 14 bold\", justify=CENTER)\n\t\tself.filename_entry.grid(row=3)\n\n\t\t# Error Message labels (row 4)\n\t\tself.save_error_label = Label(self.export_frame, text=\"\", fg=\"maroon\",\n\t\t\t\t\t\t\t\t\t  bg=background)\n\t\tself.save_error_label.grid(row=4)\n\n\t\t# Save / Cancel Frame (row 4)\n\t\tself.save_cancel_frame = Frame(self.export_frame)\n\t\tself.save_cancel_frame.grid(row=5, pady=10)\n\n\t\t# Save and Cancel Button (row 0 of save_cancel_frame)\n\t\tself.save_button = Button(self.save_cancel_frame, text=\"Save\",\n\t\t\t\t\t\t\t\t  command=partial(lambda: self.save_history\n\t\t\t\t\t\t\t\t  (partner, calc_history)))\n\t\tself.save_button.grid(row=0, column=0)\n\n\t\tself.cancel_button = Button(self.save_cancel_frame, text=\"Cancel\",\n\t\t\t\t\t\t\t\t\tcommand=partial(self.close_export,\n\t\t\t\t\t\t\t\t\t\t\t\t\tpartner))\n\t\tself.cancel_button.grid(row=0, column=1)\n\n\tdef save_history(self, partner, calc_history):\n\t\t# Regular Expression to check filename can be upper or lower case\n\t\t# letters, numbers or underscore\n\t\tvalid_char = \"[A-Za-z0-9_]\"\n\t\thas_error = \"no\"\n\n\t\tfilename = self.filename_entry.get()\n\t\tprint(filename)\n\n\t\tfor letter in filename:\n\t\t\tif re.match(valid_char, letter):\n\t\t\t\tcontinue  # If the letter is valid, goes back and checks next\n\n\t\t\telif letter == \" \":  # Otherwise, find problem\n\t\t\t\terror_type = \"(no spaces allowed)\"\n\t\t\telse:\n\t\t\t\terror_type = f\"(no {letter}'s allowed)\"\n\t\t\thas_error = \"yes\"\n\n\t\tif filename == \"\":\n\t\t\terror_type = \"can't be blank\"\n\t\t\thas_error = \"yes\"\n\n\t\tif has_error == \"yes\":\n\t\t\t# Display error message\n\t\t\tself.save_error_label.config(text=f\"Invalid filename - \"\n\t\t\t\t\t\t\t\t\t\t\t  f\"{error_type}\")\n\t\t\t# Change entry box background to orange\n\t\t\tself.filename_entry.config(bg=\"#ebc091\")\n\t\t\tprint()\n\t\telse:\n\t\t\t# If there are no errors, generate text and file and then close\n\t\t\t# dialogue, Add .txt suffix\n\t\t\tfilename = filename + \".txt\"\n\n\t\t\t# Create file to hole data\n\t\t\tf = open(filename, \"w+\")\n\n\t\t\tfor item in calc_history:\n\t\t\t\tf.write(item + \"\\n\")\n\n\t\t\t# close file\n\t\t\tf.close()\n\n\t\t\t# Close dialogue\n\t\t\tself.close_export(partner)\n\n\tdef close_export(self, partner):\n\t\t# Put export button back to normal...\n\t\tpartner.export_button.config(state=NORMAL)\n\t\tself.export_box.destroy()\n\n", "description": null, "category": "math", "imports": ["from tkinter import *", "from functools import partial  # To prevent unwanted windows", "import re"]}], [{"term": "class", "name": "classwalls:\r", "data": "class walls:\r\n\tdef __init__(self, wallsArr):\r\n\t\tself.wallCtr = 0\r\n\t\tself.wallsArr = wallsArr\r\n\t\tself.spriteArr = []\r\n\t\tself.wallHitboxArr = []\r\n\r\n\t\tself.wallThicc = 1\r\n\r\n\t\tself.labelBatch = pyglet.graphics.Batch()\r\n\t\tself.inRange = False\r\n\r\n\t\tself.dotBatch = pyglet.graphics.Batch()\r\n\r\n\t\timage = pyglet.image.load('Res/sprites/dot.png')\r\n\t\tself.dot1 = pyglet.sprite.Sprite(image, x=0, y = 0, batch = self.dotBatch)\r\n\t\tself.dot2 = pyglet.sprite.Sprite(image, x=0, y = 0, batch = self.dotBatch)\r\n\t\tself.dot3 = pyglet.sprite.Sprite(image, x=0, y = 0, batch = self.dotBatch)\r\n\t\tself.dot4 = pyglet.sprite.Sprite(image, x=0, y = 0, batch = self.dotBatch)\r\n\r\n\t\tself.collisionDot = pyglet.sprite.Sprite(image, x=0, y =0, batch = self.dotBatch)\r\n\r\n\t\tself.wallBatch = pyglet.graphics.Batch()\r\n\r\n\t\tfor wall in wallsArr:\r\n\t\t\t\r\n\t\t\tprint(\"wall \" + str(self.wallCtr))\r\n\t\t\timage = \"wall\" + str(self.wallCtr) + \".png\"\r\n\t\t\timage = pyglet.image.load('Res/sprites/' + image)\r\n\t\t\tsprite = pyglet.sprite.Sprite(image, x=0, y = 0, batch = self.wallBatch)\r\n\t\t\tself.spriteArr.append(sprite)\r\n\t\t\tself.calcWallHitbox(wall)\r\n\r\n\t\t\tself.wallCtr += 1\r\n\r\n\t\tfor wallHitbox in self.wallHitboxArr:\r\n\t\t\twallHitbox.updateEdges()\r\n\t\t\tprint(wallHitbox.leftMostx)\r\n\t\t\tprint(wallHitbox.rightMostx)\r\n\t\t\tprint(wallHitbox.topMosty)\r\n\t\t\tprint(wallHitbox.botMosty)\r\n\t\t\t\r\n\r\n\tdef draw(self):\r\n\t\tself.wallBatch.draw()\r\n\t\tself.dotBatch.draw()\r\n\t\tself.labelBatch.draw()\r\n\r\n\tdef checkCollision(self, hitboxAdd):\r\n\t\tctr = 0\r\n\t\tfor wall in self.wallHitboxArr:\r\n\t\t\tif wall.checkCollision(hitboxAdd):\r\n\t\t\t\treturn True\r\n\t\t\telse:\r\n\t\t\t\tctr += 1\r\n\t\t\t\tif ctr == self.wallCtr:\r\n\t\t\t\t\treturn False\r\n\t\t\t\t\r\n\r\n\tdef calcWallHitbox(self, wall):\r\n\t\tthiccness = int(self.wallThicc / 2)\r\n\t\tif wall[0][0] <= wall[1][0]:\r\n\t\t\tprint(\"1\")\r\n\t\t\tleftMostx = wall[0][0]\r\n\t\t\trightMostx = wall[1][0]\r\n\t\telse:\r\n\t\t\tprint(\"2\")\r\n\t\t\tleftMostx = wall[1][0]\r\n\t\t\trightMostx = wall[0][0]\r\n\t\tif wall[0][1] >= wall[1][1]:\r\n\t\t\tprint(\"3\")\r\n\t\t\ttopMosty = wall[1][1]\r\n\t\t\tbotMosty = wall[0][1]\r\n\t\telse:\r\n\t\t\tprint(\"4\")\r\n\t\t\ttopMosty = wall[0][1]\r\n\t\t\tbotMosty = wall[1][1]\r\n\r\n\t\tthiccCalc = ((topMosty - botMosty) / (rightMostx - leftMostx)) * thiccness\r\n\t\tinverseThiccCalc = (-1 * (rightMostx - leftMostx) / (topMosty - botMosty)) * thiccness\r\n\r\n\t\tcord1x = 0\r\n\t\tcord1y = 0\r\n\t\tcord2x = 0\r\n\t\tcord2y = 0\r\n\t\tcord3x = 0\r\n\t\tcord3y = 0\r\n\t\tcord4x = 0\r\n\t\tcord4y = 0\r\n\r\n\t\tif wall[0][0] <= wall[1][0]:\r\n\t\t\tif wall[0][1] >= wall[1][1]:\r\n\t\t\t\tprint(\"meme\")\r\n\t\t\t\tcord1x = wall[0][0] + thiccCalc\r\n\t\t\t\tcord1y = wall[0][1] + inverseThiccCalc\r\n\t\t\t\tcord2x = wall[0][0] - thiccCalc\r\n\t\t\t\tcord2y = wall[0][1] - inverseThiccCalc\r\n\t\t\t\tcord3x = wall[1][0] + thiccCalc\r\n\t\t\t\tcord3y = wall[1][1] + inverseThiccCalc\r\n\t\t\t\tcord4x = wall[1][0] - thiccCalc\r\n\t\t\t\tcord4y = wall[1][1] - inverseThiccCalc\r\n\t\t\telse:\r\n\t\t\t\tprint(\"meme2\")\r\n\t\t\t\tcord1x = wall[1][0] + thiccCalc\r\n\t\t\t\tcord1y = wall[1][1] + inverseThiccCalc\r\n\t\t\t\tcord2x = wall[1][0] - thiccCalc\r\n\t\t\t\tcord2y = wall[1][1] - inverseThiccCalc\r\n\t\t\t\tcord3x = wall[0][0] + thiccCalc\r\n\t\t\t\tcord3y = wall[0][1] + inverseThiccCalc\r\n\t\t\t\tcord4x = wall[0][0] - thiccCalc\r\n\t\t\t\tcord4y = wall[0][1] - inverseThiccCalc\r\n\t\telse:\r\n\t\t\tif wall[0][1] >= wall[1][1]:\r\n\t\t\t\tprint(\"meme3\")\r\n\t\t\t\tcord1x = wall[0][0] + thiccCalc\r\n\t\t\t\tcord1y = wall[0][1] + inverseThiccCalc\r\n\t\t\t\tcord2x = wall[0][0] - thiccCalc\r\n\t\t\t\tcord2y = wall[0][1] - inverseThiccCalc\r\n\t\t\t\tcord3x = wall[1][0] + thiccCalc\r\n\t\t\t\tcord3y = wall[1][1] + inverseThiccCalc\r\n\t\t\t\tcord4x = wall[1][0] - thiccCalc\r\n\t\t\t\tcord4y = wall[1][1] - inverseThiccCalc\r\n\t\t\telse:\r\n\t\t\t\tprint(\"meme4\")\r\n\t\t\t\tcord1x = wall[1][0] + thiccCalc\r\n\t\t\t\tcord1y = wall[1][1] + inverseThiccCalc\r\n\t\t\t\tcord2x = wall[1][0] - thiccCalc\r\n\t\t\t\tcord2y = wall[1][1] - inverseThiccCalc\r\n\t\t\t\tcord3x = wall[0][0] + thiccCalc\r\n\t\t\t\tcord3y = wall[0][1] + inverseThiccCalc\r\n\t\t\t\tcord4x = wall[0][0] - thiccCalc\r\n\t\t\t\tcord4y = wall[0][1] - inverseThiccCalc\r\n\r\n\t\tself.dot1.x = cord1x\r\n\t\tself.dot1.y = cord1y\r\n\t\tself.dot2.x = cord2x\r\n\t\tself.dot2.y = cord2y\r\n\t\tself.dot3.x = cord3x\r\n\t\tself.dot3.y = cord3y\r\n\t\tself.dot4.x = cord4x\r\n\t\tself.dot4.y = cord4y\r\n\r\n\t\tprint(str(cord1x) + \" \" + str(cord1y) + \" \" +str(cord2x) + \" \" + str(cord2y) + \" \" + str(cord3x) + \" \" +str(cord3y) + \" \" + str(cord4x) + \" \" + str(cord4y))\r\n\r\n\t\twallhitbox = hitbox(cord1x, cord1y, cord2x, cord2y, cord3x, cord3y, cord4x, cord4y)\r\n\t\tself.wallHitboxArr.append(wallhitbox)\r\n", "description": null, "category": "math", "imports": ["import pyglet\r", "from hitbox import hitbox\r"]}], [{"term": "def", "name": "calc_rankings", "data": "def calc_rankings(input_year, input_week):\n\tteams = init.init_teams(input_year, input_week);\n\tteams = calculations.init_calc_team_record_ranking(teams)\n\n\tteams = calculations.calc_value_ranking(teams, 'points_scored_avg', 'points_scored_ranking', True)\n\tteams = calculations.calc_value_ranking(teams, 'points_against_avg', 'points_against_ranking', False)\n\tteams = calculations.calc_value_ranking(teams, 'turnover_differential', 'turnover_differential_ranking', True)\n\tteams = calculations.calc_value_transformation(teams, 'points_scored_avg', 'points_scored_transformation', True)\n\tteams = calculations.calc_value_transformation(teams, 'points_against_avg', 'points_against_transformation', False)\n\tteams = calculations.calc_value_transformation(teams, 'turnover_differential', 'turnover_differential_transformation', True)\n\n\tteams = calculations.calc_advanced_stats(teams)\n\n\tteams = calculations.calc_value_transformation(teams, 'pythagorean_wins', 'pythagorean_wins_transformation', True)\n\tteams = calculations.calc_value_transformation(teams, 'victory_value', 'victory_value_transformation', True)\n\tteams = calculations.calc_value_transformation(teams, 'point_differential_strength', 'point_differential_transformation', True)\n\tteams = calculations.calc_value_transformation(teams, 'win_percentage', 'win_percentage_transformation', True)\n\n\tteams = calculations.init_calc_power_ranking(teams)\n\n\toutput.print_power_rankings(teams)\n\toutput.export_to_json(teams, input_week, input_year)\n", "description": null, "category": "math", "imports": ["from __future__ import division", "import sys", "import init", "import calculations", "import output"]}, {"term": "def", "name": "calc_multiple_weeks", "data": "def calc_multiple_weeks(beg_year, beg_week, end_year, end_week):\n\tfirst_archived_year = 2009\n\tweeks_in_a_season = 17\n\n\tyear_iterations = (end_year - beg_year) + 1\n\n\tif year_iterations == 1:\n\t\tbeg_year_week_iterations = (end_week - beg_week) + 1\n\t\tfinal_year_week_iterations = (end_week - beg_week) + 1\n\telse:\n\t\tbeg_year_week_iterations = (weeks_in_a_season - beg_week) + 1\n\t\tfinal_year_week_iterations = end_week\n\n\tfor year_index in range(year_iterations):\n\t\tyear = beg_year + year_index\n\n\t\tif year == beg_year:\n\t\t\tweek_iterations = beg_year_week_iterations\n\t\t\tinitial_week = beg_week\n\t\telif year == end_year:\n\t\t\tweek_iterations = final_year_week_iterations\n\t\t\tinitial_week = 1\n\t\telse:\n\t\t\tweek_iterations = weeks_in_a_season\n\t\t\tinitial_week = 1\n\n\t\tfor week_index in range(week_iterations):\n\t\t\tweek = initial_week + week_index\n\n\t\t\tcalc_rankings(year, week)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "import sys", "import init", "import calculations", "import output"]}, {"term": "def", "name": "entry", "data": "def entry(year=None, week=None, calc_type=None):\n\tcalc_type = calc_type or sys.argv[1]\n\n\tif calc_type == 'multiple':\n\t\tbeg_year = year[0] if year else int(sys.argv[2])\n\t\tbeg_week = week[0] if week else int(sys.argv[3])\n\t\tend_year = year[-1] if year else int(sys.argv[4])\n\t\tend_week = week[-1] if week else int(sys.argv[5])\n\n\t\tcalc_multiple_weeks(beg_year, beg_week, end_year, end_week)\n\telif calc_type == 'single':\n\t\tinput_year = year or int(sys.argv[2])\n\t\tinput_week = week or int(sys.argv[3])\n\n\t\tcalc_rankings(input_year, input_week)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "import sys", "import init", "import calculations", "import output"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await ultroid_bot.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "run", "data": "def run(atoms):\n\tatoms.get_forces()\n\tprint(sorted(atoms.calc.results))\n\tfor key, value in atoms.calc.results.items():\n\t\tif isinstance(value, np.ndarray):\n\t\t\tprint(key, value.shape, value.dtype)\n\t\telse:\n\t\t\tprint(key, value)\n\n\tfor name in required_quantities:\n\t\tassert name in atoms.calc.results\n\n\treturn atoms.calc.results\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_si", "data": "def test_si(factory):\n\tatoms = bulk('Si')\n\tatoms.calc = factory.calc(nbands=4 * len(atoms), kpts=[4, 4, 4])\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_au", "data": "def test_au(factory, pps):\n\tatoms = bulk('Au')\n\tatoms.calc = factory.calc(\n\t\tpps=pps,\n\t\tnbands=10 * len(atoms),\n\t\ttsmear=0.1,\n\t\toccopt=3,\n\t\tkpts=[2, 2, 2],\n\t\tpawecutdg=6.0 * Hartree,\n\t)\n\t# Somewhat awkward to set pawecutdg also when we are not doing paw,\n\t# but it's an error to pass None as pawecutdg.\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "fe_atoms", "data": "def fe_atoms(abinit_factory):\n\tatoms = bulk('Fe')\n\tatoms.set_initial_magnetic_moments([1])\n\tcalc = abinit_factory.calc(nbands=8,\n\t\t\t\t\t\t\t   kpts=[2, 2, 2])\n\tatoms.calc = calc\n\treturn atoms\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_fe_fixed_magmom", "data": "def test_fe_fixed_magmom(fe_atoms):\n\tfe_atoms.calc.set(spinmagntarget=2.3)\n\trun(fe_atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_fe_any_magmom", "data": "def test_fe_any_magmom(fe_atoms):\n\tfe_atoms.calc.set(occopt=7)\n\trun(fe_atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_h2o", "data": "def test_h2o(factory):\n\tatoms = molecule('H2O', vacuum=2.5)\n\tatoms.calc = factory.calc(nbands=8)\n\trun(atoms)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_o2", "data": "def test_o2(factory):\n\tatoms = molecule('O2', vacuum=2.5)\n\tatoms.calc = factory.calc(nbands=8, occopt=7)\n\trun(atoms)\n\tmagmom = atoms.get_magnetic_moment()\n\tassert magmom == pytest.approx(2, 1e-2)\n\tprint('magmom', magmom)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_manykpts", "data": "def test_manykpts(factory):\n\tatoms = bulk('Au') * (2, 2, 2)\n\tatoms.rattle(stdev=0.01)\n\tatoms.symbols[:2] = 'Cu'\n\tatoms.calc = factory.calc(nbands=len(atoms) * 7, kpts=[8, 8, 8])\n\trun(atoms, 'manykpts')\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}, {"term": "def", "name": "test_manyatoms", "data": "def test_manyatoms(factory):\n\tatoms = bulk('Ne', cubic=True) * (4, 2, 2)\n\tatoms.rattle(stdev=0.01)\n\tatoms.calc = factory.calc(nbands=len(atoms) * 5)\n\trun(atoms, 'manyatoms')\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.build import bulk, molecule", "from ase.units import Hartree"]}], [{"term": "def", "name": "make_button", "data": "def make_button(method):\r\n\treturn tk.Button(text=method, bd=5, font=('Arial', 17), bg='yellow', command=lambda : choose(method))\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "from itertools import permutations\r"]}, {"term": "def", "name": "choose", "data": "def choose(method):\r\n\tif method == \"\u041c\u0435\u0442\u043e\u0434 \u0411\u043e\u0440\u0434\u0430\":\r\n\t\tframe_Borda(method)\r\n\telse:\r\n\t\tframe_Condorce(method)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "from itertools import permutations\r"]}, {"term": "def", "name": "make_label_main", "data": "def make_label_main(label):\r\n\treturn tk.Label(text=label, bd=5, font=('Arial', 17), borderwidth=3, relief=\"solid\")\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "from itertools import permutations\r"]}, {"term": "def", "name": "make_label_other", "data": "def make_label_other(label, fr):\r\n\treturn tk.Label(fr, text=label, bd=5, font=('Arial', 15), borderwidth=3, relief=\"solid\")\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "from itertools import permutations\r"]}, {"term": "def", "name": "frame_Borda", "data": "def frame_Borda(method):\r\n\tA = method_Borda(input_matrix, 'A')\r\n\tB = method_Borda(input_matrix, 'B')\r\n\tC = method_Borda(input_matrix, 'C')\r\n\t\r\n\twindow_calc = tk.Tk()\r\n\twindow_calc.geometry(\"380x500\")\r\n\twindow_calc.resizable(0,0)\r\n\twindow_calc.title(method)\r\n\t\r\n\tA_B_C = [\"A\", \"B\", \"C\"]\r\n\tres_A_B_C = [A, B, C]\r\n\t\r\n\tfor i in range(0, len(A_B_C)):\r\n\t\tmake_label_other(i+1, window_calc).grid(row=i+1, column=1, stick='wens', padx=3, pady=3)\r\n\t\tmake_label_other(A_B_C[i], window_calc).grid(row=i+1, column=2, stick='wens', padx=3, pady=3)\r\n\t\tmake_label_other(res_A_B_C[i], window_calc).grid(row=i+1, column=3, stick='wens', padx=3, pady=3)\r\n\t\r\n\tbest = max(res_A_B_C)\r\n\tres_str = \"\u041f\u0435\u0440\u0435\u043c\u043e\u0436\u0446\u0435\u043c \u0437\u0430 \u043c\u0435\u0442\u043e\u0434\u043e\u043c\\n \u0411\u043e\u0440\u0434\u0430 \u0454 \u043a\u0430\u043d\u0434\u0438\u0434\u0430\u0442 \" + A_B_C[res_A_B_C.index(best)] + \"\\n\u0437 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \" + str(best)\r\n\tres = make_label_other(res_str, window_calc)\r\n\tres.grid(row=4, rowspan=5, column=1, columnspan=3, stick='wens', padx=3, pady=3)\r\n\t\r\n\twindow_calc.grid_columnconfigure(0, minsize = 70)\r\n\twindow_calc.grid_columnconfigure(1, minsize = 70)\r\n\twindow_calc.grid_columnconfigure(2, minsize = 70)\r\n\twindow_calc.grid_columnconfigure(3, minsize = 70)\r\n\twindow_calc.grid_columnconfigure(4, minsize = 70)\r\n\t\r\n\twindow_calc.grid_rowconfigure(0, minsize = 70)\r\n\twindow_calc.grid_rowconfigure(1, minsize = 70)\r\n\twindow_calc.grid_rowconfigure(2, minsize = 70)\r\n\twindow_calc.grid_rowconfigure(3, minsize = 70)\r\n\twindow_calc.grid_rowconfigure(4, minsize = 70)\r\n\twindow_calc.grid_rowconfigure(5, minsize = 70)\r\n\t\r\n\twindow_calc.mainloop()\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "from itertools import permutations\r"]}, {"term": "def", "name": "method_Borda", "data": "def method_Borda(mat, candidate):\r\n\tSum = 0\r\n\tfor i in range(0, len(mat)):\t\r\n\t\tfor j in range(1, len(mat[i])):\r\n\t\t\tif mat[i][j] == candidate:\r\n\t\t\t\tif mat[i].index(candidate) == 1:\r\n\t\t\t\t\tSum += mat[i][0] * 2\r\n\t\t\t\telif mat[i].index(candidate) == 2:\r\n\t\t\t\t\tSum += mat[i][0] * 1\r\n\t\t\t\telif mat[i].index(candidate) == 3:\r\n\t\t\t\t\tSum += mat[i][0] * 0\r\n\treturn Sum\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "from itertools import permutations\r"]}, {"term": "def", "name": "frame_Condorce", "data": "def frame_Condorce(method):\r\n\tstr_A_B, sum_A_B = method_Condorce(input_matrix, 'A', 'B')\r\n\tstr_B_C, sum_B_C = method_Condorce(input_matrix, 'B', 'C')\r\n\tstr_A_C, sum_A_C = method_Condorce(input_matrix, 'A', 'C')\r\n\t\r\n\tall_str = str_A_B + str_B_C + str_A_C\r\n\tall_digit = sum_A_B + sum_B_C + sum_A_C\r\n\t\r\n\twindow_calc = tk.Tk()\r\n\twindow_calc.geometry(\"340x500\")\r\n\twindow_calc.resizable(0,0)\r\n\twindow_calc.title(method)\r\n\t\r\n\tfor i in range(0, len(all_str)):\r\n\t\tmake_label_other(all_str[i], window_calc).grid(row=i+1, column=1, stick='wens', padx=3, pady=3)\r\n\t\tmake_label_other(all_digit[i], window_calc).grid(row=i+1, column=2, stick='wens', padx=3, pady=3)\r\n\t\r\n\tA_B = make_label_other(str_A_B[sum_A_B.index(max(sum_A_B))], window_calc)\r\n\tA_B.grid(row=1, rowspan=2, column=3, stick='wens', padx=3, pady=3)\r\n\tB_C = make_label_other(str_B_C[sum_B_C.index(max(sum_B_C))], window_calc)\r\n\tB_C.grid(row=3, rowspan=2, column=3, stick='wens', padx=3, pady=3)\r\n\tA_C = make_label_other(str_A_C[sum_A_C.index(max(sum_A_C))], window_calc)\r\n\tA_C.grid(row=5, rowspan=2, column=3, stick='wens', padx=3, pady=3)\r\n\t\r\n\tall_str_2d = [str_A_B[sum_A_B.index(max(sum_A_B))],\r\n\t\t\t\t  str_B_C[sum_B_C.index(max(sum_B_C))],\r\n\t\t\t\t  str_A_C[sum_A_C.index(max(sum_A_C))]]\r\n\tall_str_2d = list(permutations(all_str_2d))\r\n\t\r\n\tfor i in range(0, len(all_str_2d)):\r\n\t\tdetermine_result(all_str_2d[i][0], all_str_2d[i][1], all_str_2d[i][2], window_calc)\r\n\t\r\n\twindow_calc.grid_columnconfigure(0, minsize = 50)\r\n\twindow_calc.grid_columnconfigure(1, minsize = 50)\r\n\twindow_calc.grid_columnconfigure(2, minsize = 50)\r\n\twindow_calc.grid_columnconfigure(3, minsize = 50)\r\n\twindow_calc.grid_columnconfigure(4, minsize = 50)\r\n\t\r\n\twindow_calc.grid_rowconfigure(0, minsize = 50)\r\n\twindow_calc.grid_rowconfigure(1, minsize = 50)\r\n\twindow_calc.grid_rowconfigure(2, minsize = 50)\r\n\twindow_calc.grid_rowconfigure(3, minsize = 50)\r\n\twindow_calc.grid_rowconfigure(4, minsize = 50)\r\n\twindow_calc.grid_rowconfigure(5, minsize = 50)\r\n\twindow_calc.grid_rowconfigure(6, minsize = 50)\r\n\twindow_calc.grid_rowconfigure(7, minsize = 50)\r\n\twindow_calc.grid_rowconfigure(8, minsize = 50)\r\n\t\r\n\twindow_calc.mainloop()\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "from itertools import permutations\r"]}, {"term": "def", "name": "method_Condorce", "data": "def method_Condorce(mat, candidate1, candidate2):\r\n\tres1 = 0\r\n\tres2 = 0\r\n\tfor i in range(0, len(mat)):\r\n\t\tif mat[i].index(candidate1) < mat[i].index(candidate2):\r\n\t\t\tres1 += mat[i][0]\r\n\t\telse:\r\n\t\t\tres2 += mat[i][0]\r\n\tres = [res1, res2]\r\n\tcompare = [candidate1 + \" > \" + candidate2, candidate2 + \" > \" + candidate1]\r\n\treturn compare, res\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "from itertools import permutations\r"]}, {"term": "def", "name": "determine_result", "data": "def determine_result(str1, str2, str3, fr):\r\n\tif str1[len(str1) - 1] == str2[0]:\r\n\t\tstr1_str2 = str1 + ' > ' + str2[len(str2) - 1]\r\n\t\tif str1_str2[0] == str3[0] and str1_str2[len(str1_str2) - 1] == str3[len(str3) - 1]:\r\n\t\t\tmake_label_other(str1_str2, fr).grid(row=7, column=1, columnspan=3, stick='wens', padx=3, pady=3)\r\n\t\t\tmake_label_other('\u041f\u0435\u0440\u0435\u043c\u043e\u0436\u0446\u0435\u043c \u0437\u0430 \u043c\u0435\u0442\u043e\u0434\u043e\u043c\\n\u041a\u043e\u043d\u0434\u043e\u0440\u0441\u0435 \u0454 \u043a\u0430\u043d\u0434\u0438\u0434\u0430\u0442 '+ str1_str2[0], fr).grid(row=8, column=1, columnspan=3, stick='wens', padx=3, pady=3)\r\n\t\telse:\r\n\t\t\tmake_label_other('\u0420\u0430\u0437\u043e\u043c \u0446\u0456 \u0442\u0432\u0435\u0440\u0434\u0436\u0435\u043d\u043d\u044f \u0441\u0443\u043f\u0435\u0440\u0435\u0447\u043b\u0438\u0432\u0456.\\n\u041d\u0435\u043c\u043e\u0436\u043b\u0438\u0432\u043e \u043f\u0440\u0438\u0439\u043d\u044f\u0442\u0438 \u044f\u043a\u0435\u0441\u044c\\n\u0443\u0437\u0433\u043e\u0434\u0436\u0435\u043d\u0435 \u0440\u0456\u0448\u0435\u043d\u043d\u044f', fr).grid(row=7, rowspan=9, column=1, columnspan=3, stick='wens', padx=3, pady=3)\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r", "from itertools import permutations\r"]}], [], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(\"Error\", cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "kpts_changed", "data": "def kpts_changed(calc, x):\n\t'''\n\tcheck if kpt grid has changed.\n\n\twe have to take care to generate the right k-points from x if\n\tneeded. if a user provides (4,4,4) we need to generate the MP\n\tgrid, etc...\n\n\tSince i changed the MP code in set_kpts, there is some\n\tincompatibility with old jacapo calculations and their MP\n\tgrids.\n\t'''\n\t#chadi-cohen\n\tif isinstance(x, basestring):\n\t\tlistofkpts = getattr(ase.dft.kpoints, x)\n\t#monkhorst-pack grid\n\telif np.array(x).shape == (3,):\n\t\tfrom ase.dft.kpoints import monkhorst_pack\n\t\tN1, N2, N3 = x\n\t\tlistofkpts = monkhorst_pack((N1, N2, N3))\n\t#user-defined list is provided\n\telif len(np.array(x).shape) == 2:\n\t\tlistofkpts = np.array(x)\n\telse:\n\t\traise Exception('apparent invalid setting for kpts')\n\n\tgrid = calc.get_kpts()\n\n\tif grid.shape != listofkpts.shape:\n\t\treturn True\n\n\tif (abs(listofkpts - grid) < 1e-6).all():\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "electronic_minimization_changed", "data": "def electronic_minimization_changed(calc, x):\n\tmyx = calc.get_electronic_minimization()\n\n\tfor key in myx:\n\t\tif myx[key] != x[key]:\n\t\t\tprint(key, myx[key], ' changed to ', x[key])\n\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "spinpol_changed", "data": "def spinpol_changed(calc, x):\n\tif x != calc.get_spinpol():\n\t\treturn True\n\telse:\n\t\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "symmetry_changed", "data": "def symmetry_changed(calc, x):\n\tif x != calc.get_symmetry():\n\t\treturn True\n\telse:\n\t\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "xc_changed", "data": "def xc_changed(calc, x):\n\tif x != calc.get_xc():\n\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "calculate_stress_changed", "data": "def calculate_stress_changed(calc, x):\n\tif x != calc.get_calculate_stress():\n\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "ados_changed", "data": "def ados_changed(calc, x):\n\tados = calc.get_ados()\n\n\t#ados may not be defined, and then None is returned\n\tif ados is None and x is None:\n\t\treturn False\n\telif ados is None and x is not None:\n\t\treturn True\n\telif ados is not None and x is None:\n\t\treturn True\n\n\t#getting here means ados and x are not none so we compare them\n\tfor key in x:\n\t\ttry:\n\t\t\tif x[key] != ados[key]:\n\t\t\t\treturn True\n\t\texcept ValueError:\n\t\t\tif (x[key] != ados[key]).all():\n\t\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "convergence_changed", "data": "def convergence_changed(calc, x):\n\tconv = calc.get_convergence()\n\tfor key in x:\n\t\tif x[key] != conv[key]:\n\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "charge_mixing_changed", "data": "def charge_mixing_changed(calc, x):\n\tcm = calc.get_charge_mixing()\n\tif x is None and cm is None:\n\t\treturn False\n\telse:\n\t\treturn True\n\n\tfor key in x:\n\t\tif x[key] != cm[key]:\n\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "decoupling_changed", "data": "def decoupling_changed(calc, x):\n\tpars = calc.get_decoupling()\n\tfor key in x:\n\t\tif x[key] != pars[key]:\n\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "dipole_changed", "data": "def dipole_changed(calc, x):\n\n\tpars = calc.get_dipole() #pars stored in calculator\n\n\t# pars = False if no dipole variables exist\n\t# XXX fix the \"logic\" below.   \"if not pars and not x\"\n\t# or can it be very different types?  This is very difficult to read\n\tif (pars is False and x is False):\n\t\treturn False #no change\n\telif (pars is False and x is not False):\n\t\treturn True\n\n\t# both x and pars is a dictionary\n\t# XXX wtf?  type(dict) == dict.  If x is a dict then type(x) is at least\n\tif (isinstance(pars, type(dict)) and\n\t\tisinstance(pars, type(x))):\n\t\tfor key in x:\n\t\t\tif key == 'position':\t# dipole layer position is never written to the nc file\n\t\t\t\tprint('need to do something special')\n\t\t\t\tcontinue\n\t\t\tif x[key] != pars[key]:\n\t\t\t\treturn True\n\n\t#nothing seems to have changed.\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "extpot_changed", "data": "def extpot_changed(calc, x):\n\textpot = calc.get_extpot()\n\tif (x == extpot).all():\n\t\treturn False\n\treturn True\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "fftgrid_changed", "data": "def fftgrid_changed(calc, x):\n\t# validkeys = ['soft', 'hard']\n\n\tmyx = calc.get_fftgrid()\n\tif (myx['soft'] == x['soft'] and myx['hard'] == x['hard']):\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "ncoutput_changed", "data": "def ncoutput_changed(calc, x):\n\tncout = calc.get_ncoutput()\n\tfor key in x:\n\t\tif x[key] != ncout[key]:\n\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "nbands_changed", "data": "def nbands_changed(calc, x):\n\tif calc.get_nbands() == x:\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "occupationstatistics_changed", "data": "def occupationstatistics_changed(calc, x):\n\tif calc.get_occupationstatistics() == x:\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "pw_changed", "data": "def pw_changed(calc, x):\n\tif calc.get_pw() == x:\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "dw_changed", "data": "def dw_changed(calc, x):\n\tif calc.get_dw() == x:\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "ft_changed", "data": "def ft_changed(calc, x):\n\tif calc.get_ft() == x:\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "mdos_changed", "data": "def mdos_changed(calc,x):\n\n\tmyx = calc.get_mdos()\n\n\tlog.debug('myx = %s' % str(myx))\n\tlog.debug('x = %s' % str(x))\n\n\tif x is None and myx is None:\n\t\treturn False\n\telif ((x is None and myx is not None)\n\t\tor (x is not None and myx is None)):\n\t\treturn True\n\telse:\n\t\tfor key in x:\n\t\t\tif x[key] != myx[key]:\n\t\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "pseudopotentials_changed", "data": "def pseudopotentials_changed(calc,x):\n\n\tmypsp = calc.get_pseudopotentials()\n\n\tif len(mypsp) != len(x):\n\t\treturn True\n\n\tfor key in x:\n\t\tif key not in mypsp:\n\t\t\treturn True\n\t\tif mypsp[key] != x[key]:\n\t\t\treturn True\n\n\tfor key in mypsp:\n\t\tif key not in x:\n\t\t\treturn True\n\t\tif mypsp[key] != x[key]:\n\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "status_changed", "data": "def status_changed(calc,x):\n\tif calc.get_status() != x:\n\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import numpy as np", "import logging", "import ase.dft.kpoints", "from ase.utils import basestring", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}], [{"term": "def", "name": "test_vasp_charge", "data": "def test_vasp_charge(require_vasp):\n\t\"\"\"\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied charge works correctly. This is conditional on the existence\n\tof the VASP_COMMAND or VASP_SCRIPT environment variables.\n\n\t\"\"\"\n\n\timport pytest\n\tfrom ase.build import bulk\n\tfrom ase.calculators.vasp import Vasp\n\tfrom ase.test.calculator.vasp import installed\n\n\tassert installed()\n\n\tsystem = bulk('Al', 'fcc', a=4.5, cubic=True)\n\n\t# Dummy calculation to let VASP determine default number of electrons\n\tcalc = Vasp(xc='LDA', nsw=-1, ibrion=-1, nelm=1, lwave=False, lcharg=False)\n\tcalc.calculate(system)\n\tdefault_nelect_from_vasp = calc.get_number_of_electrons()\n\tassert default_nelect_from_vasp == 12\n\n\t# Make sure that no nelect was written into INCAR yet (as it wasn't necessary)\n\tcalc = Vasp()\n\tcalc.read_incar()\n\tassert calc.float_params['nelect'] is None\n\n\t# Compare VASP's output nelect from before minus charge to default nelect\n\t# determined by us minus charge\n\tcharge = -2\n\tcalc = Vasp(xc='LDA', nsw=-1, ibrion=-1, nelm=1, lwave=False, lcharg=False,\n\t\t\t\tcharge=charge)\n\tcalc.initialize(system)\n\tcalc.write_input(system)\n\tcalc.read_incar()\n\tassert calc.float_params['nelect'] == default_nelect_from_vasp - charge\n\n\t# Test that conflicts between explicitly given nelect and charge are detected\n\twith pytest.raises(ValueError):\n\t\tcalc = Vasp(xc='LDA', nsw=-1, ibrion=-1, nelm=1, lwave=False, lcharg=False,\n\t\t\t\t\tnelect=default_nelect_from_vasp-charge+1,\n\t\t\t\t\tcharge=charge)\n\t\tcalc.calculate(system)\n\n\t# Test that nothing is written if charge is 0 and nelect not given\n\tcalc = Vasp(xc='LDA', nsw=-1, ibrion=-1, nelm=1, lwave=False, lcharg=False,\n\t\t\t\tcharge=0)\n\tcalc.initialize(system)\n\tcalc.write_input(system)\n\tcalc.read_incar()\n\tassert calc.float_params['nelect'] is None\n\n\t# Test that explicitly given nelect still works as expected\n\tcalc = Vasp(xc='LDA', nsw=-1, ibrion=-1, nelm=1, lwave=False, lcharg=False,\n\t\t\t\tnelect=15)\n\tcalc.calculate(system)\n\tassert calc.get_number_of_electrons() == 15\n", "description": "\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied charge works correctly. This is conditional on the existence\n\tof the VASP_COMMAND or VASP_SCRIPT environment variables.\n\n\t", "category": "math", "imports": ["\timport pytest", "\tfrom ase.build import bulk", "\tfrom ase.calculators.vasp import Vasp", "\tfrom ase.test.calculator.vasp import installed"]}], [{"term": "def", "name": "test_al", "data": "def test_al(factory):\n\trun(factory)\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "test_al_old", "data": "def test_al_old(name):\n\tfactory = ObsoleteFactoryWrapper(name)\n\trun(factory)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "run", "data": "def run(factory):\n\tname = factory.name\n\tpar = required.get(name, {})\n\t# What on earth does kpts=1.0 mean?  Was failing, I changed it.  --askhl\n\t# Disabled GPAW since it was failing anyway. --askhl\n\tkpts = [2, 2, 2]\n\tcalc = factory.calc(label=name, xc='LDA', kpts=kpts, **par)\n\tal = bulk('AlO', crystalstructure='rocksalt', a=4.5)\n\tal.calc = calc\n\te = al.get_potential_energy()\n\tcalc.set(xc='PBE', kpts=kpts)\n\tepbe = al.get_potential_energy()\n\tprint(e, epbe)\n\tcalc = factory.calc(restart=name)\n\tprint(calc.parameters, calc.results, calc.atoms)\n\tassert not calc.calculation_required(al, ['energy'])\n\tal = calc.get_atoms()\n\tprint(al.get_potential_energy())\n\tlabel = 'dir/' + name + '-2'\n\tcalc = factory.calc(label=label, atoms=al, xc='LDA', kpts=kpts,\n\t\t\t\t\t\t**par)\n\tprint(al.get_potential_energy())\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.test.factories import ObsoleteFactoryWrapper"]}], [{"term": "def", "name": "trajectory_similirity_compute", "data": "def trajectory_similirity_compute(traj_A, traj_B):\n\t######## Sequence-only and Discrete ########\n\t# x, y, zero, h, time : 3\n\t# ED - Euclidean distance calc\n\tedResult, edCalcTime= euclidean.ed_traj(traj_A, traj_B)\n\tprint (\"ED Distance: \" + str(edResult) + \" calcTime : \" + str(edCalcTime))\n\n\t# DTW - Dynamic Time Warping calc\n\tdtwResult, dtwCalcTime = dtw.e_dtw(traj_A, traj_B)\n\tprint (\"DTW Distance: \" + str(dtwResult) + \" calcTime : \" + str(dtwCalcTime))\n\t# ERP  - Edit distance with Real Penalty\n\t# g (gap) : parameter defalut value 0\n\terpResult, erpCalcTime = erp.e_erp(traj_A, traj_B, 0)\n\tprint (\"ERP Distance: \" + str(erpResult) + \" calcTime : \" + str(erpCalcTime))\n\t# EDR - Edit Distance on Real Sequence\n\t# esp : subcost(p1, p2) = 0 , d(p1, p2) \u2264 \u03b5 \n\t#\t\t\t\t\t\t 1, otherwise\n\tedrResult, edrCalcTime = edr.e_edr(traj_A, traj_B, 0.1)\n\tprint (\"EDR Distance: \" + str(edrResult) + \" calcTime : \" + str(edrCalcTime))\n\t# LCSS - Longuest Common Sebsequence dtwCalcTime\n\t# esp : subcost(p1, p2) = 0 , d(p1, p2) \u2264 \u03b5 \n\t#\t\t\t\t\t\t 1, otherwise\n\tlcssResult, lcssCalcTime = lcss.e_lcss(traj_A, traj_B, 0.1)\n\tprint (\"LCSS Distance: \" + str(lcssResult) + \" calcTime : \" + str(lcssCalcTime))\n\t# SSPD - Symmetric Segment-Path Distance calc\n\tsspdResult, sspdCalcTime = sspd.e_sspd(traj_A, traj_B)\n\tprint (\"SSPD Distance: \" + str(sspdResult) + \" calcTime : \" + str(sspdCalcTime))\n\t######## Sequence-only and Continuous ########\n\t# OWD - One-Way Distance calc\n\tsowdResult, sowdCalcTime = sowd.sowd_grid(traj_A, traj_B)\n\tprint (\"OWD Distance: \" + str(sowdResult) + \" calcTime : \" + str(sowdCalcTime))\n\t######## Spatial-temporal and Discrete ########\n\n\t######## Spatial-temporal and Continuous ########\n\t# Frechet dtwCalcTime\n\tfrechetResult, frechetCalcTime = frechet.frechet(traj_A, traj_B)\n\tprint (\"Frechet Distance: \" + str(frechetResult) + \" calcTime : \" + str(frechetCalcTime))\n\tdf = pd.DataFrame([\n\t\t['ED',edResult, edCalcTime],['DTW',dtwResult, dtwCalcTime]\n\t\t,['ERP', erpResult, erpCalcTime], ['EDR', edrResult, edrCalcTime]\n\t\t,['LCSS', lcssResult, lcssCalcTime],['SSPD', sspdResult, sspdCalcTime]\n\t\t,['OWD', sowdResult, sowdCalcTime],['Frechet', frechetResult, frechetCalcTime]]\n\t\t,columns=['Name','Distance', 'Time'])\n\treturn df\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pandas as pd", "import sys", "import dtw", "import sspd", "import edr", "import erp", "import lcss", "import sowd", "import basic_euclidean as euclidean", "import frechet", "from L_anonymity import anonymity"]}, {"term": "def", "name": "getArrays", "data": "def getArrays(filename, skip_header):\n\ttraj_list = np.genfromtxt(filename, delimiter=',', skip_header=skip_header)\n\treturn np.array(traj_list)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pandas as pd", "import sys", "import dtw", "import sspd", "import edr", "import erp", "import lcss", "import sowd", "import basic_euclidean as euclidean", "import frechet", "from L_anonymity import anonymity"]}, {"term": "def", "name": "main", "data": "def main():\n\tif len(sys.argv) < 3:\n\t\tprint('You must input two filename to compare!')\n\t\tsys.exit(1)  # abort because of error\n\n\tfilename1 = str(sys.argv[1])\n\tfilename2 = str(sys.argv[2])\n\n\t##### non-Anonymized calculation ########\n\ttraj_A = getArrays(filename1, 7)\n\ttraj_B = getArrays(filename2, 7)\n\n\tselection = np.array([True, True, False, False, False, False, False])\n\ttraj_A = traj_A[:, selection]\n\ttraj_B = traj_B[:, selection]\n\tresult = trajectory_similirity_compute(traj_A, traj_B)\n\tresult.to_csv('result.csv', index=True, header=True)\n\t##### Anonymized calculation ########\n\tk_file1 = anonymity(filename1)\n\tk_file2 = anonymity(filename2)\n\n\tk_traj_A = getArrays(k_file1, 0)\n\tk_traj_B = getArrays(k_file2, 0)\n\tselection = np.array([True, True, False, False])\n\tk_traj_A = k_traj_A[:, selection]\n\tk_traj_B = k_traj_B[:, selection]\n\tresult = trajectory_similirity_compute(k_traj_A, k_traj_B)\n\tresult.to_csv('result_any.csv', index=True, header=True)\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pandas as pd", "import sys", "import dtw", "import sspd", "import edr", "import erp", "import lcss", "import sowd", "import basic_euclidean as euclidean", "import frechet", "from L_anonymity import anonymity"]}], [{"term": "def", "name": "test_turbomole_h2o", "data": "def test_turbomole_h2o():\n\tmol = molecule('H2O')\n\n\tparams = {\n\t\t'title': 'water',\n\t\t'task': 'geometry optimization',\n\t\t'use redundant internals': True,\n\t\t'basis set name': 'def2-SV(P)',\n\t\t'total charge': 0,\n\t\t'multiplicity': 1,\n\t\t'use dft': True,\n\t\t'density functional': 'b3-lyp',\n\t\t'use resolution of identity': True,\n\t\t'ri memory': 1000,\n\t\t'force convergence': 0.001,\n\t\t'geometry optimization iterations': 50,\n\t\t'scf iterations': 100\n\t}\n\n\tcalc = Turbomole(**params)\n\tmol.calc = calc\n\tcalc.calculate(mol)\n\tassert calc.converged\n\n\t# use the get_property() method\n\tprint(calc.get_property('energy', mol, False))\n\tprint(calc.get_property('forces', mol, False))\n\tprint(calc.get_property('dipole', mol, False))\n\n\t# use the get_results() method\n\tresults = calc.get_results()\n\tprint(results['molecular orbitals'])\n\n\t# use the __getitem__() method\n\tprint(calc['results']['molecular orbitals'])\n\tprint(calc['results']['geometry optimization history'])\n\n\t# perform a normal mode calculation with the optimized structure\n\n\tparams.update({\n\t\t'task': 'normal mode analysis',\n\t\t'density convergence': 1.0e-7\n\t})\n\n\tcalc = Turbomole(**params)\n\tmol.calc = calc\n\tcalc.calculate(mol)\n\n\tprint(calc['results']['vibrational spectrum'])\n\tprint(calc.todict(skip_default=False))\n", "description": null, "category": "math", "imports": ["from ase.calculators.turbomole import Turbomole", "from ase.build import molecule"]}], [{"term": "class", "name": "classSolver2:", "data": "class Solver2:\n\n\tdef __init__(self, a, b, n, r):\n\t\tassert 0 < a < 1 and 0 < b < 1 <= n and r >= 1\n\t\tself.a = a\n\t\tself.b = b\n\t\tself.inA = 1 - a\n\t\tself.inB = 1 - b\n\t\tself.n = n\n\t\tself.r = r\n\t\tself.R = n + r\n\t\tself.count = 0\n\t\tself.q = [None for i in range(n+r+1)]\n\t\tself.q[n+r] = 1\n\n\t# -------------------------1st----------------------------\n\n\tdef calc_pij(self, i, j):\n\n\t\tif i == j == self.R:\n\t\t\treturn self.inB**self.n + self.a*self.n*self.inB**(self.n-1)*self.b\n\t\telif j == i+1 and self.n <= i <= self.R-1:\n\t\t\treturn self.a*self.inB**self.n\n\t\telif i - self.n + 1 <= j <= min(i, self.R-1) and self.n <= i <= self.R:\n\t\t\treturn self.inA*C(self.n, i-j)*self.inB**(self.n-i+j)*self.b**(i-j) + self.a*C(self.n, i-j+1)*self.inB**(self.n-i+j-1)*self.b**(i-j+1)\n\t\telif self.n <= i <= self.R and j == i - self.n:\n\t\t\treturn self.inA*self.b**self.n\n\t\telif 0 <= i <= self.n - 1 and j == i + 1:\n\t\t\treturn self.a*self.inB**i\n\t\telif self.n - 1 >= i >= 0 == j:\n\t\t\treturn self.inA*self.b**i\n\t\telif 1 <= i <= self.n - 1 and 1 <= j <= i:\n\t\t\treturn self.inA*C(i, j)*self.inB**j*self.b**(i-j) + self.a*C(i, j-1)*self.inB**(j-1)*self.b**(i-j+1)\n\n\tdef calc_qi(self, i):\n\t\tif self.q[i]:\n\t\t\tif self.q[i-1]:\n\t\t\t\treturn self.q[i]\n\t\t\telse:\n\t\t\t\tif self.r >= i >= 1:\n\t\t\t\t\tsumm = 0\n\t\t\t\t\tfor j in range(i+1, i+self.n+1):\n\t\t\t\t\t\tsumm += self.calc_pij(j, i)*self.calc_qi(j)\n\t\t\t\t\tself.q[i-1] = ((1 - self.calc_pij(i, i))*self.q[i] - summ) / self.calc_pij(i-1, i)\n\t\t\t\telif self.R >= i >= self.r+1:\n\t\t\t\t\tsumm = 0\n\t\t\t\t\tfor j in range(i+1, self.R+1):\n\t\t\t\t\t\tsumm += self.calc_pij(j, i)*self.calc_qi(j)\n\t\t\t\t\tself.q[i-1] = ((1 - self.calc_pij(i, i))*self.q[i] - summ) / self.calc_pij(i-1, i)\n\t\t\t\treturn self.q[i]\n\t\telse:\n\t\t\tself.calc_qi(i+1)\n\t\t\treturn self.calc_qi(i)\n\n\tdef calc_pi(self, i):\n\t\tif i == self.R:\n\t\t\tsumm = 0\n\t\t\tfor k in range(0, self.R):\n\t\t\t\tsumm += self.calc_qi(k)\n\t\t\treturn 1 / (1 + summ)\n\t\telse:\n\t\t\treturn self.calc_pi(self.R)*self.calc_qi(i)\n\n\tdef calc_pxij(self, i, j):\n\t\tif self.n <= i <= self.R and i - self.n <= j <= i:\n\t\t\treturn C(self.n, i-j)*self.inB**(self.n-i+j)*self.b**(i-j)\n\t\telif 0 <= i <= self.n - 1 and 0 <= j <= i:\n\t\t\treturn C(i, j)*self.inB**j*self.b**(i-j)\n\n\tdef calc_pxi(self, i):\n\t\tif self.r+1 <= i <= self.R:\n\t\t\tsumm = 0\n\t\t\tfor j in range(i, self.R+1):\n\t\t\t\tsumm += self.calc_pi(j) * self.calc_pxij(j, i)\n\t\telif 0 <= i <= self.r:\n\t\t\tsumm = 0\n\t\t\tfor j in range(i, i+self.n+1):\n\t\t\t\tsumm += self.calc_pi(j) * self.calc_pxij(j, i)\n\t\telse:\n\t\t\tsumm = 'errrrrrror'\n\t\treturn summ\n\n\tdef calc_special_pi(self):\n\t\treturn self.calc_pxi(self.R)\n\n\tdef calc_wxij(self, i, j):\n\t\tif i == 1:\n\t\t\tif 0 <= j <= self.n:\n\t\t\t\treturn C(self.n, j)*self.b**j*self.inB**(self.n-j)\n\t\t\telse:\n\t\t\t\treturn 0\n\t\telse:\n\t\t\tif 0 <= j <= i*self.n and i >= 2:\n\t\t\t\treturn C(i*self.n, j)*self.b**j*self.inB**(self.n*i-j)\n\t\t\telse:\n\t\t\t\treturn 0\n\n\tdef calc_wij(self,i, j):\n\t\tif i == 1:\n\t\t\tsumm = 0\n\t\t\tfor k in range(j+1, 1000):\n\t\t\t\tsumm += self.calc_wxij(1, k)\n\t\t\treturn summ\n\t\telse:\n\t\t\tsumm = 0\n\t\t\tfor k in range(j+1):\n\t\t\t\tsumm += self.calc_wxij(i-1, k) * self.calc_wij(1, j-k)\n\t\t\treturn summ\n\n\tdef calc_wi(self, i):\n\t\tif i == 0:\n\t\t\tsumm = 0\n\t\t\tfor j in range(self.n):\n\t\t\t\tsumm += self.calc_pxi(j)\n\t\t\treturn summ / (1 - self.calc_special_pi())\n\t\telse:\n\t\t\tsumm = 0\n\t\t\tfor j in range(self.n, self.R):\n\t\t\t\tsumm += self.calc_pxi(j) * self.calc_wij(i, j-self.n)\n\t\t\treturn summ / (1 - self.calc_special_pi())\n\n\t# -------------------------2nd----------------------------\n\tdef calc_N(self):\n\t\tsumm = 0\n\t\tfor i in range(self.R+1):\n\t\t\tsumm += i * self.calc_pi(i)\n\t\treturn summ\n\n\tdef calc_Nx(self):\n\t\tsumm = 0\n\t\tfor i in range(self.R+1):\n\t\t\tsumm += i* self.calc_pxi(i)\n\t\treturn summ\n\n\tdef calc_VarN(self):\n\t\tsumm = 0\n\t\tfor i in range(self.R+1):\n\t\t\tsumm += (i - self.calc_N)**2*self.calc_pi(i)\n\t\treturn summ\n\n\tdef calc_VarNx(self):\n\t\tsumm = 0\n\t\tfor i in range(self.R+1):\n\t\t\tsumm += (i + self.calc_Nx())**2*self.calc_pi(i)\n\t\treturn summ\n\n\tdef calc_w(self):\n\t\tsumm = 0\n\t\tfor i in range(1000):\n\t\t\tsumm += i * self.calc_wi(i)\n\t\treturn summ\n\n\tdef calc_Dw(self):\n\t\tsumm = 0\n\t\tw = self.calc_w()\n\t\tfor i in range(1000):\n\t\t\tsumm += (i - w)**2*self.calc_wi(i)\n\t\treturn summ\n", "description": null, "category": "math", "imports": ["from lab2 import C"]}], [{"term": "def", "name": "do_calc", "data": "def do_calc (calc_list):\n\tresult = calc_list[0]\n\tcalc_list = calc_list[1:]\n\twhile calc_list:\n\t\tif calc_list[0] == \"*\":\n\t\t\tresult = result * calc_list[1]\n\t\telse:\n\t\t\tresult = result + calc_list[1]\n\t\tcalc_list = calc_list[2:]\n\treturn result\n\n", "description": null, "category": "math", "imports": ["import re"]}, {"term": "def", "name": "do_calc_2", "data": "def do_calc_2 (calc_list):\n\twhile \"+\" in calc_list:\n\t\top_index = calc_list.index(\"+\")\n\t\tcalc_list = calc_list[:op_index-1] + [calc_list[op_index-1] + calc_list[op_index+1]] + calc_list[op_index+2:]\n\twhile \"*\" in calc_list:\n\t\top_index = calc_list.index(\"*\")\n\t\tcalc_list = calc_list[:op_index-1] + [calc_list[op_index-1] * calc_list[op_index+1]] + calc_list[op_index+2:]\n\treturn calc_list[0]\n\n", "description": null, "category": "math", "imports": ["import re"]}, {"term": "def", "name": "parse_calc", "data": "def parse_calc(calc, func):\n\tinput = [a if a in \"()*+\" else int(a) for a in re.findall(\"\\d+|[*+()]\", calc)]\n\twhile \")\" in input:\n\t\tend_index = input.index(\")\")\n\t\tstart_index = end_index - input[:end_index][::-1].index(\"(\")\n\t\tresult = func(input[start_index:end_index])\n\t\tinput = input[:start_index-1] + [result] + input[end_index+1:]\n\treturn func (input)\n\n", "description": null, "category": "math", "imports": ["import re"]}], [{"term": "class", "name": "FirstStepTests", "data": "class FirstStepTests(unittest.TestCase):\n\tdef test_empty_string_input(self):\n\t\tself.assertEqual(0, calc.add(\"\"))\n\t\tself.assertEqual(0, calc.add(\" \"))\n\n\tdef test_one_string_input(self):\n\t\tself.assertEqual(1, calc.add(\"1\"))\n\t\tself.assertEqual(2, calc.add(\"2\"))\n\n\tdef test_two_string_input(self):\n\t\tself.assertEqual(3, calc.add(\"1,2\"))\n\t\tself.assertEqual(6, calc.add(\"2,4\"))\n\n", "description": null, "category": "math", "imports": ["import unittest", "import string_calculator as calc"]}, {"term": "class", "name": "SecondStepTests", "data": "class SecondStepTests(unittest.TestCase):\n\tdef test_unknown_amount_input(self):\n\t\tself.assertEqual(6, calc.add(\"1,2,3\"))\n\t\tself.assertEqual(4, calc.add(\"1,1,1,1\"))\n\t\tself.assertEqual(6, calc.add(\"1,1,1,1,2\"))\n\n", "description": null, "category": "math", "imports": ["import unittest", "import string_calculator as calc"]}, {"term": "class", "name": "ThirdStepTests", "data": "class ThirdStepTests(unittest.TestCase):\n\tdef test_newline_between_numbers_input(self):\n\t\tself.assertEqual(6, calc.add(\"1\\n2,3\"))\n\t\tself.assertEqual(6, calc.add(\"1,2\\n3\"))\n\t\tself.assertEqual(12, calc.add(\"1,2\\n3\\n1,2,3\"))\n\n", "description": null, "category": "math", "imports": ["import unittest", "import string_calculator as calc"]}, {"term": "class", "name": "FourthStepTests", "data": "class FourthStepTests(unittest.TestCase):\n\tdef test_different_delimiters(self):\n\t\tself.assertEqual(3, calc.add(\"//;\\n1;2\"))\n\t\tself.assertEqual(6, calc.add(\"//;\\n1;2\\n3\"))\n\t\tself.assertEqual(6, calc.add(\"//;1;2\\n3\"))\n\t\tself.assertEqual(6, calc.add(\"//;1\\n2\\n3\"))\n\n", "description": null, "category": "math", "imports": ["import unittest", "import string_calculator as calc"]}, {"term": "class", "name": "FifthStepTests", "data": "class FifthStepTests(unittest.TestCase):\n\tdef test_with_negative_number(self):\n\t\twith self.assertRaises(Exception) as context:\n\t\t\tcalc.add(\"//;\\n-1\")\n\t\tself.assertTrue(\"Negatives not allowed: -1\" in str(context.exception))\n\n", "description": null, "category": "math", "imports": ["import unittest", "import string_calculator as calc"]}, {"term": "class", "name": "SixthStepTests", "data": "class SixthStepTests(unittest.TestCase):\n\tdef test_with_several_negative_numbers(self):\n\t\twith self.assertRaises(Exception) as context:\n\t\t\tcalc.add(\"//;\\n-1;-2\")\n\t\tself.assertTrue(\"Negatives not allowed: [-1, -2]\" in str(context.exception))\n\n", "description": null, "category": "math", "imports": ["import unittest", "import string_calculator as calc"]}, {"term": "class", "name": "SeventhStepTests", "data": "class SeventhStepTests(unittest.TestCase):\n\tdef test_numbers_bigger_than(self):\n\t\tself.assertEqual(2, calc.add(\"//;\\n1001;2\"))\n\t\tself.assertEqual(1002, calc.add(\"//;\\n1000;2\"))\n\t\tself.assertEqual(2, calc.add(\"//;\\n2;1001\"))\n\t\tself.assertEqual(6, calc.add(\"//;\\n2;1001;1;3\"))\n\n", "description": null, "category": "math", "imports": ["import unittest", "import string_calculator as calc"]}, {"term": "class", "name": "EighthStepTests", "data": "class EighthStepTests(unittest.TestCase):\n\tdef test_any_length_delimiter(self):\n\t\tself.assertEqual(6, calc.add(\"//[***]\\n1***2***3\"))\n\t\tself.assertEqual(10, calc.add(\"//[+]\\n1+2+3+4\"))\n\t\tself.assertEqual(10, calc.add(\"//[..]\\n1..2\\n3..4\"))\n\n", "description": null, "category": "math", "imports": ["import unittest", "import string_calculator as calc"]}, {"term": "class", "name": "NinthStepTests", "data": "class NinthStepTests(unittest.TestCase):\n\tdef test_multiple_delimiters(self):\n\t\tself.assertEqual(6, calc.add(\"//[*][%]\\n1*2%3\"))\n\t\tself.assertEqual(10, calc.add(\"//[a][x][..]\\n1a2..3x4\"))\n\n", "description": null, "category": "math", "imports": ["import unittest", "import string_calculator as calc"]}], [{"term": "def", "name": "signal_handler", "data": "def signal_handler(signum, frame):\n\tmsg = 'FAILED`recv signal ' + str(signum) + '. exit now.'\n\tcommon.info(my_log, log_tag, time_tag + msg)\n\n\tif os.path.isfile(my_pidfile):\n\t\tos.remove(my_pidfile)\n\t\n\tsys.exit(0)\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "create_obc_hdf", "data": "def create_obc_hdf(name_tage,hfile,numpy_data, obc_setting):\n\n\ttry:\n\t\tprevious_idx = 0 # time idx = 0\n\t\tfor one_setting in obc_setting:\n\t\t\tstart_idx = previous_idx + 1\n\t\t\tfor one_column in xrange(1, one_setting['columns'] + 1):\n\t\t\t\tif one_setting['columns'] == 1:\n\t\t\t\t\tds_name = one_setting['db_field'] + '_' + name_tage\n\t\t\t\telse:\n\t\t\t\t\tds_name = one_setting['db_field'] + str(one_column) + '_'+ name_tage\n\n\t\t\t\tidx = start_idx + one_column - 1\n\t\t\t\t#factor = int(one_setting['factor'])\n\t\t\t\t#print one_setting['factor'] \n\t\t\t\tfactor =one_setting['factor']\t\t \n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_one_channel", "data": "def draw_one_channel(channel):\n\tif len(channel_table_3day) <= 0:\n\t\treturn True\n\tif len(channel_table_1month) <= 0:\n\t\treturn True\n\tif len(Calc_channel_table_3day) <= 0:\n\t\treturn True\n\tif len(Calc_channel_table_1month) <= 0:\n\t\treturn True\n\t\n\ttmpfile3day = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n\t\t\t+ '.ch' + format(channel, '02d') + '.3day'\n\tsql_3day = common.get_obc_3dim_sql(ins_conf.obc_3dim_to_db.values(),str(channel),\n\t\t\t\t\t\t\t\t  channel_table_3day, conf.obc_select_prefix_sql,\n\t\t\t\t\t\t\t\t  conf.obc_3dim_where_sql) \\\n\t\t+ conf.export_txt%(tmpfile3day + '.txt')\n\tbegin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + channel_table_3day[0] \\\n\t\t\t\t+ conf.obc_3dim_where_sql + str(channel) + \" limit 1\"\n\t\t\t\t\n\ttmpfile1month = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n\t\t\t+ '.ch' + format(channel, '02d')+ '.1month' \n\tsql_1month = common.get_obc_3dim_sql(ins_conf.obc_3dim_to_db.values(),str(channel),\n\t\t\t\t\t\t\t\t  channel_table_1month, conf.obc_select_prefix_sql,\n\t\t\t\t\t\t\t\t  conf.obc_3dim_where_sql) \\\n\t\t+ conf.export_txt%(tmpfile1month + '.txt')\n\t\t\n\t\t\n\ttmpfile3day_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n\t\t\t+ '.ch' + format(channel, '02d') + '.3day_calc'\n\tsql_3day_calc = common.get_obc_3dim_sql(ins_conf.calc_3dim_to_db.values(),str(channel),\n\t\t\t\t\t\t\t\t  Calc_channel_table_3day, conf.obc_select_prefix_sql,\n\t\t\t\t\t\t\t\t  conf.obc_3dim_where_sql) \\\n\t\t+ conf.export_txt%(tmpfile3day_calc + '.txt')\n\t\n\t\t\t\t\n\ttmpfile1month_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n\t\t\t+ '.ch' + format(channel, '02d')+ '.1month_calc' \n\tsql_1month_calc = common.get_obc_3dim_sql(ins_conf.calc_3dim_to_db.values(),str(channel),\n\t\t\t\t\t\t\t\t  Calc_channel_table_1month, conf.obc_select_prefix_sql,\n\t\t\t\t\t\t\t\t  conf.obc_3dim_where_sql) \\\n\t\t+ conf.export_txt%(tmpfile1month_calc + '.txt')\t\n\t\t\n\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor(MySQLdb.cursors.DictCursor)\n\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\t  \n\t\tcur.execute(sql_3day)\n\t\tcur.execute(sql_1month)\n\t\t#print Calc_channel_table_3day\n\t\t#print \"-------------------------------------\"\n\t\t#print sql_1month_calc\n\t\tcur.execute(sql_3day_calc)\n\t\tcur.execute(sql_1month_calc)\n\t\tcur.execute(begin_sql_3day)\n\t\tbegin_data = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\t# do NOT exit in thread!! To avoid zombie process.\n\t\tmsg = 'draw obc 3-dim ch' + str(channel) + ' png`Mysql Fatal Error[' \\\n\t\t\t+ str(e.args[0]) + ']: ' + e.args[1]\t\t\t  \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\n\ttmpfile1year = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() + '.CH' + format(channel, '02d') +'.1year' + '.obc'\n\ttmpfilelife = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() + '.CH' + format(channel, '02d') +'.life' + '.obc'\n\n\tget_channel_txt(tmpfile1year,tmpfilelife,'cal_coef1',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'cal_coef2',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'cal_coef3',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'gain',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'agc',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'SPBB1',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'SPBB2',channel)\n\n\t\n\t\n\ttmphdf = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS()+ '.CH' +format(channel, '02d')+'.HDF'\n\tprint tmphdf\n\t# trans txt result to numpy fmt, to easy hdf create.\n\tdata_3day = numpy.loadtxt(tmpfile3day + '.txt', dtype='str', delimiter=',')\n\tdata_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n\t\n\tdata_3day_calc = numpy.loadtxt(tmpfile3day_calc + '.txt', dtype='str', delimiter=',')\n\tdata_1month_calc = numpy.loadtxt(tmpfile1month_calc + '.txt', dtype='str', delimiter=',')\n\t\n\n\thfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_1month[:, 0]) )\n\thfile.create_dataset(\"time_1month\", data = ymdh_arr.astype(numpy.int32))\n\t\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n\thfile.create_dataset(\"time_1month_calc\", data = ymdh_arr.astype(numpy.int32))\n\t \n\tret = create_obc_hdf('1month',hfile,data_1month, ins_conf.obc_3dim_to_db.values())\n\tret = create_obc_hdf('1month',hfile,data_1month_calc, ins_conf.calc_3dim_to_db.values())\n\tif not ret:\n\t\treturn False\n\t\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_3day[:, 0]) )\n\thfile.create_dataset(\"time_3day\", data = ymdh_arr.astype(numpy.int32)) \n\t\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n\thfile.create_dataset(\"time_3day_calc\", data = ymdh_arr.astype(numpy.int32))\n\t\t\n\tret = create_obc_hdf('3day',hfile,data_3day, ins_conf.obc_3dim_to_db.values())\n\tret = create_obc_hdf('3day',hfile,data_3day_calc, ins_conf.calc_3dim_to_db.values())\n\tif not ret:\n\t\treturn False\n\t\n\t#hfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n\t#ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n\t#hfile.create_dataset(\"time_1month_channel_calc\", data = ymdh_arr.astype(numpy.int32)) \n\t#ret = create_obc_hdf('1month',hfile,data_1month_calc, ins_conf.calc_3dim_to_db.values())\n\t#if not ret:\n\t#\treturn False\n\t\n\t#ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n\t#hfile.create_dataset(\"time_3day_channel_calc\", data = ymdh_arr.astype(numpy.int32))\t \n\t#ret = create_obc_hdf('3day',hfile,data_3day_calc, ins_conf.calc_3dim_to_db.values())\n\t#if not ret:\n\t#\treturn False\n\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'cal_coef1',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'cal_coef2',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'cal_coef3',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'gain',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'agc',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'SPBB1',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'SPBB2',hfile)\n\t\n\n\thfile.close()\n\t\n\t#return \n\t\n\n\n\t# like: FY3C_MWTS_20140303_0259_TO_20140428_1159_12H_CH01_[PRT|INS_TEMP|...]\n\tpng_title = sat.upper() + '_' + ins.upper() + '_' \\\n\t\t\t\t+ begin_data[0]['ymdhms'].strftime(\"%Y%m%d\") + '_' \\\n\t\t\t\t+ begin_data[0]['ymdhms'].strftime(\"%H%M\") + '_TO_' \\\n\t\t\t\t+ datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d') \\\n\t\t\t\t+ '_' \\\n\t\t\t\t+ datetime.utcfromtimestamp(timespan['end_t']).strftime('%H%M') \\\n\t\t\t\t+ '_' \\\n\t\t\t\t+ format(int(hour_span), '02d') + 'H_CH' \\\n\t\t\t\t+ format(channel,'02d')\n\t\n\tret = draw_channel(tmphdf, format(channel,'02d'), png_title,begin_data[0]['ymdhms'].strftime(\"%Y%m%d\"),\\\n\t\t\t\t\t   datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d'))\n\t\n\treturn True\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_channel", "data": "def draw_channel(tmphdf, channel, png_title, begin_time, end_time):\n\tcmd = []\n\tsds_len = len(conf.draw_ncl_new[ins]['ncl_prog_channel'])\n\tfor i in xrange(0, sds_len): \n\t\tfile_out = \"/home/fymonitor/MONITORFY3C/py2/plot/\" + png_title + '_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png']\n\t\tncl_name = \"/home/fymonitor/MONITORFY3C/py2/plot/\" + sat.upper() + '_' + ins.upper()+'_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + '_4SUB.ncl'\n\t\ttemp_log = conf.tmp_path + '/monitor.' + log_tag + '.ch' + channel+'.' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] +'.log'\n\t\ttemp_cmd = conf.ncl + \" 'sat=\\\"\" + sat.upper() + \"\\\"' \" \\\n\t\t\t+ \"'instrument=\\\"\" + ins.upper() + \"\\\"' channel=\" + str(channel) \\\n\t\t\t+ \" 'file_in=\\\"\" + tmphdf + \"\\\"' \" \\\n\t\t\t+ \" 'file_out=\\\"\" + file_out + \"\\\"' \" \\\n\t\t\t+ \" 'file_title=\\\"\" + png_title + '_' +conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + \"\\\"' \" +  ncl_name \\\n\t\t\t+ ' > ' + temp_log + ' 2>&1'\n\t\tprint temp_cmd\n\t\t\n\t\tcmd.append(temp_cmd)\n\n\t#print cmd\n\n\t#use map:16.6s ; not use map:44.52s\n\ttimeuse_begin = time.time()\n\t\n\tfor cmd_temp in cmd:\n\t\tprint cmd_temp\n\t\t(status, output) = commands.getstatusoutput(cmd_temp)\n\t\tcommon.debug(my_log, log_tag, str(status) + '`' + cmd_temp + '`' + output)\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "get_channel_txt", "data": "def get_channel_txt(tmpfile1year,tmpfilelife,type,channel):\n\t#now_time = datetime.datetime.now()\n\tnow_time = datetime.now()\n\t#yes_time = now_time + datetime.timedelta(days=(-365))\n\tyes_time = now_time + timedelta(days=(-365))\n\tlast_year = yes_time.strftime('%Y-%m-%d %H:%M:%S')\n\n\t#select * from FY3C_MWTS_DAILY order by ymdh desc limit 365;\n\tsql_1year = 'select * from FY3C_MWHS_DAILY_15 where type = \\''+type + \\\n\t\t\t\t'\\'' + ' and channel = ' + str(channel) +' and ymdh > ' + '\\'' +last_year + '\\'' + \\\n\t\t\t\tconf.export_txt%(tmpfile1year +'.' +type + '.txt')\n\n\tsql_life = 'select * from FY3C_MWHS_DAILY_15 where type = \\''+type + \\\n\t\t\t\t'\\''  + ' and channel = ' + str(channel)\\\n\t\t\t\t+ conf.export_txt%(tmpfilelife +'.' +type + '.txt')\n\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor(MySQLdb.cursors.DictCursor)\n\t\tconn.select_db(conf.db_setting['stat_db'])\t  \n\t\tcur.execute(sql_1year)\n\t\tcur.execute(sql_life)\n\t\tbegin_data = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\t# do NOT exit in thread!! To avoid zombie process.\n\t\tmsg = 'export channel date `Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1] \n\t\tprint msg\t\t\t \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\n\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "get_obc_txt", "data": "def get_obc_txt(tmpfile1year,tmpfilelife,type):\n\t#now_time = datetime.datetime.now()\n\tnow_time = datetime.now()\n\t#yes_time = now_time + datetime.timedelta(days=(-365))\n\tyes_time = now_time + timedelta(days=(-365))\n\tlast_year = yes_time.strftime('%Y-%m-%d %H:%M:%S')\n\t\n\t\n\t#select * from FY3C_MWTS_DAILY order by ymdh desc limit 365;\n\tsql_1year = 'select * from FY3C_MWHS_DAILY where type = \\''+type + \\\n\t\t\t\t'\\'' + ' and ymdh > ' + '\\'' +last_year + '\\'' + \\\n\t\t\t\tconf.export_txt%(tmpfile1year +'.' +type + '.txt')\n\tsql_life = 'select * from FY3C_MWHS_DAILY where type = \\''+type + '\\''\\\n\t\t\t\t+ conf.export_txt%(tmpfilelife +'.' +type + '.txt')\n\t\t\t\t\n\t#print sql_1year\n\t#print \"----------\"\n\t#print sql_life\n\n\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor(MySQLdb.cursors.DictCursor)\n\t\tconn.select_db(conf.db_setting['stat_db'])\t  \n\t\tcur.execute(sql_1year)\n\t\tcur.execute(sql_life)\n\t\tbegin_data = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\t# do NOT exit in thread!! To avoid zombie process.\n\t\tmsg = 'qqqdraw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1] \n\t\tprint msg\t\t\t \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "create_1year_hdf", "data": "def create_1year_hdf(tmpfile1year,tmpfilelife,type,hfile):\n\tdata_1year = numpy.loadtxt(tmpfile1year +'.' +type + '.txt', dtype='str', delimiter=',')\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_1year[:, 0]) )\n\thfile.create_dataset(type+\"_time_1year\", data = ymdh_arr.astype(numpy.int32))\n\thfile.create_dataset(type+\"_avg_1year\",data=data_1year[: ,3].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_max_1year\",data=data_1year[: ,4].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_min_1year\",data=data_1year[: ,5].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_std_1year\",data=data_1year[: ,6].astype(numpy.float32)) \n\t\n\t\n\tdata_life = numpy.loadtxt(tmpfilelife +'.' +type + '.txt', dtype='str', delimiter=',')\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_life[:, 0]) )\n\thfile.create_dataset(type+\"_time_life\", data = ymdh_arr.astype(numpy.int32))\n\thfile.create_dataset(type+\"_avg_life\",data=data_life[: ,3].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_max_life\",data=data_life[: ,4].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_min_life\",data=data_life[: ,5].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_std_life\",data=data_life[: ,6].astype(numpy.float32)) \n\t  \n\treturn True\n\t\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "create_1year_hdf_channel", "data": "def create_1year_hdf_channel(tmpfile1year,tmpfilelife,type,hfile):\n\tdata_1year = numpy.loadtxt(tmpfile1year +'.' +type + '.txt', dtype='str', delimiter=',')\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_1year[:, 0]) )\n\thfile.create_dataset(type+\"_time_1year\", data = ymdh_arr.astype(numpy.int32))\n\thfile.create_dataset(type+\"_avg_1year\",data=data_1year[: ,4].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_max_1year\",data=data_1year[: ,5].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_min_1year\",data=data_1year[: ,6].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_std_1year\",data=data_1year[: ,7].astype(numpy.float32)) \n\t\n\t\n\tdata_life = numpy.loadtxt(tmpfilelife +'.' +type + '.txt', dtype='str', delimiter=',')\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_life[:, 0]) )\n\thfile.create_dataset(type+\"_time_life\", data = ymdh_arr.astype(numpy.int32))\n\thfile.create_dataset(type+\"_avg_life\",data=data_life[: ,4].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_max_life\",data=data_life[: ,5].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_min_life\",data=data_life[: ,6].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_std_life\",data=data_life[: ,7].astype(numpy.float32)) \n\t  \n\treturn True\n\t \n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_just_obc", "data": "def draw_just_obc():\n\tif len(obc_table_3day) <= 0:\n\t\treturn True\n\tif len(obc_table_1month) <= 0:\n\t\treturn True\n\tif len(Calc_table_3day) <= 0:\n\t\treturn True\n\tif len(Calc_table_1month) <= 0:\n\t\treturn True\n\t\n\ttmpfile3day = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.3day' +'.obc'\n\tsql_3day = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n\t\t\t\t\t\t\t\t  obc_table_3day, conf.obc_select_prefix_sql) \\\n\t\t+ conf.export_txt%(tmpfile3day + '.txt')\n\tbegin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + obc_table_3day[0] \\\n\t\t\t\t+ \" limit 1\"   \n\t\n\ttmpfile1month = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.1month' +'.obc'\n\tsql_1month = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n\t\t\t\t\t\t\t\t  obc_table_1month, conf.obc_select_prefix_sql) \\\n\t\t+ conf.export_txt%(tmpfile1month + '.txt')\n\t\t\n\n\n\ttmpfile3day_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.3day.calc' +'.obc'\n\tsql_3day_calc = common.get_obc_2dim_sql(ins_conf.calc_to_db.values(),ins_conf.channels,\n\t\t\t\t\t\t\t\t  Calc_table_3day, conf.obc_select_prefix_sql) \\\n\t\t + conf.export_txt%(tmpfile3day_calc + '.txt')  \n\t  \n\ttmpfile1month_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.1month.calc' +'.obc'\n\tsql_1month_calc = common.get_obc_2dim_sql(ins_conf.calc_to_db.values(),ins_conf.channels,\n\t\t\t\t\t\t\t\t  Calc_table_1month, conf.obc_select_prefix_sql) \\\n\t\t + conf.export_txt%(tmpfile1month_calc + '.txt')\n\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor(MySQLdb.cursors.DictCursor)\n\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\t  \n\t\tcur.execute(sql_3day)\n\t\tcur.execute(sql_1month)\n\t\tcur.execute(sql_3day_calc)\n\t\tcur.execute(sql_1month_calc)\n\t\tcur.execute(begin_sql_3day)\n\t\tbegin_data = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\t# do NOT exit in thread!! To avoid zombie process.\n\t\t#print sql_3day\n\t\t#print \"------------------\"\n\t\t#print sql_1month\n\t\t#print \"------------------\"\n\t\t#print sql_3day_calc\n\t\t#print \"------------------\"\n\t\t#print sql_1month_calc\n\t\t#print \"------------------\"\n\t\t#print begin_sql_3day\n\t\t#print \"------------------\"\n\t\tmsg = '??draw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1] \n\t\tprint msg\t\t\t \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\t\n \n\ttmpfile1year = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.1year' + '.obc'\n\ttmpfilelife = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.life' + '.obc'\n\n\t\n\tsds_len = len(ins_conf.sds_name)\n\tfor i in xrange(1, sds_len+1):\n\t\tget_obc_txt(tmpfile1year,tmpfilelife,ins_conf.sds_name[i]['name'])\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_nochannel", "data": "def draw_nochannel(tmphdf, png_title, begin_time, end_time):\t\n\tcmd = []\n\tsds_len = len(conf.draw_ncl_new[ins]['ncl_prog_no_channel'])\n\tfor i in xrange(0, sds_len): \n\t\tfile_out = conf.plot_path + '/'+ png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png']\n\t\tfile_title = png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png']\n\t\tncl_name = conf.plot_path +'/' + sat.upper() +'_' + ins.upper() +'_'+ conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] + '_4SUB.ncl'\n\t\ttemp_log = conf.tmp_path + '/monitor.' + log_tag +'.' + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] +'.log'\n\t\ttemp_cmd = conf.ncl + \" 'sat=\\\"\" + sat.upper() + \"\\\"' \" \\\n\t\t\t+ \"'instrument=\\\"\" + ins.upper() + \"\\\"\" +'\\'' \\\n\t\t\t+ \" 'file_in=\\\"\" + tmphdf + \"\\\"' \" \\\n\t\t\t+ \" 'file_out=\\\"\" + file_out + \"\\\"' \" \\\n\t\t\t+ \" 'file_title=\\\"\" + file_title + \"\\\"' \" +  ncl_name \\\n\t\t\t+ ' > ' + temp_log + ' 2>&1'\n\t\tprint temp_cmd\n\t\tcmd.append(temp_cmd)\n\n\t#print cmd\n \n\ttimeuse_begin = time.time()\n\t\n\tfor cmd_temp in cmd:\n\t\tprint cmd_temp\n\t\t(status, output) = commands.getstatusoutput(cmd_temp)\n\t\tcommon.debug(my_log, log_tag, str(status) + '`' + cmd_temp + '`' + output)\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_obc", "data": "def draw_obc(input):\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "main", "data": "def main():\n\tglobal my_channel_table\n\tglobal my_Calc_channel_table\n\tglobal my_obc_table\n\tglobal my_Calc_table\n\t\n\tcommon.wt_file(my_pidfile, str(pid))\n\tcommon.info(my_log, log_tag, time_tag + 'program start')\n\n\t# register signal function.\n\tsignal.signal(signal.SIGTERM, signal_handler)   \n\tsignal.signal(signal.SIGINT, signal_handler)\t  \n\t\n\t# check ps result, kill previous same program, avoiding hang.\n\t# we do NOT grep --date=2014-04-27-18 for convenience.\n\tcmd = conf.ps + ' -elf | ' + conf.grep + ' ' + conf.bin_path + ' | ' \\\n\t\t+ conf.grep + ' -v grep | ' + conf.grep + ' -v tail | ' + conf.grep \\\n\t\t+ ' -v bash | ' + conf.grep + ' ' + fname + ' | ' + conf.grep \\\n\t\t+ \" '\\-\\-sat=\" + sat + \"' | \" + conf.grep + \" '\\-\\-ins=\" + ins \\\n\t\t+ \"' | \" + conf.grep + \" '\\-\\-span=\" + hour_span + \"' | \" \\\n\t\t+ conf.awk + \" '{print $4}'\"\n\t(status, value) = commands.getstatusoutput(cmd)\n\tpid_list = value.split()\n\tfor one_pid in pid_list:\n\t\tif int(one_pid) != pid:\n\t\t\tmsg = 'more then one prog find, kill old same prog[' + one_pid + ']'\n\t\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\t\tcmd = conf.kill + ' -kill ' + one_pid\n\t\t\tcommands.getstatusoutput(cmd)\n\t\n\t#get the correct tables. we MUST get table name from INFO db, not show tables!!\n\t\"\"\"\n\tWe MUST create fy3b-mwts table's info, for easy time search\n\talso, there is a BUG... ...\n\t\"\"\"\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor()\n\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\n\t\tcur.execute('show tables') # the result is already sorted by ascii.\n\t\tall_tables = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\tmsg = 'Mysql Fatal Error[' + str(e.args[0])+']: '+e.args[1] \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\tsys.exit(3)\n\t\t\n\t# ignore L1B table.\n\tall_obc_table = [ x for x in all_tables if 'OBCXX_MS' in x[0] ]\n\t\n\tCalc_tag = 'OBCXX_MS_CALC'\n\tCalc_channel_tag='OBCXX_MS_CALC_'\n\tCalc_table = [ x for x in all_obc_table if Calc_tag in x[0]]\n\tCalc_channel_table=[ x for x in Calc_table if Calc_channel_tag in x[0]]\n\tCalc_table =[ x for x in Calc_table if Calc_channel_tag not in x[0]]\n\t\n\tchannel_tag = 'OBCXX_MS_' + str(ins_conf.channels)\n\tchannel_table = [ x for x in all_obc_table if channel_tag in x[0]]\n\tchannel_table=list(set(channel_table).difference(set(Calc_table)).difference(set(Calc_channel_table)))\n\t\n\tobc_table = list(set(all_obc_table).difference(set(Calc_table)).difference(set(channel_table)).difference(set(Calc_channel_table))) #return in all_obc_table but no in channel_table\n\t#print obc_table\n\t#print \"-------------------------\"\n\t#print Calc_table\n\t#print \"-------------------------\"\n\t#print channel_table\n\t#print \"-------------------------\"\n\t#print Calc_channel_table\n\n\n\tfor idx, one_table in enumerate(Calc_table):\n\t\ttable_t = one_table[0][19:32] # FY3B_MWTSX_GBAL_L1_20131123_0501_060KM_MS\n\t\ttimeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n\t\tcur_timeStamp = time.mktime(timeArray)\n\t\tif idx < len(all_tables) - 1:\n\t\t\ttable_t = all_tables[idx+1][0][19:32]\n\t\t\ttimeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n\t\t\tnext_timeStamp = time.mktime(timeArray)\n\t\telse:\n\t\t\ttimeArray = time.strptime('3013-12-08 00:00', \"%Y-%m-%d %H:%M\")\n\t\t\tnext_timeStamp = time.mktime(timeArray)\n\t\t\n\t\tif timespan['begin_t'] == cur_timeStamp:\n\t\t\tmy_Calc_table.extend([one_table[0]])\n\t\telif timespan['begin_t'] > cur_timeStamp \\\n\t\t\tand timespan['begin_t'] < next_timeStamp:\n\t\t\tmy_Calc_table.extend([one_table[0]])\n\t\telif timespan['begin_t'] < cur_timeStamp \\\n\t\t\tand timespan['end_t'] > cur_timeStamp:\n\t\t\tmy_Calc_table.extend([one_table[0]])\n\t\telif timespan['end_t'] == cur_timeStamp:\n\t\t\tbreak\n\t\t\t\n\tif len(my_Calc_table)<=0:\n\t\tmsg = time_tag + 'no table found for my_Calc_table data'\n\t\tcommon.warn(my_log, log_tag, msg)\n\t\t\n\t#now_time = datetime.datetime.now()\n\tnow_time = datetime.now() - timedelta(days = 3)\n\tshifen = now_time.strftime(\"%H%M\")\n\t\n\tif int(shifen)< 0030:\n\t\tfor i in range(0, 3):\n\t\t\tyes_time = now_time + datetime.timedelta(days=(-3 + i))\n\t\t\tymd = yes_time.strftime('%Y%m%d')\n\t\t\tymd = '201410'+ymd[6:8]\n\t\t\tfor idx, one_table in enumerate(my_channel_table):\n\t\t\t\tif ymd in one_table:\n\t\t\t\t\tCalc_table_3day.extend([one_table])\n\telse:\n\t\tfor i in range(0, 3):\n\t\t\t#yes_time = now_time + datetime.timedelta(days=(-2 + i))\n\t\t\tyes_time = now_time + timedelta(days=(-2 + i))\n\t\t\tymd = yes_time.strftime('%Y%m%d')\n\t\t\tymd = '201410'+ymd[6:8]\n\t\t\tfor idx, one_table in enumerate(my_Calc_table):\n\t\t\t\tif ymd in one_table:\n\t\t\t\t\tCalc_table_3day.extend([one_table])\n   \n\tfor i in range(0, 30):\n\t\t#yes_time = now_time + datetime.timedelta(days=(-30 + i))\n\t\tyes_time = now_time + timedelta(days=(-30 + i))\n\t\tymd = yes_time.strftime('%Y%m%d')\n\t\tymd = '201410'+ymd[6:8]\n\t\tfor idx, one_table in enumerate(my_Calc_table):\n\t\t\tif ymd in one_table:\n\t\t\t\tCalc_table_1month.extend([one_table])\n\n", "description": "\n\tWe MUST create fy3b-mwts table's info, for easy time search\n\talso, there is a BUG... ...\n\t", "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}], [{"term": "def", "name": "add", "data": "def add(num1, num2):\n\tans = str(round(float(num1) + num2, 2))\n\tnum1s = str(num1)\n\tnum2s = str(num2)\n\tcalc = [num1s, '+', num2s, '=', ans]\n\treturn ans, calc\n", "description": null, "category": "math", "imports": []}, {"term": "def", "name": "subtract", "data": "def subtract(num1, num2):\n\tans = str(round(float(num1) - num2, 2))\n\tnum1s = str(num1)\n\tnum2s = str(num2)\n\tcalc = [num1s, '-', num2s, '=', ans]\n\treturn ans, calc\n", "description": null, "category": "math", "imports": []}, {"term": "def", "name": "multiply", "data": "def multiply(num1, num2):\n\tans = str(round(float(num1) * num2, 2))\n\tnum1s = str(num1)\n\tnum2s = str(num2)\n\tcalc = [num1s, 'x', num2s, '=', ans]\n\treturn ans, calc\n", "description": null, "category": "math", "imports": []}, {"term": "def", "name": "divide", "data": "def divide(num1, num2):\n\tans = str(round(float(num1) / num2, 2))\n\tnum1s = str(num1)\n\tnum2s = str(num2)\n\tcalc = [num1s, chr(247), num2s, '=', ans]\n\treturn ans, calc\n", "description": null, "category": "math", "imports": []}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "TSF_calc_Initwords", "data": "def TSF_calc_Initwords(TSF_words):\t#TSF_doc:\u96fb\u5353\u95a2\u9023\u306e\u30ef\u30fc\u30c9\u3092\u8ffd\u52a0\u3059\u308b(TSFAPI)\u3002\n\tTSF_words[\"#TSF_brackets\"]=TSF_calc_brackets; TSF_words[\"#\u6570\u5f0f\u306b\u9023\u7d50\"]=TSF_calc_brackets\n\tTSF_words[\"#TSF_calcFX\"]=TSF_calc_calcFX; TSF_words[\"#\u5206\u6570\u8a08\u7b97\"]=TSF_calc_calcFX\n\tTSF_words[\"#TSF_calcFXQQ\"]=TSF_calc_calcFXQQ; TSF_words[\"#\u5206\u6570\u4e5d\u4e5d\"]=TSF_calc_calcFXQQ\n\tTSF_words[\"#TSF_calcDC\"]=TSF_calc_calcDC; TSF_words[\"#\u5c0f\u6570\u8a08\u7b97\"]=TSF_calc_calcDC\n\tTSF_words[\"#TSF_calcDCQQ\"]=TSF_calc_calcDCQQ; TSF_words[\"#\u5c0f\u6570\u4e5d\u4e5d\"]=TSF_calc_calcDCQQ\n\tTSF_words[\"#TSF_calcKN\"]=TSF_calc_calcKN; TSF_words[\"#\u5358\u4f4d\u8a08\u7b97\"]=TSF_calc_calcKN\n\tTSF_words[\"#TSF_calcKNQQ\"]=TSF_calc_calcKNQQ; TSF_words[\"#\u5358\u4f4d\u4e5d\u4e5d\"]=TSF_calc_calcKNQQ\n\tTSF_words[\"#TSF_calcPR\"]=TSF_calc_calcPR; TSF_words[\"#\u6709\u52b9\u6841\u6570\"]=TSF_calc_calcPR\n\tTSF_words[\"#TSF_calcRO\"]=TSF_calc_calcRO; TSF_words[\"#\u7aef\u6570\u51e6\u7406\"]=TSF_calc_calcRO\n\treturn TSF_words\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_calcbrackets", "data": "def TSF_calc_calcbrackets(TSF_tsvBL,TSF_tsvBR):   #TSF_doc:\u62ec\u5f27\u3067\u30b9\u30bf\u30c3\u30af\u3092\u9023\u7d50\u3059\u308b\u3002\n\tTSF_tsvA=TSF_Forth_popthat()\n\tfor TSF_stacksK,TSF_stacksV in TSF_Forth_stacksitems():\n\t\tTSF_calcK=\"\".join([TSF_tsvBL,TSF_stacksK])\n\t\tif TSF_calcK in TSF_tsvA:\n\t\t\tfor TSF_stackC,TSF_stackQ in enumerate(TSF_stacksV):\n\t\t\t\tTSF_calcK=\"\".join([TSF_tsvBL,TSF_stacksK,str(TSF_stackC),TSF_tsvBR])\n\t\t\t\tif TSF_calcK in TSF_tsvA:\n\t\t\t\t\tTSF_tsvA=TSF_tsvA.replace(TSF_calcK,TSF_stackQ)\n\tfor TSF_stackC in range(TSF_Forth_stackslen()):\n\t\tTSF_calcK=\"\".join([TSF_tsvBL,str(TSF_stackC),TSF_tsvBR])\n\t\tif TSF_calcK in TSF_tsvA:\n\t\t\tTSF_tsvA=TSF_tsvA.replace(TSF_calcK,TSF_Forth_popthat())\n\t\telse:\n\t\t\tbreak\n\treturn TSF_tsvA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_brackets", "data": "def TSF_calc_brackets():   #TSF_doc:[stackN\u2026stackB,stackA,count,calc,brackets]\u3053\u308c\u81ea\u4f53\u306f\u8a08\u7b97\u306f\u305b\u305a\u3001\u4efb\u610f\u306e\u62ec\u5f27\u306b\u56f2\u307e\u308c\u305f\u30b9\u30bf\u30c3\u30af\u756a\u53f7\u3092\u30b9\u30bf\u30c3\u30af\u5185\u5bb9\u306b\u7f6e\u63db\u3002brackets\u3068calc\u81ea\u8eab\u3068calc\u5185\u306e\u8a72\u5f53\u62ec\u5f27\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u3002\n\tTSF_tsvB=TSF_Forth_popthat()\n\tif len(TSF_tsvB) < 2: TSF_tsvB=\"[]\"\n\tTSF_tsvBL,TSF_tsvBR=TSF_tsvB[0],TSF_tsvB[-1]\n\tTSF_Forth_pushthat(TSF_calc_calcbrackets(TSF_tsvBL,TSF_tsvBR))\n\treturn None\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_calcFX", "data": "def TSF_calc_calcFX():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3059\u308b\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n\tTSF_Forth_pushthat(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),None))\n\treturn None\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_calcFXQQ", "data": "def TSF_calc_calcFXQQ():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3059\u308b(\u6697\u8a18\u3082\u3059\u308b)\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n\tTSF_Forth_pushthat(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),True))\n\treturn None\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_calcDC", "data": "def TSF_calc_calcDC():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3057\u3066\u7d50\u679c\u3092\u5c0f\u6570\u307e\u305f\u306f\u6574\u6570\u3067\u8868\u793a\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n\tTSF_Forth_pushthat(TSF_calc_decimalizeDC(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),None)))\n\treturn None\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_calcDCQQ", "data": "def TSF_calc_calcDCQQ():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3057\u3066\u7d50\u679c\u3092\u5c0f\u6570\u307e\u305f\u306f\u6574\u6570\u3067\u8868\u793a(\u6697\u8a18\u3082\u3059\u308b)\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n\tTSF_Forth_pushthat(TSF_calc_decimalizeDC(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),True)))\n\treturn None\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_calcKN", "data": "def TSF_calc_calcKN():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3057\u3066\u7d50\u679c\u3092\u6f22\u6570\u5b57\u3092\u6df7\u305c\u3066\u3067\u8868\u793a\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n\tTSF_Forth_pushthat(TSF_calc_decimalizeKN(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),None)))\n\treturn None\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_calcKNQQ", "data": "def TSF_calc_calcKNQQ():   #TSF_doc:[calc]\u5206\u6570\u96fb\u5353\u3057\u3066\u7d50\u679c\u3092\u6f22\u6570\u5b57\u3092\u6df7\u305c\u3066\u3067\u8868\u793a(\u6697\u8a18\u3082\u3059\u308b)\u3002calc\u3068\u9023\u7d50\u5206\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0b\u308d\u3057\u30011\u30b9\u30bf\u30c3\u30af\u7a4d\u307f\u4e0a\u3052\u3002\n\tTSF_Forth_pushthat(TSF_calc_decimalizeKN(TSF_calc(TSF_calc_calcbrackets(\"[\",\"]\"),True)))\n\treturn None\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_calcPR", "data": "def TSF_calc_calcPR():   #TSF_doc:[prec]\u6709\u52b9\u6841\u6570\u3092\u5909\u66f4\u3059\u308b\u3002\u6841\u6570\u304c\u5909\u308f\u308b\u3068\u540c\u3058\u5f0f\u3067\u3082\u5024\u304c\u5909\u308f\u308b\u306e\u3067\u6697\u8a18(\u4e5d\u4e5d)\u3082\u521d\u671f\u5316\u3059\u308b\u3002\n\tTSF_calc_precision(TSF_Forth_popintthe(TSF_Forth_stackthat()))\n\treturn None\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_calcRO", "data": "def TSF_calc_calcRO():   #TSF_doc:[round]\u7aef\u6570\u51e6\u7406\u3092\u5909\u66f4\u3059\u308b\u3002\u7aef\u6570\u304c\u5909\u308f\u308b\u3068\u540c\u3058\u5f0f\u3067\u3082\u5024\u304c\u5909\u308f\u308b\u306e\u3067\u6697\u8a18(\u4e5d\u4e5d)\u3082\u521d\u671f\u5316\u3059\u308b\u3002\n\tTSF_calc_rounding(TSF_Forth_popintthe(TSF_Forth_stackthat()))\n\treturn None\n\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_precision", "data": "def TSF_calc_precision(TSF_prec):\t#TSF_doc:\u96fb\u5353\u306e\u6709\u52b9\u6841\u6570\u3092\u5909\u66f4\u3059\u308b\u3002\u521d\u671f\u5024\u306f72\u6841(\u5343\u7121\u91cf\u5927\u6570)\u3002\u5186\u5468\u7387\u3068\u30cd\u30a4\u30d4\u30a2\u6570\u30824\u6841\u63a7\u3048\u3066\u518d\u8a08\u7b97\u3059\u308b\u3002\n\tglobal TSF_calc_precisionMAX,TSF_calc_precisionPI,TSF_calcQQmemory\n\tTSF_calc_precisionMAX=min(max(TSF_prec,5),1000); TSF_calc_precisionPI=TSF_calc_precisionMAX-4\n\tdecimal.getcontext().prec=TSF_calc_precisionMAX*2\n\tTSF_PI_A,TSF_PI_B,TSF_PI_T,TSF_PI_C=decimal.Decimal(1),decimal.Decimal(1)/decimal.Decimal(2).sqrt(),decimal.Decimal(1)/decimal.Decimal(4),decimal.Decimal(1)\n\tfor TSF_PI_X in range(int(math.ceil(math.log(TSF_calc_precisionPI,2)))):\n\t   TSF_PI_AB=decimal.Decimal(TSF_PI_A+TSF_PI_B)/decimal.Decimal(2)\n\t   TSF_PI_B=decimal.getcontext().sqrt(TSF_PI_A*TSF_PI_B)\n\t   TSF_PI_T-=decimal.Decimal(TSF_PI_C)*decimal.getcontext().power(TSF_PI_A-TSF_PI_AB,2)\n\t   TSF_PI_A=TSF_PI_AB; TSF_PI_C*=2\n\tTSF_PI_P2=decimal.getcontext().power(TSF_PI_A+TSF_PI_B,2)/TSF_PI_T/decimal.Decimal(2)\n\tTSF_calc_PI2=str(TSF_PI_P2).replace('.',''); TSF_calc_PI=str(TSF_PI_P2/decimal.Decimal(2)).replace('.','')\n\tTSF_PI_E,TSF_PI_K=decimal.Decimal(1),decimal.Decimal(1)\n\tfor TSF_PI_X in range(TSF_calc_precisionPI):\n\t\tTSF_PI_K*=decimal.Decimal(TSF_PI_X+1)\n\t\tTSF_PI_E+=decimal.Decimal(1)/TSF_PI_K\n\tTSF_calc_E=str(TSF_PI_E).replace('.','')\n\tdecimal.getcontext().prec=TSF_calc_precisionMAX\n\tTSF_calcQQmemory={}\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_rounding", "data": "def TSF_calc_rounding(TSF_round):\t#TSF_doc:\u96fb\u5353\u306e\u7aef\u6570\u51e6\u7406\u3092\u6307\u5b9a\u3002\u521d\u671f\u5024\u306fROUND_DOWN(\u30bc\u30ed\u65b9\u5411\u306b\u4e38\u3081\u308b)\n\tglobal TSF_calc_precisionROUND,TSF_calcQQmemory\n\tTSF_calc_precisionROUND=TSF_calc_roundopt.get(TSF_round,decimal.ROUND_DOWN)\n\tdecimal.getcontext().prec=TSF_calc_precisionROUND\n\tTSF_calcQQmemory={}\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_bracketsbalance", "data": "def TSF_calc_bracketsbalance(TSF_calcQ):\t#TSF_doc:\u62ec\u5f27\u306e\u30d0\u30e9\u30f3\u30b9\u3092\u6574\u3048\u308b\u3002\u3064\u3044\u3067\u306b\u7121\u52b9\u306a\u6f14\u7b97\u5b50\u3092\u9664\u53bb\u3057\u305f\u308a\u5186\u5468\u7387\u5104\u5343\u4e07\u306a\u3069\u8a08\u7b97\u306e\u4e0b\u6e96\u5099\u3002\n\tTSF_calcA=\"\"; TSF_calcbracketLR,TSF_calcbracketCAP=0,0\n\tfor TSF_opewordK,TSF_opewordV in TSF_calc_opeword.items():\n\t\tTSF_calcQ=TSF_calcQ.replace(TSF_opewordK,TSF_opewordV)\n\tfor TSF_calcbracketQ in TSF_calcQ:\n\t\tTSF_calcA+=TSF_calc_operator.get(TSF_calcbracketQ,'')\n\t\tif TSF_calcbracketQ == '(':\n\t\t\tTSF_calcbracketLR+=1\n\t\tif TSF_calcbracketQ == ')':\n\t\t\tTSF_calcbracketLR-=1\n\t\t\tif TSF_calcbracketLR 0:\n\t\tTSF_calcA=TSF_calcA+')'*abs(TSF_calcbracketLR)\n\tif TSF_calcbracketLR < 0:\n\t\tTSF_calcA='('*abs(TSF_calcbracketLR)+TSF_calcA\n\tTSF_calcA='('*abs(TSF_calcbracketCAP)+TSF_calcA+')'*abs(TSF_calcbracketCAP)\n\tTSF_calcA=re.sub(re.compile(\"([0-9\u5343\u767e\u5341]+?)\u92ad\"),\"+(\\\\1)/100\",TSF_calcA)\n\tfor TSF_okusenK,TSF_okusenV in TSF_calc_okusendic.items():\n\t\tTSF_calcA=re.sub(re.compile(\"\".join([\"([0-9\u5343\u767e\u5341]+?)\",TSF_okusenK])),\"\".join([\"(\\\\1)*\",TSF_okusenV,\"+\"]),TSF_calcA)\n\tTSF_calcA=re.sub(re.compile(\"([0-9]+?)\u5343\"),\"(\\\\1*1000)+\",TSF_calcA)\n\tTSF_calcA=re.sub(re.compile(\"([0-9]+?)\u767e\"),\"(\\\\1*100)+\",TSF_calcA)\n\tTSF_calcA=re.sub(re.compile(\"([0-9]+?)\u5341\"),\"(\\\\1*10)+\",TSF_calcA)\n\tTSF_calcA=TSF_calcA.replace('\u92ad',\"1|100+\")\n\tTSF_calcA=TSF_calcA.replace('\u5341',\"10+\")\n\tTSF_calcA=TSF_calcA.replace('\u767e',\"100+\")\n\tTSF_calcA=TSF_calcA.replace('\u5343',\"1000+\")\n\tfor TSF_okusenK,TSF_okusenV in TSF_calc_okusendic.items():\n\t\tTSF_calcA=TSF_calcA.replace(TSF_okusenK,\"\".join([TSF_okusenV,\"+\"]))\n\tTSF_calcA=TSF_calcA.replace('y',\"\".join([TSF_calc_PI[:TSF_calc_precisionPI],\"|1\",'0'*(TSF_calc_precisionPI-1)]))\n\tTSF_calcA=TSF_calcA.replace('Y',\"\".join([TSF_calc_PI2[:TSF_calc_precisionPI],\"|1\",'0'*(TSF_calc_precisionPI-1)]))\n\tTSF_calcA=TSF_calcA.replace('e',\"\".join([TSF_calc_E[:TSF_calc_precisionPI],\"|1\",'0'*(TSF_calc_precisionPI-1)]))\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc", "data": "def TSF_calc(TSF_calcQ,TSF_calcQQ=None):\t#TSF_doc:\u5206\u6570\u96fb\u5353\u306emain\u3002\u62ec\u5f27\u306e\u5185\u5074\u3092\u691c\u7d22(\u6b63\u898f\u8868\u73fe)\u3002\n\tglobal TSF_calcQQmemory\n\tTSF_calcA=\"n|0\"\n\tTSF_calcA=TSF_calc_bracketsbalance(TSF_calcQ);\n\tTSF_calc_bracketreg=re.compile(\"[(](?<=[(])[^()]*(?=[)])[)]\")\n\twhile \"(\" in TSF_calcA:\n\t\tfor TSF_calcK in re.findall(TSF_calc_bracketreg,TSF_calcA):\n\t\t\tTSF_calcA=TSF_calcA.replace(TSF_calcK,TSF_calc_referential(TSF_calcK,TSF_calcQQ))\n\tTSF_calcA=TSF_calcA.replace(TSF_calcA,TSF_calc_referential(TSF_calcA,TSF_calcQQ))\n\treturn TSF_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_referential", "data": "def TSF_calc_referential(TSF_calcQ,TSF_calcQQ=None):\t#TSF_doc:\u5206\u6570\u96fb\u5353\u306e\u548c\u96c6\u5408\u7a4d\u96c6\u5408\u304a\u3088\u3073\u30bc\u30ed\u6bd4\u8f03\u6f14\u7b97\u5b50\u7cfb\u3002\n\tglobal TSF_calcQQmemory\n\tTSF_calcQ=TSF_calcQ.lstrip(\"(\").rstrip(\")\")\n\tif TSF_calcQQ != None:\n\t\tif TSF_calcQQ == True:\n\t\t\tTSF_calcA=TSF_calcQ.replace(TSF_calcQ,TSF_calcQQmemory.get(TSF_calcQ,TSF_calc_function(TSF_calcQ))); TSF_calcQQmemory[TSF_calcQ]=TSF_calcA\n\t\telse:\n\t\t\tTSF_calcA=TSF_calcQ.replace(TSF_calcQ,TSF_calc_function(TSF_calcQ))\n\telse:\n\t\tTSF_calcA=TSF_calcQ.replace(TSF_calcQ,TSF_calcQQmemory.get(TSF_calcQ,TSF_calc_function(TSF_calcQ)))\n\treturn TSF_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_Fermatmodulo", "data": "def TSF_calc_Fermatmodulo(TSF_calcSeq,TSF_pow,TSF_modulo):\t#\u51aa\u4e57\u30e2\u30b8\u30e5\u30ed\u3002\u7d20\u6570\u306e\u30d5\u30a7\u30eb\u30de\u30fc\u30c6\u30b9\u30c8\u306a\u3069\u3067\u4f7f\u7528\u3002\n\ttry:\n\t\tTSF_calcA=\"0\"\n\t\tTSF_calcSeq=decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_calcSeq))).to_integral_value()\n\t\tTSF_pow=decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_pow))).to_integral_value()\n\t\tTSF_modulo=decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_modulo))).to_integral_value()\n\t\tTSF_calcA=str(decimal.getcontext().power(TSF_calcSeq,TSF_pow,TSF_modulo))\n\texcept decimal.InvalidOperation:\n\t\tTSF_calcA=\"n|0\"\n\treturn TSF_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_function_limit", "data": "def TSF_calc_function_limit(TSF_LimFirst,TSF_LimRest):\t#TSF_doc:\u548c\u96c6\u5408\u7a4d\u96c6\u5408\u306erange\u4f5c\u6210\u3002\n\ttry:\n\t\tTSF_LimStart,TSF_LimGoal=decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_LimFirst))).to_integral_value(),decimal.Decimal(TSF_calc_decimalizeDC(TSF_calc_addition(TSF_LimRest))).to_integral_value()\n\t\tif TSF_LimStart <= TSF_LimGoal:\n\t\t\tTSF_limstep=1; TSF_LimGoal+=1\n\t\telse:\n\t\t\tTSF_limstep=-1; TSF_LimGoal-=1\n\t\treturn range(TSF_LimStart,TSF_LimGoal,TSF_limstep)\n\texcept decimal.InvalidOperation:\n\t\tTSF_LimStart,TSF_LimGoal,TSF_limstep=None,None,None\n\t\treturn range(0)\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_function", "data": "def TSF_calc_function(TSF_calcQ):\t#TSF_doc:\u5206\u6570\u96fb\u5353\u306e\u548c\u96c6\u5408\u7a4d\u96c6\u5408\u304a\u3088\u3073\u30bc\u30ed\u6bd4\u8f03\u6f14\u7b97\u5b50\u7cfb\u3002\n\tTSF_calcOfind=-1; TSF_calc_NOZUin=\"\"\n\tfor TSF_calc_NOZU in TSF_calc_NOZUs.keys():\n\t\tif TSF_calc_NOZU in TSF_calcQ:\n\t\t\tTSF_calc_NOZUin+=TSF_calc_NOZU\n\t\t\tTSF_calcOfind=TSF_calcQ.find(TSF_calc_NOZUin)\n\tif TSF_calcOfind >= 0:\n\t\tTSF_calcQ='\\t'.join([TSF_calcQ[:TSF_calcOfind],TSF_calcQ[TSF_calcOfind+1:]])\n\t\tfor TSF_calc_NOZU in TSF_calc_NOZUin:\n\t\t\tTSF_calcQ=TSF_calcQ.replace(TSF_calc_NOZU,'')\n\t\tTSF_calc_NOZU=TSF_calc_NOZUin[-1]\n\t\tTSF_calcSeq,TSF_calcLim=TSF_calcQ.split('\\t')\n\t\tif not '~' in TSF_calcLim:\n\t\t\tif TSF_calc_NOZU in \"MP\":\n\t\t\t\tTSF_calcLim=\"~\".join([\"1\",TSF_calcLim])\n\t\t\telif TSF_calc_NOZU in \"$\":\n\t\t\t\tTSF_calcLim=TSF_calcLim\n\t\t\telse:\n\t\t\t\tTSF_calcLim=\"~\".join([TSF_calcLim,\"0\"])\n\t\tif '~' in TSF_calcLim:\n\t\t\tTSF_LimFirst,TSF_LimRest=TSF_calcLim.split('~')[0],TSF_calcLim.split('~')[-1]\n\t\telse:\n\t\t\tTSF_LimFirst,TSF_LimRest=TSF_calcLim,TSF_calcLim\n\t\tTSF_calcQ=TSF_calc_NOZUs[TSF_calc_NOZU](TSF_calcSeq,TSF_LimFirst,TSF_LimRest)\n\tTSF_calcA=TSF_calc_addition(TSF_calcQ)\n\treturn TSF_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_addition", "data": "def TSF_calc_addition(TSF_calcQ):\t#TSF_doc:\u5206\u6570\u96fb\u5353\u306e\u8db3\u3057\u7b97\u5f15\u304d\u7b97\u30fb\u6d88\u8cbb\u7a0e\u8a08\u7b97\u7b49\u3002\n\tTSF_calcLN,TSF_calcLD=decimal.Decimal(0),decimal.Decimal(1)\n\tTSF_calcQ=TSF_calcQ.replace('+','\\t+').replace('-','\\t-').replace('~','').replace(',','')\n\tTSF_calcQsplits=TSF_calcQ.strip('\\t').split('\\t')\n\tfor TSF_calcQmulti in TSF_calcQsplits:\n\t\tTSF_calcO=TSF_calcQmulti[0] if len(TSF_calcQmulti)>0 else '+'\n\t\tTSF_calcO=TSF_calcO if not '%' in TSF_calcQmulti else '%'\n\t\tTSF_calcR=TSF_calc_multiplication(TSF_calcQmulti.replace('%',''))\n\t\tTSF_calcRN,TSF_calcRD=TSF_calcR.split('|')\n\t\tif float(TSF_calcRD) == 0.0:\n\t\t\tTSF_calcA=\"n|0\"\n\t\t\tbreak\n\t\tif TSF_calcO == '%':\n\t\t\tTSF_calcLN=TSF_calcLN*decimal.Decimal(100)+TSF_calcLN*decimal.Decimal(TSF_calcRN)*TSF_calcLD\n\t\t\tTSF_calcLD=TSF_calcLD*decimal.Decimal(100)\n\t\telse:  # TSF_calcO == '+' or TSF_calcO == '-':\n\t\t\tTSF_calcLN=TSF_calcLN*decimal.Decimal(TSF_calcRD)+decimal.Decimal(TSF_calcRN)*TSF_calcLD\n\t\t\tTSF_calcLD=TSF_calcLD*decimal.Decimal(TSF_calcRD)\n\t\ttry:\n\t\t\tTSF_GCD=fractions.gcd(TSF_calcLN,TSF_calcLD)\n\t\t\tTSF_calcLN=TSF_calcLN//TSF_GCD\n\t\t\tTSF_calcLD=TSF_calcLD//TSF_GCD\n\t\t\tif TSF_calcLD < 0: TSF_calcLN,TSF_calcLD=-TSF_calcLN,-TSF_calcLD\n\t\t\tTSF_calcA=\"|\".join([str(TSF_calcLN),str(TSF_calcLD)])\n\t\texcept decimal.InvalidOperation:\n\t\t\tTSF_calcA=\"n|0\"\n\tif TSF_calcA != \"0|1\" and TSF_calcA != \"n|0\":\n\t\tTSF_calcA=TSF_calcA.replace('-','m') if TSF_calcA.startswith(\"-\") else \"\".join([\"p\",str(TSF_calcA)])\n\treturn TSF_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_multiplication", "data": "def TSF_calc_multiplication(TSF_calcQ):\t#TSF_doc:\u5206\u6570\u96fb\u5353\u306e\u639b\u3051\u7b97\u5272\u308a\u7b97\u7b49\u3002\u516c\u500d\u6570\u516c\u7d04\u6570\u3001\u6700\u5927\u5024\u6700\u5c0f\u5024\u3082\u6271\u3046\u3002\n\tTSF_calcLN,TSF_calcLD=decimal.Decimal(1),decimal.Decimal(1)\n\tTSF_calcQ=TSF_calcQ.replace('*',\"\\t*\").replace('/',\"\\t/\").replace('\\\\',\"\\t\\\\\").replace('#',\"\\t#\").replace('&',\"\\t&\")\n\tTSF_calcQ=TSF_calcQ.replace('G',\"G\\t\").replace('g',\"g\\t\").replace('^',\"^\\t\").replace('l',\"l\\t\").replace('A',\"A\\t\").replace('a',\"a\\t\").replace('>',\">\\t\").replace('<',\"<\\t\")\n\tTSF_calcQsplits=TSF_calcQ.replace(\"\\t\\t\",'\\t').strip('\\t').split('\\t')\n\tfor TSF_calcQmulti in TSF_calcQsplits:\n\t\tTSF_calcO=TSF_calcQmulti[0] if len(TSF_calcQmulti)>0 else '*'\n\t\tTSF_calcO=TSF_calcO if not 'G' in TSF_calcQmulti else 'G'\n\t\tTSF_calcO=TSF_calcO if not 'g' in TSF_calcQmulti else 'g'\n\t\tTSF_calcO=TSF_calcO if not '^' in TSF_calcQmulti else '^'\n\t\tTSF_calcO=TSF_calcO if not 'l' in TSF_calcQmulti else 'l'\n\t\tTSF_calcO=TSF_calcO if not 'A' in TSF_calcQmulti else 'A'\n\t\tTSF_calcO=TSF_calcO if not 'a' in TSF_calcQmulti else 'a'\n\t\tTSF_calcO=TSF_calcO if not '>' in TSF_calcQmulti else '>'\n\t\tTSF_calcO=TSF_calcO if not '<' in TSF_calcQmulti else '<'\n\t\tTSF_calcR=TSF_calc_fractalize(TSF_calcQmulti.lstrip('*/\\\\#').rstrip('Gg^lAa><').replace('&',''))\n\t\tTSF_calcRN,TSF_calcRD=TSF_calcR.split('|')\n\t\tif decimal.Decimal(TSF_calcRD) == 0:\n\t\t\tTSF_calcA=\"n|0\"\n\t\t\tbreak\n\t\tif TSF_calcO == '/':\n\t\t\tTSF_calcLN=TSF_calcLN*decimal.Decimal(TSF_calcRD)\n\t\t\tTSF_calcLD=TSF_calcLD*decimal.Decimal(TSF_calcRN)\n\t\t\tif TSF_calcLD < 0: TSF_calcLN,TSF_calcLD=-TSF_calcLN,-TSF_calcLD\n\t\telif TSF_calcO == '\\\\':\n\t\t\tTSF_calcLN=TSF_calcLN*decimal.Decimal(TSF_calcRD)\n\t\t\tTSF_calcLD=TSF_calcLD*decimal.Decimal(TSF_calcRN)\n\t\t\tTSF_calcLN,TSF_calcLD=TSF_calcLN//TSF_calcLD,1\n\t\t\tif TSF_calcLD < 0: TSF_calcLN,TSF_calcLD=-TSF_calcLN,-TSF_calcLD\n\t\telif TSF_calcO == '#':\n\t\t\tif decimal.Decimal(TSF_calcRN) == 0:\n\t\t\t\tTSF_calcLD=0\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_fractalize", "data": "def TSF_calc_fractalize(TSF_calcQ):\t#TSF_doc:\u5206\u6570\u96fb\u5353\u306a\u306e\u3067\u5c0f\u6570\u3092\u5206\u6570\u306b\u3002\u3064\u3044\u3067\u306b\u5e73\u65b9\u6839\u3084\u4e09\u89d2\u95a2\u6570\u3082\u30020\u3067\u5272\u308b\u3001\u3082\u3057\u304f\u306f\u6841\u304c\u9650\u754c\u8d8a\u3048\u305f\u3068\u304d\u306a\u3069\u306f\u300cn|0\u300d\u3092\u8fd4\u3059\u3002\n\tTSF_calcQ=TSF_calcQ.replace('/','|').rstrip('.').rstrip('+')\n\tif not '|' in TSF_calcQ:\n\t\tTSF_calcQ=\"|\".join([TSF_calcQ,\"1\"])\n\tTSF_calcM=TSF_calcQ.count('m')+TSF_calcQ.count('-') if not '!' in TSF_calcQ else 0\n\tTSF_calcQ=TSF_calcQ.replace('p','').replace('m','').replace('-','').replace('!','')\n\tTSF_calc_SCTin=\"\"\n\tfor TSF_calcSCT in TSF_calc_SCTs.keys():\n\t\tif TSF_calcSCT in TSF_calcQ:\n\t\t\tTSF_calc_SCTin+=TSF_calcSCT\n\t\t\tTSF_calcQ=TSF_calcQ.replace(TSF_calcSCT,'')\n\tTSF_calcR=TSF_calcQ.split('|'); TSF_calcNs,TSF_calcDs=TSF_calcR[0],TSF_calcR[1:]\n\tif len(TSF_calcNs) == 0: TSF_calcNs=\"0\"\n\tif \"n\" in TSF_calcNs:\n\t\tTSF_calcA=\"n|0\"\n\telse:\n\t\ttry:\n\t\t\tTSF_calcN=decimal.Decimal(TSF_calcNs)\n\t\texcept decimal.InvalidOperation:\n\t\t\tTSF_calcN=decimal.Decimal(\"0\")\n\t\tTSF_calcD=decimal.Decimal(\"1\")\n\t\tfor TSF_calcDmulti in TSF_calcDs:\n\t\t\tif len(TSF_calcDmulti) == 0: TSF_calcDmulti=\"0\"\n\t\t\ttry:\n\t\t\t\tTSF_calcD=TSF_calcD*decimal.Decimal(TSF_calcDmulti)\n\t\t\texcept decimal.InvalidOperation:\n\t\t\t\tTSF_calcD=decimal.Decimal(\"0\")\n\t\tif TSF_calcD != decimal.Decimal(\"0\"):\n\t\t\ttry:\n\t\t\t\tTSF_GCD=fractions.gcd(TSF_calcN,TSF_calcD)\n\t\t\t\tTSF_calcN=TSF_calcN//TSF_GCD\n\t\t\t\tTSF_calcD=TSF_calcD//TSF_GCD\n\t\t\t\tif TSF_calcM%2 != 0:\n\t\t\t\t\tTSF_calcN=-TSF_calcN\n\t\t\t\tTSF_calcA=\"|\".join([str(TSF_calcN),str(TSF_calcD)])\n\t\t\texcept decimal.InvalidOperation:\n\t\t\t\tTSF_calcA=\"n|0\"\n\t\telse:\n\t\t\tTSF_calcA=\"n|0\"\n\tif TSF_calcA != \"n|0\":\n\t\tif len(TSF_calc_SCTin) > 0:\n\t\t\tfor TSF_calcSCT in TSF_calc_SCTin:\n\t\t\t\ttry:\n\t\t\t\t\tTSF_calcA=TSF_calc_SCTs[TSF_calcSCT](TSF_calcN,TSF_calcD)\n\t\t\t\texcept ValueError:\n\t\t\t\t\tTSF_calcA=\"n|0\"\n\t\t\t\texcept decimal.InvalidOperation:\n\t\t\t\t\tTSF_calcA=\"n|0\"\n\t\t\t\tTSF_calcA=TSF_calc_fractalize(TSF_calcA)\n\treturn TSF_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_LCM", "data": "def TSF_calc_LCM(TSF_calcN,TSF_calcD):\t#TSF_doc:\u6700\u5c0f\u516c\u500d\u6570\u306e\u8a08\u7b97\u3002\n\treturn decimal.Decimal(TSF_calcN*TSF_calcD)//decimal.Decimal(fractions.gcd(TSF_calcN,TSF_calcD))\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_decimalizeDC", "data": "def TSF_calc_decimalizeDC(TSF_calcQ):\t#TSF_doc:\u5206\u6570(\u304c\u5165\u529b\u3055\u308c\u3066\u308b\u3082\u306e\u3068\u4fe1\u7528\u3057\u3066)\u3092\u5909\u63db\u3057\u3066\u5c0f\u6570\u3092\u8fd4\u3059\u3002\u305f\u3060\u3057\u300cn|0\u300d\u306e\u6642\u306f\u300cn|0\u300d\u3092\u8fd4\u3059\u3002\n\tTSF_calcRN,TSF_calcRD=TSF_calcQ.replace('m','-').replace('p','').split('|')\n\tif float(TSF_calcRD) != 0.0:\n\t\tTSF_calcA=str(decimal.Decimal(TSF_calcRN)/decimal.Decimal(TSF_calcRD))\n\telse:\n\t\tTSF_calcA=\"n|0\"\n\treturn TSF_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_decimalizeKN", "data": "def TSF_calc_decimalizeKN(TSF_calcQ):\t#TSF_doc:\u5206\u6570(\u304c\u5165\u529b\u3055\u308c\u3066\u308b\u3082\u306e\u3068\u4fe1\u7528\u3057\u3066)\u3092\u5909\u63db\u3057\u30664\u6841\u6bce\u306b\u6f22\u5b57\u3067\u8fd4\u3059\u3002\u305f\u3060\u3057\u300cn|0\u300d\u306e\u6642\u306f\u300cn|0\u300d\u3092\u8fd4\u3059\u3002\n\tTSF_calcF=\"\u30de\u30a4\u30ca\u30b9\" if TSF_calcQ.startswith('m') else \"\"\n\tTSF_calcRN,TSF_calcRD=TSF_calcQ.replace('m','').replace('p','').split('|')\n\tif float(TSF_calcRD) != 0.0:\n\t\tTSF_calcA=\"\".join([TSF_calcF,TSF_calc_decimalizeKNcomma(TSF_calcRD),\"\u5206\u306e\",TSF_calc_decimalizeKNcomma(TSF_calcRN)])\n\t\tTSF_calcA=TSF_calcA.replace(\"1\u5206\u306e\",'')\n\telse:\n\t\tTSF_calcA=\"n|0\"\n\tTSF_calcA=TSF_calcA.replace('\u6052','\u6052\u6cb3\u6c99').replace('\u963f','\u963f\u50e7\u7947').replace('\u90a3','\u90a3\u7531\u4ed6').replace('\u601d','\u4e0d\u53ef\u601d\u8b70').replace('\u91cf','\u7121\u91cf\u5927\u6570')\n\treturn TSF_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_decimalizeKNcomma", "data": "def TSF_calc_decimalizeKNcomma(TSF_calcQ):\t#TSF_doc:\u6574\u6570\u30924\u6841\u3067\u533a\u5207\u3063\u3066\u6f22\u6570\u5b57\u3092\u4ed8\u3051\u308b\u3002\n\tTSF_calcA=\"\"\n\tTSF_calcO=decimal.Decimal(TSF_calcQ); TSF_calcK=TSF_calcO%decimal.Decimal(10000)\n\tif TSF_calcK:\n\t\tTSF_calcA=\"\".join([TSF_calcA,str(TSF_calcK)])\n\tfor TSF_okusenK in TSF_calc_okusenman:\n\t\tTSF_calcO=TSF_calcO//decimal.Decimal(10000); TSF_calcK=TSF_calcO%decimal.Decimal(10000)\n\t\tif TSF_calcK > decimal.Decimal(0):\n\t\t\tTSF_calcA=\"\".join([str(TSF_calcK),TSF_okusenK,TSF_calcA])\n\tif TSF_calcO > decimal.Decimal(10000):\n\t\tTSF_calcO=TSF_calcO//decimal.Decimal(10000)\n\t\tTSF_calcA=\"\".join([str(TSF_calcO),TSF_calcA])\n\treturn TSF_calcA\n\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}, {"term": "def", "name": "TSF_calc_debug", "data": "def TSF_calc_debug():\t#TSF_doc:\u300cTSF/TSF_calc.py\u300d\u5358\u4f53\u30c6\u30b9\u30c8\u98a8\u30c7\u30d0\u30c3\u30b0\u95a2\u6570\u3002\n\tTSF_debug_log=\"\"\n\tTSF_Forth_init(TSF_argvs,[TSF_calc_Initwords])\n\tTSF_Forth_setTSF(TSF_Forth_1ststack(),\"\\t\".join([\"UTF-8\",\"#TSF_encoding\",\"10\",\"#TSF_calcPR\",\"TSF_calctest:\",\"#TSF_this\",\"0\",\"#TSF_fin.\"]))\n\tTSF_Forth_setTSF(\"TSF_calc.py:\",\"\\t\".join([\"Python{0.major}.{0.minor}.{0.micro}\".format(sys.version_info),sys.platform,TSF_io_stdout]))\n\tTSF_Forth_setTSF(\"TSF_calctest:\",\"\\t\".join([\"TSF_calc\u6f22\u6570\u5b57:\",\"#TSF_that\",\"\u4e00\u5272\u308b\u4e09\u5f15\u304f(\u30de\u30a4\u30ca\u30b9\u4e8c\u5206\u306e\u4e00)\",\"#TSF_calcFX\"]))\n\tTSF_Forth_addfin(TSF_argvs)\n\tTSF_Forth_run()\n\tfor TSF_thename in TSF_Forth_stackskeys():\n\t\tTSF_debug_log=TSF_Forth_view(TSF_thename,True,TSF_debug_log)\n\tTSF_debug_log=TSF_io_printlog(\"#--- OrderedDict ---\",TSF_debug_log)\n\tLTsv_calcQlist=OrderedDict([\n\t\t(\"TSF_calc\u6f22\u6570\u5b57:\",[\"\u4e00\u5272\u308b\u4e09\u5f15\u304f(\u30de\u30a4\u30ca\u30b9\u4e8c\u5206\u306e\u4e00)\",\"2\u5206\u306e1\u30925\u4e57\",\"(2\u5206\u306e1)\u30925\u4e57\",\"2\u5206\u306e(1\u30925\u4e57)\",\"(100\u5206\u306e1)\u30925\u4e57\",\"(8\u4e07\u5206\u306e1)\u30925\u4e57\",\"(478\u4e07\u5206\u306e1)\u30925\u4e57\",\"\u5104\",\"\u4e8c\u767e\u4e07\u5186\",\"\u5341\u5104\u767e\u4e8c\u5341\u5186\",\"\u5341\u5104\u3068\u98db\u3093\u3067\u767e\u4e8c\u5341\u5186\",\"\u767e\u4e8c\u5341\u5186\",\"3.14\",\"\u5186\u5468\u7387\",\"\u30cd\u30a4\u30d4\u30a2\u6570\",\"\u221e\",\"\u221a\uff12\",\"\u221am2\",\"\uff12\u306e\u5e73\u65b9\u6839\",\"256\u3092\u4e8c\u9032\u5bfe\u6570\",\"\uff12\u309216\u4e57\",\"\u7121\u91cf\u5927\u6570\"]),\n\t\t(\"TSF_calc\u5c0f\u6570\u5206\u6570\u30d1\u30fc\u30bb\u30f3\u30c8:\",[\"0.5|3.5\",\"0.5/3.5\",\"1|2/7|2\",\"2|3|5|7\",\"0/100\",\"100/0\",\"10000+%8\", \"10000-5%\",\"7\\\\3\",\"3.14\\\\1\",\"9#6\",\"3|2#1|3\",\"-6\",\"m6\",\"-m6\",\"-6!\",\"m6!\",\"-m6!\"]),\n\t\t(\"TSF_calc\u30bc\u30ed\u6bd4\u8f03\u6f14\u7b97\u5b50(\u4e09\u9805\u6f14\u7b97\u5b50):\",[\"m1Z1|1~0|1\",\"0Z1|1~0|1\",\"p1Z1|1~0|1\",\"m1z1|1~0|1\",\"0z1|1~0|1\",\"p1z1|1~0|1\"]),\n\t\t(\"TSF_calc\u30bc\u30ed\u4ee5\u4e0a\u6f14\u7b97\u5b50(\u4e09\u9805\u6f14\u7b97\u5b50):\",[\"m1O1|1~0|1\",\"0O1|1~0|1\",\"p1O1|1~0|1\",\"m1o1|1~0|1\",\"0o1|1~0|1\",\"p1o1|1~0|1\"]),\n\t\t(\"TSF_calc\u30bc\u30ed\u4ee5\u4e0b\u6f14\u7b97\u5b50(\u4e09\u9805\u6f14\u7b97\u5b50):\",[\"m1U1|1~0|1\",\"0U1|1~0|1\",\"p1U1|1~0|1\",\"m1u1|1~0|1\",\"0u1|1~0|1\",\"p1u1|1~0|1\"]),\n\t\t(\"TSF_calc\u30bc\u30ed\u9664\u7b97\u6f14\u7b97\u5b50(\u4e09\u9805\u6f14\u7b97\u5b50):\",[\"n|0N1|1~0|1\",\"0/1N1|1~0|1\",\"1/0N1|1~0|1\",\"1/0?1|1~0|1\",\"n|0Z1|1~0|1\",\"n|0z1|1~0|1\",\"n|0O1|1~0|1\",\"n|0o1|1~0|1\",\"n|0U1|1~0|1\",\"n|0u1|1~0|1\"]),\n\t\t(\"TSF_calc max,min:\",[\"0&0<\",\"0&1<\",\"1&0<\",\"1&1<\",\"0&0>\",\"0&1>\",\"1&0>\",\"1&1>\"]),\n\t\t(\"TSF_calc\u5e73\u65b9\u6839atan2:\",[\"\u221a\uff12\",\"0&m9a\",\"0&m9a\",\"m9&m9A\",\"m9&m9a\",\"m9&0A\",\"m9&0a\",\"0&9A\",\"0&9a\",\"9&9A\",\"9&9a\",\"9&0A\",\"9&0a\",\"9&m9A\",\"9&m9a\",\"0&m9A\",\"0&0A\",\"0&0a\"]),\n\t\t(\"TSF_calc\u5bfe\u6570\u4e57\u6570:\",[\"E1\",\"E2\",\"Ee\",\"E0\",\"L10000\",\"L256\",\"E256/E2\",\"L256/L2\",\"E256+L256\",\"256&2l\",\"254&2l\",\"10000&10l\",\"81&3l\",\"E(256-2)\",\"E(254)\",\"2&16^\",\"2&1|2^\",\"2&0^\",\"2&0|0^\",\"0&0^\",\"2&2^+3&2^\"]),\n\t\t(\"TSF_calc\u5186\u5468\u7387:\",[\"y\",\"Y\",\"\u03c0\",\"\u03b8\",\"\u03b8|2\",\"\u03b8*30|360\",\"\u03b8/360*30\",\"30|360*\u03b8\",\"S(\u03b8*30|360)\",\"S(Y/360*30)\"]),\n\t\t(\"TSF_calc\u4e09\u89d2\u95a2\u6570sincostan:\",[\"sin(\u03b8*0|360)\",\"S(\u03b8*30|360)\",\"S(\u03b8*60|360)\",\"S(\u03b8*90|360)\",\"cos(\u03b8*0|360)\",\"C(\u03b8*30|360)\",\"C(\u03b8*60|360)\",\"C(\u03b8*90|360)\",\"tan(\u03b8*0|360)\",\"T(\u03b8*30|360)\",\"T(\u03b8*60|360)\",\"T(\u03b8*90|360)\"]),\n\t\t(\"TSF_calc\u548c\u6570\u5217\u7a4d\u6570\u5217:\",[\"kM7\",\"kM5~10\",\"kM10~0\",\"kP7\",\"kP5~10\",\"kP10~0\",\"kP10~2\",\"kM100\",\"kP1~10\",\"2P16\"]),\n\t\t(\"TSF_calc\u516c\u7d04\u6570\u516c\u500d\u6570:\",[\"12&16G\",\"12\u306816\u306e\u516c\u7d04\u6570\",\"12\u306816\u306e\u6700\u5927\u516c\u7d04\u6570\",\"12&16g\",\"12\u306816\u306e\u516c\u500d\u6570\",\"12\u306816\u306e\u6700\u5c0f\u516c\u500d\u6570\"]),\n\t\t(\"TSF_calc\u51aa\u4e57\u30e2\u30b8\u30e5\u30ed(\u7d20\u6570\u30d5\u30a7\u30eb\u30de\u30fc\u30c6\u30b9\u30c8):\",[\"2F0~0\",\"3F0~0\",\"2F7~7\",\"3F7~7\",\"2F60~60\",\"3F60~60\",\"2F341~341\",\"3F341~341\",\"2F561~561\",\"3F561~561\"]),\n\t])\n\tfor TSF_QlistK,TSF_QlistV in iter(LTsv_calcQlist.items()):\n\t\tTSF_debug_log=TSF_io_printlog(\"#{0}\".format(TSF_QlistK),TSF_log=TSF_debug_log)\n\t\tfor LTsv_calcQ in TSF_QlistV:\n\t\t\tTSF_debug_log=TSF_io_printlog(\"#\\t{0}\u21d4{1};{2};{3}\".format(LTsv_calcQ,TSF_calc(LTsv_calcQ,True),TSF_calc_decimalizeDC(TSF_calc(LTsv_calcQ,True)),TSF_calc_decimalizeKN(TSF_calc(LTsv_calcQ,True))),TSF_debug_log)\n\treturn TSF_debug_log\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import math", "import decimal", "import fractions", "import re", "from collections import OrderedDict", "from TSF_Forth import *"]}], [], [{"term": "def", "name": "makewalls", "data": "def makewalls():\n\ta, b, c, d = 0,0,0,0\n\twalls = []\n\tfor i in range(0, rootx*2+rooty*2):\n\t\tif i < rootx:\n\t\t\ta += 1\n\t\t\twalls.append(f'{a},{0}')\n\t\telif i < rootx*2:\n\t\t\tb += 1\n\t\t\twalls.append(f'{b},{rooty}')\n\t\telif i < rootx*2+rooty:\n\t\t\tc += 1\n\t\t\twalls.append(f'{0},{c}')\n\t\telse:\n\t\t\td += 1\n\t\t\twalls.append(f'{rootx},{d}')\n\n\treturn walls\n\n", "description": null, "category": "math", "imports": ["import tkinter as tk"]}, {"term": "def", "name": "calculateXYtoAdd", "data": "def calculateXYtoAdd(angle):\n\tXY_to_add = [0, 0]\n\tif angle == 90:\n\t\tXY_to_add = [0, 90]\n\tif angle == 180:\n\t\tXY_to_add = [90, 0]\n\tif angle == 270:\n\t\tXY_to_add = [0, -90]\n\tif angle == 360:\n\t\tXY_to_add = [-90, 0]\n\n\tif 0 < angle < 90:\n\t\tXY_to_add = [angle-90, -90]\n\tif 90 < angle < 180:\n\t\tXY_to_add = [angle-90, 90]\n\tif 180 < angle < 270:\n\t\tXY_to_add = [90, angle-90]\n\tif 270 < angle < 360:\n\t\tXY_to_add = [-90, angle-90]\n\n\tXY_to_add[0] = XY_to_add[0]/90\n\tXY_to_add[1] = XY_to_add[1] / 90\n\treturn XY_to_add\n", "description": null, "category": "math", "imports": ["import tkinter as tk"]}, {"term": "def", "name": "draw", "data": "def draw(pos):\n\tcanvas.create_rectangle(pos[0], pos[1], pos[0]+10, pos[1]+10, fill='white')\n\tcanvas.update()\n\n", "description": null, "category": "math", "imports": ["import tkinter as tk"]}, {"term": "def", "name": "calcDistance", "data": "def calcDistance(pos, direction):\n\tglobal AllDistances\n\tAllDistances = []\n\tcalcPos = [0, 0]\n\tcalcAngle = (direction - 50)\n\tdistance = 0\n\tfor a in range(0, 100):\n\t\tXY_add_calc = calculateXYtoAdd(calcAngle)\n\t\tdistance = 0\n\t\tcalcPos = CharacterXY\n\n\t\twhile(True):\n\t\t\tcalcPos[0] += XY_add_calc[0]\n\t\t\tcalcPos[1] += XY_add_calc[1]\n\t\t\tdistance += 1\n\t\t\tif distance == 100:\n\t\t\t\tsomething = 1\n\t\t\tif f'{calcPos[0]},{calcPos[1]}' in WallsPos:\n\t\t\t\tsomething = 1\n\t\t\telse:\n\t\t\t\tbreak\n\n\t\tAllDistances.append(distance)\n\t\tcalcAngle += a\n\n\n\n", "description": null, "category": "math", "imports": ["import tkinter as tk"]}, {"term": "def", "name": "jump", "data": "def jump():\n\taaaaa = \"aaaaaaaaaaaaaaaaaaaaaaaaa\"\n\n\n\n", "description": null, "category": "math", "imports": ["import tkinter as tk"]}, {"term": "def", "name": "keydown", "data": "def keydown(key):\n\tglobal CharacterXY\n\tglobal CharacterAngle\n\n\tif key.char == 'w':\n\t\tCharacterXY[1] -= 5\n\t\tadd = calculateXYtoAdd(CharacterAngle)\n\t\tCharacterXY[0] += add[0]\n\t\tCharacterXY[1] += add[1]\n\t\tdraw(CharacterXY)\n\t\t#calcDistance(CharacterXY[0], CharacterXY[1])\n\tif key.char == 'a':\n\t\tCharacterAngle -= 1\n\t\t#calcDistance(CharacterXY[0], CharacterXY[1])\n\tif key.char == 's':\n\t\tCharacterXY[1] += 5\n\t\tadd = calculateXYtoAdd(CharacterAngle)\n\t\tCharacterXY[0] += add[0]\n\t\tCharacterXY[1] += add[1]\n\t\tdraw(CharacterXY)\n\t\t#calcDistance(CharacterXY[0], CharacterXY[1])\n\tif key.char == 'd':\n\t\tCharacterAngle += 1\n\t\t#calcDistance(CharacterXY[0], CharacterXY[1])\n\tif key.char == 'space':\n\t\tjump\n", "description": null, "category": "math", "imports": ["import tkinter as tk"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "countData", "data": "def countData(a):\n\tc=0\n\tfor i in a:\n\t\tif(i is not None):\n\t\t\tc+=1\n\t\t\t\n\treturn c\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "descData", "data": "def descData(a):\n\t\n\tcount=countData(a)\n\tmean=calcMean(a)\n\tstd=calcStd(a)\n   \n\tq1=calcQuantile(a,0.25)\n\tmedian=calcQuantile(a,0.50)\n\tq3=calcQuantile(a,0.75)\n\tminimum=calcMinimum(a)\n\tmaximum=calcMaximum(a)\n\t\t\n\tprint('Count'\t   , count)\n\tprint(\"Mean\t %.6f\" %mean)\n\tprint('std\t  %.6f' %std)\n\tprint('min\t  %.6f' %minimum)\n\tprint('25%','\t  %.6f' %q1)\n\tprint('50%','\t  %.6f' %median)\n\tprint('75%','\t  %.6f' %q3)\n\tprint('max','\t  %.6f' %maximum)\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcMinimum", "data": "def calcMinimum(nums):\n\tminimum = nums[0]\n\tfor num in nums:\n\t\tif num < minimum:\n\t\t\tminimum = num\n\treturn minimum\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcMaximum", "data": "def calcMaximum(nums):\n\tmaximum = nums[0]\n\tfor num in nums:\n\t\tif num > maximum:\n\t\t\tmaximum = num\n\treturn maximum\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcArgMinimum", "data": "def calcArgMinimum(a):\n\tmin1=100000000000\n\tfor i in range(0,len(a)):\n\t\tif(a[i]max1):\n\t\t\tmax1=a[i]\n\t\t\tidx=i\n\treturn idx\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcIdxMinimum", "data": "def calcIdxMinimum(a):\n\tmini=a[0]\n\tmin_index =0\n\tfor i in range(len(a)):\n\t\tif (a[i] < mini):\n\t\t\tmini=a[i]\n\t\t\tmin_index=i\n\treturn min_index\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcIdxMaximum", "data": "def calcIdxMaximum(a):\n\tmx=a[0]\n\tmax_index =0\n\tfor i in range(len(a)):\n\t\tif (a[i] > mx):\n\t\t\tmx=a[i]\n\t\t\tmax_index=i\n\treturn max_index\n\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcQuantile", "data": "def calcQuantile(a,q):\n\tb=a\n\tb=b.sort_values()\n\tb=b.reset_index(drop=True)\n\tn=len(b)\n\t\n\treturn b[int(n*q)]\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcSum", "data": "def calcSum(a):\n\tsum=0\n\tfor i in a :\n\t\tsum+=i\n\treturn sum\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcMean", "data": "def calcMean(a):\n\tsum=0\n\tfor i in a:\n\t\tsum+=i\n\t\t\n\tn=len(a)\n\treturn sum/n\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcMedian", "data": "def calcMedian(a):\n\tmedian=0\n\ta= sorted(a)  \n\tn=len(a)\n\tif n % 2 == 0:\n\t\tmedian1 = a[n//2]\n\t\tmedian2 = a[n//2 - 1]\n\t\tmedian = (median1 + median2)/2\n\telse:\n\t\tmedian = a[n//2]\n\treturn median\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcProduct", "data": "def calcProduct(nums):\n\tproduct = 1\n\tfor num in nums:\n\t\tproduct *= num\n\treturn product\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcMad", "data": "def calcMad(nums):\n\tmean = calcMean(nums)\n\tn = len(nums)\n\tresult = 0\n\tfor num in nums:\n\t\tresult += abs(num - mean)\n\treturn result / n\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcVariance", "data": "def calcVariance(a):\n\tM=calcMean(a)\n\tvar=0\n\tfor i in range(len(a)):\n\t\tvar = var + (a[i]-M)**2\n\tresult=var/(len(a)-1)\n\treturn result\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcStd", "data": "def calcStd(a):\n\treturn (calcVariance(a)**0.5)\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcSkewness", "data": "def calcSkewness(a):\n\tm=calcMean(a)\n\ts=calcStd(a)\n\tn=len(a)\n\t\n\tresult=[(i-m)**3 for i in a]\n\tsum1= calcSum(result)\n\t\n\treturn (sum1/((n-1)*(s**3)))\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcKurtosis", "data": "def calcKurtosis(nums):\n\tmean = calcMean(nums)\n\tstd = calcStd(nums)\n\tn = len(nums)\n\t\n\tresult = [(num - mean) ** 4 for num in nums]\n\tnumerator = calcSum(result)\n\tdenominator = (n - 1) * (std ** 4)\n\t\n\treturn numerator / denominator - 3\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcCumSum", "data": "def calcCumSum(a):\n\tnew_list=[]\n\tj=0\n\tfor i in range(0,len(a)):\n\t\tj=j+a[i]\n\t\tnew_list.append(j)\n\treturn new_list\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcCumMin", "data": "def calcCumMin(nums):\n\tresult = []\n\tfor i in range(len(nums)):\n\t\tif i == 0:\n\t\t\tresult.append(nums[i])\n\t\telse:\n\t\t\tresult.append(min(result[i-1], nums[i]))\n\treturn result\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcCumMax", "data": "def calcCumMax(a):\n\tb=[]\n\tc=[]\n\t\n\tfor i in a:\n\t\tb.append(i)\n\t\tc.append(max(b))\n\n\treturn c\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcCumProd", "data": "def calcCumProd(a):\n\ta_list=[]\n\tj=1\n\tfor i in a:\n\t\tj=j * i\n\t\ta_list.append(j)\n\treturn a_list\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "printCumulative", "data": "def printCumulative(nums):\n\tfor i in range(len(nums)):\n\t\tprint(i, '  ', nums[i])\n\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcDiff", "data": "def calcDiff(a):\n\tb=[None]\n\tfor i in range(1,len(a)):\n\t\tb.append(a[i]-a[i-1])\n\t\t\n\treturn b\n", "description": null, "category": "math", "imports": ["import time"]}, {"term": "def", "name": "calcPctChange", "data": "def calcPctChange(nums):\n\tresult = []\n\tfor i in range(len(nums)):\n\t\tif i == 0:\n\t\t\tresult.append(None)\n\t\telse:\n\t\t\tresult.append(round((nums[i] - nums[i-1]) / nums[i-1], 6))\n\treturn result\n\n", "description": null, "category": "math", "imports": ["import time"]}], [{"term": "def", "name": "trace", "data": "def trace(fn):\n\tdef wrapper(*args, **kwargs):\n\t\tfn(*args, **kwargs)\n\treturn wrapper\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from generator.actions import Actions", "from numpy import int32, uint16", "import copy", "import math", "import operator as op", "import random", "import re"]}, {"term": "class", "name": "TemplateGenerator", "data": "class TemplateGenerator(Actions):\n\tline_regex = re.compile(r'(\\d+):\\s+(\\d+)?')\n\tERR_TOO_FEW_ARGS = \"Error: Too few arguments for '{}' command\"\n\tERR_INVALID_INPUT = \"Error: Invalid input\"\n\n\tADD_HISTORY = 1\n\tNO_HISTORY = 2\n\n\tclass Stack(object):\n\t\tdef __init__(self):\n\t\t\tself._storage = []\n\n\t\tdef pop(self):\n\t\t\treturn self._storage.pop()\n\n\t\tdef peek(self,):\n\t\t\treturn self._storage[-1]\n\n\t\tdef push(self, value):\n\t\t\treturn self._storage.append(value)\n\n\t\tdef invert(self):\n\t\t\tself._storage.reverse()\n\n\t\tdef __len__(self):\n\t\t\treturn len(self._storage)\n\n\t\tdef copy(self):\n\t\t\treturn copy.deepcopy(self)\n\n\tclass CalcStack(Stack):\n\t\tdef pformat(self):\n\t\t\theight = max(len(self._storage), 80)\n\t\t\tpadding = 80 - len(self._storage) if len(self._storage) < 80 else 0\n\t\t\treturn [\n\t\t\t\t'{:03}:\\t{}'.format(height - i - 1, v)\n\t\t\t\tfor i, v in enumerate(\n\t\t\t\t\t([''] * padding) + self._storage\n\t\t\t\t)\n\t\t\t]\n\n\tdef _readln(self, s):\n\t\treturn self.read(expect=s + '\\n', delim='\\n')\n\n\tdef _writeln(self, s):\n\t\treturn self.write(s + '\\n')\n\n\tdef _parse_calc(self):\n\t\tself.read(expect='\\x1b[2J\\x1b[H', length=len('\\x1b[2J\\x1b[H'))\n\t\t# s = '\\n'.join([line for line in self.state['calc'].pformat()]) + '\\n'\n\t\t# self.read(expect=s, length=len(s))\n\t\tfor line in self.state['calc'].pformat():\n\t\t\tself._readln(line)\n\n\t\tif self.state['err']:\n\t\t\tself._readln(self.state['err'])\n\t\telse:\n\t\t\tself._readln('-' * 120)\n\n\tdef start(self):\n\t\t#self.delay(100)\n\t\tself.state['calc'] = self.CalcStack()\n\t\tself.state['hist'] = self.Stack()\n\t\tself.state['err'] = ''\n\t\tself.state['ret'] = self.ADD_HISTORY\n\t\tself.state['prev_stack'] = self.state['calc'].copy()\n\n\t\tself.write(self.magic_page[:4])\n\t\tself.read(length=0x1000, expect=self.magic_page)\n\n\t\tfor _ in xrange(8):\n\t\t\tself.command()\n\t\t\tself.implicit_push()\n\n\tdef command(self):\n\t\tif not self.state['err'] and self.state['ret'] == self.ADD_HISTORY:\n\t\t\tself.state['hist'].push(self.state['prev_stack'])\n\t\tself.state['prev_stack'] = self.state['calc'].copy()\n\n\t\tself._parse_calc()\n\n\t\tself.state['err'] = ''\n\t\tself.state['ret'] = self.ADD_HISTORY\n\n\tdef _ensure_n(self, cmd, n):\n\t\tif len(self.state['calc']) < n:\n\t\t\tself.state['err'] = self.ERR_TOO_FEW_ARGS.format(cmd)\n\t\t\treturn False\n\t\telse:\n\t\t\treturn True\n\n\tdef _unop(self, name, oper):\n\t\tcmd = name\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 1):\n\t\t\treturn\n\n\t\tself.state['calc'].push(int32(oper(self.state['calc'].pop())))\n\n\tdef _binop(self, name, oper, rev_args=False):\n\t\tcmd = name\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 2):\n\t\t\treturn\n\n\t\tv1, v2 = self.state['calc'].pop(), self.state['calc'].pop()\n\t\tif rev_args:\n\t\t\tself.state['calc'].push(int32(oper(v2, v1)))\n\t\telse:\n\t\t\tself.state['calc'].push(int32(oper(v1, v2)))\n\n\tdef implicit_push(self):\n\t\tvalue = int32(random.randint(-(2 ** 31), 2 ** 31 - 1))\n\t\tself._writeln(str(value))\n\t\tself.state['calc'].push(value)\n\n\tdef explicit_push(self):\n\t\tvalue = int32(random.randint(-(2 ** 31), 2 ** 31 - 1))\n\t\tself._writeln(\"push {}\".format(value))\n\t\tself.state['calc'].push(value)\n\n\tdef add(self):\n\t\tself._binop('+', op.add)\n\n\tdef sub(self):\n\t\tself._binop('-', op.sub, True)\n\n\tdef mul(self):\n\t\tself._binop('*', op.mul)\n\n\tdef div(self):\n\t\tcmd = '/'\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 2):\n\t\t\treturn\n\n\t\tv1, v2 = self.state['calc'].pop(), self.state['calc'].pop()\n\t\tif v1 == 0:\n\t\t\tself.state['err'] = self.ERR_INVALID_INPUT\n\t\t\tself.state['calc'].push(v2)\n\t\t\tself.state['calc'].push(v1)\n\t\t\treturn\n\n\t\tself.state['calc'].push((int32(v2 / v1)))\n\n\tdef fact(self):\n\t\tcmd = '!'\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 1):\n\t\t\treturn\n\n\t\tv = self.state['calc'].pop()\n\n\t\tif v < 0 or v > 1000:\n\t\t\tself.state['err'] = self.ERR_INVALID_INPUT\n\t\t\tself.state['calc'].push(v)\n\t\t\treturn\n\n\t\tr = int32(1)\n\t\twhile v > 0:\n\t\t\tr = int32(r * int32(v))\n\t\t\tv -= 1\n\t\tself.state['calc'].push(r)\n\n\tdef neg(self):\n\t\tself._unop('neg', op.neg)\n\n\tdef abs(self):\n\t\tself._unop('abs', op.abs)\n\n\tdef mod_(self):\n\t\tcmd = 'mod'\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 2):\n\t\t\treturn\n\n\t\tv1, v2 = self.state['calc'].pop(), self.state['calc'].pop()\n\t\tif v1 == 0:\n\t\t\tself.state['err'] = self.ERR_INVALID_INPUT\n\t\t\tself.state['calc'].push(v2)\n\t\t\tself.state['calc'].push(v1)\n\t\t\treturn\n\n\t\tself.state['calc'].push((int32(math.fmod(int32(v2), int32(v1)))))\n\n\tdef xor(self):\n\t\tself._binop('^', op.xor)\n\n\tdef or_(self):\n\t\tself._binop('|', op.or_)\n\n\tdef and_(self):\n\t\tself._binop('&', op.and_)\n\n\tdef not_(self):\n\t\tself._unop('~', lambda x: int32(~x))\n\n\tdef sum_(self):\n\t\tcmd = 'sum'\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 1):\n\t\t\treturn\n\n\t\tn = self.state['calc'].pop()\n\n\t\tif len(self.state['calc']) < n or n < 0:\n\t\t\tself.state['err'] = self.ERR_TOO_FEW_ARGS.format(cmd)\n\t\t\tself.state['calc'].push(n)\n\t\t\treturn\n\n\t\ts = int32(0)\n\t\tfor _ in xrange(n):\n\t\t\tv = self.state['calc'].pop()\n\t\t\ts = int32(int32(s) + int32(v))\n\n\t\tself.state['calc'].push(s)\n\n\tdef avg(self):\n\t\tcmd = 'avg'\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 1):\n\t\t\treturn\n\n\t\tn = self.state['calc'].pop()\n\t\tif n == 0:\n\t\t\tself.state['err'] = self.ERR_INVALID_INPUT\n\t\t\tself.state['calc'].push(n)\n\t\t\treturn\n\n\t\tif len(self.state['calc']) < n or n < 0:\n\t\t\tself.state['err'] = self.ERR_TOO_FEW_ARGS.format(cmd)\n\t\t\tself.state['calc'].push(n)\n\t\t\treturn\n\n\t\ts = int32(0)\n\t\tfor _ in xrange(n):\n\t\t\tv = self.state['calc'].pop()\n\t\t\ts = int32(int32(s) + int32(v))\n\n\t\tself.state['calc'].push(int32(s / n))\n\n\tdef dup(self):\n\t\tcmd = 'dup'\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 1):\n\t\t\treturn\n\n\t\tself.state['calc'].push(self.state['calc'].peek())\n\n\tdef dupn(self):\n\t\tcmd = 'dupn'\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 1):\n\t\t\treturn\n\n\t\tn = self.state['calc'].pop()\n\n\t\tif len(self.state['calc']) < n or n <= 0:\n\t\t\tself.state['err'] = self.ERR_TOO_FEW_ARGS.format(cmd)\n\t\t\tself.state['calc'].push(n)\n\t\t\treturn\n\n\t\tif n > 0:\n\t\t\tself.state['calc']._storage.extend(self.state['calc']._storage[-n:])\n\n\tdef dupr(self):\n\t\tcmd = 'dupr'\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 2):\n\t\t\treturn\n\n\t\tlen_ = self.state['calc'].pop()\n\t\tpos = self.state['calc'].pop()\n\n\t\tif (\n\t\t\t\tlen(self.state['calc']) < uint16(pos) or\n\t\t\t\tlen(self.state['calc']) < uint16(len_) or\n\t\t\t\tlen(self.state['calc']) < uint16(pos + len_)\n\t\t):\n\t\t\tself.state['err'] = self.ERR_INVALID_INPUT\n\t\t\tself.state['calc'].push(pos)\n\t\t\tself.state['calc'].push(len_)\n\t\t\treturn\n\n\t\tself.state['calc']._storage.extend(self.state['calc']._storage[-pos:-pos + len_])\n\n\t\tself.state['ret'] = self.NO_HISTORY\n\n\tdef drop(self):\n\t\tcmd = 'drop'\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 1):\n\t\t\treturn\n\n\t\tself.state['calc'].pop()\n\n\tdef dropn(self):\n\t\tcmd = 'dropn'\n\t\tself._writeln(cmd)\n\n\t\tif not self._ensure_n(cmd, 1):\n\t\t\treturn\n\n\t\tn = self.state['calc'].pop()\n\n\t\tif len(self.state['calc']) < n or n < 0:\n\t\t\tself.state['err'] = self.ERR_TOO_FEW_ARGS.format(cmd)\n\t\t\tself.state['calc'].push(n)\n\t\t\treturn\n\n\t\tfor _ in xrange(n):\n\t\t\tself.state['calc'].pop()\n\n\tdef min(self):\n\t\tself._binop('min', min)\n\n\tdef max(self):\n\t\tself._binop('max', max)\n\n\tdef depth(self):\n\t\tcmd = 'depth'\n\t\tself._writeln(cmd)\n\n\t\tself.state['calc'].push(int32(len(self.state['calc'])))\n\n\tdef invert(self):\n\t\tcmd = 'ivrt'\n\t\tself._writeln(cmd)\n\n\t\tself.state['calc'].invert()\n\n\tdef undo(self):\n\t\tcmd = 'undo'\n\t\tself._writeln(cmd)\n\n\t\tif len(self.state['hist']) < 2:\n\t\t\tself.state['err'] = self.ERR_INVALID_INPUT\n\t\t\treturn\n\n\t\tself.state['calc'] = self.state['hist'].pop()\n\t\tself.state['ret'] = self.NO_HISTORY\n\n\tdef quit(self):\n\t\tself._writeln('quit')\n\t\tself._readln('Bye bye')\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from generator.actions import Actions", "from numpy import int32, uint16", "import copy", "import math", "import operator as op", "import random", "import re"]}], [{"term": "def", "name": "get_dx", "data": "def get_dx(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n\t\"\"\"\n\tCalculates the derivatives of u and v with respect to x\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_dx (float): the derivative of u w.r.t. x\n\tdv_dx (float): the derivative of v w.r.t. x\n\t\"\"\"\n\n\tdu = f/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n\tdv = 0\n\n\treturn du, dv\n\n", "description": "\n\tCalculates the derivatives of u and v with respect to x\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_dx (float): the derivative of u w.r.t. x\n\tdv_dx (float): the derivative of v w.r.t. x\n\t", "category": "math", "imports": ["from math import sin, cos", "# import sympy", "# from sympy.matrices import Matrix, zeros", "However, I did not remove it because I believe it demonstrates an important part of my project, the"]}, {"term": "def", "name": "get_dy", "data": "def get_dy(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n\t\"\"\"\n\tCalculates the derivatives of u and v with respect to y\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_dy (float): the derivative of u w.r.t. y\n\tdv_dy (float): the derivative of v w.r.t. y\n\t\"\"\"\n\n\tdu = 0\n\tdv = f/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n\n\treturn du, dv\n\n", "description": "\n\tCalculates the derivatives of u and v with respect to y\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_dy (float): the derivative of u w.r.t. y\n\tdv_dy (float): the derivative of v w.r.t. y\n\t", "category": "math", "imports": ["from math import sin, cos", "# import sympy", "# from sympy.matrices import Matrix, zeros", "However, I did not remove it because I believe it demonstrates an important part of my project, the"]}, {"term": "def", "name": "get_dz", "data": "def get_dz(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n\t\"\"\"\n\tCalculates the derivatives of u and v with respect to z\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_dz (float): the derivative of u w.r.t. z\n\tdv_dz (float): the derivative of v w.r.t. z\n\t\"\"\"\n\n\tdu = -f*(x + z_calc*(sin(pitch)*cos(roll)*cos(yaw) + sin(roll)*sin(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*cos(pitch)*cos(yaw) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*cos(yaw) - sin(yaw)*cos(roll)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2\n\tdv = -f*(y + z_calc*(sin(pitch)*sin(yaw)*cos(roll) - sin(roll)*cos(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*sin(yaw)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*sin(yaw) + cos(roll)*cos(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2\n\n\treturn du, dv\n\t\n", "description": "\n\tCalculates the derivatives of u and v with respect to z\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_dz (float): the derivative of u w.r.t. z\n\tdv_dz (float): the derivative of v w.r.t. z\n\t", "category": "math", "imports": ["from math import sin, cos", "# import sympy", "# from sympy.matrices import Matrix, zeros", "However, I did not remove it because I believe it demonstrates an important part of my project, the"]}, {"term": "def", "name": "get_droll", "data": "def get_droll(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n\t\"\"\"\n\tCalculates the derivatives of u and v with respect to roll\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_droll (float): the derivative of u w.r.t. roll\n\tdv_droll (float): the derivative of v w.r.t. roll\n\t\"\"\"\n\n\tdu = f*(z_calc*(-sin(pitch)*sin(roll)*cos(yaw) + sin(yaw)*cos(roll)) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*cos(roll)*cos(yaw) + sin(roll)*sin(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch)) + f*(z_calc*sin(roll)*cos(pitch) - (-cv*z_calc/f + v1*z_calc/f)*cos(pitch)*cos(roll))*(x + z_calc*(sin(pitch)*cos(roll)*cos(yaw) + sin(roll)*sin(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*cos(pitch)*cos(yaw) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*cos(yaw) - sin(yaw)*cos(roll)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2\n\tdv = f*(z_calc*(-sin(pitch)*sin(roll)*sin(yaw) - cos(roll)*cos(yaw)) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(yaw)*cos(roll) - sin(roll)*cos(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch)) + f*(z_calc*sin(roll)*cos(pitch) - (-cv*z_calc/f + v1*z_calc/f)*cos(pitch)*cos(roll))*(y + z_calc*(sin(pitch)*sin(yaw)*cos(roll) - sin(roll)*cos(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*sin(yaw)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*sin(yaw) + cos(roll)*cos(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2\n\n\treturn du, dv\n\t\n", "description": "\n\tCalculates the derivatives of u and v with respect to roll\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_droll (float): the derivative of u w.r.t. roll\n\tdv_droll (float): the derivative of v w.r.t. roll\n\t", "category": "math", "imports": ["from math import sin, cos", "# import sympy", "# from sympy.matrices import Matrix, zeros", "However, I did not remove it because I believe it demonstrates an important part of my project, the"]}, {"term": "def", "name": "get_dpitch", "data": "def get_dpitch(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n\t\"\"\"\n\tCalculates the derivatives of u and v with respect to pitch\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_dpitch (float): the derivative of u w.r.t. pitch\n\tdv_dpitch (float): the derivative of v w.r.t. pitch\n\t\"\"\"\n\n\tdu = f*(z_calc*sin(pitch)*cos(roll) - (cu*z_calc/f - u1*z_calc/f)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(pitch)*sin(roll))*(x + z_calc*(sin(pitch)*cos(roll)*cos(yaw) + sin(roll)*sin(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*cos(pitch)*cos(yaw) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*cos(yaw) - sin(yaw)*cos(roll)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2 + f*(z_calc*cos(pitch)*cos(roll)*cos(yaw) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch)*cos(yaw) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch)*cos(yaw))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n\tdv = f*(z_calc*sin(pitch)*cos(roll) - (cu*z_calc/f - u1*z_calc/f)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(pitch)*sin(roll))*(y + z_calc*(sin(pitch)*sin(yaw)*cos(roll) - sin(roll)*cos(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*sin(yaw)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*sin(yaw) + cos(roll)*cos(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))**2 + f*(z_calc*sin(yaw)*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch)*sin(yaw) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*sin(yaw)*cos(pitch))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n\t\n\treturn du, dv\n\t\n", "description": "\n\tCalculates the derivatives of u and v with respect to pitch\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_dpitch (float): the derivative of u w.r.t. pitch\n\tdv_dpitch (float): the derivative of v w.r.t. pitch\n\t", "category": "math", "imports": ["from math import sin, cos", "# import sympy", "# from sympy.matrices import Matrix, zeros", "However, I did not remove it because I believe it demonstrates an important part of my project, the"]}, {"term": "def", "name": "get_dyaw", "data": "def get_dyaw(z_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw):\n\t\"\"\"\n\tCalculates the derivatives of u and v with respect to yaw\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_dyaw (float): the derivative of u w.r.t. yaw\n\tdv_dyaw (float): the derivative of v w.r.t. yaw\n\t\"\"\"\n\n\tdu = f*(z_calc*(-sin(pitch)*sin(yaw)*cos(roll) + sin(roll)*cos(yaw)) - (-cu*z_calc/f + u1*z_calc/f)*sin(yaw)*cos(pitch) + (-cv*z_calc/f + v1*z_calc/f)*(-sin(pitch)*sin(roll)*sin(yaw) - cos(roll)*cos(yaw)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n\tdv = f*(z_calc*(sin(pitch)*cos(roll)*cos(yaw) + sin(roll)*sin(yaw)) + (-cu*z_calc/f + u1*z_calc/f)*cos(pitch)*cos(yaw) + (-cv*z_calc/f + v1*z_calc/f)*(sin(pitch)*sin(roll)*cos(yaw) - sin(yaw)*cos(roll)))/(z + z_calc*cos(pitch)*cos(roll) - (-cu*z_calc/f + u1*z_calc/f)*sin(pitch) + (-cv*z_calc/f + v1*z_calc/f)*sin(roll)*cos(pitch))\n\n\treturn du, dv\n", "description": "\n\tCalculates the derivatives of u and v with respect to yaw\n\n\tParameters\n\t----------\n\tz_calc, u1, v1, f, cu, cv, x, y, z, roll, pitch, yaw, as explained in module docstring\n\t\n\tReturns\n\t-------\n\tdu_dyaw (float): the derivative of u w.r.t. yaw\n\tdv_dyaw (float): the derivative of v w.r.t. yaw\n\t", "category": "math", "imports": ["from math import sin, cos", "# import sympy", "# from sympy.matrices import Matrix, zeros", "However, I did not remove it because I believe it demonstrates an important part of my project, the"]}], [{"term": "def", "name": "test_calculator_label", "data": "def test_calculator_label():\n\tfrom ase.calculators.calculator import Calculator\n\n\tcalc = Calculator()\n\tassert calc.directory == '.'\n\tassert calc.prefix is None\n\tassert calc.label is None\n\n\tcalc.label = 'dir/pref'\n\tassert calc.directory == 'dir'\n\tassert calc.prefix == 'pref'\n\tassert calc.label == 'dir/pref'\n\n\tcalc.label = 'dir2/'\n\tassert calc.directory == 'dir2'\n\tassert calc.prefix is None\n\tassert calc.label == 'dir2/'\n\n\tcalc.label = 'hello'\n\tassert calc.directory == '.'\n\tassert calc.prefix == 'hello'\n\tassert calc.label == 'hello'\n\n\tcalc.label = None\n\tassert calc.label is None\n\tassert calc.prefix is None\n\tassert calc.directory == '.'\n", "description": null, "category": "math", "imports": ["\tfrom ase.calculators.calculator import Calculator"]}], [{"term": "class", "name": "classSpline:", "data": "class Spline:\n\tu\"\"\"\n\tCubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.b, self.c, self.d, self.w = [], [], [], []\n\n\t\tself.x = x\n\t\tself.y = y\n\n\t\tself.nx = len(x)  # dimension of x\n\t\th = np.diff(x)\n\n\t\t# calc coefficient c\n\t\tself.a = [iy for iy in y]\n\n\t\t# calc coefficient c\n\t\tA = self.__calc_A(h)\n\t\tB = self.__calc_B(h)\n\t\tself.c = np.linalg.solve(A, B)\n\t\t#  print(self.c1)\n\n\t\t# calc spline coefficient b and d\n\t\tfor i in range(self.nx - 1):\n\t\t\tself.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n\t\t\ttb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n\t\t\t\t(self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n\t\t\tself.b.append(tb)\n\n\tdef calc(self, t):\n\t\tu\"\"\"\n\t\tCalc position\n\n\t\tif t is outside of the input x, return None\n\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.a[i] + self.b[i] * dx + \\\n\t\t\tself.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n\t\treturn result\n\n\tdef calcd(self, t):\n\t\tu\"\"\"\n\t\tCalc first derivative\n\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n\t\treturn result\n\n\tdef calcdd(self, t):\n\t\tu\"\"\"\n\t\tCalc second derivative\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n\t\treturn result\n\n\tdef __search_index(self, x):\n\t\tu\"\"\"\n\t\tsearch data segment index\n\t\t\"\"\"\n\t\treturn bisect.bisect(self.x, x) - 1\n\n\tdef __calc_A(self, h):\n\t\tu\"\"\"\n\t\tcalc matrix A for spline coefficient c\n\t\t\"\"\"\n\t\tA = np.zeros((self.nx, self.nx))\n\t\tA[0, 0] = 1.0\n\t\tfor i in range(self.nx - 1):\n\t\t\tif i != (self.nx - 2):\n\t\t\t\tA[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n\t\t\tA[i + 1, i] = h[i]\n\t\t\tA[i, i + 1] = h[i]\n\n\t\tA[0, 1] = 0.0\n\t\tA[self.nx - 1, self.nx - 2] = 0.0\n\t\tA[self.nx - 1, self.nx - 1] = 1.0\n\t\t#  print(A)\n\t\treturn A\n\n\tdef __calc_B(self, h):\n\t\tu\"\"\"\n\t\tcalc matrix B for spline coefficient c\n\t\t\"\"\"\n\t\tB = np.zeros(self.nx)\n\t\tfor i in range(self.nx - 2):\n\t\t\tB[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n\t\t\t\th[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n\t\t#  print(B)\n\t\treturn B\n\n", "description": "\n\tCubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "class", "name": "classSpline2D:", "data": "class Spline2D:\n\tu\"\"\"\n\t2D Cubic Spline class\n\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.s = self.__calc_s(x, y)\n\t\tself.sx = Spline(self.s, x)\n\t\tself.sy = Spline(self.s, y)\n\n\tdef __calc_s(self, x, y):\n\t\tdx = np.diff(x)\n\t\tdy = np.diff(y)\n\t\tself.ds = [math.sqrt(idx ** 2 + idy ** 2)\n\t\t\t\t   for (idx, idy) in zip(dx, dy)]\n\t\ts = [0]\n\t\ts.extend(np.cumsum(self.ds))\n\t\treturn s\n\n\tdef calc_position(self, s):\n\t\tu\"\"\"\n\t\tcalc position\n\t\t\"\"\"\n\t\tx = self.sx.calc(s)\n\t\ty = self.sy.calc(s)\n\n\t\treturn x, y\n\n\tdef calc_curvature(self, s):\n\t\tu\"\"\"\n\t\tcalc curvature\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tddx = self.sx.calcdd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tddy = self.sy.calcdd(s)\n\t\tk = (ddy * dx - ddx * dy) / (dx ** 2 + dy ** 2)\n\t\treturn k\n\n\tdef calc_yaw(self, s):\n\t\tu\"\"\"\n\t\tcalc yaw\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tyaw = math.atan2(dy, dx)\n\t\treturn yaw\n\n", "description": "\n\t2D Cubic Spline class\n\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "class", "name": "classSpline3D:", "data": "class Spline3D:\n\t\"\"\"\n\t3D Cubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y, z):\n\t\tself.s = self.__calc_s(x, y, z)\n\t\tself.sx = Spline(self.s, x)\n\t\tself.sy = Spline(self.s, y)\n\t\tself.sz = Spline(self.s, z)\n\n\tdef __calc_s(self, x, y, z):\n\t\tdx = np.diff(x)\n\t\tdy = np.diff(y)\n\t\tdz = np.diff(z)\n\t\tself.ds = [math.sqrt(idx ** 2 + idy ** 2 + idz ** 2) for (idx, idy, idz) in zip(dx, dy, dz)]\n\t\ts = [0]\n\t\ts.extend(np.cumsum(self.ds))\n\t\treturn s\n\n\tdef calc_position(self, s):\n\t\tu\"\"\"\n\t\tcalc position\n\t\t\"\"\"\n\t\tx = self.sx.calc(s)\n\t\ty = self.sy.calc(s)\n\t\tz = self.sz.calc(s)\n\t\treturn x, y, z\n\n\tdef calc_curvature(self, s):\n\t\tu\"\"\"\n\t\tcalc curvature\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tddx = self.sx.calcdd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tddy = self.sy.calcdd(s)\n\t\tk = (ddy * dx - ddx * dy) / (dx ** 2 + dy ** 2)\n\t\treturn k\n\n\tdef calc_yaw(self, s):\n\t\tu\"\"\"\n\t\tcalc yaw\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tyaw = math.atan2(dy, dx)\n\t\treturn yaw\n\n\tdef calc_pitch(self, s):\n\t\t\"\"\"\n\t\tcalc pitch - this function needs to be double checked\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tdz = self.sz.calcd(s)\n\t\tpitch = math.atan2(dz, dx)\n\t\treturn pitch\n\n", "description": "\n\t3D Cubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "calc_spline_course", "data": "def calc_spline_course(x, y, ds=0.1):\n\tsp = Spline2D(x, y)\n\ts = list(np.arange(0, sp.s[-1], ds))\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\treturn rx, ry, ryaw, rk, s\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():\n\tprint(\"Spline 2D test\")\n\timport matplotlib.pyplot as plt\n\tx = [0.0, 2.5, 5.0, 7.5, 10.0, 12.5, 15.0, 17.5, 20.0]\n\ty = [0.0, 0.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0]\n\n\tsp = Spline2D(x, y)\n\ts = np.arange(0, sp.s[-1], 0.1)\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\tflg, ax = plt.subplots(1)\n\tplt.plot(x, y, \"xb\", label=\"input\")\n\tplt.plot(rx, ry, \"-r\", label=\"spline\")\n\tplt.grid(True)\n\tplt.axis(\"equal\")\n\tplt.xlabel(\"x[m]\")\n\tplt.ylabel(\"y[m]\")\n\tplt.legend()\n\n\tflg, ax = plt.subplots(1)\n\tplt.plot(s, [math.degrees(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"yaw angle[deg]\")\n\n\tflg, ax = plt.subplots(1)\n\tplt.plot(s, rk, \"-r\", label=\"curvature\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"curvature [1/m]\")\n\n\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}], [{"term": "def", "name": "solution", "data": "def solution(N, stages):\n\tdic = {}\n\tn = len(stages)\n\tfor i in range(1,N+1):\n\t\tif stages.count(i) == 0 : \n\t\t\tdic[i] = 0 \n\t\t\tcontinue\n\t\titem = stages.count(i)/n\n\t\tn-=stages.count(i)\n\t\tdic[i] = item\n\treturn sorted(dic, key=lambda k : dic[k], reverse = True)\n", "description": null, "category": "math", "imports": []}], [{"term": "class", "name": "classCalculationDispatcher:", "data": "class CalculationDispatcher:\n\tdef __init__(self, request):\n\n\t\t# now on construction, it will automatically run parse request on the input request, so theres no extra in between step\n\t\tself.request = self.parse_request(request)\n\t\tdata_list = request[\"ReportInfo\"]\n\t\tself.params = request[\"Meta\"]\n\t\tself.data_dict = CalculationDispatcher.__group_by_data_def(data_list)\n\t\tself.data_service = DataService(request[\"Meta\"])\n\t\t\n\t@staticmethod\n\tdef __group_by_data_def(data_list):\n\t\t\"\"\"Returns dict of data defs grouped by reportDictid and sorted by dataDefid\n\t\t\n\t\tdata_dict is a dictionary that groups the data definitions in data_list by reportDictId\n\t\tand sorts the data definitions in each group by their dataDefId, highest to smallest.\n\t\tDoes not modify data_list.\n\t\tdata_dict = { \n\t\t\t1: [{\"reportDictId\": 1, \"dataDefId\": 1 },   {\"reportDictId\": 1, \"dataDefId\": 2 }, ... ],\n\t\t\t2:  [{\"reportDictId\": 2, \"dataDefId\": 5 },   {\"reportDictId\": 2, \"dataDefId\": 6 }, ... ],\n\t\t\t3:  [{\"reportDictId\": 3, \"dataDefId\": 19 },   {\"reportDictId\": 3, \"dataDefId\": 20 }, ... ],\n\t\t}\n\t\t\n\t\t\"\"\"\n\n\t\tdata_dict = {}\n\t\tfor item in data_list:\n\t\t\tentry_list = data_dict.get(item[\"reportDictId\"])\n\t\t\tif entry_list is None:\n\t\t\t\tpos = item[\"reportDictId\"]\n\t\t\t\tdata_dict[pos] = [item]\n\t\t\telse:\n\t\t\t\tentry_list.append(item)\n\n\t\tfor entry_list in data_dict.values():\n\t\t\tentry_list.sort(key = lambda e: e[\"dataDefId\"])\n\t\treturn data_dict\n\t\t\n\t\n\t#runs calculation on each data_def in data_dict\n\t#and appends the result of the calculation to the data_def\n\t#modifies: self.request\n\t#returns the modified data_defs as a list\n\tdef run_calculations(self):\n\t\tfor group in self.data_dict.values():\n\t\t\tfor data_def in group:\n\t\t\t\tdata = self.data_service.get_data_for_definition(data_def[\"dataDefId\"])\n\t\t\t\tif self.has_data(data):\n\t\t\t\t\tself.params[\"no_data\"] = False\n\t\t\t\t\tfunc = data_calc_function_switcher[data_def[\"dataDefId\"]]\n\t\t\t\t\tdata_def[\"value\"] = func(data)\n\t\t\t\telse:\n\t\t\t\t\tself.params[\"no_data\"] = True\n\n\t\treturn self.request[\"ReportInfo\"]\n\n\t# static callable parse request\n\t@staticmethod\n\tdef parse_request(input_dict):\n\t\t# Setting the scope type\n\t\tscope_field = input_dict[\"Meta\"][\"scope_field\"]\n\t\tif scope_field.startswith(\"fip\"):\n\t\t\tinput_dict[\"Meta\"][\"scope_type\"] = \"geography\"\n\t\telse:\n\t\t\tinput_dict[\"Meta\"][\"scope_type\"] = \"hierarchy\"\n\t\t\n\t\t# Setting the control type\n\t\tif \"control_type_name\" not in input_dict[\"Meta\"]:\n\t\t\tinput_dict[\"Meta\"][\"control_type_name\"] = DEFAULT_CTRL\n\n\t\tif \"control_age_group_id\" not in input_dict[\"Meta\"]:\n\t\t\tinput_dict[\"Meta\"][\"control_age_group_id\"] = DEFAULT_AGE_GROUP_ID\n\n\t\treturn input_dict\n\n\t@staticmethod\n\tdef has_data(data):\n\t\tif isinstance(data, pd.DataFrame):\n\t\t\treturn not(len(data) == 0)\n\t\telif type(data) is dict:\n\t\t\tkeys_to_look_for = [KEY_SERVICE, KEY_FAMILY, KEY_MEMBER]\n\t\t\tany_empty = False\n\t\t\ti = 0\n\t\t\twhile(i < len(keys_to_look_for) and not(any_empty)):\n\t\t\t\tkey = keys_to_look_for[i]\n\t\t\t\tdata_frame = data.get(key)\n\t\t\t\tif data_frame is not None:\n\t\t\t\t\tif isinstance(data_frame, pd.DataFrame):\n\t\t\t\t\t\tany_empty = any_empty or (len(data_frame) == 0)\n\t\t\t\t\telse: \n\t\t\t\t\t\t#only dataframes should be stored in the \n\t\t\t\t\t\t#dictionary of data passed to the calculations\n\t\t\t\t\t\tany_empty = True\n\t\t\t\ti += 1\n\t\t\treturn not(any_empty)\n\t\telse:\n\t\t\treturn False\n", "description": "Returns dict of data defs grouped by reportDictid and sorted by dataDefid\n\t\t\n\t\tdata_dict is a dictionary that groups the data definitions in data_list by reportDictId\n\t\tand sorts the data definitions in each group by their dataDefId, highest to smallest.\n\t\tDoes not modify data_list.\n\t\tdata_dict = { \n\t\t\t1: [{\"reportDictId\": 1, \"dataDefId\": 1 },   {\"reportDictId\": 1, \"dataDefId\": 2 }, ... ],\n\t\t\t2:  [{\"reportDictId\": 2, \"dataDefId\": 5 },   {\"reportDictId\": 2, \"dataDefId\": 6 }, ... ],\n\t\t\t3:  [{\"reportDictId\": 3, \"dataDefId\": 19 },   {\"reportDictId\": 3, \"dataDefId\": 20 }, ... ],\n\t\t}\n\t\t\n\t\t", "category": "math", "imports": ["from .services.data_service import DataService, KEY_SERVICE, KEY_MEMBER, KEY_FAMILY", "import transform_layer.calc_service_types as calc_service_types", "import transform_layer.calc_families as calc_families", "import transform_layer.calc_fact_services as calc_fact_services", "import transform_layer.calc_new_families as calc_new_families", "import transform_layer.calc_geographies as calc_geographies", "import transform_layer.calc_service_trends as calc_service_trends", "import transform_layer.calc_family_members as calc_family_members", "import pandas as pd"]}], [{"term": "def", "name": "calcContainer", "data": "def calcContainer(parent=None):\r\n\tfrm = Frame(parent)\t   \r\n\tfrm.pack(expand=YES, fill=BOTH)\r\n\tLabel(frm, text='Calc Container').pack(side=TOP)\r\n\tCalcGui(frm)\r\n\tLabel(frm, text='Calc Container').pack(side=BOTTOM)\r\n\treturn frm\r\n", "description": null, "category": "math", "imports": ["from Tkinter import *\r", "from calculator import CalcGui\r", "from PP3E.Dbase.TableBrowser.guitools import *\r", "\timport sys\r"]}, {"term": "class", "name": "calcSubclass", "data": "class calcSubclass(CalcGui): \r\n\tdef makeWidgets(self, fg, bg, font):\r\n\t\tLabel(self, text='Calc Subclass').pack(side=TOP)\r\n\t\tLabel(self, text='Calc Subclass').pack(side=BOTTOM)\r\n\t\tCalcGui.makeWidgets(self, fg, bg, font)\r\n\t\t#Label(self, text='Calc Subclass').pack(side=BOTTOM)\r\n", "description": null, "category": "math", "imports": ["from Tkinter import *\r", "from calculator import CalcGui\r", "from PP3E.Dbase.TableBrowser.guitools import *\r", "\timport sys\r"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "classSpline:", "data": "class Spline:\n\tu\"\"\"\n\tCubic Spline class\n\t\"\"\"\n\tdef __init__(self, x, y):\n\t\tself.b, self.c, self.d, self.w = [], [], [], []\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.nx = len(x)\n\t\th = np.diff(x)\n\t\tself.a = [iy for iy in y]\n\t\tA = self.__calc_A(h)\n\t\tB = self.__calc_B(h)\n\t\tself.c = np.linalg.solve(A, B)\n\t\tfor i in range(self.nx - 1):\n\t\t\tself.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n\t\t\ttb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n\t\t\t\t(self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n\t\t\tself.b.append(tb)\n\tdef calc(self, t):\n\t\tu\"\"\"\n\t\tCalc position\n\n\t\tif t is outside of the input x, return None\n\n\t\t\"\"\"\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.a[i] + self.b[i] * dx + \\\n\t\t\tself.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\t\treturn result\n\n\tdef calcd(self, t):\n\t\tu\"\"\"\n\t\tCalc first derivative\n\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n\t\treturn result\n\n\tdef calcdd(self, t):\n\t\tu\"\"\"\n\t\tCalc second derivative\n\t\t\"\"\"\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n\t\treturn result\n\n\tdef __search_index(self, x):\n\t\tu\"\"\"\n\t\tsearch data segment index\n\t\t\"\"\"\n\t\treturn bisect.bisect(self.x, x) - 1\n\n\tdef __calc_A(self, h):\n\t\tu\"\"\"\n\t\tcalc matrix A for spline coefficient c\n\t\t\"\"\"\n\t\tA = np.zeros((self.nx, self.nx))\n\t\tA[0, 0] = 1.0\n\t\tfor i in range(self.nx - 1):\n\t\t\tif i != (self.nx - 2):\n\t\t\t\tA[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n\t\t\tA[i + 1, i] = h[i]\n\t\t\tA[i, i + 1] = h[i]\n\n\t\tA[0, 1] = 0.0\n\t\tA[self.nx - 1, self.nx - 2] = 0.0\n\t\tA[self.nx - 1, self.nx - 1] = 1.0\n\t\treturn A\n\n\tdef __calc_B(self, h):\n\t\tu\"\"\"\n\t\tcalc matrix B for spline coefficient c\n\t\t\"\"\"\n\t\tB = np.zeros(self.nx)\n\t\tfor i in range(self.nx - 2):\n\t\t\tB[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n\t\t\t\th[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n\t\treturn B\n\n", "description": "\n\tCubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "class", "name": "classSpline2D:", "data": "class Spline2D:\n\tu\"\"\"\n\t2D Cubic Spline class\n\n\t\"\"\"\n\tdef __init__(self, x, y):\n\t\tself.s = self.__calc_s(x, y)\n\t\tself.sx = Spline(self.s, x)\n\t\tself.sy = Spline(self.s, y)\n\n\tdef __calc_s(self, x, y):\n\t\tdx = np.diff(x)\n\t\tdy = np.diff(y)\n\t\tself.ds = [math.sqrt(idx ** 2 + idy ** 2)\n\t\t\t\t   for (idx, idy) in zip(dx, dy)]\n\t\ts = [0]\n\t\ts.extend(np.cumsum(self.ds))\n\t\treturn s\n\n\tdef calc_position(self, s):\n\t\tu\"\"\"\n\t\tcalc position\n\t\t\"\"\"\n\t\tx = self.sx.calc(s)\n\t\ty = self.sy.calc(s)\n\t\treturn x, y\n\n\tdef calc_curvature(self, s):\n\t\tu\"\"\"\n\t\tcalc curvature\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tddx = self.sx.calcdd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tddy = self.sy.calcdd(s)\n\t\tk = (ddy * dx - ddx * dy) / (dx ** 2 + dy ** 2)\n\t\treturn k\n\n\tdef calc_yaw(self, s):\n\t\tu\"\"\"\n\t\tcalc yaw\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tyaw = math.atan2(dy, dx)\n\t\treturn yaw\n\n", "description": "\n\t2D Cubic Spline class\n\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "calc_spline_course", "data": "def calc_spline_course(x, y, ds=0.1):\n\tsp = Spline2D(x, y)\n\ts = list(np.arange(0, sp.s[-1], ds))\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\treturn rx, ry, ryaw, rk, s\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():\n\tprint(\"Spline 2D test\")\n\timport matplotlib.pyplot as plt\n\tx = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n\ty = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n\tsp = Spline2D(x, y)\n\ts = np.arange(0, sp.s[-1], 0.1)\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\tflg, ax = plt.subplots(1)\n\tplt.plot(x, y, \"xb\", label=\"input\")\n\tplt.plot(rx, ry, \"-r\", label=\"spline\")\n\tplt.grid(True)\n\tplt.axis(\"equal\")\n\tplt.xlabel(\"x[m]\")\n\tplt.ylabel(\"y[m]\")\n\tplt.legend()\n\tflg, ax = plt.subplots(1)\n\tplt.plot(s, [math.degrees(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"yaw angle[deg]\")\n\tflg, ax = plt.subplots(1)\n\tplt.plot(s, rk, \"-r\", label=\"curvature\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"curvature [1/m]\")\n\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}], [{"term": "class", "name": "TestCalculate", "data": "class TestCalculate(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.calc = Calculator()\n\n\tdef test_add_method_returns_correct_result(self):\n\t\tself.assertEqual(4, self.calc.add(2, 2))\n\t\tself.assertEqual(0, self.calc.add(2, -2))\n\t\tself.assertEqual(0, self.calc.add(-2, 2))\n\t\tself.assertEqual(1, self.calc.add(1, 0))\n\n\tdef test_add_method_returns_correct_result1(self):\n\t\tself.assertEqual(5, self.calc.add(3, 2))\n\t\tself.assertEqual(0, self.calc.add(2, -2))\n\t\tself.assertEqual(0, self.calc.add(-2, 2))\n\t\tself.assertEqual(1, self.calc.add(1, 0))\t  \n\t\t\n\tdef test_divide_method_returns_correct_result(self):\n\t\tself.assertEqual(1, self.calc.divide(2, 2))\n\t\tself.assertEqual(1.5, self.calc.divide(3, 2))\n\t\tself.assertRaises(TypeError, self.calc.divide, \"2\", 2)\n\n\tdef test_add_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.add, \"2\", 2)\n\t\tself.assertRaises(TypeError, self.calc.add, 2, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.add, \"2\", \"2\")\n\t\tself.assertRaises(TypeError, self.calc.add, None, 2)\n\t\tself.assertRaises(TypeError, self.calc.add, 2, None)\n\t\tself.assertRaises(TypeError, self.calc.add, object(), 2)\n\t\tself.assertRaises(TypeError, self.calc.add, 2, object())\n\n\tdef test_divide_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.divide, \"2\", 2)\n\t\tself.assertRaises(TypeError, self.calc.divide, 2, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.divide, \"2\", \"2\")\n\n\tdef test_divide_method_fails_with_division_by_zero(self):\n\t\tself.assertRaises(TypeError, self.calc.divide, 2, 0)\n\t\tself.assertRaises(TypeError, self.calc.divide, 2, -0)\n\t\tself.assertRaises(TypeError, self.calc.divide, 0, 0)\n\t\tself.assertRaises(TypeError, self.calc.divide, \"0\", 0)\n\n\tdef test_multiply_method_returns_correct_result(self):\n\t\tself.assertEqual(4, self.calc.multiply(2, 2))\n\t\tself.assertEqual(0, self.calc.multiply(1, 0))\n\t\tself.assertEqual(0, self.calc.multiply(-1, 0))\n\t\tself.assertEqual(-2, self.calc.multiply(-1, 2))\n\t\tself.assertRaises(TypeError, self.calc.multiply, \"0\", 0)\n\t\t\n\tdef test_power_method_returns_correct_result(self):\n\t\tself.assertEqual(4, self.calc.power(2, 2))\n\t\tself.assertEqual(1, self.calc.power(1, 0))\n\t\tself.assertEqual(1, self.calc.power(-1, 0))\n\t\tself.assertEqual(-27, self.calc.power(-3, 3))\n\t\tself.assertRaises(TypeError, self.calc.power, \"0\", 0)\n\t\t\n\tdef test_substract_method_returns_correct_result(self):\n\t\tself.assertEqual(4, self.calc.substract(10, 6))\n\t\tself.assertEqual(-2, self.calc.substract(256, 258))\n\t\tself.assertEqual(-1, self.calc.substract(-1, 0))\n\t\tself.assertEqual(0, self.calc.substract(0, 0))\n\t\tself.assertEqual(0, self.calc.substract(0, 0))\n\t\tself.assertRaises(TypeError, self.calc.substract, \"0\", 0)\n", "description": null, "category": "math", "imports": ["import pytest", "import unittest", "from app.calc import Calculator"]}], [{"term": "def", "name": "Atoms_fcc_Ni_with_H_at_center", "data": "def Atoms_fcc_Ni_with_H_at_center():\n\tatoms = bulk(\"Ni\", cubic=True)\n\tatoms += Atom(\"H\", position=atoms.cell.diagonal() / 2)\n\treturn atoms\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "lammps_data_file_Fe", "data": "def lammps_data_file_Fe(datadir):\n\treturn datadir / \"lammpslib_simple_input.data\"\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "calc_params_Fe", "data": "def calc_params_Fe(lammps_data_file_Fe):\n\tcalc_params = {}\n\tcalc_params[\"lammps_header\"] = [\n\t\t\"units\t\t   real\",\n\t\t\"atom_style\t  full\",\n\t\t\"boundary\t\tp p p\",\n\t\t\"box tilt\t\tlarge\",\n\t\t\"pair_style\t  lj/cut/coul/long 12.500\",\n\t\t\"bond_style\t  harmonic\",\n\t\t\"angle_style\t harmonic\",\n\t\t\"kspace_style\tewald 0.0001\",\n\t\t\"kspace_modify   gewald 0.01\",\n\t\tf\"read_data\t  {lammps_data_file_Fe}\",\n\t]\n\tcalc_params[\"lmpcmds\"] = []\n\tcalc_params[\"atom_types\"] = {\"Fe\": 1}\n\tcalc_params[\"create_atoms\"] = False\n\tcalc_params[\"create_box\"] = False\n\tcalc_params[\"boundary\"] = False\n\tcalc_params[\"log_file\"] = \"test.log\"\n\tcalc_params[\"keep_alive\"] = True\n\treturn calc_params\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "Atoms_Fe", "data": "def Atoms_Fe(lammps_data_file_Fe):\n\tAtoms_Fe = ase.io.read(\n\t\tlammps_data_file_Fe,\n\t\tformat=\"lammps-data\",\n\t\tZ_of_type={1: 26},\n\t\tunits=\"real\",\n\t)\n\treturn Atoms_Fe\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}, {"term": "def", "name": "test_lammpslib_simple", "data": "def test_lammpslib_simple(\n\tfactory,\n\tcalc_params_NiH,\n\tAtoms_fcc_Ni_with_H_at_center,\n\tcalc_params_Fe,\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase import Atom", "from ase.build import bulk", "import ase.io", "from ase import units", "from ase.md.verlet import VelocityVerlet"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\tawait e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\tawait e.answer(\"Error\", cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\tawait e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "calcDiameter", "data": "def calcDiameter(A):\n\treturn np.sqrt(4*A/np.pi)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcVolume", "data": "def calcVolume(M, rho):\n\treturn M/rho\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcDensity", "data": "def calcDensity(p, R, T):\n\treturn p/(R*T)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcGasConstant", "data": "def calcGasConstant(Ru,MM):\n\treturn Ru*1e3/MM;\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "vanker", "data": "def vanker(y):\n\treturn np.sqrt(y*(2/(y+1))**((y+1)/(y-1)));\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcExitPressure", "data": "def calcExitPressure(gasGamma,chamberPressure,nozzleEpsilon,pressureGuess):\n\tf = lambda x: 1/nozzleEpsilon - (((gasGamma+1)/2)**(1/(gasGamma-1)))* \\\n\tnp.sqrt((gasGamma+1)/(gasGamma-1))*((x/chamberPressure)**(1/gasGamma))* \\\n\tnp.sqrt(1-(x/chamberPressure)**((gasGamma-1)/gasGamma));\n\treturn fsolve(f,pressureGuess)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcCharacteristicVelocity", "data": "def calcCharacteristicVelocity(R_cp,T_c,GAMMA):\n\treturn np.sqrt(R_cp*T_c)/GAMMA\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcExitVelocity", "data": "def calcExitVelocity(eta_2D,y,R_cp,T_c,p_e,p_c):\n\treturn eta_2D*np.sqrt(2*(y/(y-1))*R_cp*T_c*(1-(p_e/p_c)**((y-1)/y)));\n\t#RITORNA UN ARRAY\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcAdaptedSpecificImpulse", "data": "def calcAdaptedSpecificImpulse(u_e,g_0):\n\treturn u_e/g_0\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcAdaptedThrustCoefficient", "data": "def calcAdaptedThrustCoefficient(eta_2D,I_s_e,g_0,c_star):\n\treturn eta_2D*I_s_e*g_0/c_star\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcThrustCoefficientWhat", "data": "def calcThrustCoefficientWhat(p_a,y,eps,p_e,p_c):\n\treturn np.sqrt((2*(y**2)/(y-1))*((2/(y+1))**((y+1)/(y-1))))+eps*((p_e-p_a)/p_c);\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcThrustCoefficient", "data": "def calcThrustCoefficient(p_a,y,eps,p_e,p_c,eta_2d):\n\treturn eta_2d*y*np.sqrt(2/(y-1)*((2/(y+1))**((y+1)/(y-1)))*(1-(p_e/p_c)**((y-1)/y)))+eps*(p_e-p_a)/p_c;\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcPropFlowRate", "data": "def calcPropFlowRate(T_z, u_e, eps, p_c, ct, p_e, p_z):\n\treturn T_z/(u_e+((eps*u_e)/(p_c*ct))*(p_e-p_z));\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcThroatArea", "data": "def calcThroatArea(m_p, u_e, p_c, ct):\n\treturn (m_p*u_e)/(p_c*ct)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcExitArea", "data": "def calcExitArea(A_t,eps):\n\treturn A_t*eps\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcThrust", "data": "def calcThrust(m_p, u_e, A_e, p_e, p_a):\n\treturn m_p*u_e + (p_e-p_a)*A_e\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcTropoPressure", "data": "def calcTropoPressure(z,p_0,T_0,a,g_0, R_air):\n\treturn p_0*(1+a*z/T_0)**(-g_0/(a*R_air))\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcPressureFromAltitude", "data": "def calcPressureFromAltitude(z,p_0,T_0,a,g_0, R_air):\n\treturn np.where(z<=11e3,calcTropoPressure(z,p_0,T_0,a,g_0, R_air),calcTropoPressure(11e3,p_0,T_0,a,g_0, R_air)*np.exp(-g_0*(z-11e3)/(R_air*(T_0-a*11e3))))\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcAltitudeFromPressure", "data": "def calcAltitudeFromPressure(p,p_0,T_0,a,g_0, R_air):\n\treturn np.where(p<=calcTropoPressure(11e3,p_0,T_0,a,g_0, R_air),11e3-R_air*(T_0-a*11e3)*np.log(p/calcTropoPressure(11e3,p_0,T_0,a,g_0, R_air))/g_0,calcTropoAltitude(p,p_0,T_0,a,g_0, R_air))\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcTropoAltitude", "data": "def calcTropoAltitude(p,p_0,T_0,a,g_0, R_air):\n\treturn T_0/a*((p/p_0)**(-a*R_air/g_0)-1)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "kiloNewtonToNewton", "data": "def kiloNewtonToNewton(f):\n\treturn 1e3*f\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcFuelRate", "data": "def calcFuelRate(m_p,r):\n\treturn m_p/(r+1)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcOxidizerRate", "data": "def calcOxidizerRate(m_f, r):\n\treturn r*m_f\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcMass", "data": "def calcMass(m, t_b, k_s):\n\treturn m*t_b*k_s\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcRhoAvg", "data": "def calcRhoAvg(M_f, M_ox, V_f, V_ox):\n\treturn (M_f+M_ox)/(V_f+V_ox)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcSpecificImpulse", "data": "def calcSpecificImpulse(thr, m_p, g_0):\n\treturn thr/(m_p*g_0)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcVolumetricSpecificImpulse", "data": "def calcVolumetricSpecificImpulse(I_s, rho_avg):\n\treturn I_s*rho_avg\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcTotalVolumetricImpulse", "data": "def calcTotalVolumetricImpulse(I_s, M_ox, M_f, g_0):\n\treturn I_s*(M_ox+M_f)*g_0\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcChamberVelocity", "data": "def calcChamberVelocity(Ma_c, y_c, R_c, T_c):\n\treturn Ma_c*np.sqrt(y_c*R_c*T_c)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcChamberArea", "data": "def calcChamberArea(m_p, rho_c, u_c):\n\treturn m_p/(rho_c*u_c)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcChamberVolume", "data": "def calcChamberVolume(L_star, A_t):\n\treturn L_star*A_t\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcChamberLength", "data": "def calcChamberLength(V_c, A_c):\n\treturn V_c/A_c\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcTotalHolesArea", "data": "def calcTotalHolesArea(m, C_d, rho, p_loss_inj, p_c):\n\treturn m/(C_d*np.sqrt(2*rho*p_loss_inj*p_c))\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcNumber1Holes", "data": "def calcNumber1Holes(A_th):\n\treturn 4*A_th/(np.pi*1e-6)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcNumberHoles", "data": "def calcNumberHoles(n_h_f, n_h_ox):\n\treturn np.ceil(min(n_h_f, n_h_ox))\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcHoleArea", "data": "def calcHoleArea(A_th, n_h):\n\treturn A_th/n_h\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcInjectionVelocity", "data": "def calcInjectionVelocity(C_d, p_loss_inj, p_c, rho):\n\treturn C_d*np.sqrt(2*p_loss_inj*p_c/rho)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcFuelInjectionAngle", "data": "def calcFuelInjectionAngle(m_ox, m_f, u_ox, u_f, alfa_ox):\n\treturn np.arcsin(np.sin(alfa_ox)*(m_ox*u_ox)/(m_f*u_f))\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcPStarF", "data": "def calcPStarF(p_c,P_loss_inj,P_loss_exc,P_loss_feed,P_loss_valves):\n\treturn p_c*(1+P_loss_inj+P_loss_exc+P_loss_feed+P_loss_valves)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcPStarOx", "data": "def calcPStarOx(p_c,P_loss_inj,P_loss_feed,P_loss_valves):\n\treturn p_c*(1+P_loss_inj+P_loss_feed+P_loss_valves)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcConeLength", "data": "def calcConeLength(eps, D_t, theta):\n\treturn (np.sqrt(eps)-1)*(D_t/2)/np.tan(theta)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcBellLength", "data": "def calcBellLength(L_cone):\n\treturn 0.8*L_cone\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcThetai", "data": "def calcThetai(D_c, D_t):\n\tf = lambda x: D_c/2-1.5*(D_t/2)*np.sin(x)-1.5*(D_t/2)-D_t/2\n\treturn fsolve(f, (-3/4)*np.pi)#VALORE TIPICO theta_i\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcXConv", "data": "def calcXConv(alpha, D_t):\n\ta=D_t/2\n\tinterval = np.linspace(alpha, np.pi*3/2, 20)\n\treturn 1.5*a*np.cos(interval)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcYConv", "data": "def calcYConv(alpha, D_t):\n\ta=D_t/2\n\tinterval = np.linspace(alpha, np.pi*3/2, 20)\n\treturn 1.5*a*(np.sin(interval)+1)+a\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcXDivPlus", "data": "def calcXDivPlus(theta_n, D_t):\n\tinterval = np.linspace(-np.pi/2, theta_n-np.pi/2, 50)\n\treturn 0.382*(D_t/2)*np.cos(interval)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcYDivPlus", "data": "def calcYDivPlus(theta_n, D_t):\n\tinterval = np.linspace(-np.pi/2, theta_n-np.pi/2, 50)\n\treturn 0.382*(D_t/2)*(np.sin(interval)+1)+D_t/2\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcXDivMinus", "data": "def calcXDivMinus(theta_n, theta_e, D_t, L_bell, D_e):\n\tN_x = 0.382*(D_t/2)*np.cos(theta_n-np.pi/2)\n\tN_y = 0.382*(D_t/2)*(np.sin(theta_n-np.pi/2)+1)+D_t/2\n\tC_1 = N_y-np.tan(theta_n)*N_x\n\tC_2 = (D_e/2)-np.tan(theta_e)*L_bell\n\tQ_x = (C_2-C_1)/(np.tan(theta_n)-np.tan(theta_e))\n\tt = np.linspace(0, 1, 50)\n\treturn N_x*(1-t)**2 + 2*Q_x*(1-t)*t + L_bell*t**2\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcYDivMinus", "data": "def calcYDivMinus(theta_n, theta_e, D_t, L_bell, D_e):\n\tN_x = 0.382 * (D_t / 2) * np.cos(theta_n - np.pi / 2)\n\tN_y = 0.382 * (D_t / 2) * (np.sin(theta_n - np.pi / 2) + 1) + D_t / 2\n\tC_1 = N_y - np.tan(theta_n) * N_x\n\tC_2 = (D_e / 2) - np.tan(theta_e) * L_bell\n\tQ_y = (np.tan(theta_n)*C_2-np.tan(theta_e)*C_1)/(np.tan(theta_n)-np.tan(theta_e))\n\tt = np.linspace(0, 1, 50)\n\treturn N_y*(1-t)**2 + 2*Q_y*(1-t)*t + (D_e/2)*t**2\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcAlpha", "data": "def calcAlpha(D_c,D_t,rad):\n\ta=D_t/2\n\tb=D_c/2\n\treturn np.arcsin((rad+5/2*a-b)/(rad+3/2*a))+np.pi\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcLTC", "data": "def calcLTC(D_c,D_t,alpha):\n\ta=D_t/2\n\tb=D_c/2\n\treturn np.cos(alpha)/(1+np.sin(alpha))*(a-b)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcRad", "data": "def calcRad(D_c,D_t,alpha):\n\ta=D_t/2\n\tb=D_c/2\n\treturn (b-a*(5/2+3/2*np.sin(alpha)))/(1+np.sin(alpha))\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcXRac", "data": "def calcXRac(alpha,l_tc,rad):\n\tbeta=alpha-np.pi\n\tinterval = np.linspace(beta, np.pi/2, 50)\n\treturn -l_tc + rad*np.cos(interval)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcYRac", "data": "def calcYRac(alpha,D_c,rad):\n\tb=D_c/2\n\tbeta=alpha-np.pi\n\tinterval = np.linspace(beta, np.pi/2, 50)\n\treturn b - rad + rad*np.sin(interval)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcXCc", "data": "def calcXCc(l_tc,L_c):\n\treturn np.array([-l_tc-L_c,-l_tc-L_c,-l_tc])\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcYCc", "data": "def calcYCc(D_c):\n\treturn np.array([0,D_c/2,D_c/2])\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaObj", "data": "def getCeaObj(fuelName, oxName):\n\t#print(type(fuelName),type(oxName))\n\treturn CEA_Obj( oxName=oxName, fuelName=fuelName, pressure_units='Pa', temperature_units='K', density_units='kg/m^3', sonic_velocity_units='m/s',specific_heat_units='J/kg-K')\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaObjSU", "data": "def getCeaObjSU(fuelName, oxName):\n\t#print(type(fuelName),type(oxName))\n\treturn CEA_ObjSU( oxName=oxName, fuelName=fuelName)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaChamberMM", "data": "def getCeaChamberMM(obj,pc,mr,eps=1):\n\treturn obj.get_Chamber_MolWt_gamma(Pc=pc,MR=mr,eps=eps)[0]\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaChamberGam", "data": "def getCeaChamberGam(obj,pc,mr,eps=1):\n\treturn obj.get_Chamber_MolWt_gamma(Pc=pc,MR=mr,eps=eps)[1]\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaThroatMM", "data": "def getCeaThroatMM(obj,pc,mr,eps=1):\n\treturn obj.get_Throat_MolWt_gamma(Pc=pc,MR=mr,eps=eps)[0]\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaThroatGam", "data": "def getCeaThroatGam(obj,pc,mr,eps=1):\n\t#print(obj,pc,mr,eps)\n\treturn obj.get_Throat_MolWt_gamma(Pc=pc,MR=mr,eps=eps)[1]\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaChamberTemperature", "data": "def getCeaChamberTemperature(obj,pc,mr,eps=1):\n\treturn obj.get_Temperatures(Pc=pc,MR=mr,eps=eps,frozen=1,frozenAtThroat=1)[0]\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaThroatTemperature", "data": "def getCeaThroatTemperature(obj,pc,mr,eps=1):\n\treturn obj.get_Temperatures(Pc=pc,MR=mr,eps=eps,frozen=1,frozenAtThroat=1)[1]\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaExitTemperature", "data": "def getCeaExitTemperature(obj,pc,mr,eps=1):\n\treturn obj.get_Temperatures(Pc=pc,MR=mr,eps=eps,frozen=1,frozenAtThroat=1)[2]\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaChamberCp", "data": "def getCeaChamberCp(obj,pc,mr,eps=1,frozen=0):\n\treturn obj.get_Chamber_Cp(Pc=pc,MR=mr,eps=eps)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaThrustCoefficient", "data": "def getCeaThrustCoefficient(obj, pamb, pc, mr, eps):\n\tprint(obj,pamb,pc,mr,eps)\n\treturn obj.getFrozen_PambCf(Pamb=pamb, Pc=pc, MR=mr, eps=eps, frozenAtThroat=1)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaCharacteristicVelocity", "data": "def getCeaCharacteristicVelocity(obj, pc, mr):\n\treturn obj.get_Cstar(Pc=pc, MR=mr)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaExitVelocity", "data": "def getCeaExitVelocity(obj, pc, mr, eps):\n\tson=obj.get_SonicVelocities(Pc=pc, MR=mr, eps=eps)[2]\n\tmach=obj.get_MachNumber(Pc=pc, MR=mr, eps=eps)\n\t#print(son,mach)\n\treturn son*mach\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaSpecificImpulse", "data": "def getCeaSpecificImpulse(obj, pc, mr, eps, pamb):\n\treturn obj.estimate_Ambient_Isp(Pc=pc, MR=mr, eps=eps, Pamb=pamb, frozen=1, frozenAtThroat=1)[0]\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "Pa2Psia", "data": "def Pa2Psia(pr):\n\treturn pr / 6894.75728\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "calcSpilF", "data": "def calcSpilF(q_eng_f,deltap_pump_f,deltap_pump_ox,eta_pump_f,eta_pump_ox,rho_f,rho_ox,tau_cc,tau_pb,eta_mt,eta_ad,cp_cpb,T_c,p_out,p_c,y_cpb):\n\tpsi=lambda tau: tau*rho_f/rho_ox\n\tbl=lambda tau: deltap_pump_f/eta_pump_f + psi(tau)*deltap_pump_ox/eta_pump_ox\n\tdenp=rho_f*(1+tau_pb)*eta_mt*eta_ad*cp_cpb*T_c*(1-(p_out/p_c)**((y_cpb-1)/y_cpb))\n\treturn bl(tau_cc)/(denp+bl(tau_pb))*q_eng_f\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}, {"term": "def", "name": "getCeaFullOutput", "data": "def getCeaFullOutput(obj, pc, mr, eps):\n\treturn CeaOutput(obj.get_full_cea_output(Pc=pc*1e-5, MR=mr, eps=eps, frozen=1, frozenAtThroat=1, pc_units='bar'))\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve", "from rocketcea.cea_obj_w_units import CEA_Obj", "from rocketcea.cea_obj import CEA_Obj as CEA_ObjSU", "from models import CeaOutput"]}], [{"term": "class", "name": "classBidirectionalAStarPlanner:", "data": "class BidirectionalAStarPlanner:\n\n\tdef __init__(self, ox, oy, resolution, rr):\n\t\t\"\"\"\n\t\tInitialize grid map for a star planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t\"\"\"\n\n\t\tself.min_x, self.min_y = None, None\n\t\tself.max_x, self.max_y = None, None\n\t\tself.x_width, self.y_width, self.obstacle_map = None, None, None\n\t\tself.resolution = resolution\n\t\tself.rr = rr\n\t\tself.calc_obstacle_map(ox, oy)\n\t\tself.motion = self.get_motion_model()\n\n\tclass Node:\n\t\tdef __init__(self, x, y, cost, parent_index):\n\t\t\tself.x = x  # index of grid\n\t\t\tself.y = y  # index of grid\n\t\t\tself.cost = cost\n\t\t\tself.parent_index = parent_index\n\n\t\tdef __str__(self):\n\t\t\treturn str(self.x) + \",\" + str(self.y) + \",\" + str(\n\t\t\t\tself.cost) + \",\" + str(self.parent_index)\n\n\tdef planning(self, sx, sy, gx, gy):\n\t\t\"\"\"\n\t\tBidirectional A star path search\n\n\t\tinput:\n\t\t\ts_x: start x position [m]\n\t\t\ts_y: start y position [m]\n\t\t\tgx: goal x position [m]\n\t\t\tgy: goal y position [m]\n\n\t\toutput:\n\t\t\trx: x position list of the final path\n\t\t\try: y position list of the final path\n\t\t\"\"\"\n\n\t\tstart_node = self.Node(self.calc_xy_index(sx, self.min_x),\n\t\t\t\t\t\t\t   self.calc_xy_index(sy, self.min_y), 0.0, -1)\n\t\tgoal_node = self.Node(self.calc_xy_index(gx, self.min_x),\n\t\t\t\t\t\t\t  self.calc_xy_index(gy, self.min_y), 0.0, -1)\n\n\t\topen_set_A, closed_set_A = dict(), dict()\n\t\topen_set_B, closed_set_B = dict(), dict()\n\t\topen_set_A[self.calc_grid_index(start_node)] = start_node\n\t\topen_set_B[self.calc_grid_index(goal_node)] = goal_node\n\n\t\tcurrent_A = start_node\n\t\tcurrent_B = goal_node\n\t\tmeet_point_A, meet_point_B = None, None\n\n\t\twhile 1:\n\t\t\tif len(open_set_A) == 0:\n\t\t\t\tprint(\"Open set A is empty..\")\n\t\t\t\tbreak\n\n\t\t\tif len(open_set_B) == 0:\n\t\t\t\tprint(\"Open set B is empty..\")\n\t\t\t\tbreak\n\n\t\t\tc_id_A = min(\n\t\t\t\topen_set_A,\n\t\t\t\tkey=lambda o: self.find_total_cost(open_set_A, o, current_B))\n\n\t\t\tcurrent_A = open_set_A[c_id_A]\n\n\t\t\tc_id_B = min(\n\t\t\t\topen_set_B,\n\t\t\t\tkey=lambda o: self.find_total_cost(open_set_B, o, current_A))\n\n\t\t\tcurrent_B = open_set_B[c_id_B]\n\n\t\t\t# show graph\n\t\t\tif show_animation:  # pragma: no cover\n\t\t\t\tplt.plot(self.calc_grid_position(current_A.x, self.min_x),\n\t\t\t\t\t\t self.calc_grid_position(current_A.y, self.min_y),\n\t\t\t\t\t\t \"xc\")\n\t\t\t\tplt.plot(self.calc_grid_position(current_B.x, self.min_x),\n\t\t\t\t\t\t self.calc_grid_position(current_B.y, self.min_y),\n\t\t\t\t\t\t \"xc\")\n\t\t\t\t# for stopping simulation with the esc key.\n\t\t\t\tplt.gcf().canvas.mpl_connect(\n\t\t\t\t\t'key_release_event',\n\t\t\t\t\tlambda event: [exit(0) if event.key == 'escape' else None])\n\t\t\t\tif len(closed_set_A.keys()) % 10 == 0:\n\t\t\t\t\tplt.pause(0.001)\n\n\t\t\tif current_A.x == current_B.x and current_A.y == current_B.y:\n\t\t\t\tprint(\"Found goal\")\n\t\t\t\tmeet_point_A = current_A\n\t\t\t\tmeet_point_B = current_B\n\t\t\t\tbreak\n\n\t\t\t# Remove the item from the open set\n\t\t\tdel open_set_A[c_id_A]\n\t\t\tdel open_set_B[c_id_B]\n\n\t\t\t# Add it to the closed set\n\t\t\tclosed_set_A[c_id_A] = current_A\n\t\t\tclosed_set_B[c_id_B] = current_B\n\n\t\t\t# expand_grid search grid based on motion model\n\t\t\tfor i, _ in enumerate(self.motion):\n\n\t\t\t\tc_nodes = [self.Node(current_A.x + self.motion[i][0],\n\t\t\t\t\t\t\t\t\t current_A.y + self.motion[i][1],\n\t\t\t\t\t\t\t\t\t current_A.cost + self.motion[i][2],\n\t\t\t\t\t\t\t\t\t c_id_A),\n\t\t\t\t\t\t   self.Node(current_B.x + self.motion[i][0],\n\t\t\t\t\t\t\t\t\t current_B.y + self.motion[i][1],\n\t\t\t\t\t\t\t\t\t current_B.cost + self.motion[i][2],\n\t\t\t\t\t\t\t\t\t c_id_B)]\n\n\t\t\t\tn_ids = [self.calc_grid_index(c_nodes[0]),\n\t\t\t\t\t\t self.calc_grid_index(c_nodes[1])]\n\n\t\t\t\t# If the node is not safe, do nothing\n\t\t\t\tcontinue_ = self.check_nodes_and_sets(c_nodes, closed_set_A,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  closed_set_B, n_ids)\n\n\t\t\t\tif not continue_[0]:\n\t\t\t\t\tif n_ids[0] not in open_set_A:\n\t\t\t\t\t\t# discovered a new node\n\t\t\t\t\t\topen_set_A[n_ids[0]] = c_nodes[0]\n\t\t\t\t\telse:\n\t\t\t\t\t\tif open_set_A[n_ids[0]].cost > c_nodes[0].cost:\n\t\t\t\t\t\t\t# This path is the best until now. record it\n\t\t\t\t\t\t\topen_set_A[n_ids[0]] = c_nodes[0]\n\n\t\t\t\tif not continue_[1]:\n\t\t\t\t\tif n_ids[1] not in open_set_B:\n\t\t\t\t\t\t# discovered a new node\n\t\t\t\t\t\topen_set_B[n_ids[1]] = c_nodes[1]\n\t\t\t\t\telse:\n\t\t\t\t\t\tif open_set_B[n_ids[1]].cost > c_nodes[1].cost:\n\t\t\t\t\t\t\t# This path is the best until now. record it\n\t\t\t\t\t\t\topen_set_B[n_ids[1]] = c_nodes[1]\n\n\t\trx, ry = self.calc_final_bidirectional_path(\n\t\t\tmeet_point_A, meet_point_B, closed_set_A, closed_set_B)\n\n\t\treturn rx, ry\n\n\t# takes two sets and two meeting nodes and return the optimal path\n\tdef calc_final_bidirectional_path(self, n1, n2, setA, setB):\n\t\trx_A, ry_A = self.calc_final_path(n1, setA)\n\t\trx_B, ry_B = self.calc_final_path(n2, setB)\n\n\t\trx_A.reverse()\n\t\try_A.reverse()\n\n\t\trx = rx_A + rx_B\n\t\try = ry_A + ry_B\n\n\t\treturn rx, ry\n\n\tdef calc_final_path(self, goal_node, closed_set):\n\t\t# generate final course\n\t\trx, ry = [self.calc_grid_position(goal_node.x, self.min_x)], \\\n\t\t\t\t [self.calc_grid_position(goal_node.y, self.min_y)]\n\t\tparent_index = goal_node.parent_index\n\t\twhile parent_index != -1:\n\t\t\tn = closed_set[parent_index]\n\t\t\trx.append(self.calc_grid_position(n.x, self.min_x))\n\t\t\try.append(self.calc_grid_position(n.y, self.min_y))\n\t\t\tparent_index = n.parent_index\n\n\t\treturn rx, ry\n\n\tdef check_nodes_and_sets(self, c_nodes, closedSet_A, closedSet_B, n_ids):\n\t\tcontinue_ = [False, False]\n\t\tif not self.verify_node(c_nodes[0]) or n_ids[0] in closedSet_A:\n\t\t\tcontinue_[0] = True\n\n\t\tif not self.verify_node(c_nodes[1]) or n_ids[1] in closedSet_B:\n\t\t\tcontinue_[1] = True\n\n\t\treturn continue_\n\n\t@staticmethod\n\tdef calc_heuristic(n1, n2):\n\t\tw = 1.0  # weight of heuristic\n\t\td = w * math.hypot(n1.x - n2.x, n1.y - n2.y)\n\t\treturn d\n\n\tdef find_total_cost(self, open_set, lambda_, n1):\n\t\tg_cost = open_set[lambda_].cost\n\t\th_cost = self.calc_heuristic(n1, open_set[lambda_])\n\t\tf_cost = g_cost + h_cost\n\t\treturn f_cost\n\n\tdef calc_grid_position(self, index, min_position):\n\t\t\"\"\"\n\t\tcalc grid position\n\n\t\t:param index:\n\t\t:param min_position:\n\t\t:return:\n\t\t\"\"\"\n\t\tpos = index * self.resolution + min_position\n\t\treturn pos\n\n\tdef calc_xy_index(self, position, min_pos):\n\t\treturn round((position - min_pos) / self.resolution)\n\n\tdef calc_grid_index(self, node):\n\t\treturn (node.y - self.min_y) * self.x_width + (node.x - self.min_x)\n\n\tdef verify_node(self, node):\n\t\tpx = self.calc_grid_position(node.x, self.min_x)\n\t\tpy = self.calc_grid_position(node.y, self.min_y)\n\n\t\tif px < self.min_x:\n\t\t\treturn False\n\t\telif py < self.min_y:\n\t\t\treturn False\n\t\telif px >= self.max_x:\n\t\t\treturn False\n\t\telif py >= self.max_y:\n\t\t\treturn False\n\n\t\t# collision check\n\t\tif self.obstacle_map[node.x][node.y]:\n\t\t\treturn False\n\n\t\treturn True\n\n\tdef calc_obstacle_map(self, ox, oy):\n\n\t\tself.min_x = round(min(ox))\n\t\tself.min_y = round(min(oy))\n\t\tself.max_x = round(max(ox))\n\t\tself.max_y = round(max(oy))\n\t\tprint(\"min_x:\", self.min_x)\n\t\tprint(\"min_y:\", self.min_y)\n\t\tprint(\"max_x:\", self.max_x)\n\t\tprint(\"max_y:\", self.max_y)\n\n\t\tself.x_width = round((self.max_x - self.min_x) / self.resolution)\n\t\tself.y_width = round((self.max_y - self.min_y) / self.resolution)\n\t\tprint(\"x_width:\", self.x_width)\n\t\tprint(\"y_width:\", self.y_width)\n\n\t\t# obstacle map generation\n\t\tself.obstacle_map = [[False for _ in range(self.y_width)]\n\t\t\t\t\t\t\t for _ in range(self.x_width)]\n\t\tfor ix in range(self.x_width):\n\t\t\tx = self.calc_grid_position(ix, self.min_x)\n\t\t\tfor iy in range(self.y_width):\n\t\t\t\ty = self.calc_grid_position(iy, self.min_y)\n\t\t\t\tfor iox, ioy in zip(ox, oy):\n\t\t\t\t\td = math.hypot(iox - x, ioy - y)\n\t\t\t\t\tif d <= self.rr:\n\t\t\t\t\t\tself.obstacle_map[ix][iy] = True\n\t\t\t\t\t\tbreak\n\n\t@staticmethod\n\tdef get_motion_model():\n\t\t# dx, dy, cost\n\t\tmotion = [[1, 0, 1],\n\t\t\t\t  [0, 1, 1],\n\t\t\t\t  [-1, 0, 1],\n\t\t\t\t  [0, -1, 1],\n\t\t\t\t  [-1, -1, math.sqrt(2)],\n\t\t\t\t  [-1, 1, math.sqrt(2)],\n\t\t\t\t  [1, -1, math.sqrt(2)],\n\t\t\t\t  [1, 1, math.sqrt(2)]]\n\n\t\treturn motion\n\n", "description": "\n\t\tInitialize grid map for a star planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t", "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():\n\tprint(__file__ + \" start!!\")\n\n\t# start and goal position\n\tsx = 10.0  # [m]\n\tsy = 10.0  # [m]\n\tgx = 50.0  # [m]\n\tgy = 50.0  # [m]\n\tgrid_size = 2.0  # [m]\n\trobot_radius = 1.0  # [m]\n\n\t# set obstacle positions\n\tox, oy = [], []\n\tfor i in range(-10, 60):\n\t\tox.append(i)\n\t\toy.append(-10.0)\n\tfor i in range(-10, 60):\n\t\tox.append(60.0)\n\t\toy.append(i)\n\tfor i in range(-10, 61):\n\t\tox.append(i)\n\t\toy.append(60.0)\n\tfor i in range(-10, 61):\n\t\tox.append(-10.0)\n\t\toy.append(i)\n\tfor i in range(-10, 40):\n\t\tox.append(20.0)\n\t\toy.append(i)\n\tfor i in range(0, 40):\n\t\tox.append(40.0)\n\t\toy.append(60.0 - i)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(ox, oy, \".k\")\n\t\tplt.plot(sx, sy, \"og\")\n\t\tplt.plot(gx, gy, \"ob\")\n\t\tplt.grid(True)\n\t\tplt.axis(\"equal\")\n\n\tbidir_a_star = BidirectionalAStarPlanner(ox, oy, grid_size, robot_radius)\n\trx, ry = bidir_a_star.planning(sx, sy, gx, gy)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(rx, ry, \"-r\")\n\t\tplt.pause(.0001)\n\t\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}], [{"term": "def", "name": "calculate_base_ratings", "data": "def calculate_base_ratings(raw_contact, raw_power, raw_avk):\n\tcalc_contact = (raw_contact-1)*2\n\tcalc_power = (raw_power-1)*2\n\tcalc_avk = (raw_avk-1)*2\n\n\treturn calc_contact, calc_power, calc_avk\n", "description": null, "category": "math", "imports": ["import math", "import sys"]}, {"term": "def", "name": "calc_avk_power_adjustors", "data": "def calc_avk_power_adjustors(calc_contact, calc_power, calc_avk):\n\tmodifiers = high_contact_modifiers if calc_contact > 100 else low_contact_modifiers\n\t\n\tif calc_avk > 100:\n\t\tif calc_power > 100:\n\t\t\tavk_power_adjustor_low_contact = low_contact_modifiers[\"high_avk\"]*(calc_avk-100) + low_contact_modifiers[\"high_power\"]*(calc_power-100)\n\t\t\tavk_power_adjustor_high_contact = high_contact_modifiers[\"high_avk\"]*(calc_avk-100) + high_contact_modifiers[\"high_power\"]*(calc_power-100)\n\t\telse:\n\t\t\tavk_power_adjustor_low_contact = low_contact_modifiers[\"high_avk\"]*(calc_avk-100) + low_contact_modifiers[\"low_power\"]*(calc_power-100)\n\t\t\tavk_power_adjustor_high_contact = high_contact_modifiers[\"high_avk\"]*(calc_avk-100) + high_contact_modifiers[\"low_power\"]*(calc_power-100)\n\telse:\n\t\tif calc_power > 100:\n\t\t\tavk_power_adjustor_low_contact = low_contact_modifiers[\"low_avk\"]*(calc_avk-100) + low_contact_modifiers[\"high_power\"]*(calc_power-100)\n\t\t\tavk_power_adjustor_high_contact = high_contact_modifiers[\"low_avk\"]*(calc_avk-100) + high_contact_modifiers[\"high_power\"]*(calc_power-100)\n\t\telse:\n\t\t\tavk_power_adjustor_low_contact = low_contact_modifiers[\"low_avk\"]*(calc_avk-100) + low_contact_modifiers[\"low_power\"]*(calc_power-100)\n\t\t\tavk_power_adjustor_high_contact = high_contact_modifiers[\"low_avk\"]*(calc_avk-100) + high_contact_modifiers[\"low_power\"]*(calc_power-100)\n\t\n\n\treturn avk_power_adjustor_low_contact, avk_power_adjustor_high_contact\n", "description": null, "category": "math", "imports": ["import math", "import sys"]}, {"term": "def", "name": "round_up_to_even", "data": "def round_up_to_even(f):\n\treturn math.ceil(f / 2.) * 2\n", "description": null, "category": "math", "imports": ["import math", "import sys"]}, {"term": "def", "name": "calc_babip", "data": "def calc_babip(raw_contact, raw_power, raw_avk):\n\tscaled = False\n\tlocal_contact, local_power, local_avk = raw_contact, raw_power, raw_avk\n\tif raw_contact < 11 and raw_power < 11 and raw_avk < 11:\n\t\tlocal_contact = local_contact * 10\n\t\tlocal_power = local_power * 10\n\t\tlocal_avk = local_avk * 10\n\t\tscaled = True\n\t\n\tcalc_contact, calc_power, calc_avk = calculate_base_ratings(local_contact, local_power, local_avk)\n\tmodifiers = low_contact_modifiers\n\t#print(f'calc contact:{calc_contact}  calc_power:{calc_power} calc_avk:{calc_avk}')\n\n\tavk_power_adjustor_low_contact, avk_power_adjustor_high_contact = calc_avk_power_adjustors(calc_contact, calc_power, calc_avk)\n\t#print(f'avk_power_adjustor_low_contact:{avk_power_adjustor_low_contact}  avk_power_adjustor_high_contact:{avk_power_adjustor_high_contact}')\n\tif calc_contact > 100:\n\t\tintermediate_contact = (calc_contact - 100 - avk_power_adjustor_high_contact)/high_contact_modifiers[\"low_babip\"] + 100\n\telse:\n\t\tintermediate_contact = (calc_contact - 100 - avk_power_adjustor_low_contact)/low_contact_modifiers[\"low_babip\"] + 100\n\n\t#print(f'intermediate_contact:{intermediate_contact}')\n\n\tif intermediate_contact > 100:\n\t\tif calc_contact > 100:\n\t\t\tcalc_babip = (calc_contact - 100 - avk_power_adjustor_high_contact)/high_contact_modifiers[\"high_babip\"] + 100\n\t\telse:\n\t\t\tcalc_babip = (calc_contact - 100 - avk_power_adjustor_high_contact)/low_contact_modifiers[\"high_babip\"] + 100\n\telse:\n\t\tif calc_contact > 100:\n\t\t\tcalc_babip = (calc_contact - 100 - avk_power_adjustor_high_contact)/high_contact_modifiers[\"low_babip\"] + 100\n\t\telse:\n\t\t\tcalc_babip = (calc_contact - 100 - avk_power_adjustor_low_contact)/low_contact_modifiers[\"low_babip\"] + 100\n\t\n\tfinal_babip = round_up_to_even( (round(calc_babip)+1)/2 )\n\n\tif scaled:\n\t\tfinal_babip = round(final_babip/10)\n\n\treturn final_babip\n", "description": null, "category": "math", "imports": ["import math", "import sys"]}], [], [{"term": "class", "name": "WorkbookProperties", "data": "class WorkbookProperties(Serialisable):\n\n\ttagname = \"workbookPr\"\n\n\tdate1904 = Bool(allow_none=True)\n\tdateCompatibility = Bool(allow_none=True)\n\tshowObjects = NoneSet(values=(['all', 'placeholders']))\n\tshowBorderUnselectedTables = Bool(allow_none=True)\n\tfilterPrivacy = Bool(allow_none=True)\n\tpromptedSolutions = Bool(allow_none=True)\n\tshowInkAnnotation = Bool(allow_none=True)\n\tbackupFile = Bool(allow_none=True)\n\tsaveExternalLinkValues = Bool(allow_none=True)\n\tupdateLinks = NoneSet(values=(['userSet', 'never', 'always']))\n\tcodeName = String(allow_none=True)\n\thidePivotFieldList = Bool(allow_none=True)\n\tshowPivotChartFilter = Bool(allow_none=True)\n\tallowRefreshQuery = Bool(allow_none=True)\n\tpublishItems = Bool(allow_none=True)\n\tcheckCompatibility = Bool(allow_none=True)\n\tautoCompressPictures = Bool(allow_none=True)\n\trefreshAllConnections = Bool(allow_none=True)\n\tdefaultThemeVersion = Integer(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t date1904=None,\n\t\t\t\t dateCompatibility=None,\n\t\t\t\t showObjects=None,\n\t\t\t\t showBorderUnselectedTables=None,\n\t\t\t\t filterPrivacy=None,\n\t\t\t\t promptedSolutions=None,\n\t\t\t\t showInkAnnotation=None,\n\t\t\t\t backupFile=None,\n\t\t\t\t saveExternalLinkValues=None,\n\t\t\t\t updateLinks=None,\n\t\t\t\t codeName=None,\n\t\t\t\t hidePivotFieldList=None,\n\t\t\t\t showPivotChartFilter=None,\n\t\t\t\t allowRefreshQuery=None,\n\t\t\t\t publishItems=None,\n\t\t\t\t checkCompatibility=None,\n\t\t\t\t autoCompressPictures=None,\n\t\t\t\t refreshAllConnections=None,\n\t\t\t\t defaultThemeVersion=None,\n\t\t\t\t):\n\t\tself.date1904 = date1904\n\t\tself.dateCompatibility = dateCompatibility\n\t\tself.showObjects = showObjects\n\t\tself.showBorderUnselectedTables = showBorderUnselectedTables\n\t\tself.filterPrivacy = filterPrivacy\n\t\tself.promptedSolutions = promptedSolutions\n\t\tself.showInkAnnotation = showInkAnnotation\n\t\tself.backupFile = backupFile\n\t\tself.saveExternalLinkValues = saveExternalLinkValues\n\t\tself.updateLinks = updateLinks\n\t\tself.codeName = codeName\n\t\tself.hidePivotFieldList = hidePivotFieldList\n\t\tself.showPivotChartFilter = showPivotChartFilter\n\t\tself.allowRefreshQuery = allowRefreshQuery\n\t\tself.publishItems = publishItems\n\t\tself.checkCompatibility = checkCompatibility\n\t\tself.autoCompressPictures = autoCompressPictures\n\t\tself.refreshAllConnections = refreshAllConnections\n\t\tself.defaultThemeVersion = defaultThemeVersion\n\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}, {"term": "class", "name": "CalcProperties", "data": "class CalcProperties(Serialisable):\n\n\ttagname = \"calcPr\"\n\n\tcalcId = Integer()\n\tcalcMode = NoneSet(values=(['manual', 'auto', 'autoNoTable']))\n\tfullCalcOnLoad = Bool(allow_none=True)\n\trefMode = NoneSet(values=(['A1', 'R1C1']))\n\titerate = Bool(allow_none=True)\n\titerateCount = Integer(allow_none=True)\n\titerateDelta = Float(allow_none=True)\n\tfullPrecision = Bool(allow_none=True)\n\tcalcCompleted = Bool(allow_none=True)\n\tcalcOnSave = Bool(allow_none=True)\n\tconcurrentCalc = Bool(allow_none=True)\n\tconcurrentManualCount = Integer(allow_none=True)\n\tforceFullCalc = Bool(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t calcId=124519,\n\t\t\t\t calcMode=None,\n\t\t\t\t fullCalcOnLoad=True,\n\t\t\t\t refMode=None,\n\t\t\t\t iterate=None,\n\t\t\t\t iterateCount=None,\n\t\t\t\t iterateDelta=None,\n\t\t\t\t fullPrecision=None,\n\t\t\t\t calcCompleted=None,\n\t\t\t\t calcOnSave=None,\n\t\t\t\t concurrentCalc=None,\n\t\t\t\t concurrentManualCount=None,\n\t\t\t\t forceFullCalc=None,\n\t\t\t\t):\n\t\tself.calcId = calcId\n\t\tself.calcMode = calcMode\n\t\tself.fullCalcOnLoad = fullCalcOnLoad\n\t\tself.refMode = refMode\n\t\tself.iterate = iterate\n\t\tself.iterateCount = iterateCount\n\t\tself.iterateDelta = iterateDelta\n\t\tself.fullPrecision = fullPrecision\n\t\tself.calcCompleted = calcCompleted\n\t\tself.calcOnSave = calcOnSave\n\t\tself.concurrentCalc = concurrentCalc\n\t\tself.concurrentManualCount = concurrentManualCount\n\t\tself.forceFullCalc = forceFullCalc\n\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}, {"term": "class", "name": "FileVersion", "data": "class FileVersion(Serialisable):\n\n\ttagname = \"fileVersion\"\n\n\tappName = String(allow_none=True)\n\tlastEdited = String(allow_none=True)\n\tlowestEdited = String(allow_none=True)\n\trupBuild = String(allow_none=True)\n\tcodeName = Guid(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t appName=None,\n\t\t\t\t lastEdited=None,\n\t\t\t\t lowestEdited=None,\n\t\t\t\t rupBuild=None,\n\t\t\t\t codeName=None,\n\t\t\t\t):\n\t\tself.appName = appName\n\t\tself.lastEdited = lastEdited\n\t\tself.lowestEdited = lowestEdited\n\t\tself.rupBuild = rupBuild\n\t\tself.codeName = codeName\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "class", "name": "CalculatorTest", "data": "class CalculatorTest(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tself.calc = Calculator()\n\n\tdef test_default_display_0(self):\n\t\tself.assertEqual(\"0\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_0_represented_as_0(self):\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"0\")\n\n\t\tself.assertEqual(\"0\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_intger_Number(self):\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"3\")\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"6\")\n\t\tself.calc.Press(\"7\")\n\t\tself.calc.Press(\"8\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"0\")\n\n\t\tself.assertEqual(\"1234567890\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_decimal_Number_1(self):\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"3\")\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"6\")\n\t\tself.calc.Press(\"7\")\n\t\tself.calc.Press(\"8\")\n\t\tself.calc.Press(\"9\")\n\n\t\tself.assertEqual(\"0.003456789\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_decimal_Number_2(self):\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"2\")\n\n\t\tself.assertEqual(\"42.042\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_sum_Input_first_value(self):\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"+\")\n\t\tself.assertEqual(\"12\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_sum_Input_second_value(self):\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"+\")\n\t\tself.calc.Press(\"2\")\n\t\tself.assertEqual(\"2\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_sum_two_values_with_addiction_sign(self):\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"+\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"+\")\n\t\tself.assertEqual(\"14\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_sum_input_third_value(self):\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"+\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"+\")\n\t\tself.calc.Press(\"5\")\n\t\tself.assertEqual(\"5\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_sum_three_values_with_equal_sign(self):\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"+\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"+\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"19.5\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_substract_input_two_values(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.assertEqual(\"5\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_substract_two_values_with_substract_sign(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"-\")\n\t\tself.assertEqual(\"2.5\", self.calc.Display)\n\t\tself.assertTrue(self.calc.IsNegative)\n\n\tdef test_substract_three_values_with_equal_sign(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"4.5\", self.calc.Display)\n\t\tself.assertTrue(self.calc.IsNegative)\n\n\tdef test_multiply_input_two_values(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.assertEqual(\"2.5\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_multiply_two_values_with_multiply_sign(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"x\")\n\t\tself.assertEqual(\"5\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_multiply_three_values_with_equal_sign(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"10\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_divide_input_two_values(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"/\")\n\t\tself.calc.Press(\"5\")\n\t\tself.assertEqual(\"5\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_divide_two_values_with_divide_sign(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"/\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"/\")\n\t\tself.assertEqual(\"0.5\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_divide_three_values_with_equal_sign(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"/\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"/\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"0.25\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_sum_and_multiply(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"+\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"15\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_divide_and_substract(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"/\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"=\")\n\n\t\tself.assertEqual(\"1\", self.calc.Display)\n\t\tself.assertTrue(self.calc.IsNegative)\n\n\tdef test_sum_and_equal_many_times(self):\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"+\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\"=\")\n\t\tself.calc.Press(\"=\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"7.6\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_multiple_many_times(self):\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"4\", self.calc.Display)\n\t\tself.assertTrue(self.calc.IsNegative)\n\n\tdef test_negative_values_equatation(self):\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"+\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"2.5\", self.calc.Display)\n\t\tself.assertTrue(self.calc.IsNegative)\n\n\tdef test_negative_values_equatation2(self):\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"2\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_fraction_short(self):\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"4\")\n\t\tself.assertEqual(\"0.4\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_fraction_short_second_value(self):\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"+\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"4\")\n\t\tself.assertEqual(\"0.4\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_Clear(self):\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"C/CE\")\n\t\tself.assertEqual(\"0\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_Clear_memory(self):\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"M-\")\n\t\tself.calc.Press(\"C/CE\")\n\t\tself.assertEqual(\"0\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\t\tself.assertTrue(self.calc.IsMemorized)\n\n\tdef test_Clear_memory2(self):\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"M-\")\n\t\tself.calc.Press(\"C/CE\")\n\t\tself.calc.Press(\"C/CE\")\n\t\tself.assertEqual(\"0\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\t\tself.assertFalse(self.calc.IsMemorized)\n\n\tdef test_input_after_Clear(self):\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"C/CE\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.assertEqual(\"0.5\", self.calc.Display)\n\t\tself.assertTrue(self.calc.IsNegative)\n\n\tdef test_equatation_after_Clear(self):\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"C/CE\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\".\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"2.5\", self.calc.Display)\n\t\tself.assertTrue(self.calc.IsNegative)\n\n\tdef test_negative_multiply(self):\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"6\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"30\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_M_plus_value(self):\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.assertTrue(self.calc.IsMemorized)\n\n\tdef test_M_plus_value2(self):\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.calc.Press(\"5\")\n\t\tself.assertEqual(\"5\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_MRC_value(self):\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.calc.Press(\"MRC\")\n\t\tself.assertEqual(\"1\", self.calc.Display)\n\t\tself.assertTrue(self.calc.IsNegative)\n\n\tdef test_MRC_value2(self):\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"M-\")\n\t\tself.calc.Press(\"MRC\")\n\t\tself.assertEqual(\"9\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_value_after_MRC(self):\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.calc.Press(\"MRC\")\n\t\tself.calc.Press(\"3\")\n\t\tself.assertEqual(\"3\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\t\tself.assertTrue(self.calc.IsMemorized)\n\n\tdef test_value_after_MRC2(self):\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.calc.Press(\"MRC\")\n\t\tself.calc.Press(\"MRC\")\n\t\tself.assertEqual(\"1\", self.calc.Display)\n\t\tself.assertTrue(self.calc.IsNegative)\n\t\tself.assertFalse(self.calc.IsMemorized)\n\n\tdef test_value_after_MRC3(self):\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.calc.Press(\"MRC\")\n\t\tself.calc.Press(\"5\")\n\t\tself.calc.Press(\"MRC\")\n\t\tself.assertEqual(\"1\", self.calc.Display)\n\t\tself.assertTrue(self.calc.IsNegative)\n\t\tself.assertTrue(self.calc.IsMemorized)\n\n\tdef test_multiply_after_MRC(self):\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"M+\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"MRC\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"8\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\t\tself.assertTrue(self.calc.IsMemorized)\n\n\tdef test_sqrt(self):\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"sqrt\")\n\t\tself.assertEqual(\"2\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_sqrt_error(self):\n\t\tself.calc.Press(\"-\")\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"sqrt\")\n\t\tself.assertEqual(\"0\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\t\tself.assertTrue(self.calc.Error)\n\n\tdef test_div0_error(self):\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"/\")\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"0\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\t\tself.assertTrue(self.calc.Error)\n\n\tdef test_percent_multiply(self):\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"x\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"p\")\n\t\tself.assertEqual(\"2\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_percent_Divide(self):\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"/\")\n\t\tself.calc.Press(\"2\")\n\t\tself.calc.Press(\"p\")\n\t\tself.assertEqual(\"5000\", self.calc.Display)\n\t\tself.assertFalse(self.calc.IsNegative)\n\n\tdef test_div0_error(self):\n\t\tself.calc.Press(\"4\")\n\t\tself.calc.Press(\"/\")\n\t\tself.calc.Press(\"0\")\n\t\tself.calc.Press(\"=\")\n\t\tself.calc.Press(\"4\")\n\t\tself.assertEqual(\"0\", self.calc.Display)\n\t\tself.assertTrue(self.calc.Error)\n\n\tdef test_div0_error2(self):\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"+\")\n\t\tself.assertEqual(\"99999999999\", self.calc.Display)\n\t\tself.assertFalse(self.calc.Error)\n\n\tdef test_div0_error3(self):\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"9\")\n\t\tself.calc.Press(\"+\")\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"100000000000\", self.calc.Display)\n\t\tself.assertTrue(self.calc.Error)\n\n\tdef test_div1_3(self):\n\t\tself.calc.Press(\"1\")\n\t\tself.calc.Press(\"/\")\n\t\tself.calc.Press(\"3\")\n\t\tself.calc.Press(\"=\")\n\t\tself.assertEqual(\"0.33333333333\", self.calc.Display)\n\t\tself.assertFalse(self.calc.Error)\n", "description": null, "category": "math", "imports": ["from Calculator import Calculator", "import unittest"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "solve", "data": "def solve(calc, pre):\n\twhile calc.find(' ') > 0:\n\t\tif calc.find('(') >= 0:\n\t\t\tinner = get_inner_calc(calc)\n\t\t\tcalc = calc.replace('(' + inner + ')', solve(inner, pre), 1)\n\t\tterm = []\n\t\tfor item in calc.split(' '):\n\t\t\tterm.append(item.strip('()'))\n\t\t\tif len(term) == 3:\n\t\t\t\tif pre and term[1] != '+' and calc.find('+') > 0:\n\t\t\t\t\tterm = [term[2]]\n\t\t\t\telse:\n\t\t\t\t\tcalc = calc.replace(' '.join(term), str(operate(term)), 1)\n\treturn calc\n\n", "description": null, "category": "math", "imports": []}, {"term": "def", "name": "get_inner_calc", "data": "def get_inner_calc(calc):\n\tstart_index = 0\n\topen_braces = 0\n\tfor index, char in enumerate(calc):\n\t\tif char == '(':\n\t\t\tif open_braces == 0:\n\t\t\t\tstart_index = index\n\t\t\topen_braces += 1\n\t\telif char == ')':\n\t\t\topen_braces -= 1\n\t\t\tif open_braces == 0:\n\t\t\t\treturn calc[start_index + 1: index]\n\n", "description": null, "category": "math", "imports": []}, {"term": "def", "name": "operate", "data": "def operate(term):\n\tif term[1] == '+':\n\t\treturn int(term[0]) + int(term[2])\n\telif term[1] == '*':\n\t\treturn int(term[0]) * int(term[2])\n\n", "description": null, "category": "math", "imports": []}], [{"term": "def", "name": "test_plugin_function_class_reminder_instantiate", "data": "def test_plugin_function_class_reminder_instantiate():\n\tReminderFunctionClass()\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.reminders.function_class import ReminderFunctionClass", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_function_class_reminder_hook", "data": "def test_plugin_function_class_reminder_hook():\n\tcalc = TestCalculator()\n\tplugin = ReminderFunctionClass()\n\tcalc.register_plugin_and_enable(plugin)\n\tassert plugin in calc.plugins\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.reminders.function_class import ReminderFunctionClass", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_function_class_reminder_context_updated", "data": "def test_plugin_function_class_reminder_context_updated():\n\tcalc = TestCalculator()\n\tcalc.register_plugin_and_enable(ReminderFunctionClass())\n\tassert calc.chksym(\"output_functionclass\")\n\tassert callable(calc.getsym(\"output_functionclass\"))\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.reminders.function_class import ReminderFunctionClass", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_function_class_reminder_available", "data": "def test_plugin_function_class_reminder_available():\n\tcalc = TestCalculator()\n\tcalc.register_plugin_and_enable(ReminderFunctionClass())\n\tassert callable(calc.command(\"output_functionclass\"))\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.reminders.function_class import ReminderFunctionClass", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_function_class_reminder_example", "data": "def test_plugin_function_class_reminder_example(capfd):\n\tcalc = TestCalculator()\n\tcalc.register_plugin_and_enable(ReminderFunctionClass())\n\tcalc.command(\"sin\")\n\tassert \"is a function\" in capfd.readouterr().out\n\tcalc.command(\"cos\")\n\tassert \"is a function\" in capfd.readouterr().out\n\tcalc.command(\"arg\")\n\tassert \"is a function\" in capfd.readouterr().out\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.reminders.function_class import ReminderFunctionClass", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_function_class_reminder_validate", "data": "def test_plugin_function_class_reminder_validate(capfd):\n\tcalc = TestCalculator()\n\tcalc.register_plugin_and_enable(ReminderFunctionClass())\n\tremind = [\"sin\", \"cos\", \"tan\", \"csc\", \"sec\", \"cot\", \"arg\", \"sinh\", \"cosh\", \"tanh\", \"csch\", \"sech\", \"coth\", \"asin\", \"acos\", \"atan\", \"acsc\", \"asec\", \"acot\", \"asinh\", \"acosh\", \"atanh\", \"acsch\", \"asech\", \"acoth\"]\n\tfor r in remind:\n\t\tcalc.command(r)\n\t\tassert \"is a function\" in capfd.readouterr().out\n\tcalc.command(\"exec\")\n\tcalc.command(\"eval\")\n\tcalc.command(\"compile\")\n\tcalc.command(\"int\")\n\tcalc.command(\"float\")\n\tassert \"is a function\" not in capfd.readouterr().out\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.reminders.function_class import ReminderFunctionClass", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_function_class_reminder_enable_switch", "data": "def test_plugin_function_class_reminder_enable_switch(capfd):\n\tcalc = TestCalculator()\n\tplugin = ReminderFunctionClass()\n\tcalc.register_plugin_and_enable(plugin)\n\tcalc.command(\"sin\")\n\tassert \"is a function\" in capfd.readouterr().out\n\tcalc.command(\"cos\")\n\tassert \"is a function\" in capfd.readouterr().out\n\tcalc.command(\"arg\")\n\tassert \"is a function\" in capfd.readouterr().out\n\tassert plugin.setting_name\n\tcalc.settings[plugin.setting_name] = False\n\tcalc.command(\"sin\")\n\tcalc.command(\"cos\")\n\tcalc.command(\"arg\")\n\tassert \"is a function\" not in capfd.readouterr().out\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.reminders.function_class import ReminderFunctionClass", "from tests import TestCalculator"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await ultroid_bot.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "updateScreen", "data": "def updateScreen(stdscr, calc):\n\tstdscr.clear()\n\ttopStr = '\t {0:5}'.format(operators[calc['opcode']])\n\ttopStr += opFormat.format(calc['input'])\n\tfillRpt = curses.COLS - len(topStr) - 1\n\ttopStr = topStr + (' ' * fillRpt)\n\tstdscr.addstr(0,0, (' ' * (curses.COLS - 1)), curses.A_REVERSE)\n\tstdscr.addstr(1,0, topStr, curses.A_REVERSE)\n\tstdscr.addstr(2,0, (' ' * (curses.COLS - 1)), curses.A_REVERSE)\n\n\tstdscr.addstr(5,5, 'op1:')\n\tstdscr.addstr(6,5, 'op2:')\n\tstdscr.addstr(7,5, '   =')\n\tif calc['opcode'] > 0:\n\t\tstdscr.addstr(5,46, '{:4}'.format(operators[calc['opcode']]))\n\tif calc['op1loaded']:\n\t\tstdscr.addstr(5,10, opFormat.format(calc['op1']))\n\t\tif calc['op2loaded']:\n\t\t\tstdscr.addstr(6,10, opFormat.format(calc['op2']))\n\t\t\tif calc['haveResult']:\n\t\t\t\tresultStr = opFormat.format(calc['result'])\n\t\t\t\tif calc['negFlag'] == PiDP_CP.LED_ON: resultStr += ' -'\n\t\t\t\tif calc['carryFlag'] == PiDP_CP.LED_ON: resultStr += ' C'\n\t\t\t\tstdscr.addstr(7,10, resultStr)\n\n\tstdscr.addstr(15,5, 'Store op1: {0}  |  Store op2: {1}  |  Exec: {2}'.format(OP1_DEP_SW, OP2_DEP_SW, EXEC_SW))\n\tstdscr.addstr(17,5, 'Data Field: 1=AND 2=OR 3=XOR 4=ADD 5=NAND 6=SUB 7=NOR')\n\tstdscr.refresh()\t#update screen\n", "description": null, "category": "math", "imports": ["import PiDP_CP_NT as PiDP_CP", "import RPi.GPIO as GPIO", "import sys, curses"]}, {"term": "def", "name": "main", "data": "def main(stdscr):\n\tcalc = {\n\t\t'op1': 0,\n\t\t'op2': 0,\n\t\t'opcode': 0,\n\t\t'result': 0,\n\t\t'carryFlag': PiDP_CP.LED_OFF,\n\t\t'negFlag': PiDP_CP.LED_OFF,\n\t\t'haveResult': False,\n\t\t'input': 0,\n\t\t'op1loaded': False,\n\t\t'op2loaded': False\n\t}\n\topLeds = {\n\t\t'data_field0': 'sc3',\n\t\t'data_field1': 'sc2',\n\t\t'data_field2': 'sc1',\n\t}\n\tloop = True\n\twhile loop:\n\t\tCP.lightAllLeds(loops=5)\t\t\t\t\t\t\t# light up the LEDs\n\t\tif CP.scanAllSwitches():\n\t\t\t# switches have changed\n\t\t\tif CP.switchIsOn('stop'):\n\t\t\t\tloop = False\n\t\t\telse:\n\t\t\t\tcalc['input'] = CP.switchSetValue('swreg')\n\t\t\t\tcalc['opcode'] = CP.switchSetValue('data_field')\n\t\t\t\tCP.setLedDataBank('mq', calc['input'])\n\t\t\t\tcalc['result'] = 0\n\t\t\t\tcalc['carryFlag'] = PiDP_CP.LED_OFF\n\t\t\t\tcalc['negFlag'] = PiDP_CP.LED_OFF\n\t\t\t\tcalc['haveResult'] = False\n\t\t\t\tif CP.switchIsOn(OP1_DEP_SW):\n\t\t\t\t\tif not calc['op1loaded']:\n\t\t\t\t\t\tcalc['op1'] = calc['input']\n\t\t\t\t\t\tcalc['op1loaded'] = True\n\t\t\t\t\telse:\n\t\t\t\t\t\tif CP.switchIsOn(OP2_DEP_SW):\n\t\t\t\t\t\t\tif not calc['op2loaded']:\n\t\t\t\t\t\t\t\tcalc['op2'] = calc['input']\n\t\t\t\t\t\t\t\tcalc['op2loaded'] = True\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\tif calc['opcode'] > 0 and CP.switchIsOn(EXEC_SW):\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 1:\t\t\t\t\t\t# and\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['op1'] & calc['op2']\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 2:\t\t\t\t\t\t# or\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['op1'] | calc['op2']\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 3:\t\t\t\t\t\t# xor\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['op1'] ^ calc['op2']\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 4:\t\t\t\t\t\t# add\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['op1'] + calc['op2']\n\t\t\t\t\t\t\t\t\t\tif calc['result'] > 4095:\n\t\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['result'] % 4096\n\t\t\t\t\t\t\t\t\t\t\tcalc['carryFlag'] = PiDP_CP.LED_ON\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 5:\t\t\t\t\t\t# nand\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = ~(calc['op1'] & calc['op2']) & 0xFFF\t# mask highest bits of 32-bit int to avoid negative\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 6:\t\t\t\t\t\t# sub\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = calc['op1'] + ((~calc['op2']) + 1)\n\t\t\t\t\t\t\t\t\t\tif calc['result'] < 0:\n\t\t\t\t\t\t\t\t\t\t\tcalc['negFlag'] = PiDP_CP.LED_ON\n\t\t\t\t\t\t\t\t\tif calc['opcode'] == 7:\t\t\t\t\t\t# nor\n\t\t\t\t\t\t\t\t\t\tcalc['result'] = ~(calc['op1'] | calc['op2']) & 0xFFF\t# mask highest bits to avoid negative\n\t\t\t\t\t\t\t\t\tcalc['haveResult'] = True\n\t\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t\tcalc['haveResult'] = False\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tcalc['op2loaded'] = False\n\t\t\t\t\t\t\tcalc['op2'] = 0\n\t\t\t\telse:\n\t\t\t\t\tcalc['op1loaded'] = False\n\t\t\t\t\tcalc['op2loaded'] = False\n\t\t\t\t\tcalc['op1'] = 0\n\t\t\t\t\tcalc['op2'] = 0\n\t\t\tCP.setLedDataBank('ma', calc['op1'])\n\t\t\tCP.setLedDataBank('mb', calc['op2'])\n\t\t\tCP.setLedDataBank('ac', calc['result'])\n\t\t\tCP.setLedState('link', calc['carryFlag'])\n\t\t\tCP.setLedState('sc5', calc['negFlag'])\n\t\t\tfor switchname in opLeds:\n\t\t\t\tif CP.switchSetting(switchname):\n\t\t\t\t\tCP.setLedState(opLeds[switchname], PiDP_CP.LED_ON)\n\t\t\t\telse:\n\t\t\t\t\tCP.setLedState(opLeds[switchname], PiDP_CP.LED_OFF)\n\t\t\tCP.lightAllLeds(loops=5)\t# light up the LEDs again\n\t\t\tupdateScreen(stdscr, calc)\n", "description": null, "category": "math", "imports": ["import PiDP_CP_NT as PiDP_CP", "import RPi.GPIO as GPIO", "import sys, curses"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [], [], [], [], [{"term": "class", "name": "TestWriteCalcPr", "data": "class TestWriteCalcPr(unittest.TestCase):\n\t\"\"\"\n\tTest the Workbook _write_calc_pr() method.\n\n\t\"\"\"\n\n\tdef setUp(self):\n\t\tself.fh = StringIO()\n\t\tself.workbook = Workbook()\n\t\tself.workbook._set_filehandle(self.fh)\n\n\tdef test_write_calc_pr(self):\n\t\t\"\"\"Test the _write_calc_pr() method.\"\"\"\n\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef test_calc_mode_auto_except_tables(self):\n\t\t\"\"\"\n\t\tTest the _write_calc_pr() method with the calculation mode set\n\t\tto auto_except_tables.\n\n\t\t\"\"\"\n\n\t\tself.workbook.set_calc_mode(\"auto_except_tables\")\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef test_calc_mode_manual(self):\n\t\t\"\"\"\n\t\tTest the _write_calc_pr() method with the calculation mode set to\n\t\tmanual.\n\n\t\t\"\"\"\n\n\t\tself.workbook.set_calc_mode(\"manual\")\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef test_write_calc_pr(self):\n\t\t\"\"\"Test the _write_calc_pr() method with non-default calc id.\"\"\"\n\n\t\tself.workbook.set_calc_mode(\"auto\", 12345)\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef tearDown(self):\n\t\tself.workbook.fileclosed = 1\n", "description": "\n\tTest the Workbook _write_calc_pr() method.\n\n\t", "category": "math", "imports": ["import unittest", "from ...compatibility import StringIO", "from ...workbook import Workbook"]}], [{"term": "def", "name": "replace_allnew", "data": "def replace_allnew(astr, bstr, dict):\n\twith open(astr, 'r') as afile:\n\t\twith open(bstr, 'w') as bfile:\n\t\t\tdata = afile.read()\n\t\t\tfor key, value in dict.items():\n\t\t\t\tdata = data.replace(key, str(value))\n\t\t\tbfile.write(data)\n\treturn data\n\n", "description": null, "category": "math", "imports": ["import os"]}, {"term": "def", "name": "getWaters", "data": "def getWaters(afile):\n\tnWaters = \"\"\n\twith open(afile, 'r') as bfile:\n\t\tnWaters = int(bfile.read())\n\treturn nWaters\n\n", "description": null, "category": "math", "imports": ["import os"]}, {"term": "def", "name": "getMultCharge", "data": "def getMultCharge(afile):\n\n\twith open(afile, 'r') as afile:\n\t\ttext = afile.read()\n\t\tstartloc = text.rfind(\"$molecule\\n\") + len(\"$molecule\\n\")\n\t\tgood = [int(d) for d in text[startloc:].split(\"\\n\")[0].split()]\n\treturn good[0], good[1]\n", "description": null, "category": "math", "imports": ["import os"]}, {"term": "def", "name": "read_input_file_dict", "data": "def read_input_file_dict(start_dir, paramFile = 'input_file_specs.txt'):\n\tcalcDict = {}\n\t#What happens if we want a single point energy and need a different input file? \n\tparameter_file = os.path.join(start_dir, paramFile)\n\n\twith open(parameter_file, 'rb') as inpFile:\n\t\tfor line in inpFile:\n\t\t\tkey_string = '{#'+line.split(' = ')[0].strip()+'}'\n\t\t\tvalue_string = line.split(' = ')[-1].strip()\n\t\t\tcalcDict[key_string] = value_string\n\tif calcDict['{#IMP_SOLV}'] == 'SMD':\n\t\tcalcDict['{#IMP_SOLV}'] = \"%cosmo smd true \\nend\"\n\t\tcalcDict['{#IMP_SOLV_NAME}'] = \"SMD\"\n\telse: \n\t\tcalcDict['{#IMP_SOLV}'] = \"%cosmo epsilon 80.4\\nrefrac 1.33\\nend\"\n\t\tcalcDict['{#IMP_SOLV_NAME}'] = \"COSMO\"\n\n\treturn calcDict\n", "description": null, "category": "math", "imports": ["import os"]}, {"term": "def", "name": "read_input_file_dict_with_rxn", "data": "def read_input_file_dict_with_rxn(paramFile = 'input_file_specs.txt'):\n\tcalcDict = {}\n\t#What happens if we want a single point energy and need a different input file? \n\trxn_flag = 0\n\tparam_flag = 0\n\tcalcDict['WORKDIR'] = '/'.join(paramFile.split('/')[:-1])\n\twith open(paramFile, 'rb') as inpFile:\n\t\tfor line in inpFile:\n\t\t\tif '$RXN_LIST' in line:\n\t\t\t\trxn_flag = 1\n\t\t\t\tcalcDict['RXN_LIST'] = []\n\t\t\t\tcontinue\n\t\t\tif '$PARAMETERS' in line: \n\t\t\t\trxn_flag = 0\n\t\t\t\tparam_flag = 1 \n\t\t\t\tcontinue\n\t\t\tif rxn_flag:\n\t\t\t\tif 'END' in line:\n\t\t\t\t\trxn_flag = 0\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tcalcDict['RXN_LIST'].append(line.strip())\n\t\t\tif param_flag:\n\t\t\t\tif \"END\" in line:\n\t\t\t\t\tparam_flag = 0\n\t\t\t\telse:\n\t\t\t\t\tkey_string = '{#'+line.split(' = ')[0].strip()+'}'\n\t\t\t\t\tvalue_string = line.split(' = ')[-1].strip()\n\t\t\t\t\tcalcDict[key_string] = value_string\n\n\t#Implicit solvation details\n\tif calcDict['{#IMP_SOLV}'] == 'SMD':\n\t\tcalcDict['{#IMP_SOLV}'] = \"%cosmo smd true \\nend\"\n\t\tcalcDict['{#IMP_SOLV_NAME}'] = \"SMD\"\n\telse: \n\t\tcalcDict['{#IMP_SOLV}'] = \"%cosmo epsilon 80.4\\nrefrac 1.33\\nend\"\n\t\tcalcDict['{#IMP_SOLV_NAME}'] = \"COSMO\"\n\n\t#Dispersion correction details: \n\tif calcDict['{#DISPERSION}'] == 'NONE':\n\t\tcalcDict['{#DISPERSION}'] = ''\n\n\t#Basis set and input template details\n\tif calcDict['{#BASIS}'] == 'P6_31G':\n\t\tcalcDict['{#BASIS}'] = '_6_31G'\n\t\tcalcDict['{#TEMPLATE_INP}'] = 'template_input_pople.inp'\n\telif calcDict['{#BASIS}'] == 'def2_SVP':\n\t\tcalcDict['{#BASIS}'] = 'def2-SVP'\n\telif calcDict['{#BASIS}'] == 'def2_TZVP':\n\t\tcalcDict['{#BASIS}'] = 'def2-TZVP'\t   \n\n\treturn calcDict\n", "description": null, "category": "math", "imports": ["import os"]}, {"term": "def", "name": "read_input_file_dict_SPE", "data": "def read_input_file_dict_SPE(paramFile = 'input_file_specs.txt'):\n\tcalcDict = {}\n\t#What happens if we want a single point energy and need a different input file? \n\trxn_flag = 0\n\tparam_flag = 0\n\tcalcDict['WORKDIR'] = '/'.join(paramFile.split('/')[:-1])\n\twith open(paramFile, 'rb') as inpFile:\n\t\tfor line in inpFile:\n\t\t\tif '$RXN_LIST' in line:\n\t\t\t\trxn_flag = 1\n\t\t\t\tcalcDict['RXN_LIST'] = []\n\t\t\t\tcontinue\n\t\t\tif '$PARAMETERS' in line: \n\t\t\t\trxn_flag = 0\n\t\t\t\tparam_flag = 1 \n\t\t\t\tcontinue\n\t\t\tif rxn_flag:\n\t\t\t\tif 'END' in line:\n\t\t\t\t\trxn_flag = 0\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tcalcDict['RXN_LIST'].append(line.strip())\n\t\t\tif param_flag:\n\t\t\t\tif \"END\" in line:\n\t\t\t\t\tparam_flag = 0\n\t\t\t\telse:\n\t\t\t\t\tkey_string = '{#'+line.split(' = ')[0].strip()+'}'\n\t\t\t\t\tvalue_string = line.split(' = ')[-1].strip()\n\t\t\t\t\tcalcDict[key_string] = value_string\n\n\t#Implicit solvation details\n\tif calcDict['{#IMP_SOLV}'] == 'SMD':\n\t\tcalcDict['{#IMP_SOLV}'] = \"%cosmo smd true \\nend\\n\"\n\t\tcalcDict['{#IMP_SOLV_NAME}'] = \"SMD\"\n\telif calcDict['{#IMP_SOLV}'] == 'NONE':\n\t\tcalcDict['{#IMP_SOLV}'] = ''\n\t\tcalcDict['{#IMP_SOLV_NAME}'] = \"NONE\"\n\telse: \n\t\tcalcDict['{#IMP_SOLV}'] = \"%cosmo epsilon 80.4\\nrefrac 1.33\\nend\\n\"\n\t\tcalcDict['{#IMP_SOLV_NAME}'] = \"COSMO\"\n\n\t#Dispersion correction details: \n\tif calcDict['{#DISPERSION}'] == 'NONE':\n\t\tcalcDict['{#DISPERSION}'] = ''\n\n\t#Basis set and input template details\n\tif calcDict['{#BASIS}'] == 'P6_31G':\n\t\tcalcDict['{#BASIS}'] = '_6_31G'\n\telif calcDict['{#BASIS}'] == 'def2_SVP':\n\t\tcalcDict['{#BASIS}'] = 'def2-SVP'\n\telif calcDict['{#BASIS}'] == 'def2_TZVP':\n\t\tcalcDict['{#BASIS}'] = 'def2-TZVP'\n\telif calcDict['{#BASIS}'] == 'cc_pVTZ_cc_pVTZ_C':\n\t\tcalcDict['{#BASIS}'] = 'cc-pVTZ cc-pVTZ/C'\n\telif calcDict['{#BASIS}'] == 'cc_pVDZ_cc_pVDZ_C':\n\t\tcalcDict['{#BASIS}'] = 'cc-pVDZ cc-pVDZ/C'\t \n\n\tif calcDict['{#METHOD}'] == 'DLPNO_CCSDT':\n\t\tcalcDict['{#METHOD}'] = 'DLPNO-CCSD(T)'\n\t\tcalcDict['{#MISCELLANEOUS}'] = \"%mdci\\nTCutPNO 3.33e-7\\nTCutPairs 1e-4\\nTCutMKN 1e-3\\nend\\n\"\n\t\tcalcDict['{#MEMORY}'] = '13000' \n\telif calcDict['{#METHOD}'] == 'DLPNO_CCSD':\n\t\tcalcDict['{#METHOD}'] = 'DLPNO-CCSD'\n\t\tcalcDict['{#MISCELLANEOUS}'] = \"%mdci\\nTCutPNO 3.33e-7\\nTCutPairs 1e-4\\nTCutMKN 1e-3\\nend\\n\"\n\t\tcalcDict['{#MEMORY}'] = '13000'\n\telse:\n\t\tcalcDict['{#MISCELLANEOUS}'] = ''\n\t\tcalcDict['{#MEMORY}'] = '8000'\n\n\n\treturn calcDict\n", "description": null, "category": "math", "imports": ["import os"]}, {"term": "def", "name": "seedMagic", "data": "def seedMagic(start_dir, calcDict, template_inp='template_input.inp', template_job='template_job.sl', water_file='numWat.txt', charge_file='solute.qcinp'):\n\t\n\t'''\n\tREAD IN INPUTS FROM A FILE!\n\t'''\n\n\ttemplate_inp = calcDict['{#TEMPLATE_INP}']\n\ttemplate_job = calcDict['{#TEMPLATE_JOB}']\n\n\t#required files for magical seeding. \n\tcharge_file = \"solute.qcinp\"\n\tgeom_file = \"solute.xyz\"\n\twater_file = 'numWat.txt'\n\treq_files = [geom_file, water_file, charge_file]\n\t\n\tfor root, dir, files in os.walk(start_dir):\n\t\tif set(req_files).issubset(set(files)):\n\t\t\tprint(\"Seeding %s\" % root)\n\t\t\t# get required info\n\t\t\tcalcDict['{#NWATERS}'] = getWaters(os.path.join(root, water_file))\n\t\t\tcalcDict['{#CHARGE}'], calcDict['{#MULT}'] = getMultCharge(\n\t\t\t\tos.path.join(root, charge_file))\n\t\t\tcalcDict['{#MOLNAME}'] = root.split('/')[-2]\n\t\t\tcalcDict['{#CONFNUM}'] = int(root.split('/')[-1].split('_')[1])\n\t\t\tcalcDict['{#PROTNUM}'] = int(root.split('/')[-1].split('_')[2])\n\t\t\tcalcDict['{#TITLE}'] = \"molecule %s, conformer # %d and protonation = %d \" % (\n\t\t\t\tcalcDict['{#MOLNAME}'],\n\t\t\t\tcalcDict['{#CONFNUM}'], calcDict['{#PROTNUM}'])\n\t\t\tcalcDict['{#STARTDIR}'] = root\n\t\t\t\n\t\t\tif not calcDict['{#JOB_TYPE}'] == 'SPE':\n\t\t\t\tcalcDict[\"{#NAME}\"] = \"%s_%s_%s\" % (\n\t\t\t\t\tcalcDict['{#METHOD}'].split('/')[0].split()[0], calcDict['{#MOLNAME}'], calcDict['{#IMP_SOLV_NAME}'].split('(')[0])\n\t\t\t\tcalcDict['{#XYZFILE}'] = geom_file\n\t\t\t\n\t\t\telse:\n\t\t\t\tcalcDict[\"{#NAME}\"] = \"%s_%s_%s_SPE\" % (\n\t\t\t\t\tcalcDict['{#METHOD}'].split('-')[0], calcDict['{#MOLNAME}'], calcDict['{#IMP_SOLV_NAME}'].split('(')[0])\n\t\t\t\n\t\t\t\toptName = \"%s_%s_%s\" % (\n\t\t\t\t\tcalcDict['{#GO_METHOD}'].split('-')[0], calcDict['{#MOLNAME}'], calcDict['{#GO_IMP_SOLV}'].split('(')[0])\n\t\t\t\topt_geom_file = optName + '_opt.xyz'\n\t\t\t\tcalcDict['{#XYZFILE}'] = opt_geom_file\n\t\t\t\n\t\t\tcalcDict[\"{#FULLPATH}\"] = os.path.join(root, calcDict[\"{#NAME}\"])\n\n\t\t\tnew_job = os.path.join(root, \"%s.sl\" % calcDict[\"{#NAME}\"])\n\t\t\tnew_inp = os.path.join(root, \"%s.inp\" % calcDict[\"{#NAME}\"])\n\t\t   \n\t\t\t# create new pbs and inp files\n\t\t\t\n\t\t\treplace_allnew(template_job, new_job, calcDict)\n\t\t\treplace_allnew(template_inp, new_inp, calcDict)\n\n", "description": null, "category": "math", "imports": ["import os"]}], [{"term": "def", "name": "make_effect", "data": "def make_effect(messages: List[Messages], chances: Chances, rallies: Rallies, game: Game, set_in_game: set):\n\tdirect_chances = chances.select_direct_chance(messages)\n\tfor chance in direct_chances:\n\t\tserve_chance = chances.select_near_chance(chance, True, 1)\n\t\tdirect_induce_EffCalc.append_effect_calc(messages[serve_chance.side].slice_messages_with_chance(serve_chance), game, \"\uc11c\ube0c\uc885\ud569\")\n\n\treceive_over_chances = chances.select_receive_over_chance(messages)\n\tfor chance in receive_over_chances:\n\t\tserve_chance = chances.select_near_chance(chance, True, 1)\n\t\treceive_over_induce_EffCalc.append_effect_calc(messages[serve_chance.side].slice_messages_with_chance(serve_chance), game, \"\uc11c\ube0c\uc885\ud569\")\n\n\taccurate_receive_chances = chances.select_accurate_receive_chance(messages)\n\tfor chance in accurate_receive_chances:\n\t\tserve_chance = chances.select_near_chance(chance, True, 1)\n\t\taccurate_receive_induce_EffCalc.append_effect_calc(messages[serve_chance.side].slice_messages_with_chance(serve_chance), game, \"\uc11c\ube0c\uc885\ud569\")\n\n\tserve_EffCalc.append_effect_calc(messages[0], game, \"\uc11c\ube0c\uc885\ud569\")\n\tserve_EffCalc.append_effect_calc(messages[1], game, \"\uc11c\ube0c\uc885\ud569\")\n\n\tfor chance in chances:\n\t\tmessages_in_chance = messages[chance.side].slice_messages_with_chance(chance)\n\t\tfor message in messages_in_chance:\n\t\t\tif isinstance(message, ReceiveMessage) and message.success_failure == Message.SUCCESS:\n\t\t\t\taccurate_receive_chance_EffCalc.append_effect_calc(messages_in_chance\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   , game\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   , \"\uacf5\uaca9\uc885\ud569\")\n\t\t\tif isinstance(message, ReceiveMessage):\n\t\t\t\treceive_chance_EffCalc.append_effect_calc(messages_in_chance, game, \"\uacf5\uaca9\uc885\ud569\")\n\n\tfor rally in rallies:\n\t\tmessages_in_rally = messages[0].slice_messages_with_rallies([rally])\n\t\tfor message in messages_in_rally:\n\t\t\tif isinstance(message, ReceiveMessage) and message.success_failure == Message.SUCCESS:\n\t\t\t\taccurate_receive_rally_EffCalc.append_effect_calc(messages_in_rally, game, \"\uacf5\uaca9\uc885\ud569\")\n\t\t\tif isinstance(message, ReceiveMessage):\n\t\t\t\treceive_rally_EffCalc.append_effect_calc(messages_in_rally\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t , game\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t , \"\uacf5\uaca9\uc885\ud569\")\n\n\tfor rally in rallies:\n\t\tmessages_in_rally = messages[1].slice_messages_with_rallies([rally])\n\t\tfor message in messages_in_rally:\n\t\t\tif isinstance(message, ReceiveMessage) and message.success_failure == Message.SUCCESS:\n\t\t\t\taccurate_receive_rally_EffCalc.append_effect_calc(messages_in_rally, game, \"\uacf5\uaca9\uc885\ud569\")\n\t\t\tif isinstance(message, ReceiveMessage):\n\t\t\t\treceive_rally_EffCalc.append_effect_calc(messages_in_rally\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t , game\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t , \"\uacf5\uaca9\uc885\ud569\")\n\n\tfor index, chance in enumerate(chances):\n\t\tif index == len(chances) - 1:\n\t\t\tbreak\n\t\tif chance.message_index[0] == chance.message_index[1] \\\n\t\t\tand isinstance(messages[chance.side][chance.message_index[0]], ReceiveMessage) \\\n\t\t\tand isinstance(messages[chance.other_side()][chances[index + 1].message_index[0]], AttackMessage):\n\t\t\tdirect_effect.append_effect_calc(\n\t\t\t\tMessages([messages[chance.other_side()][chances[index + 1].message_index[0]]])\n\t\t\t\t, game\n\t\t\t\t, \"\uacf5\uaca9\uc885\ud569\")\n\n\tfor index, chance in enumerate(chances):\n\t\tif index == len(chances) - 1:\n\t\t\tbreak\n\t\tif chance.message_index[0] == chance.message_index[1] \\\n\t\t\tand isinstance(messages[chance.side][chance.message_index[0]], ReceiveMessage) \\\n\t\t\tand isinstance(messages[chance.other_side()][chances[index + 1].message_index[0]], DigMessage):\n\t\t\tjust_next.append_effect_calc(\n\t\t\t\tmessages[chance.other_side()][chances[index + 1].message_index[0]: chances[index + 1].message_index[1] + 1]\n\t\t\t\t, game\n\t\t\t\t, \"\uacf5\uaca9\uc885\ud569\")\n\n", "description": null, "category": "math", "imports": ["from volleyball.stat.Chance import Chances", "from volleyball.stat.StatMaker import *", "from volleyball.scraper.LinkProcessor import LinkProcessor", "import statistics"]}, {"term": "def", "name": "serve_eff_formula", "data": "def serve_eff_formula(player: Player, serve_stat: List[int]) -> str:\n\tif serve_stat[0] >= 200:\n\t\tserve_Eff.append(((serve_stat[1] - serve_stat[2] + serve_stat[3] * 0.6 + serve_stat[4] * 0.3 - serve_stat[5] * 0.35 - (serve_stat[0] - serve_stat[1] - serve_stat[2] - serve_stat[3] - serve_stat[4] - serve_stat[5]) * 0.25) / serve_stat[0] * 1000) / 10)\n", "description": null, "category": "math", "imports": ["from volleyball.stat.Chance import Chances", "from volleyball.stat.StatMaker import *", "from volleyball.scraper.LinkProcessor import LinkProcessor", "import statistics"]}], [{"term": "class", "name": "PlayerWithSetNum", "data": "class PlayerWithSetNum(Player):\n\n\tdef __init__(self, set_num: int, name: str, back_num: int, season: int, team: str):\n\t\tsuper().__init__(name, back_num, season, team)\n\t\tself.set_num = set_num\n\n", "description": null, "category": "math", "imports": ["from volleyball.stat.StatMaker import *", "from typing import List", "from openpyxl import Workbook"]}, {"term": "def", "name": "put_action_message_to_action", "data": "def put_action_message_to_action(messages: List[Messages], game: Game, set_in_game: Set, action: str, home_eff_calc: Dict[str, EffCalc], away_eff_calc: Dict[str, EffCalc]):\n\tfor message in messages[0].select_messages_with_action(action):\n\t\thome_team = game.teams[0]\n\t\tif home_team not in list(home_eff_calc.keys()):\n\t\t\thome_eff_calc[home_team] = EffCalc({})\n\t\t\thome_eff_calc[home_team].append_effect_calc(Messages([message]), game, action, PlayerWithSetNum, set_in_game.index + 1)\n\t\telse:\n\t\t\thome_eff_calc[home_team].append_effect_calc(Messages([message]), game, action, PlayerWithSetNum, set_in_game.index + 1)\n\n\tfor message in messages[1].select_messages_with_action(action):\n\t\thome_team = game.teams[0]\n\t\tif home_team not in list(away_eff_calc.keys()):\n\t\t\taway_eff_calc[home_team] = EffCalc({})\n\t\t\taway_eff_calc[home_team].append_effect_calc(Messages([message]), game, action, PlayerWithSetNum, set_in_game.index + 1)\n\t\telse:\n\t\t\taway_eff_calc[home_team].append_effect_calc(Messages([message]), game, action, PlayerWithSetNum, set_in_game.index + 1)\n\n", "description": null, "category": "math", "imports": ["from volleyball.stat.StatMaker import *", "from typing import List", "from openpyxl import Workbook"]}, {"term": "def", "name": "processor_in_set", "data": "def processor_in_set(messages: List[Messages], chances: Chances, rallies: Rallies, game: Game, set_in_game: Set):\n\tfor rally in rallies:\n\t\tchances_in_rally = []\n\t\tfor index in range(rally.message_index[0], rally.message_index[1] + 1):\n\t\t\tchance = chances.select_chance_with_message_index(index)\n\t\t\tif chance not in chances_in_rally:\n\t\t\t\tchances_in_rally.append(chance)\n\n\tactions_home_away = [\n\t\t[\"\ub9ac\uc2dc\ube0c\", home_team_receives, away_team_receives],\n\t\t[\"\uc11c\ube0c\", home_team_serves, away_team_serves],\n\t\t[\"\uacf5\uaca9\uc885\ud569\", home_team_attacks, away_team_attacks]\n\t]\n\n\tfor action_home_away in actions_home_away:\n\t\tput_action_message_to_action(messages, game, set_in_game, action_home_away[0], action_home_away[1], action_home_away[2])\n\n", "description": null, "category": "math", "imports": ["from volleyball.stat.StatMaker import *", "from typing import List", "from openpyxl import Workbook"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "setup_calc", "data": "def setup_calc(mode=\"test\"):\n\t\"\"\"\n\tThe workflow is as follows:\n\t1. Read in the global settings\n\t2. Generate the next calculation folder in the outputdir defined in settings\n\t3. Generate the file structure within the calcID folder\n\t\"\"\"\n\t# this gets the path to where the script lives\n\tscript_path = os.path.dirname(os.path.realpath(__file__))\n\tcwd = os.getcwd()\n\t# read in the settings file which lives with the script\n\twith open(script_path + \"/settings.json\") as open_json:\n\t\tsettings = json.load(open_json)\n\tos.chdir(settings[\"output_dir\"])\n\t# Generate the next in a chain of calculation IDs\n\tcalcID = ad.generate_folder()\n\t# Set up where the folders will live\n\tsettings[\"calc_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/calcs\"\n\tsettings[\"json_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/json\"\n\tsettings[\"figs_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/figures\"\n\tsettings[\"docs_dur\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/docs\"\n\tos.chdir(settings[\"output_dir\"] + \"/\" + str(calcID))\n\t# Set up the file structure\n\tad.setup_folders()\n\tshutil.copy2(cwd + \"/ZMAT\", settings[\"calc_dir\"] + \"/ZMAT\")\n\t# Initialise an instance of CFOUR calculation\n\tcalculation = cr.cfour_instance(\n\t\tcalcID=calcID,\n\t\tsettings=settings,\n\t\tmode=mode\n\t)\n\tcalculation.run_calc()\n\tprint(\"Calculation ID: \" + str(calcID))\n", "description": "\n\tThe workflow is as follows:\n\t1. Read in the global settings\n\t2. Generate the next calculation folder in the outputdir defined in settings\n\t3. Generate the file structure within the calcID folder\n\t", "category": "math", "imports": ["from cfour_viewer import abinitio_directories as ad", "from cfour_viewer import cfour_run as cr", "from cfour_viewer import cfour_parse as cp", "from cfour_viewer.routines import read_json, get_calc_path, save_json, atoms_from_zmat", "from cfour_viewer import isotopes", "from cfour_viewer import cfour_freq as cf", "from cfour_viewer import html_template as ht", "import subprocess", "import json", "import pandas as pd", "from pprint import pprint", "from glob import glob", "import os", "import shutil", "import sys"]}, {"term": "def", "name": "parse_calc", "data": "def parse_calc(calcID, print_dict=True):\n\tprint(\"Parsing Calculation ID: \" + str(calcID))\n\tscript_path = os.path.dirname(os.path.realpath(__file__))\n\tcwd = os.getcwd()\n\twith open(script_path + \"/settings.json\") as open_json:\n\t\tsettings = json.load(open_json)\n\tos.chdir(settings[\"output_dir\"] + \"/\" + str(calcID))\n\tsettings[\"calcID_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID)\n\toutput_instance = cp.OutputFile(\n\t\tsettings[\"calcID_dir\"] + \"/calcs/calc\" + str(calcID) + \".log\"\n\t)\n\toutput_instance.export_xyz()\n\tif print_dict is True:\n\t\tpprint(output_instance.InfoDict)\n\telse:\n\t\treturn output_instance.InfoDict\n", "description": null, "category": "math", "imports": ["from cfour_viewer import abinitio_directories as ad", "from cfour_viewer import cfour_run as cr", "from cfour_viewer import cfour_parse as cp", "from cfour_viewer.routines import read_json, get_calc_path, save_json, atoms_from_zmat", "from cfour_viewer import isotopes", "from cfour_viewer import cfour_freq as cf", "from cfour_viewer import html_template as ht", "import subprocess", "import json", "import pandas as pd", "from pprint import pprint", "from glob import glob", "import os", "import shutil", "import sys"]}, {"term": "def", "name": "copy_zmat", "data": "def copy_zmat(calcID):\n\tcwd = os.getcwd()\n\tcalc_path = get_calc_path(calcID)\n\tresults_json_path = calc_path + \"/json/calc\" + str(calcID) + \\\n\t\".results.json\"\n\tif os.path.isfile(results_json_path) is True:\n\t\tpass\t\t\t\t\t\t\t\t# do nothing\n\telse:\t\t\t\t\t\t\t\t\t\t# parse the calc if it\n\t\tparse_calc(calcID)\t\t\t\t\t   # hasn't been done yet\n\tresults_dict = read_json(results_json_path)  # read in the results\n\tif len(results_dict[\"final zmat\"]) < 2:\n\t\tprint(\"Copying unoptimized ZMAT\")\n\t\ttarget_zmat = \"input zmat\"\t\t\t   # if we don't optimise, we\n\telse:\t\t\t\t\t\t\t\t\t\t# don't get a new ZMAT so we'll\n\t\ttarget_zmat = \"final zmat\"\t\t\t   # use the initial one\n\t\tprint(\"Copying optimized ZMAT\")\n\tif os.path.isfile(\"./ZMAT\") is True:\n\t\tshutil.copy2(\"./ZMAT\", \"./ZMATold\")\n\twith open(\"./ZMAT\", \"w+\") as WriteFile:\n\t\t# Flatten the list holding the new ZMAT\n\t\tWriteFile.write(\n\t\t\"\".join(results_dict[target_zmat])\n\t\t)\n", "description": null, "category": "math", "imports": ["from cfour_viewer import abinitio_directories as ad", "from cfour_viewer import cfour_run as cr", "from cfour_viewer import cfour_parse as cp", "from cfour_viewer.routines import read_json, get_calc_path, save_json, atoms_from_zmat", "from cfour_viewer import isotopes", "from cfour_viewer import cfour_freq as cf", "from cfour_viewer import html_template as ht", "import subprocess", "import json", "import pandas as pd", "from pprint import pprint", "from glob import glob", "import os", "import shutil", "import sys"]}, {"term": "def", "name": "harm_findif", "data": "def harm_findif():\n\t\"\"\"\n\tThe workflow is as follows:\n\t1. Read in the global settings\n\t2. Generate the next calculation folder in the outputdir defined in settings\n\t3. Generate the file structure within the calcID folder\n\t\"\"\"\n\t# this gets the path to where the script lives\n\tscript_path = os.path.dirname(os.path.realpath(__file__))\n\tcwd = os.getcwd()\n\t# read in the settings file which lives with the script\n\twith open(script_path + \"/settings.json\") as open_json:\n\t\tsettings = json.load(open_json)\n\tos.chdir(settings[\"output_dir\"])\n\t# Generate the next in a chain of calculation IDs\n\tcalcID = ad.generate_folder()\n\t# Set up where the folders will live\n\tsettings[\"calc_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/calcs\"\n\tsettings[\"json_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/json\"\n\tsettings[\"figs_dir\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/figures\"\n\tsettings[\"docs_dur\"] = settings[\"output_dir\"] + \"/\" + str(calcID) + \"/docs\"\n\tos.chdir(settings[\"output_dir\"] + \"/\" + str(calcID))\n\t# Set up the file structure\n\tad.setup_folders()\n\tshutil.copy2(cwd + \"/ZMAT\", settings[\"calc_dir\"] + \"/ZMAT\")\n\t# Initialise an instance of CFOUR calculation\n\tcalculation = cr.cfour_instance(\n\t\tcalcID=calcID,\n\t\tsettings=settings,\n\t\tmode=None\n\t)\n\tcalculation.findif_freq()\n\tprint(\"Setup harmonic calculation by fin.diff. ID: \" + str(calcID))\n", "description": "\n\tThe workflow is as follows:\n\t1. Read in the global settings\n\t2. Generate the next calculation folder in the outputdir defined in settings\n\t3. Generate the file structure within the calcID folder\n\t", "category": "math", "imports": ["from cfour_viewer import abinitio_directories as ad", "from cfour_viewer import cfour_run as cr", "from cfour_viewer import cfour_parse as cp", "from cfour_viewer.routines import read_json, get_calc_path, save_json, atoms_from_zmat", "from cfour_viewer import isotopes", "from cfour_viewer import cfour_freq as cf", "from cfour_viewer import html_template as ht", "import subprocess", "import json", "import pandas as pd", "from pprint import pprint", "from glob import glob", "import os", "import shutil", "import sys"]}, {"term": "def", "name": "analyse_freq_output", "data": "def analyse_freq_output(calcID):\n\tcwd = os.getcwd()\n\tcalc_path = get_calc_path(calcID)\n\tos.chdir(calc_path + \"/calcs\")\n\tfreq_dict = cf.analyse_harmonic()\n\tfreq_dict = cp.external_parse(calc_path + \"/calcs/freq/FREQ_OUTPUT\")\n\tsave_json(calc_path + \"/json/calc\" + str(calcID) + \".results.json\",\n\t\t\t  freq_dict\n\t\t\t  )\n\tpprint(freq_dict)\n", "description": null, "category": "math", "imports": ["from cfour_viewer import abinitio_directories as ad", "from cfour_viewer import cfour_run as cr", "from cfour_viewer import cfour_parse as cp", "from cfour_viewer.routines import read_json, get_calc_path, save_json, atoms_from_zmat", "from cfour_viewer import isotopes", "from cfour_viewer import cfour_freq as cf", "from cfour_viewer import html_template as ht", "import subprocess", "import json", "import pandas as pd", "from pprint import pprint", "from glob import glob", "import os", "import shutil", "import sys"]}, {"term": "def", "name": "harmfreq_isotopes", "data": "def harmfreq_isotopes(calcID):\n\t\"\"\" Generates all isotopologues, and produces their spectroscopic constants.\n\t\tThe threshold for \"relevance\" is set as a percentage in abundance,\n\t\talthough some atoms (e.g. deuterium, 18-oxygen) are commonly used in\n\t\tsubstitution studies and are included.\n\t\"\"\"\n\tcalc_path = get_calc_path(calcID)\n\tjson_path = calc_path + \"/json/calc\" + str(calcID) + \".results.json\"\n\n\t# Pre-flight check: see if the harmonic frequency output has been analysed\n\tif os.path.isfile(json_path) is False:\n\t\traise FileNotFoundError(\"Frequency JSON file does not exist. Run analysis scripts!\")\n\n\tfreq_path = calc_path + \"/calcs/freq/\"\n\t# Get list of all the output files from the frequency analysis\n\tfreq_filelist = glob(freq_path + \"*\")\n\tfreq_filelist = [files for files in freq_filelist if os.path.isfile(files) is True]\n\tanalysis_dict = dict()\n\n\t# Generate list of atoms from the ZMAT file - this preserves the ordering of atoms\n\tatom_list = atoms_from_zmat(freq_path + \"ZMAT\")\n\tatom_list = [atom for atom in atom_list if atom != \"X\"]\n\tprint(\"Atoms in ZMAT: \" + str(atom_list))\n\tos.chdir(freq_path)\n\t# Call function to generate all isotopologues and their masses\n\tisotopologue_dict = isotopes.isotope_combinations(atom_list)\n\tfor isotopologue in isotopologue_dict:\n\t\t# Molecular formula for the isotopologue\n\t\tname = \"\".join(isotopologue)\n\t\tif os.path.isdir(name) is True:\n\t\t\t# Clean up previous analysis\n\t\t\tshutil.rmtree(name)\n\t\t# Make a directory for the isotopologue\n\t\tos.mkdir(name)\n\t\tos.chdir(freq_path + name)\n\t\tfor files in freq_filelist:\n\t\t\tshutil.copy2(files, os.getcwd(), follow_symlinks=False)\n\t\t# Write the non-standard masses to file for CFOUR to work on\n\t\twith open(\"ISOMASS\", \"w+\") as write_file:\n\t\t\tfor mass in isotopologue_dict[isotopologue]:\n\t\t\t\twrite_file.write(str(mass) + \"\\n\")\n\t\twith open(calc_path + \"/docs/\" + name + \".freq\", \"w+\") as write_file:\n\t\t\t# Run xjoda to process the frequency information\n\t\t\tprocess = subprocess.Popen(\"xjoda\", stdout=write_file, stderr=write_file)\n\t\t\tprocess.wait()\n\t\t# Parse the output of the analysis\n\t\tfreq_output = cp.external_parse(calc_path + \"/docs/\" + name + \".freq\")\n\t\tanalysis_dict[name] = dict()\n\t\tanalysis_dict[name][\"rotational constants\"] = freq_output[\"rotational constants\"]\n\t\tanalysis_dict[name][\"frequencies\"] = freq_output[\"frequencies\"]\n\t\tanalysis_dict[name][\"A-reduction CD\"] = freq_output[\"centrifugal distortion\"][\"A\"]\n\t\tanalysis_dict[name][\"S-reduction CD\"] = freq_output[\"centrifugal distortion\"][\"S\"]\n\t\tprint(\"Completed analysis for \" + name)\n\t\tos.chdir(freq_path)\n\tdataframe = pd.DataFrame.from_dict(analysis_dict)\n\tdataframe.to_csv(calc_path + \"/docs/isotope_data.csv\")\n", "description": " Generates all isotopologues, and produces their spectroscopic constants.\n\t\tThe threshold for \"relevance\" is set as a percentage in abundance,\n\t\talthough some atoms (e.g. deuterium, 18-oxygen) are commonly used in\n\t\tsubstitution studies and are included.\n\t", "category": "math", "imports": ["from cfour_viewer import abinitio_directories as ad", "from cfour_viewer import cfour_run as cr", "from cfour_viewer import cfour_parse as cp", "from cfour_viewer.routines import read_json, get_calc_path, save_json, atoms_from_zmat", "from cfour_viewer import isotopes", "from cfour_viewer import cfour_freq as cf", "from cfour_viewer import html_template as ht", "import subprocess", "import json", "import pandas as pd", "from pprint import pprint", "from glob import glob", "import os", "import shutil", "import sys"]}, {"term": "def", "name": "vpt2_findif", "data": "def vpt2_findif(calcID):\n\t\"\"\" The calcID here points to a frequency calculation that has already\n\tcompleted. The script will then set up the calculations required for the\n\tcubic force fields.\n\n\tI.e. piggy back this script on a finished harmonic frequency job, where\n\tthe ZMAT already has the following keywords:\n\n\tANH_ALGORITHM=PARALLEL\n\tFREQ_ALGORITHM=PARALLEL\n\tFD_PROJECT=OFF\n\tVIB=FINDIF\n\tANHARM=VPT2\n\t\"\"\"\n\ttop_dir = os.getcwd()\n\tcalc_path = get_calc_path(calcID)\n\tos.chdir(calc_path + \"/calcs\")\n\tif os.path.isdir(\"freq\") is not True:\n\t\tprint(\"Harmonic frequency analysis not done yet. Attempting.\")\n\t\tanalyse_freq_output(calcID)\n\tos.chdir(calc_path + \"/calcs/freq\")\n\tos.system(\"rm zmat*\")\n\tos.system(\"xcubic\")\n\tfor freq_calc_zmat in glob(\"zmat*\"):\n\t\tshutil.copy2(freq_calc_zmat, \"ZMAT\")\n\t\tharm_findif()\n", "description": " The calcID here points to a frequency calculation that has already\n\tcompleted. The script will then set up the calculations required for the\n\tcubic force fields.\n\n\tI.e. piggy back this script on a finished harmonic frequency job, where\n\tthe ZMAT already has the following keywords:\n\n\tANH_ALGORITHM=PARALLEL\n\tFREQ_ALGORITHM=PARALLEL\n\tFD_PROJECT=OFF\n\tVIB=FINDIF\n\tANHARM=VPT2\n\t", "category": "math", "imports": ["from cfour_viewer import abinitio_directories as ad", "from cfour_viewer import cfour_run as cr", "from cfour_viewer import cfour_parse as cp", "from cfour_viewer.routines import read_json, get_calc_path, save_json, atoms_from_zmat", "from cfour_viewer import isotopes", "from cfour_viewer import cfour_freq as cf", "from cfour_viewer import html_template as ht", "import subprocess", "import json", "import pandas as pd", "from pprint import pprint", "from glob import glob", "import os", "import shutil", "import sys"]}, {"term": "def", "name": "generate_reports", "data": "def generate_reports(calcIDs):\n\t\"\"\" Give a list of calcIDs, and batch generate an HTML report \"\"\"\n\tcwd = os.getcwd()\n\tjson_reports = list()\n\tfor ID in calcIDs:\n\t\tjson_reports.append(parse_calc(ID, print_dict=False))\n\tht.multi_report(cwd + \"/multi_report\", json_reports, calcIDs)\n", "description": " Give a list of calcIDs, and batch generate an HTML report ", "category": "math", "imports": ["from cfour_viewer import abinitio_directories as ad", "from cfour_viewer import cfour_run as cr", "from cfour_viewer import cfour_parse as cp", "from cfour_viewer.routines import read_json, get_calc_path, save_json, atoms_from_zmat", "from cfour_viewer import isotopes", "from cfour_viewer import cfour_freq as cf", "from cfour_viewer import html_template as ht", "import subprocess", "import json", "import pandas as pd", "from pprint import pprint", "from glob import glob", "import os", "import shutil", "import sys"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "calc", "data": "def calc(s):\n\ttotal_of_word=\"+\".join([\"+\".join(str(ord(letter))) for letter in s])\n\tmod=\"+\".join([\"+\".join(str(int(str(ord(letter)).replace(\"7\",\"1\")))) for letter in s])\n\treturn eval(total_of_word)-eval(mod)\n", "description": null, "category": "math", "imports": []}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "classEhrenfestVelocityVerlet:", "data": "class EhrenfestVelocityVerlet:\n\t\n\tdef __init__(self, calc, mass_scale = 1.0, setups='paw'):\n\t\t\"\"\"Initializes the Ehrenfest MD calculator.\n\n\t\tParameters\n\t\t----------\n\n\t\tcalc: TDDFT Object\n\n\t\tmass_scale: 1.0\n\t\t\tScaling coefficient for atomic masses\n\n\t\tsetups: {'paw', 'hgh'}\n\t\t\tType of setups to use for the calculation\n\n\t\tNote\n\t\t------\n\n\t\tUse propagator = 'EFSICN' for when creating the TDDFT object from a PAW ground state\n\t\tcalculator and propagator = 'EFSICN_HGH' for HGH pseudopotentials\n\n\t\t\"\"\"\n\t\t#print '--- EhrenfestVelocityVerlet is NOT READY FOR PRODUCTION USE ---'\n\t\tself.calc = calc\n\t\tself.setups = setups\n\t\tself.x  = self.calc.atoms.positions.copy() / Bohr\n\t\tself.xn = self.x.copy()\n\t\tself.v  = self.x.copy()\n\t\tamu_to_aumass = _amu / _me\n\t\tif self.calc.atoms.get_velocities() is not None:\n\t\t\tself.v = self.calc.atoms.get_velocities() / (Bohr / AUT)\n\t\telse:\n\t\t\tself.v[:] = 0.0\n\t\t\tself.calc.atoms.set_velocities(self.v)\n\t\t\n\t\tself.vt = self.v.copy()\n\t\tself.vh = self.v.copy()\n\t\tself.time = 0.0\n\t\t\n\t\tself.M = calc.atoms.get_masses() * amu_to_aumass * mass_scale\n\n\t\tself.a  = self.v.copy()\n\t\tself.ah = self.a.copy()\n\t\tself.an = self.a.copy()\n\t\tself.F  = self.a.copy()\n\n\t\tself.calc.get_td_energy()\n\t\tself.calc.forces.reset()\n\t\tself.F = self.calc.forces.calculate(self.calc.wfs,\n\t\t\t\t\t\t\t\t\t\t\tself.calc.td_density.get_density(),\n\t\t\t\t\t\t\t\t\t\t\tself.calc.td_hamiltonian.hamiltonian)\n\n\t\tfor i in range(len(self.F)):\n\t\t\tself.a[i] = self.F[i] / self.M[i]\n\n\n\tdef propagate(self, dt):\n\t\t\"\"\"Performs one Ehrenfest MD propagation step\n\n\t\tParameters\n\t\t---------\n\n\t\tdt: scalar\n\t\t\tTime step (in attoseconds) used for the Ehrenfest MD step\n\n\t\t\"\"\"\n\t\tself.x  = self.calc.atoms.positions.copy() / Bohr\n\t\tself.v  = self.calc.atoms.get_velocities() / (Bohr / AUT)\n\n\t\tdt = dt * attosec_to_autime\n\n\t\t# m a(t+dt)   = F[psi(t),x(t)] \n\t\tself.calc.atoms.positions = self.x * Bohr\n\t\tself.calc.set_positions(self.calc.atoms)\n\t\tself.calc.get_td_energy()\n\t\tself.calc.forces.reset()\n\t\tself.F = self.calc.forces.calculate(self.calc.wfs,\n\t\t\t\t\t\t\t\t\t\t\tself.calc.td_density.get_density(),\n\t\t\t\t\t\t\t\t\t\t\tself.calc.td_hamiltonian.hamiltonian)\n\n\t\tfor i in range(len(self.F)):\n\t\t\tself.a[i] = self.F[i] / self.M[i]\n\n\t\t# x(t+dt/2)   = x(t) + v(t) dt/2 + .5 a(t) (dt/2)^2\n\t\t# vh(t+dt/2)  = v(t) + .5 a(t) dt/2\n\t\tself.xh  = self.x + self.v * dt/2 + .5 * self.a * dt/2*dt/2\n\t\tself.vhh = self.v + .5 * self.a * dt/2\n\n\t\t# m a(t+dt/2) = F[psi(t),x(t+dt/2)a] \n\t\tself.calc.atoms.positions = self.xh * Bohr\n\t\tself.calc.set_positions(self.calc.atoms)\n\t\tself.calc.get_td_energy()\n\t\tself.calc.forces.reset()\n\t\tself.F = self.calc.forces.calculate(self.calc.wfs,\n\t\t\t\t\t\t\t\t\t\t\tself.calc.td_density.get_density(),\n\t\t\t\t\t\t\t\t\t\t\tself.calc.td_hamiltonian.hamiltonian)\n\n\t\tfor i in range(len(self.F)):\n\t\t\tself.ah[i] = self.F[i] / self.M[i]\n\n\t\t# v(t+dt/2)   = vh(t+dt/2) + .5 a(t+dt/2) dt/2\n\t\tself.vh = self.vhh + .5 * self.ah * dt/2\n\n\n\t\t# Propagate wf\n\t\t# psi(t+dt)   = U(t,t+dt) psi(t)\n\t\tif(self.setups == 'paw'):\n\t\t\tniters = self.calc.propagator.propagate(self.time, dt, self.vh)\n\t\telse:\n\t\t\tniters = self.calc.propagator.propagate(self.time, dt)\n\t\t#print 'Propagation took = ', niters\n\n\t\t# m a(t+dt/2) = F[psi(t+dt),x(t+dt/2)] \n\t\tself.calc.atoms.positions = self.xh * Bohr\n\t\tself.calc.set_positions(self.calc.atoms)\n\t\tself.calc.get_td_energy()\n\t\tself.calc.forces.reset()\n\t\tself.F = self.calc.forces.calculate(self.calc.wfs,\n\t\t\t\t\t\t\t\t\t\t\tself.calc.td_density.get_density(),\n\t\t\t\t\t\t\t\t\t\t\tself.calc.td_hamiltonian.hamiltonian)\n\n\t\tfor i in range(len(self.F)):\n\t\t\tself.ah[i] = self.F[i] / self.M[i]\n\n\t\t# x(t+dt)\t = x(t+dt/2) + v(t+dt/2) dt/2 + .5 a(t+dt/2) (dt/2)^2\n\t\t# vh(t+dt)\t= v(t+dt/2) + .5 a(t+dt/2) dt/2\n\t\tself.xn  = self.xh + self.vh * dt/2 + .5 * self.ah * dt/2*dt/2\n\t\tself.vhh = self.vh + .5 * self.ah * dt/2\n\n\t\t# m a(t+dt)   = F[psi(t+dt),x(t+dt)] \n\t\tself.calc.atoms.positions = self.xn * Bohr\n\t\tself.calc.set_positions(self.calc.atoms)\n\t\tself.calc.get_td_energy()\n\t\tself.calc.forces.reset()\n\t\tself.F = self.calc.forces.calculate(self.calc.wfs,\n\t\t\t\t\t\t\t\t\t\t\tself.calc.td_density.get_density(),\n\t\t\t\t\t\t\t\t\t\t\tself.calc.td_hamiltonian.hamiltonian)\n\n\t\tfor i in range(len(self.F)):\n\t\t\tself.an[i] = self.F[i] / self.M[i]\n\n\t\t# v(t+dt)\t = vh(t+dt/2) + .5 a(t+dt/2) dt/2\n\t\tself.vn = self.vhh + .5 * self.an * dt/2\n\n\t\t\n\t\t#print '--- X ---'\n\t\t#print self.x\n\t\t#print self.xn\n\t\t#print self.xn - self.x\n\t\t#print '-- V ---'\n\t\t#print self.v\n\t\t#print self.vn\n\t\t#print self.vn - self.v\n\t\t#print '--- A ---'\n\t\t#print self.a\n\t\t#print self.an\n\t\t#print self.an - self.a\n\t\t#print '---'\n\n\t\t# update\n\t\tself.x[:] = self.xn\n\t\tself.v[:] = self.vn\n\t\tself.a[:] = self.an\n\n\t\t# update atoms\n\t\tself.calc.atoms.set_positions(self.x * Bohr)\n\t\tself.calc.atoms.set_velocities(self.v * Bohr / AUT)\n\n\tdef get_energy(self):\n\t\t\"\"\"Updates kinetic, electronic and total energies\"\"\"\n\t\tself.Ekin = 0.0\n\t\tfor i in range(len(self.v)):\n\t\t\tself.Ekin += (\n\t\t\t\t.5 * self.M[i] * self.v[i][0]**2\n\t\t\t\t+.5 * self.M[i] * self.v[i][1]**2\n\t\t\t\t+.5 * self.M[i] * self.v[i][2]**2\n\t\t\t\t)\n\t\tself.Epot = self.calc.get_td_energy()\n\t\tself.Etot = self.Ekin + self.Epot\n\n\t\t#print 'Ecur = ', [self.Etot, self.Ekin, self.Epot]\n\t\t\n\t\treturn self.Etot\n\t\t\n\tdef get_velocities_in_au(self):\n\t\treturn self.v\n\n\tdef set_velocities_in_au(self, v):\n\t\tself.v[:] = v\n\t\tself.calc.atoms.set_velocities(v * Bohr / AUT)\n", "description": "Initializes the Ehrenfest MD calculator.\n\n\t\tParameters\n\t\t----------\n\n\t\tcalc: TDDFT Object\n\n\t\tmass_scale: 1.0\n\t\t\tScaling coefficient for atomic masses\n\n\t\tsetups: {'paw', 'hgh'}\n\t\t\tType of setups to use for the calculation\n\n\t\tNote\n\t\t------\n\n\t\tUse propagator = 'EFSICN' for when creating the TDDFT object from a PAW ground state\n\t\tcalculator and propagator = 'EFSICN_HGH' for HGH pseudopotentials\n\n\t\t", "category": "math", "imports": ["from ase.units import Bohr, AUT, _me, _amu", "from gpaw import *", "from gpaw.tddft import *", "from gpaw.tddft.units import attosec_to_autime", "from gpaw.mpi import world"]}], [{"term": "def", "name": "systems_minimum", "data": "def systems_minimum():\n\t\"\"\"two atoms at potential minimum\"\"\"\n\n\tatoms = Atoms('H2', positions=[[0, 0, 0], [0, 0, 2 ** (1.0 / 6.0)]])\n\tcalc = LennardJones(rc=1.0e5)\n\tatoms.calc = calc\n\tyield atoms\n\n\tcalc = LennardJones(rc=1.0e5, smooth=True)\n\tatoms.calc = calc\n\tyield atoms\n\n", "description": "two atoms at potential minimum", "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_minimum_energy", "data": "def test_minimum_energy():\n\t# testing at the minimum to see if anything is on fire\n\t# See https://en.wikipedia.org/wiki/Lennard-Jones_potential\n\t# Minimum is at r=2^(1/6)*sigma, and it's -1.\n\n\tfor atoms in systems_minimum():\n\t\tassert atoms.get_potential_energy() == reference_potential_energy\n\t\tassert atoms.get_potential_energies().sum() == reference_potential_energy\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_minimum_forces", "data": "def test_minimum_forces():\n\t# forces should be zero\n\tfor atoms in systems_minimum():\n\t\tnp.testing.assert_allclose(atoms.get_forces(), 0, atol=1e-14)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_system_changes", "data": "def test_system_changes():\n\t# https://gitlab.com/ase/ase/-/merge_requests/1817\n\n\tfor atoms in systems_minimum():\n\t\tatoms.calc.calculate(atoms, system_changes=['positions'])\n\t\tassert atoms.get_potential_energy() == reference_potential_energy\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_finite_difference", "data": "def test_finite_difference():\n\t# ensure that we got the modified forces right\n\th = 1e-10\n\tr = 8.0\n\tcalc = LennardJones(smooth=True, ro=6, rc=10, sigma=3)\n\tatoms = Atoms('H2', positions=[[0, 0, 0], [r, 0, 0]])\n\tatoms2 = Atoms('H2', positions=[[0, 0, 0], [r + h, 0, 0]])\n\tatoms.calc = calc\n\tatoms2.calc = calc\n\n\tfd_force = (atoms2.get_potential_energy() - atoms.get_potential_energy()) / h\n\tforce = atoms.get_forces()[0, 0]\n\n\tnp.testing.assert_allclose(fd_force, force)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "systems_bulk", "data": "def systems_bulk():\n\tatoms = bulk(\"Ar\", cubic=True)\n\tatoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n\tcalc = LennardJones(rc=10)\n\tatoms.calc = calc\n\n\tyield atoms\n\n\tatoms = bulk(\"Ar\", cubic=True)\n\tatoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n\t# somewhat hand-picked parameters, but ok for comparison\n\tcalc = LennardJones(rc=12, ro=10, smooth=True)\n\tatoms.calc = calc\n\n\tyield atoms\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_bulk_energies", "data": "def test_bulk_energies():\n\t# check energies\n\n\tfor atoms in systems_bulk():\n\t\tassert np.allclose(\n\t\t\tatoms.get_potential_energy(), atoms.get_potential_energies().sum()\n\t\t)\n\t\t# energies should be equal in this high-symmetry structure\n\t\tassert atoms.get_potential_energies().std() == pytest.approx(0.0)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_bulk_forces", "data": "def test_bulk_forces():\n\tfor atoms in systems_bulk():\n\t\t# displace atom for 0.03 \\AA\n\t\tatoms.positions[0, 0] += 0.03\n\n\t\t# check forces sum to zero\n\t\tassert np.allclose(atoms.get_forces().sum(axis=0), 0)\n\n\t\t# check reference force\n\t\tassert atoms.get_forces()[0, 0] == reference_force\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_bulk_stress", "data": "def test_bulk_stress():\n\t# check stress computation for sanity and reference\n\t# reference value computed for \"non-smooth\" LJ, so\n\t# we only test that\n\tatoms = bulk(\"Ar\", cubic=True)\n\tatoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n\tcalc = LennardJones(rc=10)\n\tatoms.calc = calc\n\n\tstress = atoms.get_stress()\n\tstresses = atoms.get_stresses()\n\n\tassert np.allclose(stress, stresses.sum(axis=0))\n\n\t# check reference pressure\n\tpressure = sum(stress[:3]) / 3\n\n\tassert pressure == reference_pressure\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "class", "name": "classTestCal:", "data": "class TestCal:\n\n\t# def setup_class(self):\n\t#\t print(\"setup\")\n\t#\t self.calc = Calculator()\n\t#\n\t# def teardown_class(self):\n\t#\t print(\"teardown\")\n\t@allure.story(\"\u76f8\u52a0-\u6574\u6570\")\n\t@pytest.mark.run(order=1)\n\tdef test_add_int(self, calc_class, get_add_calc):\n\t\tassert get_add_calc[2] == calc_class.add(get_add_calc[0], get_add_calc[1])\n\n\t@allure.story(\"\u76f8\u52a0-\u6d6e\u70b9\u6570\")\n\t@pytest.mark.run(order=2)\n\tdef test_add_float(self, calc_class, get_add_calc1):\n\t\tassert get_add_calc1[2] == round(calc_class.add(get_add_calc1[0], get_add_calc1[1]), 2)\n\n\t@allure.story(\"\u76f8\u51cf-\u6574\u6570\")\n\t@pytest.mark.run(order=6)\n\tdef test_less_int(self, calc_class, get_less_calc):\n\t\tassert get_less_calc[2] == calc_class.less(get_less_calc[0], get_less_calc[1])\n\n\t@allure.story(\"\u76f8\u51cf-\u6d6e\u70b9\u6570\")\n\t@pytest.mark.run(order=8)\n\tdef test_less_float(self, calc_class, get_less_calc1):\n\t\tassert get_less_calc1[2] == calc_class.less(get_less_calc1[0], get_less_calc1[1])\n\n\t@allure.story(\"\u76f8\u9664-\u6574\u6570\")\n\t@pytest.mark.run(order=7)\n\tdef test_div_int(self, calc_class, get_div_calc):\n\t\tassert get_div_calc[2] == (calc_class.div(get_div_calc[0], get_div_calc[1]))\n\n\t@allure.story(\"\u76f8\u9664-\u6d6e\u70b9\u6570\")\n\t@pytest.mark.run(order=5)\n\tdef test_div_float(self, calc_class, get_div_calc1):\n\t\tassert get_div_calc1[2] == calc_class.div(get_div_calc1[0], get_div_calc1[1])\n\n\t@allure.story(\"\u76f8\u9664-\u9664\u6570\u4e3a0\")\n\t@pytest.mark.run(order=4)\n\tdef test_div_zero(self, calc_class, get_div_calc2):\n\t\tassert get_div_calc2[2] == calc_class.div(get_div_calc2[0], get_div_calc2[1])\n\n\t@allure.story(\"\u76f8\u4e58-\u6574\u6570\")\n\t@pytest.mark.run(order=9)\n\tdef test_mul_int(self, calc_class, get_mul_calc):\n\t\tassert get_mul_calc[2] == calc_class.mul(get_mul_calc[0], get_mul_calc[1])\n\n\t@allure.story(\"\u76f8\u4e58-\u6d6e\u70b9\u6570\")\n\t@pytest.mark.run(order=3)\n\tdef test_mul_float(self, calc_class, get_mul_calc1):\n\t\tassert get_mul_calc1[1] == round(calc_class.mul(get_mul_calc1[0], get_mul_calc1[1]), 2)\n", "description": null, "category": "math", "imports": ["import pytest", "import allure"]}], [{"term": "def", "name": "calculate", "data": "def calculate(list):\n", "description": null, "category": "math", "imports": ["import numpy as np"]}], [{"term": "def", "name": "deal_minus_issue", "data": "def deal_minus_issue(calc_list):\n\tnew_calc_list= []\n\tfor index,item in enumerate(calc_list):\n\t\tif item.strip().endswith(\"*\") or item.strip().endswith(\"/\"):\n\t\t\tnew_calc_list.append(\"%s-%s\" %(calc_list[index] , calc_list[index+1]))\n\t\telif (\"*\" or \"/\") in item:\n\t\t\tnew_calc_list.append(item)\n\n\tprint(\"new calc_list:\",new_calc_list)\n", "description": null, "category": "math", "imports": ["import re"]}, {"term": "def", "name": "mutilpy_and_dividend", "data": "def mutilpy_and_dividend(formula):\n\tprint(\"\u8fd0\u7b97\",formula)\n\tcalc_list = re.split(\"[+-]\",formula)\n\tcalc_list = deal_minus_issue(calc_list)\n\tprint(calc_list)\n\tfor item in calc_list:\n\t\tsub_calc_list =re.split(\"[*/]\",item)\n\t\tsub_operator_list = re.findall(\"[*/]\",item)\n\t\tprint(sub_calc_list,sub_operator_list)\n\t\tsub_res = None\n\t\tfor index,i in enumerate(sub_calc_list):\n\t\t\tif sub_res:#\u8fd9\u4e0d\u662f\u7b2c\u4e00\u6b21\u5faa\u73af\n\t\t\t\tif sub_operator_list[index-1] == \"*\":\n\t\t\t\t\tsub_res *= float(i)\n\t\t\t\telse:\n\t\t\t\t\tsub_res /= float(i)\n\t\t\telse:\n\t\t\t\tsub_res = float(i)\n\t\tprint(\"\\033[31;1m[%s]=\\033[0m\" %item, sub_res)\n\t\tformula= formula.replace(item,str(sub_res))\n\n\tprint(\"\\033[32;1m\u7ed3\u679c\\033[0m\" ,formula)\n", "description": null, "category": "math", "imports": ["import re"]}, {"term": "def", "name": "calc", "data": "def calc(formula):\n\tparentheses_flag = True\n\twhile parentheses_flag:\n\t\tm = re.search(\"\\([^()]+\\)\", formula)\n\t\tif m:\n\t\t\tprint(m.group())\n\t\t\tsub_formula = m.group().strip(\"()\")\n\t\t\tsub_res = mutilpy_and_dividend(sub_formula)\n", "description": null, "category": "math", "imports": ["import re"]}], [], [{"term": "def", "name": "fswig_import_helper", "data": "\tdef swig_import_helper():\n\t\tfrom os.path import dirname\n\t\timport imp\n\t\tfp = None\n\t\ttry:\n\t\t\tfp, pathname, description = imp.find_module('_param_StackDistCalc', [dirname(__file__)])\n\t\texcept ImportError:\n\t\t\timport _param_StackDistCalc\n\t\t\treturn _param_StackDistCalc\n\t\tif fp is not None:\n\t\t\ttry:\n\t\t\t\t_mod = imp.load_module('_param_StackDistCalc', fp, pathname, description)\n\t\t\tfinally:\n\t\t\t\tfp.close()\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_setattr_nondynamic", "data": "def _swig_setattr_nondynamic(self, class_type, name, value, static=1):\n\tif (name == \"thisown\"):\n\t\treturn self.this.own(value)\n\tif (name == \"this\"):\n\t\tif type(value).__name__ == 'SwigPyObject':\n\t\t\tself.__dict__[name] = value\n\t\t\treturn\n\tmethod = class_type.__swig_setmethods__.get(name, None)\n\tif method:\n\t\treturn method(self, value)\n\tif (not static):\n\t\tobject.__setattr__(self, name, value)\n\telse:\n\t\traise AttributeError(\"You cannot add attributes to %s\" % self)\n\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_setattr", "data": "def _swig_setattr(self, class_type, name, value):\n\treturn _swig_setattr_nondynamic(self, class_type, name, value, 0)\n\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_getattr_nondynamic", "data": "def _swig_getattr_nondynamic(self, class_type, name, static=1):\n\tif (name == \"thisown\"):\n\t\treturn self.this.own()\n\tmethod = class_type.__swig_getmethods__.get(name, None)\n\tif method:\n\t\treturn method(self)\n\tif (not static):\n\t\treturn object.__getattr__(self, name)\n\telse:\n\t\traise AttributeError(name)\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_getattr", "data": "def _swig_getattr(self, class_type, name):\n\treturn _swig_getattr_nondynamic(self, class_type, name, 0)\n\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_repr", "data": "def _swig_repr(self):\n\ttry:\n\t\tstrthis = \"proxy of \" + self.this.__repr__()\n\texcept Exception:\n\t\tstrthis = \"\"\n\treturn \"<%s.%s; %s >\" % (self.__class__.__module__, self.__class__.__name__, strthis,)\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "class", "name": "\tclass_object:", "data": "\tclass _object:\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "class", "name": "\t_newclass=0", "data": "\t_newclass = 0\n\n\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_setattr_nondynamic_method", "data": "def _swig_setattr_nondynamic_method(set):\n\tdef set_attr(self, name, value):\n\t\tif (name == \"thisown\"):\n\t\t\treturn self.this.own(value)\n\t\tif hasattr(self, name) or (name == \"this\"):\n\t\t\tset(self, name, value)\n\t\telse:\n\t\t\traise AttributeError(\"You cannot add attributes to %s\" % self)\n\treturn set_attr\n\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "class", "name": "StackDistCalc", "data": "class StackDistCalc(m5.internal.param_SimObject.SimObject):\n\tthisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')\n\n\tdef __init__(self, *args, **kwargs):\n\t\traise AttributeError(\"No constructor defined - class is abstract\")\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "class", "name": "StackDistCalcParams", "data": "class StackDistCalcParams(m5.internal.param_SimObject.SimObjectParams):\n\tthisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')\n\t__repr__ = _swig_repr\n\n\tdef create(self):\n\t\treturn _param_StackDistCalc.StackDistCalcParams_create(self)\n\tdisable_linear_hists = _swig_property(_param_StackDistCalc.StackDistCalcParams_disable_linear_hists_get, _param_StackDistCalc.StackDistCalcParams_disable_linear_hists_set)\n\tdisable_log_hists = _swig_property(_param_StackDistCalc.StackDistCalcParams_disable_log_hists_get, _param_StackDistCalc.StackDistCalcParams_disable_log_hists_set)\n\tlinear_hist_bins = _swig_property(_param_StackDistCalc.StackDistCalcParams_linear_hist_bins_get, _param_StackDistCalc.StackDistCalcParams_linear_hist_bins_set)\n\tlog_hist_bins = _swig_property(_param_StackDistCalc.StackDistCalcParams_log_hist_bins_get, _param_StackDistCalc.StackDistCalcParams_log_hist_bins_set)\n\tverify = _swig_property(_param_StackDistCalc.StackDistCalcParams_verify_get, _param_StackDistCalc.StackDistCalcParams_verify_set)\n\n\tdef __init__(self):\n\t\tthis = _param_StackDistCalc.new_StackDistCalcParams()\n\t\ttry:\n\t\t\tself.this.append(this)\n\t\texcept Exception:\n\t\t\tself.this = this\n\t__swig_destroy__ = _param_StackDistCalc.delete_StackDistCalcParams\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}], [{"term": "def", "name": "fswig_import_helper", "data": "\tdef swig_import_helper():\n\t\tfrom os.path import dirname\n\t\timport imp\n\t\tfp = None\n\t\ttry:\n\t\t\tfp, pathname, description = imp.find_module('_param_StackDistCalc', [dirname(__file__)])\n\t\texcept ImportError:\n\t\t\timport _param_StackDistCalc\n\t\t\treturn _param_StackDistCalc\n\t\tif fp is not None:\n\t\t\ttry:\n\t\t\t\t_mod = imp.load_module('_param_StackDistCalc', fp, pathname, description)\n\t\t\tfinally:\n\t\t\t\tfp.close()\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_setattr_nondynamic", "data": "def _swig_setattr_nondynamic(self, class_type, name, value, static=1):\n\tif (name == \"thisown\"):\n\t\treturn self.this.own(value)\n\tif (name == \"this\"):\n\t\tif type(value).__name__ == 'SwigPyObject':\n\t\t\tself.__dict__[name] = value\n\t\t\treturn\n\tmethod = class_type.__swig_setmethods__.get(name, None)\n\tif method:\n\t\treturn method(self, value)\n\tif (not static):\n\t\tobject.__setattr__(self, name, value)\n\telse:\n\t\traise AttributeError(\"You cannot add attributes to %s\" % self)\n\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_setattr", "data": "def _swig_setattr(self, class_type, name, value):\n\treturn _swig_setattr_nondynamic(self, class_type, name, value, 0)\n\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_getattr_nondynamic", "data": "def _swig_getattr_nondynamic(self, class_type, name, static=1):\n\tif (name == \"thisown\"):\n\t\treturn self.this.own()\n\tmethod = class_type.__swig_getmethods__.get(name, None)\n\tif method:\n\t\treturn method(self)\n\tif (not static):\n\t\treturn object.__getattr__(self, name)\n\telse:\n\t\traise AttributeError(name)\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_getattr", "data": "def _swig_getattr(self, class_type, name):\n\treturn _swig_getattr_nondynamic(self, class_type, name, 0)\n\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_repr", "data": "def _swig_repr(self):\n\ttry:\n\t\tstrthis = \"proxy of \" + self.this.__repr__()\n\texcept Exception:\n\t\tstrthis = \"\"\n\treturn \"<%s.%s; %s >\" % (self.__class__.__module__, self.__class__.__name__, strthis,)\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "class", "name": "\tclass_object:", "data": "\tclass _object:\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "class", "name": "\t_newclass=0", "data": "\t_newclass = 0\n\n\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "def", "name": "_swig_setattr_nondynamic_method", "data": "def _swig_setattr_nondynamic_method(set):\n\tdef set_attr(self, name, value):\n\t\tif (name == \"thisown\"):\n\t\t\treturn self.this.own(value)\n\t\tif hasattr(self, name) or (name == \"this\"):\n\t\t\tset(self, name, value)\n\t\telse:\n\t\t\traise AttributeError(\"You cannot add attributes to %s\" % self)\n\treturn set_attr\n\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "class", "name": "StackDistCalc", "data": "class StackDistCalc(m5.internal.param_SimObject.SimObject):\n\tthisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')\n\n\tdef __init__(self, *args, **kwargs):\n\t\traise AttributeError(\"No constructor defined - class is abstract\")\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}, {"term": "class", "name": "StackDistCalcParams", "data": "class StackDistCalcParams(m5.internal.param_SimObject.SimObjectParams):\n\tthisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')\n\t__repr__ = _swig_repr\n\n\tdef create(self):\n\t\treturn _param_StackDistCalc.StackDistCalcParams_create(self)\n\tdisable_linear_hists = _swig_property(_param_StackDistCalc.StackDistCalcParams_disable_linear_hists_get, _param_StackDistCalc.StackDistCalcParams_disable_linear_hists_set)\n\tdisable_log_hists = _swig_property(_param_StackDistCalc.StackDistCalcParams_disable_log_hists_get, _param_StackDistCalc.StackDistCalcParams_disable_log_hists_set)\n\tlinear_hist_bins = _swig_property(_param_StackDistCalc.StackDistCalcParams_linear_hist_bins_get, _param_StackDistCalc.StackDistCalcParams_linear_hist_bins_set)\n\tlog_hist_bins = _swig_property(_param_StackDistCalc.StackDistCalcParams_log_hist_bins_get, _param_StackDistCalc.StackDistCalcParams_log_hist_bins_set)\n\tverify = _swig_property(_param_StackDistCalc.StackDistCalcParams_verify_get, _param_StackDistCalc.StackDistCalcParams_verify_set)\n\n\tdef __init__(self):\n\t\tthis = _param_StackDistCalc.new_StackDistCalcParams()\n\t\ttry:\n\t\t\tself.this.append(this)\n\t\texcept Exception:\n\t\t\tself.this = this\n\t__swig_destroy__ = _param_StackDistCalc.delete_StackDistCalcParams\n", "description": null, "category": "math", "imports": ["from sys import version_info", "\tdef swig_import_helper():", "\t\tfrom os.path import dirname", "\t\timport imp", "\t\t\timport _param_StackDistCalc", "\t_param_StackDistCalc = swig_import_helper()", "\tdel swig_import_helper", "\timport _param_StackDistCalc", "import m5.internal.param_SimObject", "import m5.internal.drain", "import m5.internal.serialize"]}], [{"term": "def", "name": "test_vasp_setup", "data": "def test_vasp_setup(require_vasp):\n\t\"\"\"\n\tRun some tests to ensure that VASP calculator constructs correct POTCAR files\n\n\t\"\"\"\n\n\tfrom os import remove\n\tfrom os.path import isfile\n\tfrom ase.atoms import Atoms\n\tfrom ase.calculators.vasp import Vasp\n\tfrom ase.test.calculator.vasp import installed\n\n\tassert installed()\n\n\n\tdef check_potcar(setups, filename='POTCAR'):\n\t\t\"\"\"Return true if labels in setups are found in POTCAR\"\"\"\n\n\t\tpp = []\n\t\twith open(filename, 'r') as f:\n\t\t\tfor line in f:\n\t\t\t\tif 'TITEL' in line.split():\n\t\t\t\t\tpp.append(line.split()[3])\n\t\tfor setup in setups:\n\t\t\tassert setup in pp\n\n\t# Write some POTCARs and check they are ok\n\tpotcar = 'POTCAR'\n\ttry:\n\t\tatoms = Atoms('CaGdCs',\n\t\t\t\t\t  positions=[[0, 0, 1], [0, 0, 2], [0, 0, 3]], cell=[5, 5, 5])\n\n\t\tcalc = Vasp(xc='pbe')\n\t\tcalc.initialize(atoms)\n\t\tcalc.write_potcar()\n\t\tcheck_potcar(('Ca_pv', 'Gd', 'Cs_sv'), filename=potcar)\n\n\t\tcalc = Vasp(xc='pbe', setups='recommended')\n\t\tcalc.initialize(atoms)\n\t\tcalc.write_potcar()\n\t\tcheck_potcar(('Ca_sv', 'Gd_3', 'Cs_sv'), filename=potcar)\n\n\t\tcalc = Vasp(xc='pbe', setups='materialsproject')\n\t\tcalc.initialize(atoms)\n\t\tcalc.write_potcar()\n\t\tcheck_potcar(('Ca_sv', 'Gd', 'Cs_sv'), filename=potcar)\n\n\t\tatoms = Atoms('CaInI',\n\t\t\t\t\t  positions=[[0, 0, 1], [0, 0, 2], [0, 0, 3]], cell=[5, 5, 5])\n\t\tcalc = Vasp(xc='pbe', setups={'base': 'gw'})\n\t\tcalc.initialize(atoms)\n\t\tcalc.write_potcar()\n\t\tcheck_potcar(('Ca_sv_GW', 'In_d_GW', 'I_GW'), filename=potcar)\n\n\t\tcalc = Vasp(xc='pbe', setups={'base': 'gw', 'I': ''})\n\t\tcalc.initialize(atoms)\n\t\tcalc.write_potcar()\n\t\tcheck_potcar(('Ca_sv_GW', 'In_d_GW', 'I'), filename=potcar)\n\n\t\tcalc = Vasp(xc='pbe', setups={'base': 'gw', 'Ca': '_sv', 2: 'I'})\n\t\tcalc.initialize(atoms)\n\t\tcalc.write_potcar()\n\t\tcheck_potcar(('Ca_sv', 'In_d_GW', 'I'), filename=potcar)\n\tfinally:\n\t\tif isfile(potcar):\n\t\t\tremove(potcar)\n", "description": "\n\tRun some tests to ensure that VASP calculator constructs correct POTCAR files\n\n\t", "category": "math", "imports": ["\tfrom os import remove", "\tfrom os.path import isfile", "\tfrom ase.atoms import Atoms", "\tfrom ase.calculators.vasp import Vasp", "\tfrom ase.test.calculator.vasp import installed"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "insert_number_in_calc_result", "data": "def insert_number_in_calc_result(button_number):\r\n\tcurrent = lbl_calc_result['text']\r\n\tif button_number == 'C':\r\n\t\tlbl_calc_result['text'] = '0'\r\n\telif current == '0': \r\n\t\tlbl_calc_result['text'] = button_number\r\n\telif button_number == '=':\r\n\t\tlbl_calc_result['text'] = f'{eval(current)}'\r\n\telse:\r\n\t\tif button_number in ['+', '-' , '*']:\r\n\t\t\tif current[-1] in ['+', '-' , '*']:\r\n\t\t\t\tlbl_calc_result['text'] = current[:-1] + button_number\r\n\t\t\telse:\r\n\t\t\t\tlbl_calc_result['text'] += button_number\r\n\t\telse:\r\n\t\t\tlbl_calc_result['text'] += button_number\r\n\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r"]}], [{"term": "class", "name": "TestVariables", "data": "class TestVariables(unittest.TestCase):\n\tdef TestAssign(self):\n\t\tc = Calculator()\n\n\t\tMain.calc_exp(\"i=1\", c)\n\t\tself.assertTrue(c.v_manager.is_variable(\"i\"))\n\t\tself.assertEqual(c.v_manager.get_var_val(\"i\"), 1)\n\n\t\tMain.calc_exp(\"i=i+1\", c)\n\t\tself.assertTrue(c.v_manager.is_variable(\"i\"))\n\t\tself.assertEqual(c.v_manager.get_var_val(\"i\"), 2)\n\n\tdef test_inc(self):\n\t\tc = Calculator()\n\n\t\tMain.calc_exp(\"j=1\", c)\n\t\tMain.calc_exp(\"j++\", c)\n\n\t\tself.assertTrue(c.v_manager.is_variable(\"j\"))\n\t\tself.assertEqual(c.v_manager.get_var_val(\"j\"), 2)\n\n\t\tMain.calc_exp(\"++j\", c)\n\n\t\tself.assertEqual(c.v_manager.get_var_val(\"j\"), 3)\n\n\tdef test_sub(self):\n\t\tc = Calculator()\n\n\t\tMain.calc_exp(\"j=1\", c)\n\t\tMain.calc_exp(\"j--\", c)\n\n\t\tself.assertTrue(c.v_manager.is_variable(\"j\"))\n\t\tself.assertEqual(c.v_manager.get_var_val(\"j\"), 0)\n\n\t\tMain.calc_exp(\"--j\", c)\n\n\t\tself.assertEqual(c.v_manager.get_var_val(\"j\"), -1)\n\n\tdef test_multiple_vars(self):\n\t\tc = Calculator()\n\n\t\tMain.calc_exp(\"j=1\", c)\n\t\tMain.calc_exp(\"i=j\", c)\n\t\tMain.calc_exp(\"i++\", c)\n\t\tMain.calc_exp(\"t=3\", c)\n\t\tMain.calc_exp(\"c=5\", c)\n\t\tMain.calc_exp(\"j++\", c)\n\t\tMain.calc_exp(\"k=j^(c+t)-i\", c)\n\n\t\tself.assertTrue(c.v_manager.is_variable(\"k\"))\n\t\tself.assertEqual(c.v_manager.get_var_val(\"k\"), 254)\n", "description": null, "category": "math", "imports": ["import unittest", "import Main", "from Calculator import Calculator"]}], [{"term": "def", "name": "del_space", "data": "def del_space(calc_str):\n\t\"\"\"\n\t\u53bb\u9664\u6574\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\n\t:param calc_str: \u539f\u59cb\u5b57\u7b26\u4e32\n\t:return: \u53bb\u9664\u7a7a\u683c\u540e\u7684\u5b57\u7b26\u4e32\n\t\"\"\"\n\tdata = calc_str.replace(\" \", \"\")\n\treturn data\n\n", "description": "\n\t\u53bb\u9664\u6574\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\n\t:param calc_str: \u539f\u59cb\u5b57\u7b26\u4e32\n\t:return: \u53bb\u9664\u7a7a\u683c\u540e\u7684\u5b57\u7b26\u4e32\n\t", "category": "math", "imports": ["import re"]}, {"term": "def", "name": "check_special", "data": "def check_special(calc_str):\n\t\"\"\"\n\t\u68c0\u6d4b\u5b57\u7b26\u4e32\u4e2d\u662f\u5426\u6709\u5b57\u6bcd\u53ca\u975e\u8fd0\u7b97\u7684\u7279\u6b8a\u5b57\u7b26,\n\t:param calc_str: \u539f\u59cb\u5b57\u7b26\u4e32\n\t:return: True or False, \u82e5\u4e3aTrue\uff0c\u5219\u8868\u793a\u5b58\u5728\u7279\u6b8a\u5b57\u7b26\n\t\"\"\"\n\tpattern = re.compile(r\"[^\\d\\+\\-\\*\\/()]\")\n\tcheck = pattern.findall(calc_str)\n\treturn check\n\n", "description": "\n\t\u68c0\u6d4b\u5b57\u7b26\u4e32\u4e2d\u662f\u5426\u6709\u5b57\u6bcd\u53ca\u975e\u8fd0\u7b97\u7684\u7279\u6b8a\u5b57\u7b26,\n\t:param calc_str: \u539f\u59cb\u5b57\u7b26\u4e32\n\t:return: True or False, \u82e5\u4e3aTrue\uff0c\u5219\u8868\u793a\u5b58\u5728\u7279\u6b8a\u5b57\u7b26\n\t", "category": "math", "imports": ["import re"]}, {"term": "def", "name": "calculate", "data": "def calculate(calc_str):\n\t\"\"\"\n\t\u5bf9\u5b57\u7b26\u4e32\u4e2d\u7684\u8868\u8fbe\u5f0f\u8fdb\u884c\u8ba1\u7b97\n\t:param calc_str: \u6570\u5b66\u8ba1\u7b97\u8868\u8fbe\u5f0f\u7c7b\u578b\u7684\u5b57\u7b26\u4e32\n\t:return: \u8ba1\u7b97\u540e\u7684\u7ed3\u679c\n\t\"\"\"\n\twhile True:\n\t\tif calc_str.find(\"*\") != -1:\n\t\t\tpattern = re.compile(r\"(?P[\\d]+[.]?[\\d]*)(?P[*])(?P[\\d]+[.]?[\\d]*)\")\n\t\t\tprv, typ, aft = pattern.search(calc_str).group(\"prv\", \"typ\", \"after\")\n\t\t\t# re.sub(\"%s%s%s\" % (prv, typ, aft), str(value), calc_str)\n\t\t\tcalc_str = calc_str.replace(\"%s%s%s\" % (prv, typ, aft), str(float(prv) * float(aft)))\n\t\t\tcontinue\n\t\telif calc_str.find(\"/\") != -1:\n\t\t\tpattern = re.compile(r\"(?P[\\d]+[.]?[\\d]*)(?P[/])(?P[\\d]+[.]?[\\d]*)\")\n\t\t\tprv, typ, aft = pattern.search(calc_str).group(\"prv\", \"typ\", \"after\")\n\t\t\tcalc_str = calc_str.replace(\"%s%s%s\" % (prv, typ, aft), str(float(prv) / float(aft)))\n\t\t\tcontinue\n\t\telif calc_str.find(\"+\") != -1:\n\t\t\tpattern = re.compile(r\"(?P[\\d]+[.]?[\\d]*)(?P[+])(?P[\\d]+[.]?[\\d]*)\")\n\t\t\tprv, typ, aft = pattern.search(calc_str).group(\"prv\", \"typ\", \"after\")\n\t\t\tcalc_str = calc_str.replace(\"%s%s%s\" % (prv, typ, aft), str(float(prv) + float(aft)))\n\t\t\tcontinue\n\t\telif calc_str.find(\"-\") != -1:\n\t\t\tpattern = re.compile(r\"(?P[\\d]+[.]?[\\d]*)(?P[-])(?P[\\d]+[.]?[\\d]*)\")\n\t\t\tprv, typ, aft = pattern.search(calc_str).group(\"prv\", \"typ\", \"after\")\n\t\t\tcalc_str = calc_str.replace(\"%s%s%s\" % (prv, typ, aft), str(float(prv) - float(aft)))\n\t\t\tcontinue\n\t\telse:\n\t\t\tbreak\n\treturn calc_str\n\n", "description": "\n\t\u5bf9\u5b57\u7b26\u4e32\u4e2d\u7684\u8868\u8fbe\u5f0f\u8fdb\u884c\u8ba1\u7b97\n\t:param calc_str: \u6570\u5b66\u8ba1\u7b97\u8868\u8fbe\u5f0f\u7c7b\u578b\u7684\u5b57\u7b26\u4e32\n\t:return: \u8ba1\u7b97\u540e\u7684\u7ed3\u679c\n\t", "category": "math", "imports": ["import re"]}, {"term": "def", "name": "replace_expr", "data": "def replace_expr(calc_str):\n\t\"\"\"\n\t\u627e\u5230\u6700\u5185\u90e8\u7684\u62ec\u53f7, \u8ba1\u7b97\u51fa\u503c\u540e\u5c06\u503c\u66ff\u6362\u5230\u5b57\u7b26\u4e32\u4e2d\n\t:param calc_str: \u7eaf\u7cb9\u7684\u8981\u8ba1\u7b97\u51fa\u7ed3\u679c\u7684\u5b57\u7b26\u4e32\n\t:return: \u5f53\u524d\u5b57\u7b26\u4e32\u6700\u5185\u90e8\u7684\u503c\n\t\"\"\"\n\ttry:  # re\u7684search\u65b9\u6cd5\u5982\u679c\u5339\u914d\u4e0d\u5230\u5185\u5bb9\u5c31\u4f1a\u62a5\u9519\n\t\tpattern = re.compile(r\"\\((?P[\\d\\+\\-\\*\\/.]*)\\)\")\n\t\tinit_str = pattern.search(calc_str).group(\"init\")\n\t\tvalue = str(calculate(init_str))\n\t\tresult = re.sub(r\"\\([\\d\\+\\-\\*\\/.]*\\)\", value, calc_str, 1)  # \u53ea\u66ff\u6362\u7b2c\u4e00\u6b21\u5339\u914d\u5230\u7684\n\t\treturn result\n\texcept Exception:\n\t\treturn None\n\n", "description": "\n\t\u627e\u5230\u6700\u5185\u90e8\u7684\u62ec\u53f7, \u8ba1\u7b97\u51fa\u503c\u540e\u5c06\u503c\u66ff\u6362\u5230\u5b57\u7b26\u4e32\u4e2d\n\t:param calc_str: \u7eaf\u7cb9\u7684\u8981\u8ba1\u7b97\u51fa\u7ed3\u679c\u7684\u5b57\u7b26\u4e32\n\t:return: \u5f53\u524d\u5b57\u7b26\u4e32\u6700\u5185\u90e8\u7684\u503c\n\t", "category": "math", "imports": ["import re"]}], [], [{"term": "def", "name": "test_main", "data": "def test_main(factory):\n\tatoms = molecule('H2O')\n\tatoms.rotate(30, 'x')\n\n\tcalc = factory.calc(basis='3-21G')\n\tatoms.calc = calc\n\n\t# Calculate forces ahead of time, compare against finite difference after\n\t# checking the psi4-calc.dat file\n\tatoms.get_forces()\n\tassert_allclose(atoms.get_potential_energy(), -2056.785854116688,\n\t\t\t\t\trtol=1e-4, atol=1e-4)\n\n\t# Test the reader\n\tcalc2 = factory.calc()\n\tcalc2.read('psi4-calc')\n\tassert_allclose(calc2.results['energy'], atoms.get_potential_energy(),\n\t\t\t\t\trtol=1e-4, atol=1e-4)\n\tassert_allclose(calc2.results['forces'], atoms.get_forces(),\n\t\t\t\t\trtol=1e-4, atol=1e-4)\n\n\t# Compare analytical vs numerical forces\n\tassert_allclose(atoms.get_forces(), calc.calculate_numerical_forces(atoms),\n\t\t\t\t\trtol=1e-4, atol=1e-4)\n", "description": null, "category": "math", "imports": ["from numpy.testing import assert_allclose", "import pytest", "from ase.build import molecule"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "test_plugin_constants_instantiate", "data": "def test_plugin_constants_instantiate():\n\tNotationConstants()\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.notation.constants import NotationConstants", "from tests import TestCalculator, random_str, random_int"]}, {"term": "def", "name": "test_plugin_constants_hook", "data": "def test_plugin_constants_hook():\n\tcalc = TestCalculator()\n\tplugin = NotationConstants()\n\tcalc.register_plugin(plugin)\n\tassert plugin in calc.plugins\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.notation.constants import NotationConstants", "from tests import TestCalculator, random_str, random_int"]}, {"term": "def", "name": "test_plugin_constants_context_updated", "data": "def test_plugin_constants_context_updated():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(NotationConstants())\n\tassert calc.chksym(\"constants\")\n\tassert isinstance(calc.getsym(\"constants\"), dict)\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.notation.constants import NotationConstants", "from tests import TestCalculator, random_str, random_int"]}, {"term": "def", "name": "test_plugin_constants_available", "data": "def test_plugin_constants_available():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(NotationConstants())\n\tassert isinstance(calc.command(\"constants\"), dict)\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.notation.constants import NotationConstants", "from tests import TestCalculator, random_str, random_int"]}, {"term": "def", "name": "test_plugin_constants_use_default", "data": "def test_plugin_constants_use_default():\n\tcalc = TestCalculator()\n\tplugin = NotationConstants()\n\tcalc.register_plugin_and_enable(plugin)\n\tfor k, v in plugin.table.items():\n\t\tassert calc.command(f\"_{k}\") == v\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.notation.constants import NotationConstants", "from tests import TestCalculator, random_str, random_int"]}, {"term": "def", "name": "test_plugin_constants_use_custom", "data": "def test_plugin_constants_use_custom():\n\tcalc = TestCalculator()\n\ttable = {}\n\tfor i in range(10):\n\t\ttable[random_str()] = random_str()\n\tplugin = NotationConstants(table=table)\n\tcalc.register_plugin_and_enable(plugin)\n\tfor k, v in table.items():\n\t\tassert calc.command(f\"_{k}\") == v\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.notation.constants import NotationConstants", "from tests import TestCalculator, random_str, random_int"]}, {"term": "def", "name": "test_plugin_constants_expressions", "data": "def test_plugin_constants_expressions():\n\tcalc = TestCalculator()\n\ttable = {}\n\tfor i in range(10):\n\t\ttable[random_str()] = random_int(-1000000000, 1000000000)\n\tplugin = NotationConstants(table=table)\n\tcalc.register_plugin_and_enable(plugin)\n\tfor k1, v1 in table.items():\n\t\tfor k2, v2 in table.items():\n\t\t\tassert calc.command(f\"_{k1} + _{k2}\") == v1 + v2\n\t\t\tassert calc.command(f\"_{k1} * _{k2}\") == v1 * v2\n\t\t\tassert calc.command(f\"abs(_{k1}) - abs(_{k2})\") == abs(v1) - abs(v2)\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.notation.constants import NotationConstants", "from tests import TestCalculator, random_str, random_int"]}, {"term": "def", "name": "test_plugin_constants_invalid", "data": "def test_plugin_constants_invalid(capfd):\n\tcalc = TestCalculator()\n\tcalc.register_plugin_and_enable(NotationConstants())\n\tfor t in range(20):\n\t\tcalc.command(\"_\" + random_str())\n\t\tassert \"NameError\" in capfd.readouterr().out\n\t\tcalc.command(f\"{random_int(1,100)}_{random_int(1,100)}_{random_int(1,100)}\")\n\t\tassert \"NameError\" not in capfd.readouterr().out\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.notation.constants import NotationConstants", "from tests import TestCalculator, random_str, random_int"]}, {"term": "def", "name": "test_plugin_constants_enable_switch", "data": "def test_plugin_constants_enable_switch(capfd):\n\tcalc = TestCalculator()\n\tplugin = NotationConstants()\n\tcalc.register_plugin_and_enable(plugin)\n\tfor k, v in plugin.table.items():\n\t\tassert calc.command(f\"_{k}\") == v\n\tassert plugin.setting_name\n\tcalc.settings[plugin.setting_name] = False\n\tfor k in plugin.table.keys():\n\t\tcalc.command(f\"_{k}\")\n\t\tassert \"NameError\" in capfd.readouterr().out\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.notation.constants import NotationConstants", "from tests import TestCalculator, random_str, random_int"]}], [{"term": "def", "name": "check_kpoints_line", "data": "def check_kpoints_line(n, contents):\n\t\"\"\"Assert the contents of a line\"\"\"\n\twith open('KPOINTS', 'r') as f:\n\t\tlines = f.readlines()\n\t\tassert lines[n] == contents\n", "description": "Assert the contents of a line", "category": "math", "imports": ["import os", "import filecmp", "from ase.calculators.vasp import Vasp2 as Vasp", "from ase.build import bulk", "from ase.test.vasp import installed2 as installed"]}], [{"term": "class", "name": "CalcGuiPlus", "data": "class CalcGuiPlus(Toplevel):\n\tdef __init__(self, **args):\n\t\tToplevel.__init__(self)\n\t\tlabel(self, TOP, 'PyCalc Plus - Container')\n\t\tself.calc = CalcGui(self, **args)\n\t\tfrm = frame(self, BOTTOM)\n\t\textras = [('sqrt', 'sqrt(%s)'),\n\t\t\t\t  ('x^2 ',  '(%s)**2'),\n\t\t\t\t  ('x^3 ',  '(%s)**3'),\n\t\t\t\t  ('1/x ',  '1.0/(%s)')]\n\t\tfor (lab, expr) in extras:\n\t\t\tbutton(frm, LEFT, lab, (lambda expr=expr: self.onExtra(expr)))\n\t\tbutton(frm, LEFT, ' pi ', self.onPi)\n\n\tdef onExtra(self, expr):\n\t\ttext = self.calc.text\n\t\teval = self.calc.eval\n\t\ttry:\n\t\t\ttext.set(eval.runstring(expr % text.get()))\n\t\texcept:\n\t\t\ttext.set('ERROR')\n\n\tdef onPi(self):\n\t\tself.calc.text.set(self.calc.eval.runstring('pi'))\n", "description": null, "category": "math", "imports": ["from tkinter import *", "from calculator import CalcGui, getCalcArgs", "from PP4E.Gui.Tools.widgets import frame, button, label"]}], [{"term": "class", "name": "TestCalculator", "data": "class TestCalculator(unittest.TestCase):\n\tdef test1(self):\n\t\tc = Calculator()\n\n\t\tself.assertEqual(c.calc(\"1+2\"), 3)\n\t\tself.assertEqual(c.calc(\"1-2\"), -1)\n\t\tself.assertEqual(c.calc(\"3^2\"), 9)\n\t\tself.assertEqual(c.calc(\"5*4\"), 20)\n\t\tself.assertEqual(c.calc(\"10/2\"), 5)\n\n\t\tself.assertEqual(c.calc(\"(1+2)\"), 3)\n\t\tself.assertEqual(c.calc(\"(1-2)\"), -1)\n\t\tself.assertEqual(c.calc(\"(3^2)\"), 9)\n\t\tself.assertEqual(c.calc(\"(5*4)\"), 20)\n\t\tself.assertEqual(c.calc(\"(10/2)\"), 5)\n\n\t\tself.assertEqual(c.calc(\"10/2+3\"), 8)\n\t\tself.assertEqual(c.calc(\"10/(2+3)\"), 2)\n\t\tself.assertEqual(c.calc(\"7-(1+1)\"), 5)\n", "description": null, "category": "math", "imports": ["import unittest", "from Calculator import Calculator"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "filter_by_node", "data": "def filter_by_node():\n\n\tPATH_F=os.path.join(PATH_D,\"targets_t5small_egv_beam.txt\")\n  \n\twith open(PATH_F, \"r\") as f:\n", "description": null, "category": "math", "imports": ["from vars import *", "import os", "\tfrom itertools import groupby", "\timport numpy as np"]}, {"term": "def", "name": "count_square", "data": "def count_square(line):\n\tfrom itertools import groupby\n\tgroups = groupby(line)\n\tresult = [(label, sum(1 for _ in group)) for label, group in groups]\n\tfor r in result:\n\t\tif(r[0] == ']'):\n\t\t\tif max < r[1]:\n\t\t\t\tmax=r[1]\n\treturn max\n", "description": null, "category": "math", "imports": ["from vars import *", "import os", "\tfrom itertools import groupby", "\timport numpy as np"]}, {"term": "def", "name": "score_f_nodes", "data": "def score_f_nodes(num_nodes=[1,2,3,4,5,6,7],m_type=\"\"):\n\tPATH_F=os.path.join(PATH_D,\"num_nodes_for_line.txt\")\n\t#METEOR\n\taggregator=[]\n\twith open(\"meteor/barte.txt\",\"r\") as f:\n\t\tmeteor=f.readlines()\n\twith open(\"rouge/barte1.txt\",\"r\") as f:\n\t\trouge1=f.readlines()\n\twith open(\"rouge/barte2.txt\",\"r\") as f:\n\t\trouge2=f.readlines()\n\twith open(\"rouge/barteL.txt\",\"r\") as f:\n\t\trougeL=f.readlines()\n\twith open(\"bleu/results_barte.txt\",\"r\") as f:\n\t\tbleu=f.readlines()\n\t# with open(\"rouge/results-L.txt\",\"r\") as f:\n\t#\t rougeL=f.readlines()\n\twith open(\"bleurt/bb.txt\",\"r\") as f:\n\t\tbleurt=f.readlines()\n\twith open(\"BARTScore/bart.txt\",\"r\") as f:\n\t\tbartscore=f.readlines()\n\t# with open(\"nubia/scores.txt\",\"r\") as f:\n\t#\t nub=f.readlines()\n\twith open(\"bert_score/barte.txt\",\"r\") as f:\n\t\tbert_s=f.readlines()\n\t\t\t\n\t# with open(\"repts.txt\",\"r\") as f:\n\t#\t repts=f.readlines()\n\twith open(PATH_F,\"r\") as f:\n\t\tlines=f.readlines()\n\t# with open(\"questeval/results.txt\",\"r\") as f:\n\t#\t qeval_l=f.readlines()\n\twith open(\"questeval/bart.txt\",\"r\") as f:\n\t\t qeval_l=f.readlines()\n\tind=0\n\tif m_type==\"bart\":\n\t\tprint(\"List size: {}\".format(len(lines)))\n\t\tfor nn in num_nodes:\n\t\t\tex_index=[]\n\t\t\tind=0\n\t\t\tfor i in range(0,len(lines),4):\n\t\t\t\tif int(lines[i])  == nn  and nn < 7:\n\t\t\t\t\tex_index.append(ind)\n\t\t\t\telse:\n\t\t\t\t\tif nn >= 7:\n\t\t\t\t\t\tif int(lines[i]) >= nn:\n\t\t\t\t\t\t\tex_index.append(ind)\n\t\t\t\tind+=1\n\t\t\t# print(calc_score(\"QuestEval\",ex_index,nn,qeval_l))\n\t\t\t# print(calc_score(\"Bleu\",ex_index,nn,bleu))\n\t\t\t# print(calc_score(\"Bleurt\",ex_index,nn,bleurt))\n\t\t\t#print(calc_score(\"BARTSore\",ex_index,nn,bartscore))\n\t\t\tprint(calc_score(\"Meteor\",ex_index,nn,meteor))\n\t\t\tprint(calc_score(\"Rouge1\",ex_index,nn,rouge1))\n\t\t\tprint(calc_score(\"Rouge2\",ex_index,nn,rouge2))\n\t\t\tprint(calc_score(\"RougeL\",ex_index,nn,rougeL))\n\t  \n\telse:\n\t\tfor nn in num_nodes:\n\t\t\tex_index=[]\n\t\t\tind=0\n\t\t\tfor line in lines:\n\t\t\t\tif int(line)  == nn  and nn < 7:\n\t\t\t\t\tex_index.append(ind)\n\t\t\t\telse:\n\t\t\t\t\tif nn >= 7:\n\t\t\t\t\t\tif int(line) >= nn:\n\t\t\t\t\t\t\tex_index.append(ind)\n\t\t\t\tind+=1\n\t#print(\"List size: {}\".format(len(ex_index)))  \n\t\t\tprint(calc_score(\"Meteor\",ex_index,nn,meteor))\n\t\t\tprint(calc_score(\"Rouge1\",ex_index,nn,rouge1))\n\t\t\tprint(calc_score(\"rouge2\",ex_index,nn,rouge2))\n\t\t\tprint(calc_score(\"rougeL\",ex_index,nn,rougeL))\n\t\t\t#print(calc_score(\"Bleurt\",ex_index,nn,bleurt))\n\t\t\t#print(len(nub))\n\t\t\t#print(calc_score(\"Nubia\",ex_index,nn,nub))\n\t\t\tprint(calc_score(\"Bert-score\",ex_index,nn,bert_s))\n\t\t\tprint(calc_score(\"Bleu\",ex_index,nn,bleu))\n\t\t\t# print(calc_score(\"RR\",ex_index,nn,repts))\n\t#print(calc_score(\"QuestEval\",ex_index,nn,qeval_l))\n\n\t\n  \n\n", "description": null, "category": "math", "imports": ["from vars import *", "import os", "\tfrom itertools import groupby", "\timport numpy as np"]}, {"term": "def", "name": "calc_score", "data": "def calc_score(name,ex_index,num_nodes,lines=[]):\n\timport numpy as np\n\tscores=[]\n\tprint(len(ex_index))\n\tfor c in ex_index:\n\t\tscores.append(float(lines[c]))\n\treturn {name+\"-\" + str(num_nodes) : np.mean(scores)}\n", "description": null, "category": "math", "imports": ["from vars import *", "import os", "\tfrom itertools import groupby", "\timport numpy as np"]}], [{"term": "class", "name": "classGaussianDynamics:", "data": "class GaussianDynamics:\n\tcalctype = 'optimizer'\n\tdelete = ['force']\n\tkeyword: Optional[str] = None\n\tspecial_keywords: Dict[str, str] = dict()\n\n\tdef __init__(self, atoms, calc=None):\n\t\tself.atoms = atoms\n\t\tif calc is not None:\n\t\t\tself.calc = calc\n\t\telse:\n\t\t\tif self.atoms.calc is None:\n\t\t\t\traise ValueError(\"{} requires a valid Gaussian calculator \"\n\t\t\t\t\t\t\t\t \"object!\".format(self.__class__.__name__))\n\n\t\t\tself.calc = self.atoms.calc\n\n\tdef todict(self):\n\t\treturn {'type': self.calctype,\n\t\t\t\t'optimizer': self.__class__.__name__}\n\n\tdef delete_keywords(self, kwargs):\n\t\t\"\"\"removes list of keywords (delete) from kwargs\"\"\"\n\t\tfor d in self.delete:\n\t\t\tkwargs.pop(d, None)\n\n\tdef set_keywords(self, kwargs):\n\t\targs = kwargs.pop(self.keyword, [])\n\t\tif isinstance(args, str):\n\t\t\targs = [args]\n\t\telif isinstance(args, Iterable):\n\t\t\targs = list(args)\n\n\t\tfor key, template in self.special_keywords.items():\n\t\t\tif key in kwargs:\n\t\t\t\tval = kwargs.pop(key)\n\t\t\t\targs.append(template.format(val))\n\n\t\tkwargs[self.keyword] = args\n\n\tdef run(self, **kwargs):\n\t\tcalc_old = self.atoms.calc\n\t\tparams_old = copy.deepcopy(self.calc.parameters)\n\n\t\tself.delete_keywords(kwargs)\n\t\tself.delete_keywords(self.calc.parameters)\n\t\tself.set_keywords(kwargs)\n\n\t\tself.calc.set(**kwargs)\n\t\tself.atoms.calc = self.calc\n\n\t\ttry:\n\t\t\tself.atoms.get_potential_energy()\n\t\texcept OSError:\n\t\t\tconverged = False\n\t\telse:\n\t\t\tconverged = True\n\n\t\tatoms = read(self.calc.label + '.log')\n\t\tself.atoms.cell = atoms.cell\n\t\tself.atoms.positions = atoms.positions\n\n\t\tself.calc.parameters = params_old\n\t\tself.calc.reset()\n\t\tif calc_old is not None:\n\t\t\tself.atoms.calc = calc_old\n\n\t\treturn converged\n\n", "description": "removes list of keywords (delete) from kwargs", "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}, {"term": "class", "name": "GaussianOptimizer", "data": "class GaussianOptimizer(GaussianDynamics):\n\tkeyword = 'opt'\n\tspecial_keywords = {\n\t\t'fmax': '{}',\n\t\t'steps': 'maxcycle={}',\n\t}\n\n", "description": null, "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}, {"term": "class", "name": "GaussianIRC", "data": "class GaussianIRC(GaussianDynamics):\n\tkeyword = 'irc'\n\tspecial_keywords = {\n\t\t'direction': '{}',\n\t\t'steps': 'maxpoints={}',\n\t}\n\n", "description": null, "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}, {"term": "class", "name": "Gaussian", "data": "class Gaussian(FileIOCalculator):\n\timplemented_properties = ['energy', 'forces', 'dipole']\n\tcommand = 'GAUSSIAN < PREFIX.com > PREFIX.log'\n\tdiscard_results_on_any_change = True\n\n\tdef __init__(self, *args, label='Gaussian', **kwargs):\n\t\tFileIOCalculator.__init__(self, *args, label=label, **kwargs)\n\n\tdef calculate(self, *args, **kwargs):\n\t\tgaussians = ('g16', 'g09', 'g03')\n\t\tif 'GAUSSIAN' in self.command:\n\t\t\tfor gau in gaussians:\n\t\t\t\tif which(gau):\n\t\t\t\t\tself.command = self.command.replace('GAUSSIAN', gau)\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\traise EnvironmentError('Missing Gaussian executable {}'\n\t\t\t\t\t\t\t\t\t   .format(gaussians))\n\n\t\tFileIOCalculator.calculate(self, *args, **kwargs)\n\n\tdef write_input(self, atoms, properties=None, system_changes=None):\n\t\tFileIOCalculator.write_input(self, atoms, properties, system_changes)\n\t\twrite(self.label + '.com', atoms, properties=properties,\n\t\t\t  format='gaussian-in', **self.parameters)\n\n\tdef read_results(self):\n\t\toutput = read(self.label + '.log', format='gaussian-out')\n\t\tself.calc = output.calc\n\t\tself.results = output.calc.results\n\n\t# Method(s) defined in the old calculator, added here for\n\t# backwards compatibility\n\tdef clean(self):\n\t\tfor suffix in ['.com', '.chk', '.log']:\n\t\t\ttry:\n\t\t\t\tos.remove(os.path.join(self.directory, self.label + suffix))\n\t\t\texcept OSError:\n\t\t\t\tpass\n\n\tdef get_version(self):\n\t\traise NotImplementedError  # not sure how to do this yet\n", "description": null, "category": "math", "imports": ["import os", "import copy", "from collections.abc import Iterable", "from shutil import which", "from typing import Dict, Optional", "from ase.io import read, write", "from ase.calculators.calculator import FileIOCalculator, EnvironmentError"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await ultroid_bot.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "test_h2o_xas_xes", "data": "def test_h2o_xas_xes():\n\t# d = 0.9575\n\td = 0.9775\n\t# t = np.pi / 180 * 104.51\n\tt = np.pi / 180 * 110.51\n\tatoms = Atoms('H2O',\n\t\t\t\t  positions=[(d, 0, 0),\n\t\t\t\t\t\t\t (d * np.cos(t), d * np.sin(t), 0),\n\t\t\t\t\t\t\t (0, 0, 0)])\n\n\t# set up deMon calculator\n\tbasis = {'all': 'aug-cc-pvdz'}\n\tauxis = {'all': 'GEN-A2*'}\n\n\t# XAS hch\n\tinput_arguments = {'GRID': 'FINE',\n\t\t\t\t\t   'MOMODIFY': [[1, 0],\n\t\t\t\t\t\t\t\t\t[1, 0.5]],\n\t\t\t\t\t   'CHARGE': 0,\n\t\t\t\t\t   'XRAY': 'XAS'}\n\n\tcalc = demon.Demon(basis=basis,\n\t\t\t\t\t   auxis=auxis,\n\t\t\t\t\t   scftype='UKS TOL=1.0E-6 CDF=1.0E-5',\n\t\t\t\t\t   guess='TB',\n\t\t\t\t\t   xc=['BLYP', 'BASIS'],\n\t\t\t\t\t   input_arguments=input_arguments)\n\n\tatoms.calc = calc\n\n\t# energy\n\tprint('XAS hch')\n\tprint('energy')\n\tenergy = atoms.get_potential_energy()\n\tprint(energy)\n\tref = -1815.44708987  # -469.604737006\n\terror = np.sqrt(np.sum((energy - ref)**2))\n\tprint('diff from reference:')\n\tprint(error)\n\n\ttol = 1.0e-4\n\tassert error < tol\n\n\t# check xas\n\tresults = calc.results\n\n\tprint('xray, first transition, energy')\n\tvalue = results['xray']['E_trans'][0]\n\tprint(value)\n\tref = 539.410015646\n\terror = np.sqrt(np.sum((value - ref)**2))\n\tprint('diff from reference:')\n\tprint(error)\n\n\ttol = 1.0e-4\n\tassert error < tol\n\n\tprint('xray, first transition, transition dipole moments')\n\tvalue = results['xray']['trans_dip'][0]\n\tprint(value)\n\tref = np.array([1.11921906e-02, 1.61393975e-02, 1.70983631e-07])\n\terror = np.sqrt(np.sum((value - ref)**2))\n\tprint('diff from reference:')\n\tprint(error)\n\n\ttol = 1.0e-4\n\tassert error < tol\n\n\t# XES\n\tinput_arguments = {'GRID': 'FINE',\n\t\t\t\t\t   'CHARGE': 0,\n\t\t\t\t\t   'XRAY': 'XES ALPHA=1-1'}\n\n\tcalc = demon.Demon(basis=basis,\n\t\t\t\t\t   auxis=auxis,\n\t\t\t\t\t   scftype='UKS TOL=1.0E-6 CDF=1.0E-5',\n\t\t\t\t\t   guess='TB',\n\t\t\t\t\t   xc=['BLYP', 'BASIS'],\n\t\t\t\t\t   input_arguments=input_arguments)\n\n\tatoms.calc = calc\n\n\t# energy\n\tprint('')\n\tprint('XES')\n\tprint('energy')\n\tenergy = atoms.get_potential_energy()\n\tprint(energy)\n\tref = -2079.6635944\n\terror = np.sqrt(np.sum((energy - ref)**2))\n\tprint('diff from reference:')\n\tprint(error)\n\n\ttol = 1.0e-4\n\tassert error < tol\n\n\t# check xes\n\tresults = calc.results\n\n\tprint('xray, first transition, energy')\n\tvalue = results['xray']['E_trans'][0]\n\tprint(value)\n\tref = 486.862715888  # 539.410015646\n\terror = np.sqrt(np.sum((value - ref)**2))\n\tprint('diff from reference:')\n\tprint(error)\n\n\ttol = 1.0e-4\n\tassert error < tol\n\n\tprint('xray, first transition, transition dipole moments')\n\tvalue = results['xray']['trans_dip'][0]\n\tprint(value)\n\tref = np.array([6.50528073e-03, 9.37895253e-03, 6.99433480e-09])\n\terror = np.sqrt(np.sum((value - ref)**2))\n\tprint('diff from reference:')\n\tprint(error)\n\n\ttol = 1.0e-4\n\tassert error < tol\n\n\t# and XPS\n\tinput_arguments = {'GRID': 'FINE',\n\t\t\t\t\t   'MOMODIFY': [[1, 0],\n\t\t\t\t\t\t\t\t\t[1, 0.0]],\n\t\t\t\t\t   'CHARGE': 0,\n\t\t\t\t\t   'XRAY': 'XAS'}\n\n\tcalc = demon.Demon(basis=basis,\n\t\t\t\t\t   auxis=auxis,\n\t\t\t\t\t   scftype='UKS TOL=1.0E-6 CDF=1.0E-5',\n\t\t\t\t\t   guess='TB',\n\t\t\t\t\t   xc=['BLYP', 'BASIS'],\n\t\t\t\t\t   input_arguments=input_arguments)\n\n\tatoms.calc = calc\n\n\t# energy\n\tprint('')\n\tprint('XPS')\n\tprint('energy')\n\tenergy = atoms.get_potential_energy()\n\tprint(energy)\n\tref = -1536.9295935\n\terror = np.sqrt(np.sum((energy - ref)**2))\n\tprint('diff from reference:')\n\tprint(error)\n\n\ttol = 1.0e-4\n\tassert error < tol\n\n\t# First excited state\n\tinput_arguments = {'GRID': 'FINE',\n\t\t\t\t\t   'MOMODIFY': [[1, 0],\n\t\t\t\t\t\t\t\t\t[1, 0.0]],\n\t\t\t\t\t   'CHARGE': -1}\n\n\tcalc = demon.Demon(basis=basis,\n\t\t\t\t\t   auxis=auxis,\n\t\t\t\t\t   scftype='UKS TOL=1.0E-6 CDF=1.0E-5',\n\t\t\t\t\t   guess='TB',\n\t\t\t\t\t   xc=['BLYP', 'BASIS'],\n\t\t\t\t\t   input_arguments=input_arguments)\n\n\tatoms.calc = calc\n\n\t# energy\n\tprint('')\n\tprint('EXC')\n\tprint('energy')\n\tenergy = atoms.get_potential_energy()\n\tprint(energy)\n\tref = -1543.18092135\n\terror = np.sqrt(np.sum((energy - ref)**2))\n\tprint('diff from reference:')\n\tprint(error)\n\n\ttol = 1.0e-4\n\tassert error < tol\n\n\tprint('tests passed')\n", "description": null, "category": "math", "imports": ["import ase.calculators.demon as demon", "from ase import Atoms", "import numpy as np"]}], [{"term": "def", "name": "button_click", "data": "def button_click(char):\n\tglobal calc_operator\n\tcalc_operator += str(char)\n\ttext_input.set(calc_operator)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math"]}, {"term": "def", "name": "button_clear_all", "data": "def button_clear_all():\n\tglobal calc_operator\n\tcalc_operator = \"\"\n\ttext_input.set(\"\")\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math"]}, {"term": "def", "name": "button_delete", "data": "def button_delete():\n\tglobal calc_operator\n\ttext = calc_operator[:-1]\n\tcalc_operator = text\n\ttext_input.set(text)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math"]}, {"term": "def", "name": "trig_sin", "data": "def trig_sin():\n\tglobal calc_operator\n\tresult = str(math.sin(math.radians(int(calc_operator))))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math"]}, {"term": "def", "name": "trig_cos", "data": "def trig_cos():\n\tglobal calc_operator\n\tresult = str(math.cos(math.radians(int(calc_operator))))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math"]}, {"term": "def", "name": "trig_tan", "data": "def trig_tan():\n\tglobal calc_operator\n\tresult = str(math.tan(math.radians(int(calc_operator))))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math"]}, {"term": "def", "name": "square_root", "data": "def square_root():\n\tglobal calc_operator\n\tif int(calc_operator)>=0:\n\t\ttemp = str(eval(calc_operator+'**(1/2)'))\n\t\tcalc_operator = temp\n\telse:\n\t\ttemp = \"ERROR\"\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math"]}, {"term": "def", "name": "sign_change", "data": "def sign_change():\n\tglobal calc_operator\n\tif calc_operator[0]=='-':\n\t\ttemp = calc_operator[1:]\n\telse:\n\t\ttemp = '-'+calc_operator\n\tcalc_operator = temp\n\ttext_input.set(temp)\t\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math"]}, {"term": "def", "name": "percent", "data": "def percent():\n\tglobal calc_operator\n\ttemp = str(eval(calc_operator+'/100'))\n\tcalc_operator = temp\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math"]}, {"term": "def", "name": "button_equal", "data": "def button_equal():\n\tglobal calc_operator\n\ttemp_op = str(eval(calc_operator))\n\ttext_input.set(temp_op)\n\tcalc_operator = temp_op\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math"]}], [{"term": "class", "name": "Vasp", "data": "class Vasp(Vasp_):\n\t\"\"\"\n\tThis is a wrapper around the Vasp calculator that adjusts INCAR parameters on-the-fly,\n\tallows for ASE to run VASP via Custodian, and supports several automatic k-point generation schemes\n\tfrom Pymatgen.\n\n\tParameters\n\t----------\n\tatoms\n\t\tThe Atoms object to be used for the calculation.\n\tpreset\n\t\tThe path to a .yaml file containing a list of INCAR parameters to use as a \"preset\"\n\t\tfor the calculator. If no filepath is present, it will look in quacc/defaults/calcs/vasp, such\n\t\tthat preset=\"BulkRelaxSet\" is supported. It will append .yaml at the end if not present.\n\t\tNote that any specific kwargs take precedence over the flags set in the preset dictionary.\n\tcustodian\n\t\tWhether to use Custodian to run VASP.\n\t\tDefault is True in settings.\n\tincar_copilot\n\t\tIf True, the INCAR parameters will be adjusted if they go against the VASP manual.\n\t\tDefault is True in settings.\n\tcopy_magmoms\n\t\tIf True, any pre-existing atoms.get_magnetic_moments() will be set in atoms.set_initial_magnetic_moments().\n\t\tSet this to False if you want to use a preset's magnetic moments every time.\n\tpreset_mag_default\n\t\tDefault magmom value for sites without one explicitly specified in the preset. Only used if a preset is\n\t\tspecified with an elemental_mags_dict key-value pair.\n\t\tDefault is 1.0 in settings.\n\tmag_cutoff\n\t\tSet all initial magmoms to 0 if all have a magnitude below this value.\n\t\tDefault is 0.05 in settings.\n\tverbose\n\t\tIf True, warnings will be raised when INCAR parameters are changed.\n\t**kwargs\n\t\tAdditional arguments to be passed to the VASP calculator, e.g. xc='PBE', encut=520. Takes all valid\n\t\tASE calculator arguments, in addition to those custom to QuAcc.\n\n\tReturns\n\t-------\n\tAtoms\n\t\tThe ASE Atoms object with attached VASP calculator.\n\t\"\"\"\n\n\tdef __init__(\n\t\tself,\n\t\tatoms: Atoms,\n\t\tpreset: None | str = None,\n\t\tcustodian: bool = SETTINGS.VASP_CUSTODIAN,\n\t\tincar_copilot: bool = SETTINGS.VASP_INCAR_COPILOT,\n\t\tcopy_magmoms: bool = SETTINGS.VASP_COPY_MAGMOMS,\n\t\tpreset_mag_default: float = SETTINGS.VASP_PRESET_MAG_DEFAULT,\n\t\tmag_cutoff: None | float = SETTINGS.VASP_MAG_CUTOFF,\n\t\tverbose: bool = SETTINGS.VASP_VERBOSE,\n\t\t**kwargs,\n\t):\n\n\t\t# Check constraints\n\t\tif (\n\t\t\tcustodian\n\t\t\tand atoms.constraints\n\t\t\tand not all(isinstance(c, FixAtoms) for c in atoms.constraints)\n\t\t):\n\t\t\traise ValueError(\n\t\t\t\t\"Atoms object has a constraint that is not compatible with Custodian\"\n\t\t\t)\n\n\t\t# Get VASP executable command, if necessary, and specify child environment\n\t\t# variables\n\t\tcommand = _manage_environment(custodian)\n\n\t\t# Get user-defined preset parameters for the calculator\n\t\tif preset:\n\t\t\tcalc_preset = load_yaml_calc(os.path.join(DEFAULT_CALCS_DIR, preset))[\n\t\t\t\t\"inputs\"\n\t\t\t]\n\t\telse:\n\t\t\tcalc_preset = {}\n\n\t\t# Collect all the calculator parameters and prioritize the kwargs\n\t\t# in the case of duplicates.\n\t\tuser_calc_params = {**calc_preset, **kwargs}\n\t\tnone_keys = [k for k, v in user_calc_params.items() if v is None]\n\t\tfor none_key in none_keys:\n\t\t\tdel user_calc_params[none_key]\n\n\t\t# Allow the user to use setups='mysetups.yaml' to load in a custom setups\n\t\t# from a YAML file\n\t\tif (\n\t\t\tisinstance(user_calc_params.get(\"setups\"), str)\n\t\t\tand user_calc_params[\"setups\"] not in ase_default_setups\n\t\t):\n\t\t\tuser_calc_params[\"setups\"] = load_yaml_calc(\n\t\t\t\tos.path.join(DEFAULT_CALCS_DIR, user_calc_params[\"setups\"])\n\t\t\t)[\"inputs\"][\"setups\"]\n\n\t\t# If the preset has auto_kpts but the user explicitly requests kpts, then\n\t\t# we should honor that.\n\t\tif kwargs.get(\"kpts\") and calc_preset.get(\"auto_kpts\"):\n\t\t\tdel user_calc_params[\"auto_kpts\"]\n\n\t\t# Handle special arguments in the user calc parameters that\n\t\t# ASE does not natively support\n\t\tif user_calc_params.get(\"elemental_magmoms\"):\n\t\t\telemental_mags_dict = user_calc_params[\"elemental_magmoms\"]\n\t\telse:\n\t\t\telemental_mags_dict = None\n\t\tif user_calc_params.get(\"auto_kpts\"):\n\t\t\tauto_kpts = user_calc_params[\"auto_kpts\"]\n\t\telse:\n\t\t\tauto_kpts = None\n\t\tif user_calc_params.get(\"auto_dipole\"):\n\t\t\tauto_dipole = user_calc_params[\"auto_dipole\"]\n\t\telse:\n\t\t\tauto_dipole = None\n\t\tuser_calc_params.pop(\"elemental_magmoms\", None)\n\t\tuser_calc_params.pop(\"auto_kpts\", None)\n\t\tuser_calc_params.pop(\"auto_dipole\", None)\n\n\t\t# Make automatic k-point mesh\n\t\tif auto_kpts:\n\t\t\tkpts, gamma, reciprocal = _convert_auto_kpts(atoms, auto_kpts)\n\t\t\tuser_calc_params[\"kpts\"] = kpts\n\t\t\tif reciprocal and user_calc_params.get(\"reciprocal\") is None:\n\t\t\t\tuser_calc_params[\"reciprocal\"] = reciprocal\n\t\t\tif user_calc_params.get(\"gamma\") is None:\n\t\t\t\tuser_calc_params[\"gamma\"] = gamma\n\n\t\t# Add dipole corrections if requested\n\t\tif auto_dipole:\n\t\t\tcom = atoms.get_center_of_mass(scaled=True)\n\t\t\tif \"dipol\" not in user_calc_params:\n\t\t\t\tuser_calc_params[\"dipol\"] = com\n\t\t\tif \"idipol\" not in user_calc_params:\n\t\t\t\tuser_calc_params[\"idipol\"] = 3\n\t\t\tif \"ldipol\" not in user_calc_params:\n\t\t\t\tuser_calc_params[\"ldipol\"] = True\n\n\t\t# Set magnetic moments\n\t\tset_magmoms(\n\t\t\tatoms,\n\t\t\telemental_mags_dict=elemental_mags_dict,\n\t\t\tcopy_magmoms=copy_magmoms,\n\t\t\telemental_mags_default=preset_mag_default,\n\t\t\tmag_cutoff=mag_cutoff,\n\t\t)\n\n\t\t# Handle INCAR swaps as needed\n\t\tif incar_copilot:\n\t\t\tuser_calc_params = _calc_swaps(\n\t\t\t\tatoms, user_calc_params, auto_kpts=auto_kpts, verbose=verbose\n\t\t\t)\n\n\t\t# Remove unused INCAR flags\n\t\tuser_calc_params = _remove_unused_flags(user_calc_params)\n\n\t\t# Instantiate the calculator!\n\t\tsuper().__init__(atoms=atoms, command=command, **user_calc_params)\n\n", "description": "\n\tThis is a wrapper around the Vasp calculator that adjusts INCAR parameters on-the-fly,\n\tallows for ASE to run VASP via Custodian, and supports several automatic k-point generation schemes\n\tfrom Pymatgen.\n\n\tParameters\n\t----------\n\tatoms\n\t\tThe Atoms object to be used for the calculation.\n\tpreset\n\t\tThe path to a .yaml file containing a list of INCAR parameters to use as a \"preset\"\n\t\tfor the calculator. If no filepath is present, it will look in quacc/defaults/calcs/vasp, such\n\t\tthat preset=\"BulkRelaxSet\" is supported. It will append .yaml at the end if not present.\n\t\tNote that any specific kwargs take precedence over the flags set in the preset dictionary.\n\tcustodian\n\t\tWhether to use Custodian to run VASP.\n\t\tDefault is True in settings.\n\tincar_copilot\n\t\tIf True, the INCAR parameters will be adjusted if they go against the VASP manual.\n\t\tDefault is True in settings.\n\tcopy_magmoms\n\t\tIf True, any pre-existing atoms.get_magnetic_moments() will be set in atoms.set_initial_magnetic_moments().\n\t\tSet this to False if you want to use a preset's magnetic moments every time.\n\tpreset_mag_default\n\t\tDefault magmom value for sites without one explicitly specified in the preset. Only used if a preset is\n\t\tspecified with an elemental_mags_dict key-value pair.\n\t\tDefault is 1.0 in settings.\n\tmag_cutoff\n\t\tSet all initial magmoms to 0 if all have a magnitude below this value.\n\t\tDefault is 0.05 in settings.\n\tverbose\n\t\tIf True, warnings will be raised when INCAR parameters are changed.\n\t**kwargs\n\t\tAdditional arguments to be passed to the VASP calculator, e.g. xc='PBE', encut=520. Takes all valid\n\t\tASE calculator arguments, in addition to those custom to QuAcc.\n\n\tReturns\n\t-------\n\tAtoms\n\t\tThe ASE Atoms object with attached VASP calculator.\n\t", "category": "math", "imports": ["from __future__ import annotations", "import inspect", "import os", "import warnings", "from typing import Any, Dict, List, Tuple", "import numpy as np", "from ase.atoms import Atoms", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.calculators.vasp.setups import _setups_defaults as ase_default_setups", "from ase.constraints import FixAtoms", "from quacc import SETTINGS", "from quacc.custodian import vasp as custodian_vasp", "from quacc.presets import vasp as vasp_defaults", "from quacc.util.atoms import check_is_metal, get_highest_block, set_magmoms", "from quacc.util.basics import load_yaml_calc", "from quacc.util.calc import _convert_auto_kpts"]}, {"term": "def", "name": "_manage_environment", "data": "def _manage_environment(custodian: bool = True) -> str:\n\t\"\"\"\n\tManage the environment for the VASP calculator.\n\n\tParameters\n\t----------\n\tcustodian\n\t\tIf True, Custodian will be used to run VASP.\n\n\tReturns\n\t-------\n\tstr\n\t\tThe command flag to pass to the Vasp calculator.\n\t\"\"\"\n\n\t# Check ASE environment variables\n\tif \"VASP_PP_PATH\" not in os.environ:\n\t\twarnings.warn(\n\t\t\t\"The VASP_PP_PATH environment variable must point to the library of VASP pseudopotentials. See the ASE Vasp calculator documentation for details.\",\n\t\t)\n\n\t# Check if Custodian should be used and confirm environment variables are set\n\tif custodian:\n\t\t# Return the command flag\n\t\trun_vasp_custodian_file = os.path.abspath(inspect.getfile(custodian_vasp))\n\t\tcommand = f\"python {run_vasp_custodian_file}\"\n\telse:\n\t\tif \"ASE_VASP_COMMAND\" not in os.environ and \"VASP_SCRIPT\" not in os.environ:\n\t\t\twarnings.warn(\n\t\t\t\t\"ASE_VASP_COMMAND or VASP_SCRIPT must be set in the environment to run VASP. See the ASE Vasp calculator documentation for details.\"\n\t\t\t)\n\t\tcommand = None\n\n\treturn command\n\n", "description": "\n\tManage the environment for the VASP calculator.\n\n\tParameters\n\t----------\n\tcustodian\n\t\tIf True, Custodian will be used to run VASP.\n\n\tReturns\n\t-------\n\tstr\n\t\tThe command flag to pass to the Vasp calculator.\n\t", "category": "math", "imports": ["from __future__ import annotations", "import inspect", "import os", "import warnings", "from typing import Any, Dict, List, Tuple", "import numpy as np", "from ase.atoms import Atoms", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.calculators.vasp.setups import _setups_defaults as ase_default_setups", "from ase.constraints import FixAtoms", "from quacc import SETTINGS", "from quacc.custodian import vasp as custodian_vasp", "from quacc.presets import vasp as vasp_defaults", "from quacc.util.atoms import check_is_metal, get_highest_block, set_magmoms", "from quacc.util.basics import load_yaml_calc", "from quacc.util.calc import _convert_auto_kpts"]}, {"term": "def", "name": "_remove_unused_flags", "data": "def _remove_unused_flags(user_calc_params: Dict[str, Any]) -> Dict[str, Any]:\n\t\"\"\"\n\tRemoves unused flags in the INCAR, like EDIFFG if you are doing NSW = 0.\n\n\tParameters\n\t----------\n\tuser_calc_params\n\t\tUser-specified calculation parameters\n\n\tReturns\n\t-------\n\tDict\n\t\tAdjusted user-specified calculation parameters\n\t\"\"\"\n\n\t# Turn off opt flags if NSW = 0\n\topt_flags = (\"ediffg\", \"ibrion\", \"isif\", \"potim\", \"iopt\")\n\tif user_calc_params.get(\"nsw\", 0) == 0:\n\t\tfor opt_flag in opt_flags:\n\t\t\tuser_calc_params.pop(opt_flag, None)\n\n\t# Turn off +U flags if +U is not even used\n\tldau_flags = (\n\t\t\"ldau\",\n\t\t\"ldauu\",\n\t\t\"ldauj\",\n\t\t\"ldaul\",\n\t\t\"ldautype\",\n\t\t\"ldauprint\",\n\t\t\"ldau_luj\",\n\t)\n\tif not user_calc_params.get(\"ldau\", False) and not user_calc_params.get(\n\t\t\"ldau_luj\", None\n\t):\n\t\tfor ldau_flag in ldau_flags:\n\t\t\tuser_calc_params.pop(ldau_flag, None)\n\n\treturn user_calc_params\n\n", "description": "\n\tRemoves unused flags in the INCAR, like EDIFFG if you are doing NSW = 0.\n\n\tParameters\n\t----------\n\tuser_calc_params\n\t\tUser-specified calculation parameters\n\n\tReturns\n\t-------\n\tDict\n\t\tAdjusted user-specified calculation parameters\n\t", "category": "math", "imports": ["from __future__ import annotations", "import inspect", "import os", "import warnings", "from typing import Any, Dict, List, Tuple", "import numpy as np", "from ase.atoms import Atoms", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.calculators.vasp.setups import _setups_defaults as ase_default_setups", "from ase.constraints import FixAtoms", "from quacc import SETTINGS", "from quacc.custodian import vasp as custodian_vasp", "from quacc.presets import vasp as vasp_defaults", "from quacc.util.atoms import check_is_metal, get_highest_block, set_magmoms", "from quacc.util.basics import load_yaml_calc", "from quacc.util.calc import _convert_auto_kpts"]}, {"term": "def", "name": "_calc_swaps", "data": "def _calc_swaps(\n\tatoms: Atoms,\n\tuser_calc_params: Dict[str, Any],\n\tauto_kpts: None\n\t| Dict[str, float]\n\t| Dict[str, List[Tuple[float, float]]]\n\t| Dict[str, List[Tuple[float, float, float]]],\n", "description": null, "category": "math", "imports": ["from __future__ import annotations", "import inspect", "import os", "import warnings", "from typing import Any, Dict, List, Tuple", "import numpy as np", "from ase.atoms import Atoms", "from ase.calculators.vasp import Vasp as Vasp_", "from ase.calculators.vasp.setups import _setups_defaults as ase_default_setups", "from ase.constraints import FixAtoms", "from quacc import SETTINGS", "from quacc.custodian import vasp as custodian_vasp", "from quacc.presets import vasp as vasp_defaults", "from quacc.util.atoms import check_is_metal, get_highest_block, set_magmoms", "from quacc.util.basics import load_yaml_calc", "from quacc.util.calc import _convert_auto_kpts"]}], [{"term": "def", "name": "test_calc_beta", "data": "def test_calc_beta():\n\t\"\"\" Unit test for the calc_beta function.\"\"\"\n\n\ttemperature = np.array([0., 11604.5181216])\n\n\texpected_beta = np.array([np.inf, 1.])\n\tcalculated_beta = calc_beta(temperature)\n\n\tassert pytest.approx(calculated_beta) == expected_beta\n\n", "description": " Unit test for the calc_beta function.", "category": "math", "imports": ["import pytest", "import numpy as np", "from occuprob.utils import calc_beta", "from occuprob.utils import calc_geometric_mean", "from occuprob.utils import calc_exponent", "from occuprob.utils import compare_numpy_dictionaries"]}, {"term": "def", "name": "test_calc_geometric_mean", "data": "def test_calc_geometric_mean():\n\t\"\"\" Unit test for the calc_geometric_mean function.\"\"\"\n\n\tinput_array = np.array([[0., 0.], [1., 1.], [2., 2.], [3., 3.]])\n\n\tcalculated_gmean = calc_geometric_mean(input_array)\n\n\texpected_gmean = np.array([0., 1., 2., 3.])\n\tprint(calculated_gmean)\n\n\tassert pytest.approx(calculated_gmean) == expected_gmean\n\n", "description": " Unit test for the calc_geometric_mean function.", "category": "math", "imports": ["import pytest", "import numpy as np", "from occuprob.utils import calc_beta", "from occuprob.utils import calc_geometric_mean", "from occuprob.utils import calc_exponent", "from occuprob.utils import compare_numpy_dictionaries"]}, {"term": "def", "name": "test_calc_exponent", "data": "def test_calc_exponent():\n\t\"\"\" Unit test for the calc_exponent function.\"\"\"\n\n\tenergy = np.array([0., 1.])\n\ttemperature = np.array([0., 11604.518121, 23209.036242])\n\n\texpected_exponent = np.array([[0., 0., 0.], [np.inf, 1., 0.5]])\n\tcalculated_exponent = calc_exponent(energy, temperature)\n\n\tassert pytest.approx(calculated_exponent) == expected_exponent\n\n", "description": " Unit test for the calc_exponent function.", "category": "math", "imports": ["import pytest", "import numpy as np", "from occuprob.utils import calc_beta", "from occuprob.utils import calc_geometric_mean", "from occuprob.utils import calc_exponent", "from occuprob.utils import compare_numpy_dictionaries"]}, {"term": "def", "name": "test_compare_numpy_dictionaries", "data": "def test_compare_numpy_dictionaries():\n\t\"\"\" Unit test for the compare_numpy_dictionaries function. \"\"\"\n\n\tdict1 = {1: np.zeros((2, 2)), 2: np.ones((2, 2))}\n\tdict2 = {1: np.zeros((2, 2)), 2: np.ones((2, 2))}\n\tdict3 = {1: np.ones((2, 2)), 2: np.zeros((2, 2))}\n\tdict4 = {0: np.ones((2, 2)), 1: np.zeros((2, 2))}\n\n\tassert compare_numpy_dictionaries(dict1, dict2)\n\tassert not compare_numpy_dictionaries(dict1, dict3)\n\tassert not compare_numpy_dictionaries(dict3, dict4)\n", "description": " Unit test for the compare_numpy_dictionaries function. ", "category": "math", "imports": ["import pytest", "import numpy as np", "from occuprob.utils import calc_beta", "from occuprob.utils import calc_geometric_mean", "from occuprob.utils import calc_exponent", "from occuprob.utils import compare_numpy_dictionaries"]}], [{"term": "def", "name": "wrap_and", "data": "def wrap_and(x):\n\treturn [Node(\"And\", children=x)] if len(x) > 1 else x\n\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "def", "name": "fix_between", "data": "def fix_between(inp):\n\tinp = re.sub(r\"([\\s|\\S]+) >= (\\d*) AND \\1 <= (\\d*)\", r\"\\1 BETWEEN \\2 and \\3\", inp)\n\t# DuSQL\u4e2d\u7684LIKE\u6761\u4ef6\u503c\u6ca1\u6709\u89c4\u8303\u5316\u4e3a% %\u7684\u5f62\u5f0f\n\t# inp = re.sub(r\"LIKE '([\\s|\\S]+?)'\", r\"LIKE '%\\1%'\", inp)\n\treturn inp\n\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "class", "name": "classItem:", "data": "class Item:\n\tdef __init__(self, curr_type, l_child_idx, r_child_idx, mask):\n\t\tself.curr_type = curr_type\n\t\tself.l_child_idx = l_child_idx\n\t\tself.r_child_idx = r_child_idx\n\t\tself.mask = mask\n\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "class", "name": "classZeroItem:", "data": "class ZeroItem:\n\tdef __init__(\n\t\tself,\n\t\tcurr_type,\n\t\tfinal_leaf_indices,\n\t\tspan_start_indices,\n\t\tspan_end_indices,\n\t\tentities,\n\t\tenc_original,\n\t\ttokenizer,\n\t\tdb_id,\n\t):\n\t\tself.curr_type = curr_type\n\t\tself.final_leaf_indices = final_leaf_indices\n\t\tself.span_start_indices = span_start_indices\n\t\tself.span_end_indices = span_end_indices\n\t\tself.entities = entities\n\t\tself.enc_original = enc_original\n\t\tself.tokenizer = tokenizer\n\t\tself.db_id = db_id\n\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "def", "name": "reconstruct_tree", "data": "def reconstruct_tree(\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "def", "name": "remove_keep", "data": "def remove_keep(node: Node):\n\tif node.name == \"keep\":\n\t\tnode = remove_keep(node.children[0])\n\tnode.children = [remove_keep(child) for child in node.children]\n\treturn node\n\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "def", "name": "promote", "data": "def promote(node, root=False):\n\tchildren = node.children\n\tif node.name in [\"Having\"]:\n\t\twhile True:\n\t\t\tif not node.is_root and node.parent.name not in [\n\t\t\t\t\"union\",\n\t\t\t\t\"intersect\",\n\t\t\t\t\"Subquery\",\n\t\t\t\t\"except\",\n\t\t\t]:\n\t\t\t\tprev_parent = node.parent\n\t\t\t\tgrandparent = (\n\t\t\t\t\tprev_parent.parent if not prev_parent.is_root else prev_parent\n\t\t\t\t)\n\t\t\t\tnode.parent = grandparent\n\t\t\telse:\n\t\t\t\tbreak\n\t\tnode.siblings[0].parent = node\n\tfor child in children:\n\t\tpromote(child)\n\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "def", "name": "flatten_cnf", "data": "def flatten_cnf(in_node):\n\tif in_node.name in [\"And\", \"Or\", \"Val_list\", \"Product\"]:\n\t\treturn flatten_cnf_recurse(in_node, in_node.name, is_root=True)\n\telse:\n\t\tchildren_list = []\n\t\tfor child in in_node.children:\n\t\t\tchild.parent = None\n\t\t\tchild = flatten_cnf(child)\n\t\t\tchildren_list.append(child)\n\t\tin_node.children = children_list\n\t\treturn in_node\n\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "def", "name": "flatten_cnf_recurse", "data": "def flatten_cnf_recurse(in_node, n_type, is_root=False):\n\tother_op = \"And\" if n_type == \"Or\" else \"Or\"\n\tif in_node.name == n_type:\n\t\tres = []\n\t\tfor child in in_node.children:\n\t\t\tchild.parent = None\n\t\t\tres += flatten_cnf_recurse(child, n_type)\n\t\tif is_root:\n\t\t\tin_node.children = res\n\t\t\treturn in_node\n\t\telse:\n\t\t\treturn res\n\telif in_node.name == other_op:\n\t\treturn [flatten_cnf_recurse(in_node, other_op, True)]\n\telse:\n\t\tif not is_root:\n\t\t\tchildren_list = []\n\t\t\tfor child in in_node.children:\n\t\t\t\tchild.parent = None\n\t\t\t\tchild = flatten_cnf(child)\n\t\t\t\tchildren_list.append(child)\n\t\t\tin_node.children = children_list\n\t\treturn [in_node]\n\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "def", "name": "irra_to_sql", "data": "def irra_to_sql(tree, peren=True, is_row_calc=False, alias=None):\n\tif len(tree.children) == 0:\n\t\tif tree.name == \"Table\" and isinstance(tree.val, dict):\n\t\t\treturn tree.val[\"value\"] + \" AS \" + tree.val[\"name\"]\n\t\tif hasattr(tree, \"val\"):\n\t\t\tif is_row_calc and '.' in str(tree.val) and alias is not None:\n\t\t\t\t_, column_name = str(tree.val).split('.')\n\t\t\t\tcolumn_name = alias + '.' + column_name\n\t\t\t\treturn column_name\n\t\t\telse:\n\t\t\t\treturn str(tree.val)\n\t\telse:\n\t\t\tprint(tree)\n\t\t\treturn \"\"\n\tif len(tree.children) == 1:\n\t\tif tree.name in [\n\t\t\t\"min\",\n\t\t\t\"count\",\n\t\t\t\"max\",\n\t\t\t\"avg\",\n\t\t\t\"sum\",\n\t\t]:\n\t\t\treturn \"\".join(\n\t\t\t\t[tree.name.upper(), \" ( \", irra_to_sql(tree.children[0], is_row_calc=is_row_calc), \" )\"]\n\t\t\t)\n\t\telif tree.name == \"distinct\":\n\t\t\treturn \"DISTINCT \" + irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n\t\telif tree.name == \"literal\":\n\t\t\treturn \"\"\"\\'\"\"\" + str(irra_to_sql(tree.children[0], is_row_calc=is_row_calc)) + \"\"\"\\'\"\"\"\n\t\telif tree.name == \"Subquery\":\n\t\t\tif peren:\n\t\t\t\tparsed = \"\".join([\"(\", irra_to_sql(tree.children[0], is_row_calc=is_row_calc), \")\"])\n\t\t\t\tif is_row_calc and alias is not None:\n\t\t\t\t\tparsed = parsed + ' ' + alias\n\t\t\t\treturn parsed\n\t\t\telse:\n\t\t\t\tparsed = irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n\t\t\t\tif is_row_calc and alias is not None:\n\t\t\t\t\tparsed = parsed + ' ' + alias\n\t\t\t\treturn parsed\n\t\telif tree.name == \"Join_on\":\n\t\t\ttree = tree.children[0]\n\t\t\tif tree.name == \"eq\":\n\t\t\t\tfirst_table_name = tree.children[0].val.split(\".\")[0]\n\t\t\t\tsecond_table_name = tree.children[1].val.split(\".\")[0]\n\t\t\t\treturn f\"{first_table_name} JOIN {second_table_name} ON {tree.children[0].val} = {tree.children[1].val}\"\n\t\t\telse:\n\t\t\t\tif len(tree.children) > 0:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tt_Res = \", \".join([child.val for child in tree.children])\n\t\t\t\t\texcept Exception as e:\n\t\t\t\t\t\tlogging.exception(e)\n\t\t\t\t\t\traise e\n\t\t\t\t\treturn t_Res\n\t\t\t\telse:\n\t\t\t\t\treturn tree.val\n\t\telse:  # Predicate or Table or 'literal' or Agg\n\t\t\treturn irra_to_sql(tree.children[0], is_row_calc=is_row_calc, alias=alias)\n\telse:\n\t\tif tree.name in [\n\t\t\t\"eq\",\n\t\t\t\"like\",\n\t\t\t\"nin\",\n\t\t\t\"lte\",\n\t\t\t\"lt\",\n\t\t\t\"neq\",\n\t\t\t\"in\",\n\t\t\t\"gte\",\n\t\t\t\"gt\",\n\t\t\t\"And\",\n\t\t\t\"Or\",\n\t\t\t\"except\",\n\t\t\t\"union\",\n\t\t\t\"intersect\",\n\t\t\t\"Product\",\n\t\t\t\"Val_list\",\n\t\t]:\n\t\t\tpren_t = tree.name in [\n\t\t\t\t\"eq\",\n\t\t\t\t\"like\",\n\t\t\t\t\"nin\",\n\t\t\t\t\"lte\",\n\t\t\t\t\"lt\",\n\t\t\t\t\"neq\",\n\t\t\t\t\"in\",\n\t\t\t\t\"gte\",\n\t\t\t\t\"gt\",\n\t\t\t]\n\t\t\tif tree.name == 'Product':\n\t\t\t\tif len(tree.children[0].children) == 1 and len(tree.children[1].children) == 1 and tree.children[0].children[0].name == 'Subquery' and tree.children[1].children[0].name == 'Subquery':\n\t\t\t\t\treturn (\n\t\t\t\t\t\tpred_dict[tree.name].upper()\n\t\t\t\t\t\t.join([\n\t\t\t\t\t\t\tirra_to_sql(tree.children[0], pren_t, is_row_calc=is_row_calc, alias='a'),\n\t\t\t\t\t\t\tirra_to_sql(tree.children[1], pren_t, is_row_calc=is_row_calc, alias='b'),\n\t\t\t\t\t\t])\n\t\t\t\t\t)\n\t\t\treturn (\n\t\t\t\tpred_dict[tree.name]\n\t\t\t\t.upper()\n\t\t\t\t.join([irra_to_sql(child, pren_t, is_row_calc=is_row_calc) for child in tree.children])\n\t\t\t)\n\t\telif tree.name in value_binary_op_dict.keys():\n\t\t\t# \u6b64\u65f6\u51fa\u73b0\u5217 \u6216 \u5e38\u91cf\u7684\u56db\u5219\u8fd0\u7b97\n\t\t\tif hasattr(tree.children[0], 'val') and hasattr(tree.children[1], 'val') and tree.children[0].val == tree.children[1].val:\n\t\t\t\treturn (\n\t\t\t\t\tirra_to_sql(tree.children[0], is_row_calc=is_row_calc, alias='a')\n\t\t\t\t\t+ value_binary_op_dict[tree.name]\n\t\t\t\t\t+ irra_to_sql(tree.children[1], is_row_calc=is_row_calc, alias='b')\n\t\t\t\t)\n\t\t\telse:\n\t\t\t\treturn (\n\t\t\t\t\tirra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n\t\t\t\t\t+ value_binary_op_dict[tree.name]\n\t\t\t\t\t+ irra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n\t\t\t\t)\n\t\telif tree.name == \"Orderby_desc\":\n\t\t\treturn (\n\t\t\t\tirra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n\t\t\t\t+ \" ORDER BY \"\n\t\t\t\t+ irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n\t\t\t\t+ \" DESC\"\n\t\t\t)\n\t\telif tree.name == \"Orderby_asc\":\n\t\t\treturn (\n\t\t\t\tirra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n\t\t\t\t+ \" ORDER BY \"\n\t\t\t\t+ irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n\t\t\t\t+ \" ASC\"\n\t\t\t)\n\t\telif tree.name == \"Project\":\n\t\t\treturn (\n\t\t\t\t\"SELECT \"\n\t\t\t\t+ irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n\t\t\t\t+ \" FROM \"\n\t\t\t\t+ irra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n\t\t\t)\n\t\telif tree.name == \"Join_on\":\n\t\t\t# tree\n\t\t\tdef table_name(x):\n\t\t\t\treturn x.val.split(\".\")[0]\n\n\t\t\ttable_tups = [\n\t\t\t\t(table_name(child.children[0]), table_name(child.children[1]))\n\t\t\t\tfor child in tree.children\n\t\t\t]\n\t\t\tres = table_tups[0][0]\n\t\t\tseen_tables = set(res)\n\t\t\tfor (first, sec), child in zip(table_tups, tree.children):\n\t\t\t\ttab = first if sec in seen_tables else sec\n\t\t\t\tres += (\n\t\t\t\t\tf\" JOIN {tab} ON {child.children[0].val} = {child.children[1].val}\"\n\t\t\t\t)\n\t\t\t\tseen_tables.add(tab)\n\n\t\t\treturn res\n\t\telif tree.name == \"Selection\":\n\t\t\tif len(tree.children) == 1:\n\t\t\t\treturn irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n\t\t\treturn (\n\t\t\t\tirra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n\t\t\t\t+ \" WHERE \"\n\t\t\t\t+ irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n\t\t\t)\n\t\telse:  # 'Selection'/'Groupby'/'Limit'/Having'\n\t\t\treturn (\n\t\t\t\tirra_to_sql(tree.children[1], is_row_calc=is_row_calc)\n\t\t\t\t+ else_dict[tree.name]\n\t\t\t\t+ irra_to_sql(tree.children[0], is_row_calc=is_row_calc)\n\t\t\t)\n\n", "description": "\\'", "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "def", "name": "ra_to_irra", "data": "def ra_to_irra(tree):\n\tflat_tree = flatten_cnf(copy.deepcopy(tree))\n\tfor node in findall(flat_tree, filter_=lambda x: x.name == \"Selection\"):\n\t\ttable_node = node.children[1]\n\t\tjoin_list = []\n\t\twhere_list = []\n\t\thaving_list = []\n\t\tif node.children[0].name == \"And\":\n\t\t\tfor predicate in node.children[0].children:\n\t\t\t\t# Join list\u7684\u5224\u65ad\u5b58\u5728\u95ee\u9898\n\t\t\t\tif (\n\t\t\t\t\tall(node_util.is_field(child) for child in predicate.children)\n\t\t\t\t\tand predicate.name == \"eq\"\n\t\t\t\t):\n\t\t\t\t\tjoin_list.append(predicate)\n\t\t\t\telse:\n\t\t\t\t\tif predicate.name == \"Or\" or all(\n\t\t\t\t\t\tchild.name in [\"literal\", \"Subquery\", \"Value\", \"Or\", 'add', 'sub', 'div', 'mul', 'Val_list']\n\t\t\t\t\t\tfor child in predicate.children\n\t\t\t\t\t):\n\t\t\t\t\t\twhere_list.append(predicate)\n\t\t\t\t\telse:\n\t\t\t\t\t\thaving_list.append(predicate)\n\t\t\t\tpredicate.parent = None\n\t\telse:\n\t\t\tif node.children[0].name == \"eq\" and all(\n\t\t\t\tnode_util.is_field(child) for child in node.children[0].children\n\t\t\t):\n\t\t\t\tjoin_list = [node.children[0]]\n\t\t\telif node.children[0].name == \"Or\":\n\t\t\t\twhere_list = [node.children[0]]\n\t\t\telse:\n\t\t\t\tif all(\n\t\t\t\t\tchild.name in [\"literal\", \"Subquery\", \"Value\", \"Or\", 'add', 'sub', 'div', 'mul', 'Val_list']\n\t\t\t\t\tfor child in node.children[0].children\n\t\t\t\t):\n\t\t\t\t\twhere_list = [node.children[0]]\n\t\t\t\telse:\n\t\t\t\t\thaving_list = [node.children[0]]\n\t\t\tnode.children[0].parent = None\n\t\thaving_node = (\n\t\t\t[Node(\"Having\", children=wrap_and(having_list))] if having_list else []\n\t\t)\n\t\tjoin_on = Node(\"Join_on\", children=join_list)\n\t\tif len(join_on.children) == 0:\n\t\t\tjoin_on.children = [table_node]\n\t\tnode.children = having_node + wrap_and(where_list) + [join_on]\n\tflat_tree = Node(\"Subquery\", children=[flat_tree])\n\tpromote(flat_tree)\n\treturn flat_tree.children[0]\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "def", "name": "if_row_calc", "data": "def if_row_calc(tree):\n\tif tree.name == 'Product':\n\t\tl_child = tree.children[0]\n\t\tr_child = tree.children[1]\n\t\tif len(l_child.children) == 1 and len(r_child.children) == 1 and l_child.children[0].name == 'Subquery' and r_child.children[0].name == 'Subquery':\n\t\t\treturn True\n\t\n\tif len(tree.children) == 0:\n\t\treturn False\n\treturn any([if_row_calc(x) for x in tree.children])\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}, {"term": "def", "name": "ra_to_sql", "data": "def ra_to_sql(tree):\n\tif tree:\n\t\ttree = remove_keep(tree)\n\t\tis_row_calc = if_row_calc(tree)\n\t\tirra = ra_to_irra(tree)\n\t\tsql = irra_to_sql(irra, is_row_calc=is_row_calc)\n\t\t# No Need in dusql\n\t\t# sql = fix_between(sql)\n\t\tsql = sql.replace(\"LIMIT value\", \"LIMIT 1\")\n\t\treturn sql\n\telse:\n\t\treturn \"\"\n", "description": null, "category": "math", "imports": ["from functools import reduce", "from itertools import *", "from anytree import Node", "import copy", "from anytree.search import *", "import re", "import smbop.utils.node_util as node_util", "import logging"]}], [], [{"term": "class", "name": "myCalculatorTest", "data": "class myCalculatorTest(unittest.TestCase):\n\t\n\tdef test_addTwoNumbers(self):\n\t\tmy_calc = MyCalculator()\n\t\tself.assertEqual(0, my_calc.addTwoNumbers(0, 0))\n\t\tself.assertEqual(0, my_calc.addTwoNumbers(-3, 3))\n\t\tself.assertEqual(0, my_calc.addTwoNumbers(3, -3))\n\t\tself.assertEqual(-1, my_calc.addTwoNumbers(2, -3))\n\t\tself.assertEqual(5, my_calc.addTwoNumbers(2, 3))\n\t\tself.assertEqual(-3, my_calc.addTwoNumbers(0, -3))\n\t\t\n\tdef test_subtractTwoNumbers(self):\n\t\tmy_calc = MyCalculator()\n\t\tself.assertEqual(0, my_calc.subtractTwoNumbers(2, 2))\n\t\tself.assertEqual(0, my_calc.subtractTwoNumbers(-2, -2))\n\t\tself.assertEqual(3, my_calc.subtractTwoNumbers(1, -2))\n\t\tself.assertEqual(5, my_calc.subtractTwoNumbers(7, 2))\n\t\tself.assertEqual(0, my_calc.subtractTwoNumbers(0, 0))\n\t\t\n\tdef test_multipleTwoNumbers(self):\n\t\t my_calc = MyCalculator()\n\t\t self.assertEqual(0, my_calc.multipleTwoNumbers(0,0))\n\t\t self.assertEqual(0, my_calc.multipleTwoNumbers(0,5))\n\t\t self.assertEqual(0, my_calc.multipleTwoNumbers(2,0))\n\t\t self.assertEqual(25, my_calc.multipleTwoNumbers(5,5))\n\t\t self.assertEqual(4, my_calc.multipleTwoNumbers(-2,-2))\n\t\t self.assertEqual(0.5, my_calc.multipleTwoNumbers(0.5,1))\n\t\t \n\t\t \n\tdef test_division(self):\n\t\tmy_calc = MyCalculator()\n\t\tself.assertEqual(2.5, my_calc.division(5,2))\n\t\tself.assertEqual(4, my_calc.division(2,0.5))\n\t\tself.assertEqual(2.5, my_calc.division(5,2))\n\t\tself.assertEqual(-2.5, my_calc.division(-5,2))\n\t\tself.assertEqual(2, my_calc.division(-6,-3))\n\t\t\n\tdef test_factorial(self):\n\t\tmy_calc = MyCalculator()\n\t\tself.assertEqual(24, my_calc.factorial(4))\n\t\tself.assertEqual(120, my_calc.factorial(5))\n\t\n\tdef test_combination(self):\n\t\tmy_calc = MyCalculator()\n\t\tself.assertEqual(252, my_calc.combination(10,5))\n\t\tself.assertEqual(1, my_calc.combination(10,0))\n\t\tself.assertEqual(1, my_calc.combination(0,0))\n\t\t\n\tdef test_permutation(self):\n\t\tmy_calc = MyCalculator()\n\t\tself.assertEqual(30240, my_calc.permutation(10,5))\n\t\tself.assertEqual(1, my_calc.permutation(10,0))\n\t\tself.assertEqual(1, my_calc.permutation(0,0))\n\t\tself.assertEqual(90, my_calc.permutation(10,2))\n\t\t\n\tdef test_square(self):\n\t\tmy_calc = MyCalculator()\n\t\tself.assertEqual(0, my_calc.square(0))\n\t\tself.assertEqual(4, my_calc.square(2))\n\t\tself.assertEqual(4, my_calc.square(-2))\n\t\tself.assertEqual(25, my_calc.square(5))\n\t\t\n\tdef test_squareRoot(self):\n\t\tmy_calc = MyCalculator()\n\t\tself.assertEqual(0, my_calc.squareRoot(0))\n\t\tself.assertEqual(1, my_calc.squareRoot(1))\n\t\tself.assertEqual(5, my_calc.squareRoot(25))\n\t\tself.assertEqual(2.5, my_calc.squareRoot(6.25))\n\t\t\n\tdef test_cube(self):\n\t\tmy_calc = MyCalculator()\n\t\tself.assertEqual(0, my_calc.cube(0))\n\t\tself.assertEqual(1, my_calc.cube(1))\n\t\tself.assertEqual(-1, my_calc.cube(-1))\n\t\tself.assertEqual(27, my_calc.cube(3))\n\t\tself.assertEqual(3.375, my_calc.cube(1.5))\n\t\t\n\tdef test_cubeRoot(self):\n\t\tmy_calc = MyCalculator()\n\t\tself.assertEqual(0, my_calc.cubeRoot(0))\n\t\tself.assertEqual(1, my_calc.cubeRoot(1))\n\t\tself.assertEqual(3, my_calc.cubeRoot(27))\n\t\tself.assertEqual(1.5, my_calc.cubeRoot(3.375))\n\t\t\n\tdef test_exponentiate(self):\n\t\tmy_calc = MyCalculator()\n\t\tself.assertEqual(0, my_calc.exponentiate(0,10))\n\t\tself.assertEqual(1, my_calc.exponentiate(1,0))\n\t\tself.assertEqual(1, my_calc.exponentiate(1,2))\n\t\tself.assertEqual(1, my_calc.exponentiate(-1,2))\n\t\tself.assertEqual(-1, my_calc.exponentiate(-1,3))\n\t\tself.assertEqual(625, my_calc.exponentiate(5,4))\n\t\tself.assertEqual(2187, my_calc.exponentiate(3,7))\n\t\t\n\t\n", "description": null, "category": "math", "imports": ["import unittest", "from myCalculator import MyCalculator"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "class", "name": "classCycle:", "data": "class Cycle:\n\tdef __init__(self, cycle):\n\t\tself.cycleNumber = cycle['CycleNumber']\n\t\tself.startTime = int(cycle['CycleStartTime'])\n\t\tself.endTime = int(cycle['CycleEndTime'])\n\t\tself.totalTime = float(cycle['CycleTotalTime'])\n\n\t\tdata = cycle['CycleData']\n\n\t\t# Eject Cylinder\n\n\t\teject_cylinder = data['EjectCylinder']\n\n\t\tif 'SetRWTC1Profile' in eject_cylinder:\n\t\t\tself.setRWTC1 = self.fix_list(eject_cylinder['SetRWTC1Profile'])\n\t\telse:\n\t\t\tself.setRWTC1 = 0\n\n\t\tif 'SetRWTC2Profile' in eject_cylinder:\n\t\t\tself.setRWTC2 = self.fix_list(eject_cylinder['SetRWTC2Profile'])\n\t\telse:\n\t\t\tself.setRWTC2 = 0\n\n\t\tif 'SetSuctionProfile' in eject_cylinder:\n\t\t\tself.setSuction = self.fix_list(eject_cylinder['SetSuctionProfile'])\n\t\telse:\n\t\t\tself.setSuction = 0\n\n\t\tif 'SetWTCProfile' in eject_cylinder:\n\t\t\tself.setWTC = self.fix_list(eject_cylinder['SetWTCProfile'])\n\t\telse:\n\t\t\tself.setWTC = 0\n\n\t\tself.ejectTime = float(eject_cylinder['ActEjectTime'])\n\n\t\tif 'ActRWTC1Profile' in eject_cylinder:\n\t\t\tself.RWTC1 = self.fix_list(eject_cylinder['ActRWTC1Profile'])\n\t\telse:\n\t\t\tself.RWTC1 = 0\n\n\t\tif 'ActRWTC2Profile' in eject_cylinder:\n\t\t\tself.RWTC2 = self.fix_list(eject_cylinder['ActRWTC2Profile'])\n\t\telse:\n\t\t\tself.RWTC2 = 0\n\n\t\tif 'ActSuctionProfile' in eject_cylinder:\n\t\t\tself.suction = self.fix_list(eject_cylinder['ActSuctionProfile'])\n\t\telse:\n\t\t\tself.suction = 0.0\n\n\t\tif 'ActWTCProfile' in eject_cylinder:\n\t\t\tself.WTC = self.fix_list(eject_cylinder['ActWTCProfile'])\n\t\telse:\n\t\t\tself.WTC = 0.0\n\n\t\tself.dieTempZ1 = []\n\t\tif 'ActDieTemperatureProfileZone1' in eject_cylinder:\n\t\t\tdie_temperature_profile_zone1 = eject_cylinder['ActDieTemperatureProfileZone1']\n\n\t\t\tfor t in die_temperature_profile_zone1.values():\n\t\t\t\tself.dieTempZ1.append(float(t))\n\t\telse:\n\t\t\tself.dieTempZ1.append(0.0)\n\n\t\tself.dieTempZ2 = []\n\t\tif 'ActDieTemperatureProfileZone2' in eject_cylinder:\n\t\t\tdie_temperature_profile_zone2 = eject_cylinder['ActDieTemperatureProfileZone2']\n\n\t\t\tfor t in die_temperature_profile_zone2.values():\n\t\t\t\tself.dieTempZ2.append(float(t))\n\t\telse:\n\t\t\tself.dieTempZ2.append(0.0)\n\n\t\tself.dieTempZ3 = []\n\t\tif 'ActDieTemperatureProfileZone3' in eject_cylinder:\n\t\t\tdie_temperature_profile_zone3 = eject_cylinder['ActDieTemperatureProfileZone3']\n\n\t\t\tfor t in die_temperature_profile_zone3.values():\n\t\t\t\tself.dieTempZ3.append(float(t))\n\t\telse:\n\t\t\tself.dieTempZ3.append(0.0)\n\n\t\tself.headTempZ1 = []\n\t\tif 'ActHeadTemperatureProfileZone1' in eject_cylinder:\n\t\t\thead_temperature_profile_zone1 = eject_cylinder['ActHeadTemperatureProfileZone1']\n\n\t\t\tfor t in head_temperature_profile_zone1.values():\n\t\t\t\tself.headTempZ1.append(float(t))\n\t\telse:\n\t\t\tself.headTempZ1.append(0.0)\n\n\t\tself.headTempZ2 = []\n\t\tif 'ActHeadTemperatureProfileZone2' in eject_cylinder:\n\t\t\thead_temperature_profile_zone2 = eject_cylinder['ActHeadTemperatureProfileZone2']\n\n\t\t\tfor t in head_temperature_profile_zone2.values():\n\t\t\t\tself.headTempZ2.append(float(t))\n\t\telse:\n\t\t\tself.headTempZ2.append(0.0)\n\n\t\tself.headTempZ3 = []\n\t\tif 'ActHeadTemperatureProfileZone3' in eject_cylinder:\n\t\t\thead_temperature_profile_zone3 = eject_cylinder['ActHeadTemperatureProfileZone3']\n\n\t\t\tfor t in head_temperature_profile_zone3.values():\n\t\t\t\tself.headTempZ3.append(float(t))\n\t\telse:\n\t\t\tself.headTempZ3.append(0.0)\n\n\t\tif 'SetDieTemperatureProfileZone1' in eject_cylinder:\n\t\t\tself.setDieTempZ1 = 210\n\t\telse:\n\t\t\tself.setDieTempZ1 = 0.0\n\n\t\tif 'SetDieTemperatureProfileZone2' in eject_cylinder:\n\t\t\tself.setDieTempZ2 = 210\n\t\telse:\n\t\t\tself.setDieTempZ2 = 0.0\n\n\t\tif 'SetDieTemperatureProfileZone3' in eject_cylinder:\n\t\t\tself.setDieTempZ3 = 215\n\t\telse:\n\t\t\tself.setDieTempZ3 = 0.0\n\n\t\tif 'SetHeadTemperatureProfileZone1' in eject_cylinder:\n\t\t\tself.setHeadTempZ1 = 210\n\t\telse:\n\t\t\tself.setHeadTempZ1 = 0.0\n\n\t\tif 'SetHeadTemperatureProfileZone2' in eject_cylinder:\n\t\t\tself.setHeadTempZ2 = 210\n\t\telse:\n\t\t\tself.setHeadTempZ2 = 0.0\n\n\t\tif 'SetHeadTemperatureProfileZone3' in eject_cylinder:\n\t\t\tself.setHeadTempZ3 = 210\n\t\telse:\n\t\t\tself.setHeadTempZ3 = 0.0\n\n\t\t###############\n\t\tdel eject_cylinder\n\n\t\t# Extruder Data\n\t\textruder = data['Extruder']\n\n\t\tself.meltTemp = []\n\t\tif 'ActMeltTemperatureProfile' in extruder:\n\t\t\tact_melt_temperature_profile = extruder['ActMeltTemperatureProfile']\n\n\t\t\tfor t in act_melt_temperature_profile.values():\n\t\t\t\tself.meltTemp.append(float(t))\n\t\telse:\n\t\t\tself.meltTemp.append(0.0)\n\n\t\tself.tempFZ = []\n\t\tif 'ActTemperatureProfileFeedZone' in extruder:\n\t\t\tact_temperature_profile_feed_zone = extruder['ActTemperatureProfileFeedZone']\n\n\t\t\tfor t in act_temperature_profile_feed_zone.values():\n\t\t\t\tself.tempFZ.append(float(t))\n\t\telse:\n\t\t\tself.tempFZ.append(0.0)\n\n\t\tself.tempZA1 = []\n\t\tif 'ActTemperatureProfileZoneA1' in extruder:\n\t\t\tact_temperature_profile_zone_a1 = extruder['ActTemperatureProfileZoneA1']\n\n\t\t\tfor t in act_temperature_profile_zone_a1.values():\n\t\t\t\tself.tempZA1.append(float(t))\n\t\telse:\n\t\t\tself.tempZA1.append(0.0)\n\n\t\tself.tempZA10 = []\n\t\tif 'ActTemperatureProfileZoneA10' in extruder:\n\t\t\tact_temperature_profile_zone_a10 = extruder['ActTemperatureProfileZoneA10']\n\n\t\t\tfor t in act_temperature_profile_zone_a10.values():\n\t\t\t\tself.tempZA10.append(float(t))\n\t\telse:\n\t\t\tself.tempZA10.append(0.0)\n\n\t\tself.tempZA11 = []\n\t\tif 'ActTemperatureProfileZoneA11' in extruder:\n\t\t\tact_temperature_profile_zone_a11 = extruder['ActTemperatureProfileZoneA11']\n\n\t\t\tfor t in act_temperature_profile_zone_a11.values():\n\t\t\t\tself.tempZA11.append(float(t))\n\t\telse:\n\t\t\tself.tempZA11.append(0.0)\n\n\t\tself.tempZA2 = []\n\t\tif 'ActTemperatureProfileZoneA2' in extruder:\n\t\t\tact_temperature_profile_zone_a2 = extruder['ActTemperatureProfileZoneA2']\n\n\t\t\tfor t in act_temperature_profile_zone_a2.values():\n\t\t\t\tself.tempZA2.append(float(t))\n\t\telse:\n\t\t\tself.tempZA2.append(0.0)\n\n\t\tself.tempZA3 = []\n\t\tif 'ActTemperatureProfileZoneA3' in extruder:\n\t\t\tact_temperature_profile_zone_a3 = extruder['ActTemperatureProfileZoneA3']\n\n\t\t\tfor t in act_temperature_profile_zone_a3.values():\n\t\t\t\tself.tempZA3.append(float(t))\n\t\telse:\n\t\t\tself.tempZA3.append(0.0)\n\n\t\tself.exPressure = []\n\t\tif 'ActExtruderPressureProfile' in extruder:\n\t\t\tact_extruder_pressure_profile = extruder['ActExtruderPressureProfile']\n\n\t\t\tfor t in act_extruder_pressure_profile.values():\n\t\t\t\tself.exPressure.append(float(t))\n\t\telse:\n\t\t\tself.exPressure.append(0.0)\n\n\t\tself.exSpeed = []\n\t\tif 'ActExtruderSpeedProfile' in extruder:\n\t\t\tact_extruder_speed_profile = extruder['ActExtruderSpeedProfile']\n\n\t\t\tfor t in act_extruder_speed_profile.values():\n\t\t\t\tself.exSpeed.append(float(t))\n\t\telse:\n\t\t\tself.exSpeed.append(0.0)\n\n\t\tself.exTorque = []\n\t\tif 'ActExtruderTorqueProfile' in extruder:\n\t\t\tact_extruder_torque_profile = extruder['ActExtruderTorqueProfile']\n\n\t\t\tfor t in act_extruder_torque_profile.values():\n\t\t\t\tself.exTorque.append(float(t))\n\t\telse:\n\t\t\tself.exTorque.append(0.0)\n\n\t\tif 'SetMeltTemperatureProfile' in extruder:\n\t\t\tself.setMeltTemp = 210.0\n\t\telse:\n\t\t\tself.setMeltTemp = 0.0\n\n\t\tif 'SetTemperatureProfileFeedZone' in extruder:\n\t\t\tself.setTempFZ = 250.0\n\t\telse:\n\t\t\tself.setTempFZ = 0.0\n\n\t\tif 'SetTemperatureProfileZoneA1' in extruder:\n\t\t\tself.setTempZA1 = 190.0\n\t\telse:\n\t\t\tself.setTempZA1 = 0.0\n\n\t\tif 'SetTemperatureProfileZoneA10' in extruder:\n\t\t\tself.setTempZA10 = 220.0\n\t\telse:\n\t\t\tself.setTempZA10 = 0.0\n\n\t\tif 'SetTemperatureProfileZoneA11' in extruder:\n\t\t\tself.setTempZA11 = 220.0\n\t\telse:\n\t\t\tself.setTempZA11 = 0.0\n\n\t\tif 'SetTemperatureProfileZoneA2' in extruder:\n\t\t\tself.setTempZA2 = 205.0\n\t\telse:\n\t\t\tself.setTempZA2 = 0.0\n\n\t\tif 'SetTemperatureProfileZoneA3' in extruder:\n\t\t\tself.setTempZA3 = 215.0\n\t\telse:\n\t\t\tself.setTempZA3 = 0.0\n\n\t\tdel extruder\n\n\t\tdel data\n\n\t@staticmethod\n\tdef fix_list(the_list):\n\t\tams = the_list.values()\n\t\ttrim_list = ''\n\t\tfor i in ams:\n\t\t\ti = i[1:-1]\n\t\t\ttrim_list = i\n\t\tsplit_list = trim_list.split(', ')\n\t\tsplit_list = [float(i) for i in split_list]\n\t\tclean_list = list(filter(lambda a: a != -1001.0, split_list))\n\t\treturn clean_list\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "calc_distance", "data": "def calc_distance(actual, cycle_settings):\n\tx1 = np.array(actual)\n\ty1 = x1.astype(np.float)\n\tx2 = np.array(cycle_settings)\n\ty2 = x2.astype(np.float)\n\tdistance = dtw.distance_fast(y1, y2)\n\treturn distance\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "calc_average", "data": "def calc_average(column):\n\ttest_sum = []\n\tss = 0\n\tfor col in column:\n\t\ttest_sum.append(len(col))\n\t\tss += 1\n\tff = int(sum(test_sum) / ss)\n\n\tex_default = []\n\tfor x in [*range(0, ff)]:\n\t\tval_av = []\n\t\tfor col in column:\n\t\t\ttry:\n\t\t\t\tval_av.append(col[x])\n\t\t\texcept Exception as e:\n\t\t\t\tprint(e)\n\t\t\t\tpass\n\t\tex_default.append(sum(val_av) / len(val_av))\n\treturn ex_default\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "calc_average_three", "data": "def calc_average_three(m, column):\n\tif m > 2:\n\t\tff = int((len(column[m - 1]) + len(column[m - 2]) + len(column[m - 3]))/3)\n\t\tex_default = []\n\t\tcolumn3 = column[(m - 3):m]\n\t\tfor x in [*range(0, ff)]:\n\t\t\tval_av = []\n\t\t\tfor col in column3:\n\t\t\t\ttry:\n\t\t\t\t\tval_av.append(col[x])\n\t\t\t\texcept Exception as e:\n\t\t\t\t\tprint(e)\n\t\t\t\t\tpass\n\t\t\tex_default.append(sum(val_av) / len(val_av))\n\telif m == 2:\n\t\tff = int((len(column[m - 1]) + len(column[m - 2])) / 2)\n\t\tex_default = []\n\t\tcolumn2 = column[(m - 2):m]\n\t\tfor x in [*range(0, ff)]:\n\t\t\tval_av = []\n\t\t\tfor col in column2:\n\t\t\t\ttry:\n\t\t\t\t\tval_av.append(col[x])\n\t\t\t\texcept Exception as e:\n\t\t\t\t\tprint(e)\n\t\t\t\t\tpass\n\t\t\tex_default.append(sum(val_av) / len(val_av))\n\telif m == 1:\n\t\tex_default = column[m-1]\n\telse:\n\t\tex_default = column[m]\n\treturn ex_default\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "transform_product", "data": "def transform_product(df_product):\n\tnew_df = pd.DataFrame(columns=df_product.columns)\n\tfor x in [*range(0, len(df_product)-2)]:\n\t\tdf_temp = df_product[x:x+3].copy()\n\t\tm = 0\n\t\ttemp_dict = {}\n\t\tpass\n\t\ttemp_dict['startTime'] = df_temp['startTime'][0]\n\t\ttemp_dict['endTime'] = df_temp['endTime'][2]\n\t\ttemp_dict['totalTime'] = df_temp['endTime'][2] - df_temp['startTime'][0]\n\t\ttemp_dict['ejectTime'] = df_temp['ejectTime'][1]\n\n\t\tfor col in df_temp.columns:\n\t\t\tif m > 3:\n\t\t\t\ty = df_temp[col][0].copy()\n\t\t\t\ty.extend(df_temp[col][1])\n\t\t\t\ty.extend(df_temp[col][2])\n\t\t\t\ttemp_dict[col] = y\n\t\t\telse:\n\t\t\t\tpass\n\t\t\tm += 1\n\t\tthe_index = ''\n\t\tif x < 10:\n\t\t\tthe_index = 'C0000' + str(x)\n\t\telif 9 < x < 100:\n\t\t\tthe_index = 'C000' + str(x)\n\t\telif 99 < x < 1000:\n\t\t\tthe_index = 'C00' + str(x)\n\t\telif 999 < x < 10000:\n\t\t\tthe_index = 'C0' + str(x)\n\t\tnew_df.loc[the_index] = temp_dict\n\treturn new_df\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "transform_product_selective", "data": "def transform_product_selective(df_product):\n\tnew_df = pd.DataFrame(columns=df_product.columns)\n\tfor x in [*range(0, len(df_product)-2)]:\n\t\tdf_temp = df_product[x:x+3].copy()\n\t\tm = 0\n\t\ttemp_dict = {}\n\t\tpass\n\t\ttemp_dict['startTime'] = df_temp['startTime'][0]\n\t\ttemp_dict['endTime'] = df_temp['endTime'][2]\n\t\ttemp_dict['totalTime'] = df_temp['endTime'][2] - df_temp['startTime'][0]\n\t\ttemp_dict['ejectTime'] = df_temp['ejectTime'][1]\n\t\tthe_index = ''\n\t\tfor col in df_temp.columns:\n\t\t\tif m > 13:\n\t\t\t\ty = df_temp[col][0].copy()\n\t\t\t\ttemp_dict[col] = y\n\t\t\telif 3 < m < 14:\n\t\t\t\ty = df_temp[col][1].copy()\n\t\t\t\ttemp_dict[col] = y\n\t\t\telse:\n\t\t\t\tpass\n\t\t\tm += 1\n\t\tif x < 10:\n\t\t\tthe_index = 'C0000' + str(x)\n\t\telif 9 < x < 100:\n\t\t\tthe_index = 'C000' + str(x)\n\t\telif 99 < x < 1000:\n\t\t\tthe_index = 'C00' + str(x)\n\t\telif 999 < x < 10000:\n\t\t\tthe_index = 'C0' + str(x)\n\t\tnew_df.loc[the_index] = temp_dict\n\treturn new_df\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "create_dataframe_previous_three", "data": "def create_dataframe_previous_three(df_cycle_main):\n\tstart = time.time()\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['exPressure']:\n\t\tex_default = calc_average_three(m, df_cycle_main['exPressure'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['exPressure'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['exSpeed']:\n\t\tex_default = calc_average_three(m, df_cycle_main['exSpeed'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['exSpeed'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['exTorque']:\n\t\tex_default = calc_average_three(m, df_cycle_main['exTorque'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['exTorque'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['RWTC1']:\n\t\tex_default = calc_average_three(m, df_cycle_main['RWTC1'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['RWTC1'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['RWTC2']:\n\t\tex_default = calc_average_three(m, df_cycle_main['RWTC2'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['RWTC2'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['suction']:\n\t\tex_default = calc_average_three(m, df_cycle_main['suction'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['suction'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['WTC']:\n\t\tex_default = calc_average_three(m, df_cycle_main['WTC'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['WTC'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['dieTempZ1']:\n\t\tex_default = calc_average_three(m, df_cycle_main['dieTempZ1'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['dieTempZ1'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['dieTempZ2']:\n\t\tex_default = calc_average_three(m, df_cycle_main['dieTempZ2'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['dieTempZ2'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['dieTempZ3']:\n\t\tex_default = calc_average_three(m, df_cycle_main['dieTempZ3'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['dieTempZ3'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['headTempZ1']:\n\t\tex_default = calc_average_three(m, df_cycle_main['headTempZ1'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['headTempZ1'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['headTempZ2']:\n\t\tex_default = calc_average_three(m, df_cycle_main['headTempZ2'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['headTempZ2'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['headTempZ3']:\n\t\tex_default = calc_average_three(m, df_cycle_main['headTempZ3'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['headTempZ3'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['tempFZ']:\n\t\tex_default = calc_average_three(m, df_cycle_main['tempFZ'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['tempFZ'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['tempZA1']:\n\t\tex_default = calc_average_three(m, df_cycle_main['tempZA1'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['tempZA1'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['tempZA10']:\n\t\tex_default = calc_average_three(m, df_cycle_main['tempZA10'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['tempZA10'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['tempZA11']:\n\t\tex_default = calc_average_three(m, df_cycle_main['tempZA11'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['tempZA11'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['tempZA2']:\n\t\tex_default = calc_average_three(m, df_cycle_main['tempZA2'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['tempZA2'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['tempZA3']:\n\t\tex_default = calc_average_three(m, df_cycle_main['tempZA3'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['tempZA3'][m] = i\n\t\tm += 1\n\n\tm = 0\n\tex_av3 = []\n\tfor i in df_cycle_main['meltTemp']:\n\t\tex_default = calc_average_three(m, df_cycle_main['meltTemp'])\n\t\tex_av3.append(calc_distance(i, ex_default))\n\t\tm += 1\n\n\tm = 0\n\tfor i in ex_av3:\n\t\tdf_cycle_main['meltTemp'][m] = i\n\t\tm += 1\n\n\tdel ex_default\n\tend = time.time()\n\tprint(\"Calculate Distances\")\n\tprint(end - start)\n\treturn df_cycle_main\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "create_dataframe_av", "data": "def create_dataframe_av(df_cycle_main):\n\tstart = time.time()\n\tex_default = calc_average(df_cycle_main['exPressure'])\n\tm = 0\n\tfor i in df_cycle_main['exPressure']:\n\t\tdf_cycle_main['exPressure'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tex_default = calc_average(df_cycle_main['exSpeed'])\n\tm = 0\n\tfor i in df_cycle_main['exSpeed']:\n\t\tdf_cycle_main['exSpeed'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tex_default = calc_average(df_cycle_main['exTorque'])\n\tm = 0\n\tfor i in df_cycle_main['exTorque']:\n\t\tdf_cycle_main['exTorque'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tex_default = calc_average(df_cycle_main['RWTC1'])\n\tm = 0\n\tfor i in df_cycle_main['RWTC1']:\n\t\tdf_cycle_main['RWTC1'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tex_default = calc_average(df_cycle_main['RWTC2'])\n\tm = 0\n\tfor i in df_cycle_main['RWTC2']:\n\t\tdf_cycle_main['RWTC2'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tex_default = calc_average(df_cycle_main['suction'])\n\tm = 0\n\tfor i in df_cycle_main['suction']:\n\t\tdf_cycle_main['suction'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tex_default = calc_average(df_cycle_main['WTC'])\n\tm = 0\n\tfor i in df_cycle_main['WTC']:\n\t\tdf_cycle_main['WTC'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tex_default = calc_average(df_cycle_main['dieTempZ1'])\n\tm = 0\n\tfor i in df_cycle_main['dieTempZ1']:\n\t\tdf_cycle_main['dieTempZ1'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['dieTempZ2'])\n\tfor i in df_cycle_main['dieTempZ2']:\n\t\tdf_cycle_main['dieTempZ2'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['dieTempZ3'])\n\tfor i in df_cycle_main['dieTempZ3']:\n\t\tdf_cycle_main['dieTempZ3'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['headTempZ1'])\n\tfor i in df_cycle_main['headTempZ1']:\n\t\tdf_cycle_main['headTempZ1'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['headTempZ2'])\n\tfor i in df_cycle_main['headTempZ2']:\n\t\tdf_cycle_main['headTempZ2'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['headTempZ3'])\n\tfor i in df_cycle_main['headTempZ3']:\n\t\tdf_cycle_main['headTempZ3'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['tempFZ'])\n\tfor i in df_cycle_main['tempFZ']:\n\t\tdf_cycle_main['tempFZ'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['tempZA1'])\n\tfor i in df_cycle_main['tempZA1']:\n\t\tdf_cycle_main['tempZA1'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['tempZA10'])\n\tfor i in df_cycle_main['tempZA10']:\n\t\tdf_cycle_main['tempZA10'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['tempZA11'])\n\tfor i in df_cycle_main['tempZA11']:\n\t\tdf_cycle_main['tempZA11'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['tempZA2'])\n\tfor i in df_cycle_main['tempZA2']:\n\t\tdf_cycle_main['tempZA2'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['tempZA3'])\n\tfor i in df_cycle_main['tempZA3']:\n\t\tdf_cycle_main['tempZA3'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tex_default = calc_average(df_cycle_main['meltTemp'])\n\tfor i in df_cycle_main['meltTemp']:\n\t\tdf_cycle_main['meltTemp'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\tdel ex_default\n\tend = time.time()\n\tprint(\"Calculate Distances\")\n\tprint(end - start)\n\treturn df_cycle_main\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "create_dataframe", "data": "def create_dataframe(df_cycle_main):\n\tstart = time.time()\n\n\tm = 0\n\textr = []\n\tfor i in df_cycle_main['exPressure']:\n\t\tif len(i) > 0:\n\t\t\tif m != 0:\n\t\t\t\tsettings_ = extr\n\t\t\t\textr = i\n\t\t\t\tdf_cycle_main['exPressure'][m] = calc_distance(i, settings_)\n\t\t\telse:\n\t\t\t\tsettings_ = i\n\t\t\t\textr = i\n\t\t\t\tdf_cycle_main['exPressure'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\textr = []\n\tfor i in df_cycle_main['exSpeed']:\n\t\tif len(i) > 0:\n\t\t\tif m != 0:\n\t\t\t\tsettings_ = extr\n\t\t\t\textr = i\n\t\t\t\tdf_cycle_main['exSpeed'][m] = calc_distance(i, settings_)\n\t\t\telse:\n\t\t\t\tsettings_ = i\n\t\t\t\textr = i\n\t\t\t\tdf_cycle_main['exSpeed'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\textr = []\n\tfor i in df_cycle_main['exTorque']:\n\t\tif len(i) > 0:\n\t\t\tif m != 0:\n\t\t\t\tsettings_ = extr\n\t\t\t\textr = i\n\t\t\t\tdf_cycle_main['exTorque'][m] = calc_distance(i, settings_)\n\t\t\telse:\n\t\t\t\tsettings_ = i\n\t\t\t\textr = i\n\t\t\t\tdf_cycle_main['exTorque'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\twtc_wtc = []\n\tfor i in df_cycle_main['RWTC1']:\n\t\tif m != 0:\n\t\t\tsettings_ = wtc_wtc\n\t\t\twtc_wtc = i\n\t\t\tdf_cycle_main['RWTC1'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\twtc_wtc = i\n\t\t\tdf_cycle_main['RWTC1'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\twtc_wtc = []\n\tfor i in df_cycle_main['RWTC2']:\n\t\tif m != 0:\n\t\t\tsettings_ = wtc_wtc\n\t\t\twtc_wtc = i\n\t\t\tdf_cycle_main['RWTC2'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\twtc_wtc = i\n\t\t\tdf_cycle_main['RWTC2'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\twtc_wtc = []\n\tfor i in df_cycle_main['suction']:\n\t\tif m != 0:\n\t\t\tsettings_ = wtc_wtc\n\t\t\twtc_wtc = i\n\t\t\tdf_cycle_main['suction'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\twtc_wtc = i\n\t\t\tdf_cycle_main['suction'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\twtc_wtc = []\n\tfor i in df_cycle_main['WTC']:\n\t\tif m != 0:\n\t\t\tsettings_ = wtc_wtc\n\t\t\twtc_wtc = i\n\t\t\tdf_cycle_main['WTC'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\twtc_wtc = i\n\t\t\tdf_cycle_main['WTC'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['dieTempZ1']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['dieTempZ1'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['dieTempZ1'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['dieTempZ2']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['dieTempZ2'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['dieTempZ2'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['dieTempZ3']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['dieTempZ3'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['dieTempZ3'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['headTempZ1']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['headTempZ1'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['headTempZ1'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['headTempZ2']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['headTempZ2'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['headTempZ2'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['headTempZ3']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['headTempZ3'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['headTempZ3'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['tempFZ']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempFZ'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempFZ'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['tempZA1']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempZA1'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempZA1'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['tempZA10']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempZA10'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempZA10'][m] = calc_distance(i, settings_)\n\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['tempZA11']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempZA11'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempZA11'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['tempZA2']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempZA2'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempZA2'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['tempZA3']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempZA3'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['tempZA3'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\ttemp_temp = []\n\tfor i in df_cycle_main['meltTemp']:\n\t\tif m != 0:\n\t\t\tsettings_ = temp_temp\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['meltTemp'][m] = calc_distance(i, settings_)\n\t\telse:\n\t\t\tsettings_ = i\n\t\t\ttemp_temp = i\n\t\t\tdf_cycle_main['meltTemp'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\tdel settings_\n\tdel temp_temp\n\tend = time.time()\n\tprint(\"Calculate Distances\")\n\tprint(end - start)\n\treturn df_cycle_main\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "create_dataframe_settings", "data": "def create_dataframe_settings(df_cycle_main, df_setting):\n\tstart = time.time()\n\tex_default = calc_average(df_cycle_main['exPressure'])\n\tm = 0\n\tfor i in df_cycle_main['exPressure']:\n\t\tdf_cycle_main['exPressure'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tex_default = calc_average(df_cycle_main['exSpeed'])\n\tm = 0\n\tfor i in df_cycle_main['exSpeed']:\n\t\tdf_cycle_main['exSpeed'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tex_default = calc_average(df_cycle_main['exTorque'])\n\tm = 0\n\tfor i in df_cycle_main['exTorque']:\n\t\tdf_cycle_main['exTorque'][m] = calc_distance(i, ex_default)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['RWTC1']:\n\t\tdf_cycle_main['RWTC1'][m] = calc_distance(i, df_setting['setRWTC1'][m])\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['RWTC2']:\n\t\tdf_cycle_main['RWTC2'][m] = calc_distance(i, df_setting['setRWTC2'][m])\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['suction']:\n\t\tdf_cycle_main['suction'][m] = calc_distance(i, df_setting['setSuction'][m])\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['WTC']:\n\t\tdf_cycle_main['WTC'][m] = calc_distance(i, df_setting['setWTC'][m])\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['dieTempZ1']:\n\t\tsettings_ = [df_setting['setDieTempZ1'][m]] * len(i)\n\t\tdf_cycle_main['dieTempZ1'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['dieTempZ2']:\n\t\tsettings_ = [df_setting['setDieTempZ2'][m]] * len(i)\n\t\tdf_cycle_main['dieTempZ2'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['dieTempZ3']:\n\t\tsettings_ = [df_setting['setDieTempZ3'][m]] * len(i)\n\t\tdf_cycle_main['dieTempZ3'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['headTempZ1']:\n\t\tsettings_ = [df_setting['setHeadTempZ1'][m]] * len(i)\n\t\tdf_cycle_main['headTempZ1'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['headTempZ2']:\n\t\tsettings_ = [df_setting['setHeadTempZ2'][m]] * len(i)\n\t\tdf_cycle_main['headTempZ2'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['headTempZ3']:\n\t\tsettings_ = [df_setting['setHeadTempZ3'][m]] * len(i)\n\t\tdf_cycle_main['headTempZ3'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['tempFZ']:\n\t\tsettings_ = [df_setting['setTempFZ'][m]] * len(i)\n\t\tdf_cycle_main['tempFZ'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['tempZA1']:\n\t\tsettings_ = [df_setting['setTempZA1'][m]] * len(i)\n\t\tdf_cycle_main['tempZA1'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['tempZA10']:\n\t\tsettings_ = [df_setting['setTempZA10'][m]] * len(i)\n\t\tdf_cycle_main['tempZA10'][m] = calc_distance(i, settings_)\n\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['tempZA11']:\n\t\tsettings_ = [df_setting['setTempZA11'][m]] * len(i)\n\t\tdf_cycle_main['tempZA11'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['tempZA2']:\n\t\tsettings_ = [df_setting['setTempZA2'][m]] * len(i)\n\t\tdf_cycle_main['tempZA2'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['tempZA3']:\n\t\tsettings_ = [df_setting['setTempZA3'][m]] * len(i)\n\t\tdf_cycle_main['tempZA3'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\n\tm = 0\n\tfor i in df_cycle_main['meltTemp']:\n\t\tsettings_ = [df_setting['setMeltTemp'][m]] * len(i)\n\t\tdf_cycle_main['meltTemp'][m] = calc_distance(i, settings_)\n\t\tm += 1\n\tdel settings_\n\tdel ex_default\n\tend = time.time()\n\tprint(\"Calculate Distances\")\n\tprint(end - start)\n\treturn df_cycle_main\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "process_cycles", "data": "def process_cycles(cycles_, method):\n\t# Build Vectors\n\tsettings = {}\n\tcycles = {}\n\tmeta = {}\n\tfor i in cycles_:\n\t\tz = vars(i)\n\t\tm = 0\n\t\tsetting = {}\n\t\tcycle = {}\n\t\tfor j in z:\n\t\t\tm += 1\n\t\t\tif j[0:3] == 'set':\n\t\t\t\tsetting[j] = z[j]\n\t\t\telif m > 1:\n\t\t\t\tcycle[j] = z[j]\n\t\t\telse:\n\t\t\t\tmeta[j] = z[j]\n\t\tsettings['C{}'.format(i.cycleNumber)] = setting\n\t\tcycles['C{}'.format(i.cycleNumber)] = cycle\n\tdf_cycle_main = pd.DataFrame(cycles)\n\tdf_cycle_main = df_cycle_main.transpose()\n\tdf_setting = pd.DataFrame(settings)\n\tdf_setting = df_setting.transpose()\n\tdel cycles\n\tdel meta\n\tdel settings\n\tdel cycles_\n\tdf_full = df_cycle_main.merge(df_setting, left_index=True, right_index=True)\n\n\tif method == 1:\n\t\tdf_cycle_main = create_dataframe(df_cycle_main)\n\telif method == 2:\n\t\tdf_cycle_main = create_dataframe_av(df_cycle_main)\n\telif method == 3:\n\t\tdf_cycle_main = create_dataframe_previous_three(df_cycle_main)\n\telif method == 4:\n\t\tdf_cycle_main = create_dataframe_settings(df_cycle_main, df_setting)\n\telif method == 5:\n\t\tdf_product = transform_product(df_cycle_main)\n\t\tdf_cycle_main = create_dataframe_av(df_product)\n\telif method == 6:\n\t\tdf_product = transform_product_selective(df_cycle_main)\n\t\tdf_cycle_main = create_dataframe_av(df_product)\n\tdf_setting = ''\n\tdf_product = ''\n\tprint(df_product, df_setting)\n\treturn df_cycle_main, df_full\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "read_cycles", "data": "def read_cycles(folder, method):\n\tstart = time.time()\n\tcycles_ = []\n\tjson_folder_path = os.path.join(folder)\n\tjson_files = [files for files in os.listdir(json_folder_path) if files.endswith('.json')]\n\tjson_files.sort()\n\tfor json_file in json_files:\n\t\tjson_file_path = os.path.join(json_folder_path, json_file)\n\t\twith open(json_file_path, \"r\") as file:\n\t\t\tcycle_file = json.load(file)\n\t\t\tif 151.0 > float(cycle_file['CycleTotalTime']) > 49.0:\n\t\t\t\tcycle_data = Cycle(cycle_file)\n\t\t\t\tcycles_.append(cycle_data)\n\tend = time.time()\n\tprint(\"Create Cycle objects:\")\n\tprint(end - start)\n\tdf_cycle_main, df_full = process_cycles(cycles_, method)\n\tdel cycles_\n\treturn df_cycle_main, df_full\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "read_cycles_", "data": "def read_cycles_(list_of_contents, list_of_names, list_of_dates, method):\n\tstart = time.time()\n\tcycles_ = []\n\tif list_of_contents is not None:\n\t\tfor contents, filename, date in zip(list_of_contents, list_of_names, list_of_dates):\n\t\t\tif 'json' in filename:\n\t\t\t\tcontent_type, content_string = contents.split(',')\n\t\t\t\tdecoded = base64.b64decode(content_string)\n\t\t\t\tdata = json.load(io.StringIO(decoded.decode('utf-8')))\n\t\t\t\tif 151.0 > float(data['CycleTotalTime']) > 49.0:\n\t\t\t\t\tcycle_data = Cycle(data)\n\t\t\t\t\tcycles_.append(cycle_data)\n\tend = time.time()\n\tprint(\"Create Cycle objects:\")\n\tprint(end - start)\n\tdf_cycle_main, df_full = process_cycles(cycles_, method)\n\n\tdel list_of_contents\n\tdel list_of_names\n\tdel list_of_dates\n\tdel cycles_\n\treturn df_cycle_main, df_full\n\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}, {"term": "def", "name": "update_method", "data": "def update_method(df_full, method):\n\tdf_cycle_main = df_full.iloc[:, 0:24]\n\tdf_setting = df_full.iloc[:, 24:]\n\tif method == 1:\n\t\tdf_cycle_main = create_dataframe(df_cycle_main)\n\telif method == 2:\n\t\tdf_cycle_main = create_dataframe_av(df_cycle_main)\n\telif method == 3:\n\t\tdf_cycle_main = create_dataframe_previous_three(df_cycle_main)\n\telif method == 4:\n\t\tdf_cycle_main = create_dataframe_settings(df_cycle_main, df_setting)\n\telif method == 5:\n\t\tdf_product = transform_product(df_cycle_main)\n\t\tdf_cycle_main = create_dataframe_av(df_product)\n\telif method == 6:\n\t\tdf_product = transform_product_selective(df_cycle_main)\n\t\tdf_cycle_main = create_dataframe_av(df_product)\n\tdel df_full\n\tdel df_setting\n\treturn df_cycle_main\n", "description": null, "category": "math", "imports": ["from __future__ import print_function", "import json", "import os", "import base64", "import io", "import numpy as np", "import pandas as pd", "import time", "from dtaidistance import dtw"]}], [{"term": "def", "name": "figures_of_merit_", "data": "def figures_of_merit_(f_obs,\n\t\t\t\t\t  f_calc,\n\t\t\t\t\t  alpha,\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "phase_error", "data": "def phase_error(f_obs,\n\t\t\t\tf_calc,\n\t\t\t\talpha,\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "fom", "data": "def fom(t,lcent):\n\t#\n\t# calculates the ratio I1(2t)/I0(2t) if lcent=0 and th(t) in other cases\n\t# I1() - Modified Bessel Function of 1 order\n\t# I0() - Modified Bessel Function of 0 order\n\t#\n\tif lcent == 0:\n\t   result = bessel_i1_over_i0(2.*t)\n\telse:\n\t   result = math.tanh(t)\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "class", "name": "alpha_beta_calc", "data": "class alpha_beta_calc(object):\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "__init__", "data": "  def __init__(self,f,\n\t\t\t\t\tn_atoms_absent,\n\t\t\t\t\tn_atoms_included,\n\t\t\t\t\tbf_atoms_absent,\n\t\t\t\t\tfinal_error,\n\t\t\t\t\tabsent_atom_type):\n\t#\n\t#   ss=s**2 = (2*sin(teta)/lambda)**2 for the given reflection;\n\t#   final_error - desired mean error in atomic positions (in A);\n\t#\t\t\t\t it must be specified as 0., if the user has\n\t#\t\t\t\t no idea about its other value;\n\t#   n_atoms_included - an approximate number of non-hydrogen atoms in\n\t#\t\t\t\t\t  the ASYMMETRIC PART OF THE UNIT CELL, which\n\t#\t\t\t\t\t  are INCLUDED into the current model for refinement;\n\t#   n_atoms_absent - an approximate number of non-hydrogen atoms in\n\t#\t\t\t\t\tthe ASYMMETRIC PART OF THE UNIT CELL, which are\n\t#\t\t\t\t\tNOT INCLUDED into the current model for refinement;\n\t#.....................................................................\n\t# P.Afonine, V.Lunin & A.Urzhumtsev.(2003).J.Appl.Cryst.36,158-159\n\t#\n\tself.f = f\n\tassert n_atoms_absent >= 0\n\tassert n_atoms_included >= 0\n\tassert f.size() > 0\n\tself.ss = 1./flex.pow2(f.d_spacings().data())\n\tassert self.ss.size() == f.data().size()\n\tself.nsym = f.space_group().order_z()\n\tassert self.nsym >= 1\n\tself.n_atoms_absent   = n_atoms_absent\n\tself.n_atoms_included = n_atoms_included\n\tself.bf_atoms_absent = bf_atoms_absent\n\tif final_error is None : final_error = 0.0\n\tself.final_error = final_error\n\tassert final_error >= 0.0\n\tif absent_atom_type is None : absent_atom_type=\"C\"\n\tself.absent_atom_type = absent_atom_type\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "alpha_beta", "data": "  def alpha_beta(self):\n\t#\n\t# alpha, beta by formulas\n\t#.........................................................................\n\t# V.Lunin & T.Skovoroda. Acta Cryst. (1995). A51, 880-887\n\t# A.Urzhumtsev, T.Skovoroda & V.Lunin. J. Appl. Cryst. (1996). 29, 741-744\n\t# V.Lunin, P.Afonine & A.Urzhumtsev. Acta Cryst. (2002). A58, 270-282\n\t#\n\talpha=[] ; beta=[]\n\tn_part = self.nsym * self.n_atoms_included\n\tn_lost = self.nsym * self.n_atoms_absent\n\tfor ssi in self.ss:\n\t   ak = math.exp(-0.25*ssi*(self.final_error**2)*(math.pi**3))\n\t   alpha.append( ak )\n\t   fact = self.form_factor(ssi)*math.exp(-self.bf_atoms_absent/4.0*ssi)\n\t   beta.append(((1.0-ak**2)*n_part+n_lost)*fact**2)\n\talpha_data = flex.double(alpha)\n\tbeta_data = flex.double(beta)\n\talpha = miller.array(miller_set = self.f, data = alpha_data)\n\tbeta  = miller.array(miller_set = self.f, data = beta_data)\n\treturn alpha, beta\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "form_factor", "data": "  def form_factor(self,ss):\n\t#\n\t# W & K form-factor of atom C\n\t#\n\ttable=wk1995(self.absent_atom_type).fetch()\n\ta_wk=table.array_of_a()\n\tb_wk=table.array_of_b()\n\tc_wk=table.c()\n\tresult_wk=c_wk\n\tfor i in range(5):\n\t   result_wk += a_wk[i]*math.exp(-b_wk[i]*ss/4.0)\n\treturn result_wk\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "class", "name": "alpha_beta_est_manager", "data": "class alpha_beta_est_manager(object):\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "__init__", "data": "  def __init__(self,f_obs,\n\t\t\t\t\tf_calc,\n\t\t\t\t\tfree_reflections_per_bin,\n\t\t\t\t\tflags,\n\t\t\t\t\tinterpolation,\n\t\t\t\t\tepsilons):\n\tadopt_init_args(self, locals())\n\t#\n\t# icent - array contains 0 for acentric reflections and >0 integer\n\t#\t\t for centric reflections\n\t# epsilon  - array contains the correction factors for intensity\n\t#\t\t they are equal to how many times the transposed symmetry\n\t#\t\t matrixes leaves the reciprocal space point at the same place\n\t# icont - array contains the control set; the value 1 means that\n\t#\t\t this reflection will be used in the calculation of\n\t#\t\t likelihood function;\n\t# f_calc - array of calculated magnitude values\n\t# f_obs  - array of experimental magnitude values\n\t# free_reflections_per_bin - minimal number of reflections in given\n\t#\t\t\t\t\tresolution zone used for alpha,beta calculation\n\t# V.Lunin & T.Skovoroda. Acta Cryst. (1995). A51, 880-887\n\t# P.Afonine, V.Lunin & A.Urzhumtsev.(2003).J.Appl.Cryst.36,158-159\n\t#\n\tassert len(self.flags) == self.f_obs.data().size()\n\tassert self.f_obs.data().size() == self.f_calc.data().size()\n\tassert self.f_obs.data().size() == self.epsilons.size()\n\tassert self.f_calc.indices().all_eq(self.f_obs.indices()) == 1\n\tself.f_calc = abs(self.f_calc)\n\tif(self.flags.count(True) > 0):\n\t  if free_reflections_per_bin > flags.count(True):\n\t\t self.free_reflections_per_bin = flags.count(True)\n\t  self.f_obs_test  = self.f_obs.select(self.flags)\n\t  self.f_calc_test = self.f_calc.select(self.flags)\n\t  self.epsilons_test = self.epsilons.select(self.flags)\n\tif(self.flags.count(True) == 0):\n\t  self.f_obs_test  = self.f_obs.select(~self.flags)\n\t  self.f_calc_test = self.f_calc.select(~self.flags)\n\t  self.epsilons_test = self.epsilons.select(~self.flags)\n\tself.f_obs_test.setup_binner_counting_sorted(\n\t  reflections_per_bin= self.free_reflections_per_bin)\n\tself.fo_test_sets = []\n\tself.fm_test_sets = []\n\tself.indices_sets = []\n\tself.epsilons_sets = []\n\tfor i_bin in self.f_obs_test.binner().range_used():\n\t   sel = self.f_obs_test.binner().selection(i_bin)\n\t   sel_f_obs_test = self.f_obs_test.select(sel)\n\t   sel_f_calc_test = self.f_calc_test.select(sel)\n\t   sel_epsilons_test = self.epsilons_test.select(sel)\n\t   if(sel.count(True) > 0): # XXX I do not understand why it can be 0 (in rare cases)\n\t\t self.fo_test_sets.append(sel_f_obs_test.data())\n\t\t self.fm_test_sets.append(sel_f_calc_test.data())\n\t\t self.indices_sets.append(sel_f_obs_test.indices())\n\t\t self.epsilons_sets.append(sel_epsilons_test)\n\tfor a,b,c in zip(self.fo_test_sets, self.fm_test_sets, self.indices_sets):\n\t  assert a.size() == b.size() == c.size() != 0\n\tobj = max_lik.alpha_beta_est(fo_test\t = self.fo_test_sets,\n\t\t\t\t\t\t\t\t fm_test\t = self.fm_test_sets,\n\t\t\t\t\t\t\t\t indices\t = self.indices_sets,\n\t\t\t\t\t\t\t\t epsilons\t= self.epsilons_sets,\n\t\t\t\t\t\t\t\t space_group = self.f_obs_test.space_group())\n\tself.alpha_in_zones, self.beta_in_zones = obj.alpha(), obj.beta()\n\tself.alpha, self.beta = self.alpha_beta_for_each_reflection()\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "alpha_beta", "data": "  def alpha_beta(self):\n\treturn self.alpha, self.beta\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "smooth", "data": "  def smooth(self,x):\n\tif len(x) > 1:\n\t  x1=x[0]\n\t  x2=x[1]\n\t  for i in range(1,len(x)-1,1):\n\t\t x3=x[i+1]\n\t\t tmp = (x1+x2+x3)/3.0\n\t\t x[i]=tmp\n\t\t x1=x2\n\t\t x2=x3\n\t  for i in range(0,len(x),1):\n\t\tif(x[i] < 0.01):\n\t\t  try: x[i] = x[i-1]\n\t\t  except Exception: x[i] = x[i+1]\n\n\treturn x\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "alpha_beta_for_each_reflection", "data": "  def alpha_beta_for_each_reflection(self, f_obs=None):\n\tif f_obs is None: f_obs = self.f_obs\n\talpha = flex.double(f_obs.size())\n\tbeta = flex.double(f_obs.size())\n\tf_obs.setup_binner(n_bins= len(self.alpha_in_zones))\n\tbinner = f_obs.binner()\n\tif(self.interpolation == True):\n\t  az = flex.double(self.smooth(self.alpha_in_zones))\n\t  bz = flex.double(self.smooth(self.beta_in_zones) )\n\t  alpha = binner.interpolate(az, 0)\n\t  beta  = binner.interpolate(bz, 0)\n\telif(self.interpolation == False):\n\t  for i_bin, az, bz in zip(binner.range_used(),self.alpha_in_zones,\n\t\t\t\t\t\t\t   self.beta_in_zones):\n\t\tsel = binner.selection(i_bin)\n\t\talpha.set_selected(sel, az)\n\t\tbeta.set_selected(sel, bz)\n\talpha = miller.array(miller_set=f_obs, data=alpha)\n\tbeta = miller.array(miller_set=f_obs, data=beta)\n\treturn alpha, beta\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "__init__", "data": "  def __init__(self, f_obs\t\t\t= None,\n\t\t\t\t\t f_calc\t\t   = None,\n\t\t\t\t\t free_reflections_per_bin = None,\n\t\t\t\t\t flags\t\t\t= None,\n\t\t\t\t\t verbose\t\t  = None,\n\t\t\t\t\t n_atoms_absent   = None,\n\t\t\t\t\t n_atoms_included = None,\n\t\t\t\t\t bf_atoms_absent  = None,\n\t\t\t\t\t final_error\t  = None,\n\t\t\t\t\t absent_atom_type = None,\n\t\t\t\t\t method\t\t   = None,\n\t\t\t\t\t interpolation\t= None):\n\tadopt_init_args(self, locals())\n\tassert self.method == \"calc\" or self.method == \"est\" or \\\n\t\t   self.method == \"calc_and_est\"\n\tassert self.verbose is not None\n\tif (self.method == \"est\"):\n\t  assert self.interpolation is not None\n\t  assert self.f_obs.data().size() == self.f_calc.data().size()\n\t  assert self.flags.size() == self.f_obs.data().size()\n\t  assert self.f_calc.indices().all_eq(self.f_obs.indices()) == 1\n\t  self.alpha, self.beta = alpha_beta_est_manager(\n\t\tf_obs\t\t   = self.f_obs,\n\t\tf_calc\t\t  = abs(self.f_calc),\n\t\tfree_reflections_per_bin = self.free_reflections_per_bin,\n\t\tflags\t\t   = self.flags,\n\t\tinterpolation   = self.interpolation).alpha_beta()\n\tif (self.method == \"calc\"):\n\t  assert self.f_obs is not None or self.f_calc is not None\n\t  if (self.f_obs is not None): f = self.f_obs\n\t  else: f = self.f_calc\n\t  assert self.n_atoms_absent is not None\n\t  assert self.n_atoms_included is not None\n\t  assert self.bf_atoms_absent is not None\n\t  assert self.absent_atom_type is not None\n\t  self.alpha, self.beta = alpha_beta_calc(\n\t\t\t\t\t\t\t\t\tf\t\t\t\t= f,\n\t\t\t\t\t\t\t\t\tn_atoms_absent   = self.n_atoms_absent,\n\t\t\t\t\t\t\t\t\tn_atoms_included = self.n_atoms_included,\n\t\t\t\t\t\t\t\t\tbf_atoms_absent  = self.bf_atoms_absent,\n\t\t\t\t\t\t\t\t\tfinal_error\t  = self.final_error,\n\t\t\t\t\t\t\t\t\tabsent_atom_type = self.absent_atom_type).alpha_beta()\n\tif (self.method == \"calc_and_est\"):\n\t  assert self.interpolation\tis not None\n\t  assert self.f_obs\t\t\tis not None\n\t  assert self.f_calc\t\t   is not None\n\t  assert self.free_reflections_per_bin is not None\n\t  assert self.flags\t\t\tis not None\n\t  assert self.n_atoms_absent   is not None\n\t  assert self.n_atoms_included is not None\n\t  assert self.bf_atoms_absent  is not None\n\t  assert self.final_error\t  is not None\n\t  assert self.absent_atom_type is not None\n\t  assert self.f_obs.data().size() == self.f_calc.data().size() == \\\n\t\t\t self.flags.size()\n\t  assert self.f_calc.indices().all_eq(self.f_obs.indices()) == 1\n\t  self.alpha_calc, self.beta_calc = alpha_beta_calc(\n\t\t\t\t\t\t\t\t\tf\t\t\t\t= self.f_obs,\n\t\t\t\t\t\t\t\t\tn_atoms_absent   = self.n_atoms_absent,\n\t\t\t\t\t\t\t\t\tn_atoms_included = self.n_atoms_included,\n\t\t\t\t\t\t\t\t\tbf_atoms_absent  = self.bf_atoms_absent,\n\t\t\t\t\t\t\t\t\tfinal_error\t  = self.final_error,\n\t\t\t\t\t\t\t\t\tabsent_atom_type = self.absent_atom_type).alpha_beta()\n\t  self.alpha_est, self.beta_est = alpha_beta_est(\n\t\tf_obs\t\t   = self.f_obs,\n\t\tf_calc\t\t  = abs(self.f_calc),\n\t\tfree_reflections_per_bin = self.free_reflections_per_bin,\n\t\tflags\t\t   = self.flags,\n\t\tinterpolation   = self.interpolation).alpha_beta()\n\t  alpha_calc_ma = miller.array(miller_set= self.f_obs,data= self.alpha_calc)\n\t  beta_calc_ma  = miller.array(miller_set= self.f_obs,data= self.beta_calc)\n\t  alpha_est_ma  = miller.array(miller_set= self.f_obs,data= self.alpha_est)\n\t  beta_est_ma   = miller.array(miller_set= self.f_obs,data= self.beta_est)\n\n\t  ss = 1./flex.pow2(alpha_calc_ma.d_spacings().data())\n\t  omega_calc = []\n\t  omega_est  = []\n\t  for ac,ae,ssi in zip(self.alpha_calc, self.alpha_est,ss):\n\t\tif(ac > 1.0): ac = 1.0\n\t\tif(ae > 1.0): ae = 1.0\n\t\tif(ac <= 0.0): ac = 1.e-6\n\t\tif(ae <= 0.0): ae = 1.e-6\n\t\tcoeff = -4./(math.pi**3*ssi)\n\t\tomega_calc.append( math.sqrt( math.log(ac) * coeff ) )\n\t\tomega_est.append( math.sqrt( math.log(ae) * coeff ) )\n\t  omega_calc_ma = miller.array(miller_set= self.f_obs,data= flex.double(omega_calc))\n\t  omega_est_ma  = miller.array(miller_set= self.f_obs,data= flex.double(omega_est))\n\n\t  if(self.flags.count(True) > 0):\n\t\tomega_calc_ma_test = omega_calc_ma.select(self.flags)\n\t\tomega_est_ma_test  = omega_est_ma.select(self.flags)\n\t\talpha_calc_ma_test= alpha_calc_ma.select(self.flags)\n\t\tbeta_calc_ma_test= beta_calc_ma.select(self.flags)\n\t\talpha_est_ma_test= alpha_est_ma.select(self.flags)\n\t\tbeta_est_ma_test= beta_est_ma.select(self.flags)\n\t  if(self.flags.count(True) == 0):\n\t\tomega_calc_ma_test = omega_calc_ma.select(~self.flags)\n\t\tomega_est_ma_test  = omega_est_ma.select(~self.flags)\n\t\talpha_calc_ma_test= alpha_calc_ma.select(~self.flags)\n\t\tbeta_calc_ma_test= beta_calc_ma.select(~self.flags)\n\t\talpha_est_ma_test= alpha_est_ma.select(~self.flags)\n\t\tbeta_est_ma_test= beta_est_ma.select(~self.flags)\n\n\t  alpha_calc_ma_test.setup_binner(\n\t\treflections_per_bin = self.free_reflections_per_bin)\n\t  beta_calc_ma_test.use_binning_of(alpha_calc_ma_test)\n\t  alpha_est_ma_test.use_binning_of(alpha_calc_ma_test)\n\t  beta_est_ma_test.use_binning_of(alpha_calc_ma_test)\n\t  omega_calc_ma_test.use_binning_of(alpha_calc_ma_test)\n\t  omega_est_ma_test.use_binning_of(alpha_calc_ma_test)\n\n\t  print(\"\tResolution\t\t   Estimated and calculated alpha, beta and model error\")\n\t  print(\"   d1\t\td2\tnref alpha_e\tbeta_e\terr_e alpha_c   beta_c\t err_c\")\n\t  for i_bin in alpha_calc_ma_test.binner().range_used():\n\t\tsel = alpha_calc_ma_test.binner().selection(i_bin)\n\t\tsel_alpha_calc_ma_test = alpha_calc_ma_test.select(sel)\n\t\tsel_beta_calc_ma_test  = beta_calc_ma_test.select(sel)\n\t\tsel_alpha_est_ma_test  = alpha_est_ma_test.select(sel)\n\t\tsel_beta_est_ma_test   = beta_est_ma_test.select(sel)\n\t\tsel_omega_calc_ma_test = omega_calc_ma_test.select(sel)\n\t\tsel_omega_est_ma_test  = omega_est_ma_test.select(sel)\n\t\tsize = sel_alpha_calc_ma_test.data().size()\n\t\tif(self.interpolation == False):\n\t\t  i=0\n\t\t  while i < size:\n\t\t\tv_alpha_est = sel_alpha_est_ma_test.data()[i]\n\t\t\tif(sel_alpha_est_ma_test.data().count(v_alpha_est) > size/2):\n\t\t\t  v_beta_est = sel_beta_est_ma_test.data()[i]\n\t\t\t  if(sel_beta_est_ma_test.data().count(v_beta_est) > size/2): break\n\t\t\ti+=1\n\t\telif(self.interpolation == True):\n\t\t  v_alpha_est = flex.mean(sel_alpha_est_ma_test.data())\n\t\t  v_beta_est  = flex.mean(sel_beta_est_ma_test.data())\n\t\talpha_calc = flex.mean(sel_alpha_calc_ma_test.data())\n\t\tbeta_calc  = flex.mean(sel_beta_calc_ma_test.data())\n\t\tomega_c = flex.mean(sel_omega_calc_ma_test.data())\n\t\tomega_e = flex.mean(sel_omega_est_ma_test.data())\n\t\td1 = alpha_calc_ma_test.binner().bin_d_range(i_bin)[0]\n\t\td2 = alpha_calc_ma_test.binner().bin_d_range(i_bin)[1]\n\t\tprint(\"%8.4f %8.4f %5d %6.5f %12.3f %5.3f %6.5f %12.3f %5.3f\" % \\\n\t\t  (d1,d2,size,v_alpha_est,\\\n\t\t   v_beta_est,omega_e,alpha_calc,beta_calc,omega_c))\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "alpha_beta", "data": "  def alpha_beta(self):\n\treturn self.alpha, self.beta\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "form_factor", "data": "  def form_factor(ssi, absent_atom_type):\n\ttable=wk1995(absent_atom_type).fetch()\n\ta_wk=table.array_of_a()\n\tb_wk=table.array_of_b()\n\tc_wk=table.c()\n\tresult_wk=c_wk\n\tfor i in range(5):\n\t  result_wk += a_wk[i]*math.exp(-b_wk[i]*ssi/4.0)\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import math", "from cctbx.array_family import flex", "from cctbx.eltbx.xray_scattering import wk1995", "from scitbx.math import bessel_i1_over_i0", "from mmtbx import max_lik", "import math", "from cctbx.array_family import flex", "from cctbx import miller", "from libtbx import adopt_init_args", "import iotbx.phil", "from six.moves import zip", "from six.moves import range"]}], [{"term": "def", "name": "button_click", "data": "def button_click(char):\n\tglobal calc_operator\n\tcalc_operator += str(char)\n\ttext_input.set(calc_operator)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "button_clear_all", "data": "def button_clear_all():\n\tglobal calc_operator\n\tcalc_operator = \"\"\n\ttext_input.set(\"\")\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "button_delete", "data": "def button_delete():\n\tglobal calc_operator\n\ttext = calc_operator[:-1]\n\tcalc_operator = text\n\ttext_input.set(text)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "factorial", "data": "def factorial(n):\n\tif n==0 or n==1:\n\t\treturn 1\n\telse:\n\t\treturn n*factorial(n-1)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "fact_func", "data": "def fact_func():\n\tglobal calc_operator\n\tresult = str(factorial(int(calc_operator)))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_sin", "data": "def trig_sin():\n\tglobal calc_operator\n\tresult = str(math.sin(math.radians(int(calc_operator))))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_cos", "data": "def trig_cos():\n\tglobal calc_operator\n\tresult = str(math.cos(math.radians(int(calc_operator))))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_tan", "data": "def trig_tan():\n\tglobal calc_operator\n\tresult = str(math.tan(math.radians(int(calc_operator))))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "trig_cot", "data": "def trig_cot():\n\tglobal calc_operator\n\tresult = str(1/math.tan(math.radians(int(calc_operator))))\n\tcalc_operator = result\n\ttext_input.set(result)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "square_root", "data": "def square_root():\n\tglobal calc_operator\n\tif int(calc_operator)>=0:\n\t\ttemp = str(eval(calc_operator+'**(1/2)'))\n\t\tcalc_operator = temp\n\telse:\n\t\ttemp = \"ERROR\"\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "third_root", "data": "def third_root():\n\tglobal calc_operator\n\tif int(calc_operator)>=0:\n\t\ttemp = str(eval(calc_operator+'**(1/3)'))\n\t\tcalc_operator = temp\n\telse:\n\t\ttemp = \"ERROR\"\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "sign_change", "data": "def sign_change():\n\tglobal calc_operator\n\tif calc_operator[0]=='-':\n\t\ttemp = calc_operator[1:]\n\telse:\n\t\ttemp = '-'+calc_operator\n\tcalc_operator = temp\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "percent", "data": "def percent():\n\tglobal calc_operator\n\ttemp = str(eval(calc_operator+'/100'))\n\tcalc_operator = temp\n\ttext_input.set(temp)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}, {"term": "def", "name": "button_equal", "data": "def button_equal():\n\tglobal calc_operator\n\ttemp_op = str(eval(calc_operator))\n\ttext_input.set(temp_op)\n\tcalc_operator = temp_op\n", "description": null, "category": "math", "imports": ["from tkinter import *", "import math", "import numpy as np"]}], [{"term": "def", "name": "atoms", "data": "def atoms():\n\treturn Atoms('CHO',\n\t\t\t\t [[0.0, 0.0, 0.0],\n\t\t\t\t  [0.0, 0.0, 1.35],\n\t\t\t\t  [1.178513, 0.0, -0.416662]],\n\t\t\t\t magmoms=[0.5, 0.0, 0.5])\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase import Atoms", "from ase.io import read", "from ase.calculators.gaussian import Gaussian, GaussianOptimizer, GaussianIRC", "from ase.optimize import LBFGS"]}, {"term": "def", "name": "get_calc", "data": "def get_calc(**kwargs):\n\tkwargs.update(mem='100MW', method='hf', basis='sto-3g')\n\treturn Gaussian(**kwargs)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase import Atoms", "from ase.io import read", "from ase.calculators.gaussian import Gaussian, GaussianOptimizer, GaussianIRC", "from ase.optimize import LBFGS"]}, {"term": "def", "name": "test_optimizer", "data": "def test_optimizer(atoms):\n\tpos = atoms.positions.copy()\n\tatoms.calc = get_calc(label='opt', scf='qc')\n\topt_gauss = GaussianOptimizer(atoms)\n\topt_gauss.run(fmax='tight')\n\te_gaussopt = read('opt.log', index=-1).get_potential_energy()\n\n\tatoms.positions[:] = pos\n\tatoms.calc.set_label('sp')\n\twith LBFGS(atoms) as opt_ase:\n\t\topt_ase.run(fmax=1e-2)\n\te_aseopt = atoms.get_potential_energy()\n\tassert e_gaussopt - e_aseopt == pytest.approx(0., abs=1e-3)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase import Atoms", "from ase.io import read", "from ase.calculators.gaussian import Gaussian, GaussianOptimizer, GaussianIRC", "from ase.optimize import LBFGS"]}, {"term": "def", "name": "test_irc", "data": "def test_irc(atoms):\n\tcalc_ts = get_calc(label='ts', chk='ts.chk')\n\tts = GaussianOptimizer(atoms, calc_ts)\n\tts.run(opt='calcall,ts,noeigentest')\n\ttspos = atoms.positions.copy()\n\n\tatoms.calc = get_calc(label='sp', chk='sp.chk', freq='')\n\te_ts = atoms.get_potential_energy()\n\n\tcalc_irc_for = get_calc(label='irc_for', oldchk='sp', chk='irc_for.chk')\n\tirc_for = GaussianIRC(atoms, calc_irc_for)\n\tirc_for.run(direction='forward', irc='rcfc')\n\te_for = read('irc_for.log', index=-1).get_potential_energy()\n\n\tatoms.positions[:] = tspos\n\tcalc_irc_rev = get_calc(label='irc_rev', oldchk='sp', chk='irc_rev.chk')\n\tirc_rev = GaussianIRC(atoms, calc_irc_rev)\n\tirc_rev.run(direction='reverse', irc='rcfc')\n\te_rev = read('irc_rev.log', index=-1).get_potential_energy()\n\n\tassert e_ts - e_for == pytest.approx(1.282, abs=1e-3)\n\tassert e_ts - e_rev == pytest.approx(0.201, abs=1e-3)\n", "description": null, "category": "math", "imports": ["import pytest", "from ase import Atoms", "from ase.io import read", "from ase.calculators.gaussian import Gaussian, GaussianOptimizer, GaussianIRC", "from ase.optimize import LBFGS"]}], [], [{"term": "class", "name": "CalculatorUnitTests", "data": "class CalculatorUnitTests(unittest.TestCase):\r\n\r\n\tdef test_correct_values_sum(self):\r\n\t\tcalc = calculator.Calculator()\r\n\t\tself.assertEqual(calc.sum(1, 1), 2)\r\n\t\tself.assertEqual(calc.sum(5, 6), 11)\r\n\t\tself.assertEqual(calc.sum(5, -6), -1)\r\n\t\r\n\tdef test_correct_values_difference(self):\r\n\t\tcalc = calculator.Calculator()\r\n\t\tself.assertEqual(calc.difference(1, 1), 0)\r\n\t\tself.assertEqual(calc.difference(5, 6), -1)\r\n\t\tself.assertEqual(calc.difference(5, -6), 11)\r\n\t\r\n\tdef test_correct_values_multiply(self):\r\n\t\tcalc = calculator.Calculator()\r\n\t\tself.assertEqual(calc.multiply(1, 1), 1)\r\n\t\tself.assertEqual(calc.multiply(5, 6), 30)\r\n\t\tself.assertEqual(calc.multiply(5, -6), -30)\r\n\r\n\tdef test_correct_values_divide(self):\r\n\t\tcalc = calculator.Calculator()\r\n\t\tself.assertEqual(calc.divide(1, 1), 1)\r\n\t\tself.assertEqual(calc.divide(30, 6), 5)\r\n\t\tself.assertEqual(calc.divide(30, -6), -5)\r\n\r\n\tdef test_type(self):\r\n\t\tcalc = calculator.Calculator()\r\n\t\twith self.assertRaises(TypeError):\r\n\t\t\tcalc.sum(\"4\", 2)\r\n\t\t\tcalc.difference(\"4\", 2)\r\n\t\t\tcalc.multiply(\"4\", 2)\r\n\t\t\tcalc.divide(\"4\", 2)\r\n\r\n\tdef test_failing_on_purpose(self):\r\n\t\t# NOTE: this is a terrible practice...\r\n\t\tcalc = calculator.Calculator()\r\n\t\t# these are commented out because the test suite *should* pass\r\n\t\t# self.assertEqual(calc.sum(1, 1), 42)\r\n\t\t# self.assertEqual(calc.difference(1, 1), 42)\r\n\t\t# self.assertEqual(calc.multiply(1, 1), 42)\r\n\t\t# self.assertEqual(calc.divide(1, 1), 42)\r\n\t\t# with self.assertRaises(TypeError):\r\n\t\t#\t calc.sum(\"4\", \"2\")\r\n\r\n\t\t# it would be okay to write tests that *expect* failing values\r\n\t\tself.assertNotEqual(calc.sum(1, 1), 42)\r\n\t\tself.assertNotEqual(calc.difference(1, 1), 42)\r\n\t\tself.assertNotEqual(calc.multiply(1, 1), 42)\r\n\t\tself.assertNotEqual(calc.divide(1, 1), 42)\r\n\r\n", "description": null, "category": "math", "imports": ["import calculator\r", "import unittest\r"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "class", "name": "EMACalcType", "data": "class EMACalcType(Enum):\n\t\"\"\"\u8ba1\u7b97\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5\"\"\"\n\t\"\"\"\u7b80\u5355\u79fb\u52a8\u5e73\u5747\u7ebf\"\"\"\n\tE_MA_MA = 0\n\t\"\"\"\u52a0\u6743\u79fb\u52a8\u5e73\u5747\u7ebf\"\"\"\n\tE_MA_EMA = 1\n\n", "description": "\u8ba1\u7b97\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5", "category": "math", "imports": ["from __future__ import division", "from __future__ import absolute_import", "from __future__ import print_function", "from collections import Iterable", "import matplotlib.pyplot as plt", "import pandas as pd", "from enum import Enum", "from .ABuNDBase import plot_from_order, g_calc_type, ECalcType", "from ..CoreBu.ABuPdHelper import pd_rolling_mean, pd_ewm_mean", "from ..CoreBu.ABuFixes import six", "from ..UtilBu.ABuDTUtil import catch_error", "\timport talib", "\"\"\"\u901a\u8fc7\u5728ABuNDBase\u4e2d\u5c1d\u8bd5import talib\u6765\u7edf\u4e00\u786e\u5b9a\u6307\u6807\u8ba1\u7b97\u65b9\u5f0f, \u5916\u90e8\u8ba1\u7b97\u53ea\u5e94\u8be5\u4f7f\u7528calc_ma\"\"\""]}, {"term": "def", "name": "_calc_ma_from_ta", "data": "def _calc_ma_from_ta(prices, time_period=10, from_calc=EMACalcType.E_MA_MA):\n\t\"\"\"\n\t\u4f7f\u7528talib\u8ba1\u7b97ma\uff0c\u5373\u900f\u4f20talib.MA or talib.EMA\u8ba1\u7b97\u7ed3\u679c\n\t:param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n\t:param time_period: \u79fb\u52a8\u5e73\u5747\u7684N\u503c\uff0cint\n\t:param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5\n\t\"\"\"\n\n\timport talib\n\tif isinstance(prices, pd.Series):\n\t\tprices = prices.values\n\n\tif from_calc == EMACalcType.E_MA_MA:\n\t\tma = talib.MA(prices, timeperiod=time_period)\n\telse:\n\t\tma = talib.EMA(prices, timeperiod=time_period)\n\treturn ma\n\n", "description": "\n\t\u4f7f\u7528talib\u8ba1\u7b97ma\uff0c\u5373\u900f\u4f20talib.MA or talib.EMA\u8ba1\u7b97\u7ed3\u679c\n\t:param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n\t:param time_period: \u79fb\u52a8\u5e73\u5747\u7684N\u503c\uff0cint\n\t:param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5\n\t", "category": "math", "imports": ["from __future__ import division", "from __future__ import absolute_import", "from __future__ import print_function", "from collections import Iterable", "import matplotlib.pyplot as plt", "import pandas as pd", "from enum import Enum", "from .ABuNDBase import plot_from_order, g_calc_type, ECalcType", "from ..CoreBu.ABuPdHelper import pd_rolling_mean, pd_ewm_mean", "from ..CoreBu.ABuFixes import six", "from ..UtilBu.ABuDTUtil import catch_error", "\timport talib", "\"\"\"\u901a\u8fc7\u5728ABuNDBase\u4e2d\u5c1d\u8bd5import talib\u6765\u7edf\u4e00\u786e\u5b9a\u6307\u6807\u8ba1\u7b97\u65b9\u5f0f, \u5916\u90e8\u8ba1\u7b97\u53ea\u5e94\u8be5\u4f7f\u7528calc_ma\"\"\""]}, {"term": "def", "name": "_calc_ma_from_pd", "data": "def _calc_ma_from_pd(prices, time_period=10, from_calc=EMACalcType.E_MA_MA):\n\t\"\"\"\n\t\u901a\u8fc7pandas\u8ba1\u7b97ma\u6216\u8005ema\n\t:param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n\t:param time_period: \u79fb\u52a8\u5e73\u5747\u7684N\u503c\uff0cint\n\t:param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5\n\t\"\"\"\n\n\tif isinstance(prices, pd.Series):\n\t\tprices = prices.values\n\n\tif from_calc == EMACalcType.E_MA_MA:\n\t\tma = pd_rolling_mean(prices, window=time_period, min_periods=time_period)\n\telse:\n\t\tma = pd_ewm_mean(prices, span=time_period, min_periods=time_period)\n\treturn ma\n\n", "description": "\n\t\u901a\u8fc7pandas\u8ba1\u7b97ma\u6216\u8005ema\n\t:param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n\t:param time_period: \u79fb\u52a8\u5e73\u5747\u7684N\u503c\uff0cint\n\t:param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5\n\t", "category": "math", "imports": ["from __future__ import division", "from __future__ import absolute_import", "from __future__ import print_function", "from collections import Iterable", "import matplotlib.pyplot as plt", "import pandas as pd", "from enum import Enum", "from .ABuNDBase import plot_from_order, g_calc_type, ECalcType", "from ..CoreBu.ABuPdHelper import pd_rolling_mean, pd_ewm_mean", "from ..CoreBu.ABuFixes import six", "from ..UtilBu.ABuDTUtil import catch_error", "\timport talib", "\"\"\"\u901a\u8fc7\u5728ABuNDBase\u4e2d\u5c1d\u8bd5import talib\u6765\u7edf\u4e00\u786e\u5b9a\u6307\u6807\u8ba1\u7b97\u65b9\u5f0f, \u5916\u90e8\u8ba1\u7b97\u53ea\u5e94\u8be5\u4f7f\u7528calc_ma\"\"\""]}, {"term": "def", "name": "calc_ma_from_prices", "data": "def calc_ma_from_prices(prices, time_period=10, min_periods=None, from_calc=EMACalcType.E_MA_MA):\n\t\"\"\"\n\t\u901a\u8fc7pandas\u8ba1\u7b97ma\u6216\u8005ema, \u6dfb\u52a0min_periods\u53c2\u6570\n\t:param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n\t:param time_period: \u79fb\u52a8\u5e73\u5747\u7684N\u503c\uff0cint\n\t:param min_periods: int\uff0c\u9ed8\u8ba4None\u5219\u4f7f\u7528time_period\n\t:param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5\n\t\"\"\"\n\n\tif isinstance(prices, pd.Series):\n\t\tprices = prices.values\n\n\tmin_periods = time_period if min_periods is None else min_periods\n\tif from_calc == EMACalcType.E_MA_MA:\n\t\tma = pd_rolling_mean(prices, window=time_period, min_periods=min_periods)\n\telse:\n\t\tma = pd_ewm_mean(prices, span=time_period, min_periods=min_periods)\n\treturn ma\n\n", "description": "\n\t\u901a\u8fc7pandas\u8ba1\u7b97ma\u6216\u8005ema, \u6dfb\u52a0min_periods\u53c2\u6570\n\t:param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n\t:param time_period: \u79fb\u52a8\u5e73\u5747\u7684N\u503c\uff0cint\n\t:param min_periods: int\uff0c\u9ed8\u8ba4None\u5219\u4f7f\u7528time_period\n\t:param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u79fb\u52a8\u79fb\u52a8\u5e73\u5747\u4f7f\u7528\u7684\u65b9\u6cd5\n\t", "category": "math", "imports": ["from __future__ import division", "from __future__ import absolute_import", "from __future__ import print_function", "from collections import Iterable", "import matplotlib.pyplot as plt", "import pandas as pd", "from enum import Enum", "from .ABuNDBase import plot_from_order, g_calc_type, ECalcType", "from ..CoreBu.ABuPdHelper import pd_rolling_mean, pd_ewm_mean", "from ..CoreBu.ABuFixes import six", "from ..UtilBu.ABuDTUtil import catch_error", "\timport talib", "\"\"\"\u901a\u8fc7\u5728ABuNDBase\u4e2d\u5c1d\u8bd5import talib\u6765\u7edf\u4e00\u786e\u5b9a\u6307\u6807\u8ba1\u7b97\u65b9\u5f0f, \u5916\u90e8\u8ba1\u7b97\u53ea\u5e94\u8be5\u4f7f\u7528calc_ma\"\"\""]}, {"term": "def", "name": "plot_ma_from_order", "data": "def plot_ma_from_order(order, date_ext=120, **kwargs):\n\t\"\"\"\n\t\u5c01\u88c5ABuNDBase\u4e2d\u7684plot_from_order\u4e0e\u6a21\u5757\u4e2d\u7ed8\u5236\u6280\u672f\u6307\u6807\u7684\u51fd\u6570\uff0c\u5b8c\u6210\u6280\u672f\u6307\u6807\u53ef\u89c6\u5316\u53ca\u6807\u6ce8\u4e70\u5165\u5356\u51fa\u70b9\u4f4d\n\t:param order: AbuOrder\u5bf9\u8c61\u8f6c\u6362\u7684pd.DataFrame\u5bf9\u8c61or pd.Series\u5bf9\u8c61\n\t:param date_ext: int\u5bf9\u8c61 eg. \u5982\u4ea4\u6613\u57282015-06-01\u6267\u884c\uff0c\u5982date_ext\uff1d120\uff0c\u62e9start\u5411\u524d\u63a8120\u5929\uff0cend\u5411\u540e\u63a8120\u5929\n\t:param kwargs: \u7ed8\u5236\u6280\u672f\u6307\u6807\u9700\u8981\u7684\u5176\u5b83\u5173\u952e\u5b57\u53c2\u6570\uff0ctime_period\uff0cfrom_calc, with_price\uff0c\u6700\u7ec8\u900f\u4f20\u7ed9plot_ma\n\t\"\"\"\n\treturn plot_from_order(plot_ma_from_klpd, order, date_ext, **kwargs)\n\n", "description": "\n\t\u5c01\u88c5ABuNDBase\u4e2d\u7684plot_from_order\u4e0e\u6a21\u5757\u4e2d\u7ed8\u5236\u6280\u672f\u6307\u6807\u7684\u51fd\u6570\uff0c\u5b8c\u6210\u6280\u672f\u6307\u6807\u53ef\u89c6\u5316\u53ca\u6807\u6ce8\u4e70\u5165\u5356\u51fa\u70b9\u4f4d\n\t:param order: AbuOrder\u5bf9\u8c61\u8f6c\u6362\u7684pd.DataFrame\u5bf9\u8c61or pd.Series\u5bf9\u8c61\n\t:param date_ext: int\u5bf9\u8c61 eg. \u5982\u4ea4\u6613\u57282015-06-01\u6267\u884c\uff0c\u5982date_ext\uff1d120\uff0c\u62e9start\u5411\u524d\u63a8120\u5929\uff0cend\u5411\u540e\u63a8120\u5929\n\t:param kwargs: \u7ed8\u5236\u6280\u672f\u6307\u6807\u9700\u8981\u7684\u5176\u5b83\u5173\u952e\u5b57\u53c2\u6570\uff0ctime_period\uff0cfrom_calc, with_price\uff0c\u6700\u7ec8\u900f\u4f20\u7ed9plot_ma\n\t", "category": "math", "imports": ["from __future__ import division", "from __future__ import absolute_import", "from __future__ import print_function", "from collections import Iterable", "import matplotlib.pyplot as plt", "import pandas as pd", "from enum import Enum", "from .ABuNDBase import plot_from_order, g_calc_type, ECalcType", "from ..CoreBu.ABuPdHelper import pd_rolling_mean, pd_ewm_mean", "from ..CoreBu.ABuFixes import six", "from ..UtilBu.ABuDTUtil import catch_error", "\timport talib", "\"\"\"\u901a\u8fc7\u5728ABuNDBase\u4e2d\u5c1d\u8bd5import talib\u6765\u7edf\u4e00\u786e\u5b9a\u6307\u6807\u8ba1\u7b97\u65b9\u5f0f, \u5916\u90e8\u8ba1\u7b97\u53ea\u5e94\u8be5\u4f7f\u7528calc_ma\"\"\""]}, {"term": "def", "name": "plot_ma_from_klpd", "data": "def plot_ma_from_klpd(kl_pd, with_points=None, with_points_ext=None, **kwargs):\n\t\"\"\"\n\t\u5c01\u88c5plot_ma\uff0c\u7ed8\u5236\u6536\u76d8\u4ef7\u683c\uff0c\u4ee5\u53ca\u591a\u6761\u79fb\u52a8\u5747\u7ebf\n\t:param kl_pd: \u91d1\u878d\u65f6\u95f4\u5e8f\u5217\uff0cpd.DataFrame\u5bf9\u8c61\n\t:param with_points: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u4e70\u5165order, with_points=buy_index=pd.to_datetime(orders['buy_date']))\n\t:param with_points_ext: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u5356\u51faorder, with_points_ext=sell_index=pd.to_datetime(orders['sell_date']))\n\t:param kwargs: \u7ed8\u5236\u6280\u672f\u6307\u6807\u9700\u8981\u7684\u5176\u5b83\u5173\u952e\u5b57\u53c2\u6570\uff0ctime_period\uff0cfrom_calc, with_price\uff0c\u6700\u7ec8\u900f\u4f20\u7ed9plot_ma\n\t\"\"\"\n\n\t# \u5982\u679c\u5916\u90e8\u4e0d\u8bbe\u7f6e\u5747\u7ebf\uff0c\u8fd9\u91ccpop\u7684default\u4e3a[30, 60, 90]\n\ttime_period = kwargs.pop('time_period', [30, 60, 90])\n\tplot_ma(kl_pd.close, kl_pd.index, time_period, with_points=with_points,\n\t\t\twith_points_ext=with_points_ext)\n\n", "description": "\n\t\u5c01\u88c5plot_ma\uff0c\u7ed8\u5236\u6536\u76d8\u4ef7\u683c\uff0c\u4ee5\u53ca\u591a\u6761\u79fb\u52a8\u5747\u7ebf\n\t:param kl_pd: \u91d1\u878d\u65f6\u95f4\u5e8f\u5217\uff0cpd.DataFrame\u5bf9\u8c61\n\t:param with_points: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u4e70\u5165order, with_points=buy_index=pd.to_datetime(orders['buy_date']))\n\t:param with_points_ext: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u5356\u51faorder, with_points_ext=sell_index=pd.to_datetime(orders['sell_date']))\n\t:param kwargs: \u7ed8\u5236\u6280\u672f\u6307\u6807\u9700\u8981\u7684\u5176\u5b83\u5173\u952e\u5b57\u53c2\u6570\uff0ctime_period\uff0cfrom_calc, with_price\uff0c\u6700\u7ec8\u900f\u4f20\u7ed9plot_ma\n\t", "category": "math", "imports": ["from __future__ import division", "from __future__ import absolute_import", "from __future__ import print_function", "from collections import Iterable", "import matplotlib.pyplot as plt", "import pandas as pd", "from enum import Enum", "from .ABuNDBase import plot_from_order, g_calc_type, ECalcType", "from ..CoreBu.ABuPdHelper import pd_rolling_mean, pd_ewm_mean", "from ..CoreBu.ABuFixes import six", "from ..UtilBu.ABuDTUtil import catch_error", "\timport talib", "\"\"\"\u901a\u8fc7\u5728ABuNDBase\u4e2d\u5c1d\u8bd5import talib\u6765\u7edf\u4e00\u786e\u5b9a\u6307\u6807\u8ba1\u7b97\u65b9\u5f0f, \u5916\u90e8\u8ba1\u7b97\u53ea\u5e94\u8be5\u4f7f\u7528calc_ma\"\"\""]}, {"term": "def", "name": "plot_ma", "data": "def plot_ma(prices, kl_index, time_period, from_calc=EMACalcType.E_MA_MA,\n\t\t\twith_points=None, with_points_ext=None, with_price=True):\n\t\"\"\"\n\t\u4e00\u4e2a\u753b\u5e03\u4e0a\uff0c\u7ed8\u5236\u4ef7\u683c\u66f2\u7ebf\u4ee5\u53ca\u591a\u6761\u79fb\u52a8\u5e73\u5747\u7ebf\uff0c\u5982\u679c\u6709with_points\u70b9\u4f4d\u6807\u6ce8\uff0c\u4f7f\u7528\u7ad6\u7ebf\u6807\u6ce8\n\t:param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n\t:param kl_index: pd.Index\u65f6\u95f4\u5e8f\u5217\n\t:param time_period: \u6ce8\u610f\u662fIterable\u7c7b\u578b\uff0c\u9700\u8981\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u5373\u4f7f\u4e00\u4e2a\u5143\u7d20\u4e5f\u8981\u4f7f\u7528\u5982[10]\u5305\u88f9\n\t:param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u9ed8\u8ba4\u4f7f\u7528\u7b80\u5355\u79fb\u52a8\u5e73\u5747\u7ebf\n\t:param with_points: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u4e70\u5165order, with_points=buy_index=pd.to_datetime(orders['buy_date']))\n\t:param with_points_ext: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u5356\u51faorder, with_points_ext=sell_index=pd.to_datetime(orders['sell_date']))\n\t:param with_price:  \u5c06\u4ef7\u683c\u4e00\u8d77\u7ed8\u5236\n\t:return:\n\t\"\"\"\n\t# TODO Iterable\u548csix.string_types\u7684\u5224\u65ad\u62bd\u51fa\u6765\u653e\u5728\u4e00\u4e2a\u6a21\u5757\uff0c\u505a\u4e3aIterable\u7684\u5224\u65ad\u6765\u4f7f\u7528\n\tif not isinstance(time_period, Iterable) or isinstance(time_period, six.string_types):\n\t\traise TypeError('MA CALC time_period MUST PASS Iterable!!!')\n\n\tcalc_type_func = calc_ma\n\t# \u8fed\u4ee3\u8ba1\u7b97\u591a\u6761\u79fb\u52a8\u5747\u7ebf\uff0c\u4f7f\u7528from_calc\u4f7f\u7528\u7684\u65b9\u6cd5\u8ba1\u7b97\n\tma_array = [calc_type_func(prices, period, from_calc) for period in time_period]\n\n\tplt.figure(figsize=[14, 7])\n\n\tfor ind, ma in enumerate(ma_array):\n\t\t# ind\u7684\u4f5c\u7528\u662f\u7d22\u5f15\u5728\u539f\u59cbtime_period\u4e2d\u5bf9\u5e94label\u9700\u8981\u7684\u540d\u79f0\n\t\t# noinspection PyUnresolvedReferences\n\t\tplt.plot(kl_index, ma, label='ma {}'.format(time_period[ind]))\n\n\tif with_price:\n\t\tplt.plot(kl_index, prices, label='prices')\n\n\t@catch_error(return_val=None, log=False)\n\tdef plot_with_point(points, co, cc):\n\t\t\"\"\"\n\t\t\u70b9\u4f4d\u4f7f\u7528\u5706\u70b9\uff0b\u7ad6\u7ebf\u8fdb\u884c\u6807\u6ce8\n\t\t:param points: \u70b9\u4f4d\u5750\u6807\u5e8f\u5217\n\t\t:param co: \u70b9\u989c\u8272 eg. 'go' 'ro'\n\t\t:param cc: markeredgecolor\u548c\u7ad6\u7ebfaxvline\u989c\u8272 eg. 'green' 'red'\n\t\t\"\"\"\n\t\tv_index_num = kl_index.tolist().index(points)\n\t\t# \u5982\u679c\u6709ma\u7ebf\uff0cy\u70b9\u505a\u76ee\u6807\u753b\u5728\u7b2c\u4e00\u6839ma\u7ebf\u4e0a\u5426\u5219\u753b\u5728\u4ef7\u683c\u4e0a\u9762\n\t\ty_array = ma_array[0] if len(ma_array) > 0 else prices\n\t\tplt.plot(points, y_array[v_index_num], co, markersize=12, markeredgewidth=3.0,\n\t\t\t\t markerfacecolor='None', markeredgecolor=cc)\n\t\tplt.axvline(points, color=cc)\n\n\t# with_points\u548cwith_points_ext\u7684\u70b9\u4f4d\u4f7f\u7528\u7ad6\u7ebf\u6807\u6ce8\n\tif with_points is not None:\n\t\t# plt.axvline(with_points, color='green', linestyle='--')\n\t\tplot_with_point(with_points, 'go', 'green')\n\n\tif with_points_ext is not None:\n\t\t# plt.axvline(with_points_ext, color='red')\n\t\tplot_with_point(with_points_ext, 'ro', 'red')\n\n\tplt.grid(True)\n\tplt.legend(loc='best')\n\tplt.show()\n", "description": "\n\t\u4e00\u4e2a\u753b\u5e03\u4e0a\uff0c\u7ed8\u5236\u4ef7\u683c\u66f2\u7ebf\u4ee5\u53ca\u591a\u6761\u79fb\u52a8\u5e73\u5747\u7ebf\uff0c\u5982\u679c\u6709with_points\u70b9\u4f4d\u6807\u6ce8\uff0c\u4f7f\u7528\u7ad6\u7ebf\u6807\u6ce8\n\t:param prices: \u6536\u76d8\u4ef7\u683c\u5e8f\u5217\uff0cpd.Series\u6216\u8005np.array\n\t:param kl_index: pd.Index\u65f6\u95f4\u5e8f\u5217\n\t:param time_period: \u6ce8\u610f\u662fIterable\u7c7b\u578b\uff0c\u9700\u8981\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff0c\u5373\u4f7f\u4e00\u4e2a\u5143\u7d20\u4e5f\u8981\u4f7f\u7528\u5982[10]\u5305\u88f9\n\t:param from_calc: EMACalcType enum\u5bf9\u8c61\uff0c\u9ed8\u8ba4\u4f7f\u7528\u7b80\u5355\u79fb\u52a8\u5e73\u5747\u7ebf\n\t:param with_points: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u4e70\u5165order, with_points=buy_index=pd.to_datetime(orders['buy_date']))\n\t:param with_points_ext: \u8fd9\u91cc\u7684\u5e38\u89c4\u7528\u9014\u662f\u4f20\u5165\u5356\u51faorder, with_points_ext=sell_index=pd.to_datetime(orders['sell_date']))\n\t:param with_price:  \u5c06\u4ef7\u683c\u4e00\u8d77\u7ed8\u5236\n\t:return:\n\t", "category": "math", "imports": ["from __future__ import division", "from __future__ import absolute_import", "from __future__ import print_function", "from collections import Iterable", "import matplotlib.pyplot as plt", "import pandas as pd", "from enum import Enum", "from .ABuNDBase import plot_from_order, g_calc_type, ECalcType", "from ..CoreBu.ABuPdHelper import pd_rolling_mean, pd_ewm_mean", "from ..CoreBu.ABuFixes import six", "from ..UtilBu.ABuDTUtil import catch_error", "\timport talib", "\"\"\"\u901a\u8fc7\u5728ABuNDBase\u4e2d\u5c1d\u8bd5import talib\u6765\u7edf\u4e00\u786e\u5b9a\u6307\u6807\u8ba1\u7b97\u65b9\u5f0f, \u5916\u90e8\u8ba1\u7b97\u53ea\u5e94\u8be5\u4f7f\u7528calc_ma\"\"\""]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "class", "name": "classDepthFirstSearchPlanner:", "data": "class DepthFirstSearchPlanner:\n\n\tdef __init__(self, ox, oy, reso, rr):\n\t\t\"\"\"\n\t\tInitialize grid map for Depth-First planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t\"\"\"\n\n\t\tself.reso = reso\n\t\tself.rr = rr\n\t\tself.calc_obstacle_map(ox, oy)\n\t\tself.motion = self.get_motion_model()\n\n\tclass Node:\n\t\tdef __init__(self, x, y, cost, parent_index, parent):\n\t\t\tself.x = x  # index of grid\n\t\t\tself.y = y  # index of grid\n\t\t\tself.cost = cost\n\t\t\tself.parent_index = parent_index\n\t\t\tself.parent = parent\n\n\t\tdef __str__(self):\n\t\t\treturn str(self.x) + \",\" + str(self.y) + \",\" + str(\n\t\t\t\tself.cost) + \",\" + str(self.parent_index)\n\n\tdef planning(self, sx, sy, gx, gy):\n\t\t\"\"\"\n\t\tDepth First search\n\n\t\tinput:\n\t\t\ts_x: start x position [m]\n\t\t\ts_y: start y position [m]\n\t\t\tgx: goal x position [m]\n\t\t\tgy: goal y position [m]\n\n\t\toutput:\n\t\t\trx: x position list of the final path\n\t\t\try: y position list of the final path\n\t\t\"\"\"\n\n\t\tnstart = self.Node(self.calc_xyindex(sx, self.minx),\n\t\t\t\t\t\t   self.calc_xyindex(sy, self.miny), 0.0, -1, None)\n\t\tngoal = self.Node(self.calc_xyindex(gx, self.minx),\n\t\t\t\t\t\t  self.calc_xyindex(gy, self.miny), 0.0, -1, None)\n\n\t\topen_set, closed_set = dict(), dict()\n\t\topen_set[self.calc_grid_index(nstart)] = nstart\n\n\t\twhile 1:\n\t\t\tif len(open_set) == 0:\n\t\t\t\tprint(\"Open set is empty..\")\n\t\t\t\tbreak\n\n\t\t\tcurrent = open_set.pop(list(open_set.keys())[-1])\n\t\t\tc_id = self.calc_grid_index(current)\n\n\t\t\t# show graph\n\t\t\tif show_animation:  # pragma: no cover\n\t\t\t\tplt.plot(self.calc_grid_position(current.x, self.minx),\n\t\t\t\t\t\t self.calc_grid_position(current.y, self.miny), \"xc\")\n\t\t\t\t# for stopping simulation with the esc key.\n\t\t\t\tplt.gcf().canvas.mpl_connect('key_release_event',\n\t\t\t\t\t\t\t\t\t\t\t lambda event:\n\t\t\t\t\t\t\t\t\t\t\t [exit(0) if event.key == 'escape'\n\t\t\t\t\t\t\t\t\t\t\t  else None])\n\t\t\t\tplt.pause(0.01)\n\n\t\t\tif current.x == ngoal.x and current.y == ngoal.y:\n\t\t\t\tprint(\"Find goal\")\n\t\t\t\tngoal.parent_index = current.parent_index\n\t\t\t\tngoal.cost = current.cost\n\t\t\t\tbreak\n\n\t\t\t# expand_grid search grid based on motion model\n\t\t\tfor i, _ in enumerate(self.motion):\n\t\t\t\tnode = self.Node(current.x + self.motion[i][0],\n\t\t\t\t\t\t\t\t current.y + self.motion[i][1],\n\t\t\t\t\t\t\t\t current.cost + self.motion[i][2], c_id, None)\n\t\t\t\tn_id = self.calc_grid_index(node)\n\n\t\t\t\t# If the node is not safe, do nothing\n\t\t\t\tif not self.verify_node(node):\n\t\t\t\t\tcontinue\n\n\t\t\t\tif n_id not in closed_set:\n\t\t\t\t\topen_set[n_id] = node\n\t\t\t\t\tclosed_set[n_id] = node\n\t\t\t\t\tnode.parent = current\n\n\t\trx, ry = self.calc_final_path(ngoal, closed_set)\n\t\treturn rx, ry\n\n\tdef calc_final_path(self, ngoal, closedset):\n\t\t# generate final course\n\t\trx, ry = [self.calc_grid_position(ngoal.x, self.minx)], [\n\t\t\tself.calc_grid_position(ngoal.y, self.miny)]\n\t\tn = closedset[ngoal.parent_index]\n\t\twhile n is not None:\n\t\t\trx.append(self.calc_grid_position(n.x, self.minx))\n\t\t\try.append(self.calc_grid_position(n.y, self.miny))\n\t\t\tn = n.parent\n\n\t\treturn rx, ry\n\n\tdef calc_grid_position(self, index, minp):\n\t\t\"\"\"\n\t\tcalc grid position\n\n\t\t:param index:\n\t\t:param minp:\n\t\t:return:\n\t\t\"\"\"\n\t\tpos = index * self.reso + minp\n\t\treturn pos\n\n\tdef calc_xyindex(self, position, min_pos):\n\t\treturn round((position - min_pos) / self.reso)\n\n\tdef calc_grid_index(self, node):\n\t\treturn (node.y - self.miny) * self.xwidth + (node.x - self.minx)\n\n\tdef verify_node(self, node):\n\t\tpx = self.calc_grid_position(node.x, self.minx)\n\t\tpy = self.calc_grid_position(node.y, self.miny)\n\n\t\tif px < self.minx:\n\t\t\treturn False\n\t\telif py < self.miny:\n\t\t\treturn False\n\t\telif px >= self.maxx:\n\t\t\treturn False\n\t\telif py >= self.maxy:\n\t\t\treturn False\n\n\t\t# collision check\n\t\tif self.obmap[node.x][node.y]:\n\t\t\treturn False\n\n\t\treturn True\n\n\tdef calc_obstacle_map(self, ox, oy):\n\n\t\tself.minx = round(min(ox))\n\t\tself.miny = round(min(oy))\n\t\tself.maxx = round(max(ox))\n\t\tself.maxy = round(max(oy))\n\t\tprint(\"min_x:\", self.minx)\n\t\tprint(\"min_y:\", self.miny)\n\t\tprint(\"max_x:\", self.maxx)\n\t\tprint(\"max_y:\", self.maxy)\n\n\t\tself.xwidth = round((self.maxx - self.minx) / self.reso)\n\t\tself.ywidth = round((self.maxy - self.miny) / self.reso)\n\t\tprint(\"x_width:\", self.xwidth)\n\t\tprint(\"y_width:\", self.ywidth)\n\n\t\t# obstacle map generation\n\t\tself.obmap = [[False for _ in range(self.ywidth)]\n\t\t\t\t\t  for _ in range(self.xwidth)]\n\t\tfor ix in range(self.xwidth):\n\t\t\tx = self.calc_grid_position(ix, self.minx)\n\t\t\tfor iy in range(self.ywidth):\n\t\t\t\ty = self.calc_grid_position(iy, self.miny)\n\t\t\t\tfor iox, ioy in zip(ox, oy):\n\t\t\t\t\td = math.hypot(iox - x, ioy - y)\n\t\t\t\t\tif d <= self.rr:\n\t\t\t\t\t\tself.obmap[ix][iy] = True\n\t\t\t\t\t\tbreak\n\n\t@staticmethod\n\tdef get_motion_model():\n\t\t# dx, dy, cost\n\t\tmotion = [[1, 0, 1],\n\t\t\t\t  [0, 1, 1],\n\t\t\t\t  [-1, 0, 1],\n\t\t\t\t  [0, -1, 1],\n\t\t\t\t  [-1, -1, math.sqrt(2)],\n\t\t\t\t  [-1, 1, math.sqrt(2)],\n\t\t\t\t  [1, -1, math.sqrt(2)],\n\t\t\t\t  [1, 1, math.sqrt(2)]]\n\n\t\treturn motion\n\n", "description": "\n\t\tInitialize grid map for Depth-First planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t", "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():\n\tprint(__file__ + \" start!!\")\n\n\t# start and goal position\n\tsx = 10.0  # [m]\n\tsy = 10.0  # [m]\n\tgx = 50.0  # [m]\n\tgy = 50.0  # [m]\n\tgrid_size = 2.0  # [m]\n\trobot_radius = 1.0  # [m]\n\n\t# set obstacle positions\n\tox, oy = [], []\n\tfor i in range(-10, 60):\n\t\tox.append(i)\n\t\toy.append(-10.0)\n\tfor i in range(-10, 60):\n\t\tox.append(60.0)\n\t\toy.append(i)\n\tfor i in range(-10, 61):\n\t\tox.append(i)\n\t\toy.append(60.0)\n\tfor i in range(-10, 61):\n\t\tox.append(-10.0)\n\t\toy.append(i)\n\tfor i in range(-10, 40):\n\t\tox.append(20.0)\n\t\toy.append(i)\n\tfor i in range(0, 40):\n\t\tox.append(40.0)\n\t\toy.append(60.0 - i)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(ox, oy, \".k\")\n\t\tplt.plot(sx, sy, \"og\")\n\t\tplt.plot(gx, gy, \"xb\")\n\t\tplt.grid(True)\n\t\tplt.axis(\"equal\")\n\n\tdfs = DepthFirstSearchPlanner(ox, oy, grid_size, robot_radius)\n\trx, ry = dfs.planning(sx, sy, gx, gy)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(rx, ry, \"-r\")\n\t\tplt.pause(0.01)\n\t\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}], [{"term": "class", "name": "classBreadthFirstSearchPlanner:", "data": "class BreadthFirstSearchPlanner:\n\n\tdef __init__(self, ox, oy, reso, rr):\n\t\t\"\"\"\n\t\tInitialize grid map for bfs planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t\"\"\"\n\n\t\tself.reso = reso\n\t\tself.rr = rr\n\t\tself.calc_obstacle_map(ox, oy)\n\t\tself.motion = self.get_motion_model()\n\n\tclass Node:\n\t\tdef __init__(self, x, y, cost, parent_index, parent):\n\t\t\tself.x = x  # index of grid\n\t\t\tself.y = y  # index of grid\n\t\t\tself.cost = cost\n\t\t\tself.parent_index = parent_index\n\t\t\tself.parent = parent\n\n\t\tdef __str__(self):\n\t\t\treturn str(self.x) + \",\" + str(self.y) + \",\" + str(\n\t\t\t\tself.cost) + \",\" + str(self.parent_index)\n\n\tdef planning(self, sx, sy, gx, gy):\n\t\t\"\"\"\n\t\tBreadth First search based planning\n\n\t\tinput:\n\t\t\ts_x: start x position [m]\n\t\t\ts_y: start y position [m]\n\t\t\tgx: goal x position [m]\n\t\t\tgy: goal y position [m]\n\n\t\toutput:\n\t\t\trx: x position list of the final path\n\t\t\try: y position list of the final path\n\t\t\"\"\"\n\n\t\tnstart = self.Node(self.calc_xyindex(sx, self.minx),\n\t\t\t\t\t\t   self.calc_xyindex(sy, self.miny), 0.0, -1, None)\n\t\tngoal = self.Node(self.calc_xyindex(gx, self.minx),\n\t\t\t\t\t\t  self.calc_xyindex(gy, self.miny), 0.0, -1, None)\n\n\t\topen_set, closed_set = dict(), dict()\n\t\topen_set[self.calc_grid_index(nstart)] = nstart\n\n\t\twhile 1:\n\t\t\tif len(open_set) == 0:\n\t\t\t\tprint(\"Open set is empty..\")\n\t\t\t\tbreak\n\n\t\t\tcurrent = open_set.pop(list(open_set.keys())[0])\n\n\t\t\tc_id = self.calc_grid_index(current)\n\n\t\t\tclosed_set[c_id] = current\n\n\t\t\t# show graph\n\t\t\tif show_animation:  # pragma: no cover\n\t\t\t\tplt.plot(self.calc_grid_position(current.x, self.minx),\n\t\t\t\t\t\t self.calc_grid_position(current.y, self.miny), \"xc\")\n\t\t\t\t# for stopping simulation with the esc key.\n\t\t\t\tplt.gcf().canvas.mpl_connect('key_release_event',\n\t\t\t\t\t\t\t\t\t\t\t lambda event:\n\t\t\t\t\t\t\t\t\t\t\t [exit(0) if event.key == 'escape'\n\t\t\t\t\t\t\t\t\t\t\t  else None])\n\t\t\t\tif len(closed_set.keys()) % 10 == 0:\n\t\t\t\t\tplt.pause(0.001)\n\n\t\t\tif current.x == ngoal.x and current.y == ngoal.y:\n\t\t\t\tprint(\"Find goal\")\n\t\t\t\tngoal.parent_index = current.parent_index\n\t\t\t\tngoal.cost = current.cost\n\t\t\t\tbreak\n\n\t\t\t# expand_grid search grid based on motion model\n\t\t\tfor i, _ in enumerate(self.motion):\n\t\t\t\tnode = self.Node(current.x + self.motion[i][0],\n\t\t\t\t\t\t\t\t current.y + self.motion[i][1],\n\t\t\t\t\t\t\t\t current.cost + self.motion[i][2], c_id, None)\n\t\t\t\tn_id = self.calc_grid_index(node)\n\n\t\t\t\t# If the node is not safe, do nothing\n\t\t\t\tif not self.verify_node(node):\n\t\t\t\t\tcontinue\n\n\t\t\t\tif (n_id not in closed_set) and (n_id not in open_set):\n\t\t\t\t\tnode.parent = current\n\t\t\t\t\topen_set[n_id] = node\n\n\t\trx, ry = self.calc_final_path(ngoal, closed_set)\n\t\treturn rx, ry\n\n\tdef calc_final_path(self, ngoal, closedset):\n\t\t# generate final course\n\t\trx, ry = [self.calc_grid_position(ngoal.x, self.minx)], [\n\t\t\tself.calc_grid_position(ngoal.y, self.miny)]\n\t\tn = closedset[ngoal.parent_index]\n\t\twhile n is not None:\n\t\t\trx.append(self.calc_grid_position(n.x, self.minx))\n\t\t\try.append(self.calc_grid_position(n.y, self.miny))\n\t\t\tn = n.parent\n\n\t\treturn rx, ry\n\n\tdef calc_grid_position(self, index, minp):\n\t\t\"\"\"\n\t\tcalc grid position\n\n\t\t:param index:\n\t\t:param minp:\n\t\t:return:\n\t\t\"\"\"\n\t\tpos = index * self.reso + minp\n\t\treturn pos\n\n\tdef calc_xyindex(self, position, min_pos):\n\t\treturn round((position - min_pos) / self.reso)\n\n\tdef calc_grid_index(self, node):\n\t\treturn (node.y - self.miny) * self.xwidth + (node.x - self.minx)\n\n\tdef verify_node(self, node):\n\t\tpx = self.calc_grid_position(node.x, self.minx)\n\t\tpy = self.calc_grid_position(node.y, self.miny)\n\n\t\tif px < self.minx:\n\t\t\treturn False\n\t\telif py < self.miny:\n\t\t\treturn False\n\t\telif px >= self.maxx:\n\t\t\treturn False\n\t\telif py >= self.maxy:\n\t\t\treturn False\n\n\t\t# collision check\n\t\tif self.obmap[node.x][node.y]:\n\t\t\treturn False\n\n\t\treturn True\n\n\tdef calc_obstacle_map(self, ox, oy):\n\n\t\tself.minx = round(min(ox))\n\t\tself.miny = round(min(oy))\n\t\tself.maxx = round(max(ox))\n\t\tself.maxy = round(max(oy))\n\t\tprint(\"min_x:\", self.minx)\n\t\tprint(\"min_y:\", self.miny)\n\t\tprint(\"max_x:\", self.maxx)\n\t\tprint(\"max_y:\", self.maxy)\n\n\t\tself.xwidth = round((self.maxx - self.minx) / self.reso)\n\t\tself.ywidth = round((self.maxy - self.miny) / self.reso)\n\t\tprint(\"x_width:\", self.xwidth)\n\t\tprint(\"y_width:\", self.ywidth)\n\n\t\t# obstacle map generation\n\t\tself.obmap = [[False for _ in range(self.ywidth)]\n\t\t\t\t\t  for _ in range(self.xwidth)]\n\t\tfor ix in range(self.xwidth):\n\t\t\tx = self.calc_grid_position(ix, self.minx)\n\t\t\tfor iy in range(self.ywidth):\n\t\t\t\ty = self.calc_grid_position(iy, self.miny)\n\t\t\t\tfor iox, ioy in zip(ox, oy):\n\t\t\t\t\td = math.hypot(iox - x, ioy - y)\n\t\t\t\t\tif d <= self.rr:\n\t\t\t\t\t\tself.obmap[ix][iy] = True\n\t\t\t\t\t\tbreak\n\n\t@staticmethod\n\tdef get_motion_model():\n\t\t# dx, dy, cost\n\t\tmotion = [[1, 0, 1],\n\t\t\t\t  [0, 1, 1],\n\t\t\t\t  [-1, 0, 1],\n\t\t\t\t  [0, -1, 1],\n\t\t\t\t  [-1, -1, math.sqrt(2)],\n\t\t\t\t  [-1, 1, math.sqrt(2)],\n\t\t\t\t  [1, -1, math.sqrt(2)],\n\t\t\t\t  [1, 1, math.sqrt(2)]]\n\n\t\treturn motion\n\n", "description": "\n\t\tInitialize grid map for bfs planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t", "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():\n\tprint(__file__ + \" start!!\")\n\n\t# start and goal position\n\tsx = 10.0  # [m]\n\tsy = 10.0  # [m]\n\tgx = 50.0  # [m]\n\tgy = 50.0  # [m]\n\tgrid_size = 2.0  # [m]\n\trobot_radius = 1.0  # [m]\n\n\t# set obstacle positions\n\tox, oy = [], []\n\tfor i in range(-10, 60):\n\t\tox.append(i)\n\t\toy.append(-10.0)\n\tfor i in range(-10, 60):\n\t\tox.append(60.0)\n\t\toy.append(i)\n\tfor i in range(-10, 61):\n\t\tox.append(i)\n\t\toy.append(60.0)\n\tfor i in range(-10, 61):\n\t\tox.append(-10.0)\n\t\toy.append(i)\n\tfor i in range(-10, 40):\n\t\tox.append(20.0)\n\t\toy.append(i)\n\tfor i in range(0, 40):\n\t\tox.append(40.0)\n\t\toy.append(60.0 - i)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(ox, oy, \".k\")\n\t\tplt.plot(sx, sy, \"og\")\n\t\tplt.plot(gx, gy, \"xb\")\n\t\tplt.grid(True)\n\t\tplt.axis(\"equal\")\n\n\tbfs = BreadthFirstSearchPlanner(ox, oy, grid_size, robot_radius)\n\trx, ry = bfs.planning(sx, sy, gx, gy)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(rx, ry, \"-r\")\n\t\tplt.pause(0.01)\n\t\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}], [{"term": "def", "name": "test_permitted_operators", "data": "def test_permitted_operators():\n\t\"\"\"\n\ttest for permitted operators\n\t\"\"\"\n\tassert calc.permitted_operators() == ['+', '-', '*', '/']\n\n", "description": "\n\ttest for permitted operators\n\t", "category": "math", "imports": ["import calc"]}, {"term": "def", "name": "test_permitted_symbols", "data": "def test_permitted_symbols():\n\t\"\"\"\n\ttest for permitted symbols\n\t\"\"\"\n\tassert calc.permitted_symbols() == ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n", "description": "\n\ttest for permitted symbols\n\t", "category": "math", "imports": ["import calc"]}, {"term": "def", "name": "test_is_operator", "data": "def test_is_operator():\n\t\"\"\"\n\ttest for operator checker\n\t\"\"\"\n\tassert calc.is_operator('+')\n\tassert calc.is_operator('-')\n\tassert calc.is_operator('*')\n\tassert calc.is_operator('/')\n\tassert not calc.is_operator('9')\n\tassert not calc.is_operator('&')\n\tassert not calc.is_operator('(')\n\tassert not calc.is_operator(')')\n\tassert not calc.is_operator('a')\n\tassert not calc.is_operator('//')\n\tassert not calc.is_operator('95')\n\tassert not calc.is_operator('&^()')\n\n", "description": "\n\ttest for operator checker\n\t", "category": "math", "imports": ["import calc"]}, {"term": "def", "name": "test_is_symbol_permitted_equation", "data": "def test_is_symbol_permitted_equation():\n\t\"\"\"\n\ttest for permitted symbol checker\n\t\"\"\"\n\tassert calc.is_symbol_permitted_equation('+')\n\tassert calc.is_symbol_permitted_equation('-')\n\tassert calc.is_symbol_permitted_equation('*')\n\tassert calc.is_symbol_permitted_equation('/')\n\tassert calc.is_symbol_permitted_equation('9')\n\tassert calc.is_symbol_permitted_equation('95')\n\tassert calc.is_symbol_permitted_equation('9+5')\n\tassert not calc.is_symbol_permitted_equation('%')\n\tassert not calc.is_symbol_permitted_equation('&')\n\tassert not calc.is_symbol_permitted_equation('(')\n\tassert not calc.is_symbol_permitted_equation(')')\n\tassert not calc.is_symbol_permitted_equation('a')\n\tassert not calc.is_symbol_permitted_equation('9a')\n\tassert calc.is_symbol_permitted_equation('//')\n\tassert calc.is_symbol_permitted_equation('9//5')\n\tassert not calc.is_symbol_permitted_equation('9&5')\n\tassert not calc.is_symbol_permitted_equation('&^()')\n\n", "description": "\n\ttest for permitted symbol checker\n\t", "category": "math", "imports": ["import calc"]}, {"term": "def", "name": "test_has_edge_operator", "data": "def test_has_edge_operator():\n\t\"\"\"\n\ttest for unwanted characters at the edges\n\t\"\"\"\n\tassert calc.has_edge_operator(\"+9\")\n\tassert calc.has_edge_operator(\"9+\")\n\tassert calc.has_edge_operator(\"+9+\")\n\tassert calc.has_edge_operator(\"+9+6\")\n\tassert calc.has_edge_operator(\"8+9+\")\n\tassert not calc.has_edge_operator(\"8+9+25\")\n\n", "description": "\n\ttest for unwanted characters at the edges\n\t", "category": "math", "imports": ["import calc"]}, {"term": "def", "name": "test_is_correct_sequence", "data": "def test_is_correct_sequence():\n\t\"\"\"\n\ttest for sequence checker\n\t\"\"\"\n\tassert calc.is_correct_sequence(\"8+9+25\")\n\tassert calc.is_correct_sequence(\"8+9-25/99*5\")\n\tassert not calc.is_correct_sequence(\"8+9++25\")\n\tassert not calc.is_correct_sequence(\"8+9+-25\")\n\tassert not calc.is_correct_sequence(\"8+9/-25\")\n\n", "description": "\n\ttest for sequence checker\n\t", "category": "math", "imports": ["import calc"]}, {"term": "def", "name": "test_calculate", "data": "def test_calculate():\n\t\"\"\"\n\ttests for calculator\n\t\"\"\"\n\tassert calc.calculate(\"\") == \"( Error: Please Enter the Equation in Correct Format )\"\n\tassert calc.calculate(\"10+5\") == str(15)\n\tassert calc.calculate(\"10-5\") == str(5)\n\tassert calc.calculate(\"10*3\") == str(30)\n\tassert calc.calculate(\"10/5\") == str(2)\n\tassert calc.calculate(\"10/3\") == str(3)\n\tassert calc.calculate(\"9/10\") == str(1)\n\tassert calc.calculate(\"10/4\") == str(3)\n\tassert calc.calculate(\"10/0\") == \"(Error: divide by 0)\"\n\tassert calc.calculate(\"10.4+3.5\") == \"( Error: Equation Contains Unpermitted Symbol )\"\n\tassert calc.calculate(\"abcd+efg\") == \"( Error: Equation Contains Unpermitted Symbol )\"\n\tassert calc.calculate(\"a10+3b\") == \"( Error: Equation Contains Unpermitted Symbol )\"\n\tassert calc.calculate(\"10++3\") == \"( Error: Please Enter the Equation in Correct Format )\"\n\tassert calc.calculate(\"-10+5\") == \"( Error: Please Enter the Equation in Correct Format )\"\n\tassert calc.calculate(\"1+5+1\") == str(7)\n\tassert calc.calculate(\"1+5+1-2\") == str(5)\n\tassert calc.calculate(\"3+10/3+13/3\") == str(11)\n\tassert calc.calculate(\"10/2*3\") == str(2)\n\tassert calc.calculate(\"10/2*3+3\") == str(5)\n\tassert calc.calculate(\"10/2*3+-3\") == \"( Error: Please Enter the Equation in Correct Format )\"\n\tassert calc.calculate(\"10/(2*3+3)\") == \"( Error: Equation Contains Unpermitted Symbol )\"\n\n\t# my tests:\n\tassert calc.calculate(\"+10\") == \"( Error: Please Enter the Equation in Correct Format )\"\n\tassert calc.calculate(\"10\") == str(10)\n\tassert calc.calculate(\"10-\") == \"( Error: Please Enter the Equation in Correct Format )\"\n\tassert calc.calculate(\"-10/3\") == \"( Error: Please Enter the Equation in Correct Format )\"\n\tassert calc.calculate(\"25/5++6\") == \"( Error: Please Enter the Equation in Correct Format )\"\n\tassert calc.calculate(\"23+26a-8501t\") == \"( Error: Equation Contains Unpermitted Symbol )\"\n\tassert calc.calculate(\"205+6-9/0\") == \"(Error: divide by 0)\"\n\tassert calc.calculate(\"39/16-21-20/0*22+9+32/28*33*2-8+36+40/40\") == \"(Error: divide by 0)\"\n\tassert calc.calculate(\"39/16-21-20/39*22+9+32/28*0*2-8+36+40/40\") == \"(Error: divide by 0)\"\n\tassert calc.calculate(\"39/16-21-20/39*22+9+32/28*55*0-8+36+40/40\") == \"(Error: divide by 0)\"\n\tassert calc.calculate(\"39/16-21-20/39*22+9+32/28*55*12-8+36+40/0\") == \"(Error: divide by 0)\"\n\tassert calc.calculate(\"10/3+10/3\") == str(7)\n\tassert calc.calculate(\"3+2\") == str(5)\n\tassert calc.calculate(\"3-2\") == str(1)\n\tassert calc.calculate(\"3*2\") == str(6)\n\tassert calc.calculate(\"3/2\") == str(2)\n\tassert calc.calculate(\"32-52\") == str(-20)\n\tassert calc.calculate(\"39/16-21-20/39*22+9+32/28*33*2-8+36+40/40\") == str(19)\n\tassert calc.calculate(\"2-39-37-26*21/9+37-14+25-30/29+23/22/30/12\") == str(-88)\n\tassert calc.calculate(\"16348-35509+12833/19037+13798-4346-25849*\" +\n\t\t\t\t\t\t  \"6087*11668-4769-9605+13934/26324/27774-20032\") == str(-1835876569598)\n\tassert calc.calculate(\"16348-35509+12833/19037+13798-4346-25849*\" +\n\t\t\t\t\t\t  \"6087*11668-4769-9605+13934/26324/27774-20032-1/2\") == str(-1835876569599)\n\tassert calc.calculate(\n\t\t\"191*83+250-164/88/88+44-215*236*132*94*354/79\" +\n\t\t\"-153/181*62-384+55-128/77/188+187/372-346/315-189*73+267+227/71\" +\n\t\t\"+309*152/182*264-237/72+217-393+124-317-50*203-336\" +\n\t\t\"*121/173/313/12-303+157/154/164-219-356/388-99*286+162*282\" +\n\t\t\"*181*189+292-201/140+246*50/395/8/232/251-144-289/261+301\" +\n\t\t\"*219-48+1+10/301*306*44*105/8/164/22*296*225*280\" +\n\t\t\"+359+234-395*305*52+389-192/196-233/20/68+207+337\") == str(-1264594822)\n", "description": "\n\ttests for calculator\n\t", "category": "math", "imports": ["import calc"]}], [], [{"term": "class", "name": "classDamage:", "data": "class Damage:\n\n\tdef __init__(self, raw_dmg):\n\t\tself.raw_dmg = raw_dmg\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\treturn 0.0\n\n\tdef get_color(self, alpha = 1.0):\n\t\tcol = self._color()\n\t\treturn Col(col.r, col.g, col.b, alpha)\n\n\tdef _color(self):\n\t\treturn Col.Gray\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "MagicDamage", "data": "class MagicDamage(Damage):\n\tdef calc_against(self, ctx, attacker, target):\n\t\treturn attacker.effective_magic_dmg(target, self.raw_dmg)\n\n\tdef _color(self):\n\t\treturn Col.Cyan\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "PhysDamage", "data": "class PhysDamage(Damage):\n\tdef calc_against(self, ctx, attacker, target):\n\t\treturn attacker.effective_phys_dmg(target, self.raw_dmg)\n\n\tdef _color(self):\n\t\treturn Col.Orange\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "TrueDamage", "data": "class TrueDamage(Damage):\n\tdef calc_against(self, ctx, attacker, target):\n\t\treturn self.raw_dmg\n\n\tdef _color(self):\n\t\treturn Col.White\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "WrapMaxHP", "data": "class WrapMaxHP(Damage):\n\tdef __init__(self, dmg_applied):\n\t\tself.dmg_applied = dmg_applied\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\told_dmg = self.dmg_applied.raw_dmg\n\n\t\tself.dmg_applied.raw_dmg *= target.max_health\n\t\tresult = self.dmg_applied.calc_against(ctx, attacker, target)\n\n\t\tself.dmg_applied.raw_dmg = old_dmg\n\n\t\treturn result\n\n\tdef _color(self):\n\t\treturn self.dmg_applied._color()\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "MixedDamage", "data": "class MixedDamage(Damage):\n\n\tdef __init__(self, phys = None, magic = None, true = None, others=None):\n\t\tif others is None:\n\t\t\tothers = []\n\n\t\tself.phys = phys\n\t\tself.magic = magic\n\t\tself.true = true\n\t\tself.others = others\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\ttotal = 0.0\n\t\tif self.phys:\n\t\t\ttotal += self.phys.calc_against(ctx, attacker, target)\n\t\tif self.magic:\n\t\t\ttotal += self.magic.calc_against(ctx, attacker, target)\n\t\tif self.true:\n\t\t\ttotal += self.true.calc_against(ctx, attacker, target)\n\t\tfor dmg in self.others:\n\t\t\ttotal += dmg.calc_against(ctx, attacker, target)\n\n\t\treturn total\n\n\tdef add_individual(self, dmg1, dmg2, cls):\n\t\tif dmg1 == None:\n\t\t\treturn cls(dmg2.raw_dmg) if dmg2 else None\n\t\telif dmg2 == None:\n\t\t\treturn cls(dmg1.raw_dmg) if dmg1 else None\n\n\t\treturn cls(dmg1.raw_dmg + dmg2.raw_dmg)\n\n\tdef __add__(self, other):\n\t\tdmg = MixedDamage(\n\t\t\tphys = self.phys,\n\t\t\tmagic = self.magic,\n\t\t\ttrue = self.true,\n\t\t\tothers = self.others\n\t\t)\n\n\t\totype = type(other)\n\t\tif otype == MixedDamage:\n\t\t\tdmg.phys   = self.add_individual(self.phys, other.phys, PhysDamage)\n\t\t\tdmg.magic  = self.add_individual(self.magic, other.magic, MagicDamage)\n\t\t\tdmg.true   = self.add_individual(self.true, other.true, TrueDamage)\n\t\t\tdmg.others += other.others\n\n\t\telif otype == PhysDamage:\n\t\t\tdmg.phys = self.add_individual(self.phys, other, PhysDamage)\n\t\telif otype == MagicDamage:\n\t\t\tdmg.magic = self.add_individual(self.magic, other, MagicDamage)\n\t\telif otype == TrueDamage:\n\t\t\tdmg.true = self.add_individual(self.true, other, TrueDamage)\n\t\telse:\n\t\t\tdmg.others.append(other)\n\n\t\treturn dmg\n\n\tdef _color(self):\n\t\treturn Col.Red\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "TwitchExpungeDamage", "data": "class TwitchExpungeDamage(MixedDamage):\n\tdef __init__(self, base, phys, magic):\n\t\tself.base = base\n\t\tself.phys = phys\n\t\tself.magic = magic\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tstacks = 0\n\t\tif target.has_buff('TwitchDeadlyVenom'):\n\t\t\tstacks = target.get_buff('TwitchDeadlyVenom').value\n\n\t\treturn self.base.calc_against(ctx, attacker, target) + stacks*self.phys.calc_against(ctx, attacker, target) + stacks*self.magic.calc_against(ctx, attacker, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "KalistaExpungeWrapperDamage", "data": "class KalistaExpungeWrapperDamage(PhysDamage):\n\tdef __init__(self, base, phys):\n\t\tself.base = base\n\t\tself.phys = phys\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tstacks = target.num_buff_stacks('kalistaexpungemarker')\n\n\t\treturn self.base.calc_against(ctx, attacker, target) + stacks*self.phys.calc_against(ctx, attacker, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "CassiopeiaEDamage", "data": "class CassiopeiaEDamage(MagicDamage):\n\tdef __init__(self, base, bonus):\n\t\tself.base = base\n\t\tself.bonus = bonus\n\n\tdef calc_against(self, ctx, attacker, target):\n\n\t\tdmg = self.base.calc_against(ctx, attacker, target)\n\n\t\tif type(target) == ChampionObj:\n\t\t\tpoisoned = target.has_buff('cassiopeiaqdebuff') or target.has_buff('cassiopeiawbuff')\n\t\t\tif poisoned:\n\t\t\t\tdmg += self.bonus.calc_against(ctx, attacker, target)\n\n\t\treturn dmg\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "KogMawRDamage", "data": "class KogMawRDamage(MagicDamage):\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tp = target.health/target.max_health\n\t\tif p < 0.4:\n\t\t\tself.raw_dmg *= 2.0\n\t\t\tdmg = super().calc_against(ctx, attacker, target)\n\t\t\tself.raw_dmg /= 2.0\n\t\telse:\n\t\t\tdmg = super().calc_against(ctx, attacker, target)\n\n\t\treturn dmg\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "DariusRDamage", "data": "class DariusRDamage(TrueDamage):\n\n\tdef __init__(self, base):\n\t\tself.base = base\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tnum_stacks = target.num_buff_stacks('DariusHemo')\n\t\treturn self.base + self.base * (0.2*num_stacks)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "SyndraRDamage", "data": "class SyndraRDamage(MagicDamage):\n\n\tdef __init__(self, base):\n\t\tself.base = base\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tself.raw_dmg = self.base * min(7, 3 + len(ctx.others.has_tag(Unit.SpecialSyndraSphere).alive().get()))\n\n\t\treturn super().calc_against(ctx, attacker, target)\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "TristanaEDamage", "data": "class TristanaEDamage(MagicDamage):\n\tdef __init__(self, base, bonus_per_stack):\n\t\tself.base = base\n\t\tself.bonus_per_stack = bonus_per_stack\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tself.raw_dmg = self.base + self.base * 1.2\n\t\tself.raw_dmg = self.raw_dmg + self.raw_dmg * (0.033*attacker.crit/0.1)\n\n\t\treturn super().calc_against(ctx, attacker, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "DianaRDamage", "data": "class DianaRDamage(MagicDamage):\n\tdef __init__(self, base, bonus_per_champ):\n\t\tself.base = base\n\t\tself.bonus_per_champ = bonus_per_champ\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tnum_champs = len(ctx.champs.enemy_to(attacker).targetable().near(attacker, 475).get())\n\t\tself.raw_dmg = self.base + num_champs * self.bonus_per_champ\n\t\treturn super().calc_against(ctx, attacker, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "JinxRDmage", "data": "class JinxRDmage(PhysDamage):\n\n\tmissing_hp = [0.25, 0.30, 0.35]\n\tdef __init__(self, base):\n\t\tself.base = base\n\n\tdef calc_against(self, ctx, attacker, target):\n\n\t\tlvl = max(0, attacker.spells[3].lvl - 1)\n\t\tmhp = self.missing_hp[lvl]\n\t\tmulti = min(1.0, 0.1 + 0.06 * attacker.pos.distance(target.pos) / 100.0)\n\n\t\tself.raw_dmg = self.base*multi + mhp*(target.max_health - target.health)\n\t\treturn super().calc_against(ctx, attacker, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "VeigarRDamage", "data": "class VeigarRDamage(MagicDamage):\n\n\tdef __init__(self, base):\n\t\tself.base = base\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tp = target.health/target.max_health\n\t\tself.raw_dmg = self.base + self.base * min(0.66, (1.0 - p)*1.5)\n\t\treturn super().calc_against(ctx, attacker, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "XerathRDamage", "data": "class XerathRDamage(MagicDamage):\n\n\tdef __init__(self, base):\n\t\tself.base = base\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tstacks = 0\n\t\tbuff = attacker.get_buff('xerathrshots')\n\t\tif not buff:\n\t\t\tstacks = 2 + attacker.spells[3].lvl\n\t\telse:\n\t\t\tstacks = buff.value\n\n\t\tself.raw_dmg = stacks*self.base\n\t\treturn super().calc_against(ctx, attacker, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "DivineSundererDamage", "data": "class DivineSundererDamage(PhysDamage):\n\n\tdef __init__(self):\n\t\tself.raw_dmg = 0.0\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tself.raw_dmg = max(attacker.base_atk * 1.5, target.max_health * 0.1)\n\t\treturn super().calc_against(ctx, attacker, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "BotrkDamage", "data": "class BotrkDamage(PhysDamage):\n\n\tdef __init__(self):\n\t\tself.raw_dmg = 0.0\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tdmg = target.health * (0.06 if attacker.is_ranged else 0.1)\n\t\tif dmg > 60.0 and not target.has_tags(Unit.Champion):\n\t\t\tself.raw_dmg = 60.0\n\t\telse:\n\t\t\tself.raw_dmg = dmg\n\n\t\treturn super().calc_against(ctx, attacker, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "NoonquiverDamage", "data": "class NoonquiverDamage(PhysDamage):\n\n\tdef __init__(self):\n\t\tself.raw_dmg = 0.0\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tself.raw_dmg = 0.0 if target.has_tags(Unit.Champion) else 20.0\n\n\t\treturn super().calc_against(ctx, attacker, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "JhinRShotDamage", "data": "class JhinRShotDamage(PhysDamage):\n\n\tdef __init__(self, base, shots):\n\t\tself.base = base\n\t\tself.shots = shots\n\n\tdef calc_against(self, ctx, attacker, target):\n\t\tmissing_hp = 1.0 - (target.health/target.max_health)\n\t\tself.raw_dmg = self.base + self.base * (3.0 * missing_hp)\n\t\tself.raw_dmg *= self.shots\n\n\t\treturn super().calc_against(ctx, attacker, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "load_spell_calcs", "data": "def load_spell_calcs(path):\n\tglobal Calculations\n\n\tj = {}\n\twith open(path, 'r') as f:\n\t\tj = json.loads(f.read())\n\n\n\tfor name, vdict in j.items():\n\t\tlname = name.lower()\n\t\tif lname in Calculations:\n\t\t\tcontinue\n\n\t\tobj_dict = {}\n\t\tfor dval_name, dval_values in vdict['data_vals'].items():\n\t\t\tobj_dict[dval_name] = dval_values\n\n\t\tfor formula_name, formula_str in vdict['calcs'].items():\n\t\t\tif '{' not in formula_str and '{' not in formula_name:\n\t\t\t\texec(f'def {formula_name}(self, champ, skill): return {formula_str}')\n\t\t\t\tobj_dict[formula_name] = eval(formula_name)\n\n\t\tobj = type('spell_' + lname, (object, ), obj_dict)()\n\t\tCalculations[lname] = obj\n\t\tdupes = DuplicateMap.get(lname, [])\n\t\tfor name in dupes:\n\t\t\tCalculations[name] = obj\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "classOnHitCalculator:", "data": "class OnHitCalculator:\n\tdef calculate(self, source, target) -> (int, int):\n\t\treturn get_items_onhit_damage(source) + PhysDamage(source.base_atk + source.bonus_atk)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "KalistaOnHitCalculator", "data": "class KalistaOnHitCalculator(OnHitCalculator):\n\tdef calculate(self, source, target) -> (int, int):\n\t\tdmg = super().calculate(source, target)\n\t\tdmg.phys.raw_dmg *= 0.9\n\t\treturn dmg\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "QuinnOnHitCalculator", "data": "class QuinnOnHitCalculator(OnHitCalculator):\n\tdef calculate(self, source, target) -> (int, int):\n\t\tdmg = super().calculate(source, target)\n\n\t\tif target.has_buff('QuinnW'):\n\t\t\tcalcs = Calculations.get('quinnpassive', None)\n\t\t\tdmg.phys.raw_dmg += calcs.bonusdamage(source, None)\n\n\t\treturn dmg\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "OriannaOnHitCalculator", "data": "class OriannaOnHitCalculator(OnHitCalculator):\n\tdef calculate(self, source, target) -> (int, int):\n\t\tdmg = super().calculate(source, target)\n\n\t\torianna_buff = target.get_buff('oriannapstack')\n\n\t\tif orianna_buff:\n\t\t\tbuff_dmg = orianna_buff.count * (14 + 11.2 * int(source.lvl / 3) + source.ap * 0.20)\n\t\telse:\n\t\t\tbuff_dmg = 0\n\n\t\traw_dmg = 10 + 8 * int(source.lvl / 3) + source.ap * 0.15 + buff_dmg\n\n\t\tif dmg.magic:\n\t\t\tdmg.magic.raw_dmg += raw_dmg\n\t\telse:\n\t\t\tdmg.magic = MagicDamage(raw_dmg)\n\n\t\treturn dmg\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "class", "name": "classOnHitInfo:", "data": "class OnHitInfo:\n\n\tdef __init__(self, damage_solver = lambda src, spell: PhysDamage(0.0), only_basics=False):\n\t\tself.damage_solver = damage_solver\n\t\tself.only_basics = only_basics\n\n\tdef get_damage(self, slot, source, spell):\n\t\tif spell:\n\t\t\tif self.only_basics or not spell.static.has_flag(Spell.AppliesOnHit):\n\t\t\t\treturn PhysDamage(0.0)\n\n\t\t\tif not slot.active or slot.active.cd > 0.0:\n\t\t\t\treturn PhysDamage(0.0)\n\n\t\t\treturn self.damage_solver(source, spell)\n\n\t\treturn self.damage_solver(source, None)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "crit_from_items", "data": "def crit_from_items(item_slots):\n\tcrit = 0.0\n\tfor slot in item_slots:\n\t\tif slot.item:\n\t\t\tcrit += slot.item.crit\n\treturn crit\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_guinsoo", "data": "def onhit_guinsoo(src, spell):\n\treturn PhysDamage(min(200.0, min(crit_from_items(src.item_slots), 1.0) * 100.0 * 2.0))\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_rageknife", "data": "def onhit_rageknife(src, spell):\n\treturn PhysDamage(min(175.0, min(crit_from_items(src.item_slots), 1.0) * 100.0 * 1.75))\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_noonquiver", "data": "def onhit_noonquiver(src, spell):\n\treturn NoonquiverDamage()\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_recurve_bow", "data": "def onhit_recurve_bow(src, spell):\n\treturn PhysDamage(15.0)\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_botrk", "data": "def onhit_botrk(src, spell):\n\treturn BotrkDamage()\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_doran_ring", "data": "def onhit_doran_ring(src, spell):\n\treturn PhysDamage(5.0)\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_nashors", "data": "def onhit_nashors(src, spell):\n\treturn MagicDamage(15.0 + 0.2 * src.ap)\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_wits_end", "data": "def onhit_wits_end(src, spell):\n\treturn MagicDamage(15.0 + 3.82 * (src.lvl - 1))\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_titanic_hydra", "data": "def onhit_titanic_hydra(src, spell):\n\tdmg = 3.75 if src.is_ranged else 5\n\tdmg += (src.max_health * 0.01125 if src.is_ranged else 0.015)\n\n\treturn PhysDamage(dmg)\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_sheen", "data": "def onhit_sheen(src, spell):\n\tif spell or src.has_buff('sheen'):\n\t\treturn PhysDamage(src.base_atk)\n\treturn PhysDamage(0.0)\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_trinity", "data": "def onhit_trinity(src, spell):\n\tif spell or src.has_buff('3078trinityforce'):\n\t\treturn PhysDamage(2.0 * src.base_atk)\n\treturn PhysDamage(0.0)\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_kraken", "data": "def onhit_kraken(src, spell):\n\tbuff = src.get_buff('6672buff')\n\tif buff and buff.value == 2:\n\t\treturn TrueDamage(60.0 + 0.45 * src.bonus_atk)\n\treturn PhysDamage(0.0)\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_divine_sunderer", "data": "def onhit_divine_sunderer(src, spell):\n\tif spell or src.has_buff('6632buff'):\n\t\treturn DivineSundererDamage()\n\treturn PhysDamage(0.0)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_lichbane", "data": "def onhit_lichbane(src, spell):\n\tif spell or src.has_buff('lichbane'):\n\t\treturn MagicDamage(1.5 * src.base_atk + 0.4 * src.ap)\n\treturn MagicDamage(0.0)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "onhit_essence_reaver", "data": "def onhit_essence_reaver(src, spell):\n\tif spell or src.has_buff('3508buff'):\n\t\treturn PhysDamage(src.base_atk + 0.4*src.bonus_atk)\n\treturn PhysDamage(0.0)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "get_items_onhit_damage", "data": "def get_items_onhit_damage(source, spell=None) -> MixedDamage:\n\t''' Returns raw on hit damage from items as atuple (physical_damage, magical_damage) '''\n\n\tdmg = MixedDamage()\n\tfor slot in source.item_slots:\n\t\titem = slot.item\n\t\tif not item:\n\t\t\tcontinue\n\n\t\tcalculator = OnHits.get(item.id, None)\n\t\tif not calculator:\n\t\t\tcontinue\n\n\t\tdmg = dmg + calculator.get_damage(slot, source, spell)\n\n\treturn dmg\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "calculate_onhit_dmg", "data": "def calculate_onhit_dmg(ctx: Context, source: UnitObj, target: UnitObj) -> float:\n\treturn ChampionOnHitCalculators.get(source.name, DefaultOnHitCalculator).calculate(source, target).calc_against(ctx, source, target)\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}, {"term": "def", "name": "calculate_raw_spell_dmg", "data": "def calculate_raw_spell_dmg(champ: ChampionObj, spell: SpellObj) -> Damage:\n\tcalculations = Calculations.get(spell.name, None)\n\tif calculations == None:\n\t\treturn Damage(0.0)\n\n\textractor = DamageExtractors.get(spell.name, None)\n\tif extractor == None:\n\t\treturn Damage(0.0)\n\n\tdmg = extractor(calculations, champ, spell)\n\tif spell.static.has_flag(Spell.AppliesOnHit):\n\t\treturn get_items_onhit_damage(champ, spell) + dmg\n\n\treturn dmg\n\n", "description": null, "category": "math", "imports": ["from valkyrie import *", "import os, json"]}], [{"term": "class", "name": "classTestCalculator:", "data": "class TestCalculator:\n\tdef setup(self):\n\t\tself.calc = Calculator()\n\t\n\tdef test_sum(self):\n\t\tassert(self.calc.sum(1,2) == 3)\n\t\n\tdef test_subtraction(self):\n\t\tassert(self.calc.subtraction(10,3) == 7)\n\t\n\tdef test_subtraction_negative_result(self):\n\t\tassert(self.calc.subtraction(2,6) == -4)\n\t\n\tdef test_multiplication(self):\n\t\tassert(self.calc.mult(15,14) == 210)\n\t\t\n\tdef test_division(self):\n\t\tassert(self.calc.div(100,5) == 20)\n\t\n\tdef test_division_by_zero(self):\n\t\twith pytest.raises(ZeroDivisionError):\n\t\t\tself.calc.div(10,0)\n\t\n\tdef test_square_root(self):\n\t\tassert(self.calc.sqrt(4) == 2)\n\t\tassert(pytest.approx(self.calc.sqrt(2), 0.01) == 1.41)\n\t\t\n\tdef test_square_root_of_negative(self):\n\t\twith pytest.raises(ArithmeticError):\n\t\t\tself.calc.sqrt(-10)\n\t\n\tdef test_exponential(self):\n\t\tassert(self.calc.exp(5,4) == 625)\n\t\n\tdef test_exponential_negative_exponent(self):\n\t\tassert(pytest.approx(self.calc.exp(4,-3), 1e-6) == 0.015625)\n\t\t\n", "description": null, "category": "math", "imports": ["import pytest", "from calculator import Calculator"]}], [{"term": "class", "name": "Patterns", "data": "class Patterns():\n\n\tdef __init__(self):\n\n\t\tself.config_candle_pattern_5m = True\n\t\tself.config_candle_pattern_1h = True\n\n\t\t#Run Flags:\n\t\tself.CandlePatternFlag = True\n\t\tself.DailyPatternFlag = True\n\t\tself.DivergencePatternFlag = True\n\t\t#///////////////////////////\n\n\n\t#Candle Patterns:\n\tdef CandlePatterns(self, dataset, symbol):\n\n\t\tcandle_patterns = pd.DataFrame()\n\n\t\tif self.config_candle_pattern_5m == True:\n\n\t\t\tcdl_patterns_5m = ind.cdl_pattern(\n\t\t\t\t\t\t\t\t\t\t\topen_ = dataset['open_5m'],\n\t\t\t\t\t\t\t\t\t\t\thigh = dataset['high_5m'],\n\t\t\t\t\t\t\t\t\t\t\tlow = dataset['low_5m'],\n\t\t\t\t\t\t\t\t\t\t\tclose = dataset['close_5m'],\n\t\t\t\t\t\t\t\t\t\t\tname = 'all'\n\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\tbar_config = Config()\n\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\tbar = Bar(symbol + ' ' + 'Candle Patterns 5M Finding: ', max = int(len(cdl_patterns_5m.columns)))\n\n\t\t\tcounter = 0\n\t\t\tfor pattern in cdl_patterns_5m.columns:\n\n\t\t\t\tcandle_patterns[f'pattern_5m_{counter}'] = cdl_patterns_5m[pattern]\n\n\t\t\t\tcandle_patterns[f'pattern_5m_{counter}'] = candle_patterns[f'pattern_5m_{counter}'].apply(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlambda x: 'buy' if x == 100 else ('sell' if x == -100 else np.nan)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\t\tbar.next()\n\n\t\t\t\tcounter += 1\n\n\t\tif self.config_candle_pattern_1h == True:\n\n\t\t\tcdl_patterns_1h = ind.cdl_pattern(\n\t\t\t\t\t\t\t\t\t\t\topen_ = dataset['open_1h'].dropna(),\n\t\t\t\t\t\t\t\t\t\t\thigh = dataset['high_1h'].dropna(),\n\t\t\t\t\t\t\t\t\t\t\tlow = dataset['low_1h'].dropna(),\n\t\t\t\t\t\t\t\t\t\t\tclose = dataset['close_1h'].dropna(),\n\t\t\t\t\t\t\t\t\t\t\tname = 'all'\n\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\tbar = Bar(symbol + ' ' + 'Candle Patterns 1H Finding: ', max = int(len(cdl_patterns_5m.columns)))\n\n\t\t\tcounter = 0\n\t\t\tfor pattern in cdl_patterns_1h.columns:\n\n\t\t\t\tcandle_patterns[f'pattern_1h_{counter}'] = cdl_patterns_1h[pattern]\n\n\t\t\t\tcandle_patterns[f'pattern_1h_{counter}'] = candle_patterns[f'pattern_1h_{counter}'].apply(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlambda x: 'buy' if x == 100 else ('sell' if x == -100 else np.nan)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\t\tbar.next()\n\n\t\t\t\tcounter += 1\n\n\t\treturn candle_patterns\n\t#////////////////////////////////////////\n\n\n\t#Daily Pattern:\n\tdef DailyPatterns(self, dataset, symbol):\n\n\t\tDaysOfWeek = ['Monday', 'Tuesday', 'Thursday', 'Wednesday', 'Friday']\n\n\t\tbar_config = Config()\n\t\tif bar_config.cfg['show_bar']:\n\t\t\tbar = Bar(symbol + ' ' + 'Daily Patterns Finding: ', max = int(len(DaysOfWeek)))\n\n\t\tdaily_pattern = pd.DataFrame()\n\n\t\tfor day in DaysOfWeek:\n\n\t\t\tdaily_pattern['pattern_day_' + day] = np.nan\n\t\t\tdaily_pattern['pattern_day_' + day] = dataset['time_5m'].apply(lambda x: 1 if x.day_name() == day else np.nan)\n\n\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\tbar.next()\n\n\t\treturn daily_pattern\n\t#//////////////////////\n\n\n\t#Divergence Pattern:\n\tdef DivergencePatterns(self, dataset, dataset_5M, dataset_1H, symbol):\n\n\t\tsignalpriority = ['primary', 'secondry', 'primary', 'secondry']\n\t\tsignaltype = ['buy' , 'sell', 'sell' , 'buy']\n\t\ttimeframes = ['5M' , '1H']\n\t\tindicator_names = ['macd', 'stochastic', 'rsi']\n\n\t\tparameter_reader = ParameterReader()\n\n\t\tdivergence_pattern = pd.DataFrame(index = dataset.index)\n\n\t\tbar_config = Config()\n\t\tif bar_config.cfg['show_bar']:\n\t\t\tbar = Bar(\n\t\t\t\t\t\tsymbol + ' ' + 'Daily Patterns Finding: ', \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmax = int(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlen(signalpriority) * \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlen(signaltype) * \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlen(timeframes) * \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlen(indicator_names)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t)\n\n\t\tfor ind_name in indicator_names:\n\t\t\tfor timfrm in timeframes:\n\t\t\t\tfor sigpriority, sigtype in zip(signalpriority, signaltype):\n\n\t\t\t\t\tif timfrm == '1H' and not dataset_1H: continue\n\t\t\t\t\tif timfrm == '5M' and not dataset_5M: continue\n\n\t\t\t\t\tif timfrm == '1H':\n\t\t\t\t\t\tind_parameters, ind_config, div_parameters, div_config = parameter_reader.Divergence(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsignalpriority = sigpriority,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsignaltype = sigtype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsymbol = symbol,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttimeframe = timfrm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset = dataset_1H,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindicator_name = ind_name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\telif timfrm == '5M':\n\t\t\t\t\t\tind_parameters, ind_config, div_parameters, div_config = parameter_reader.Divergence(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsignalpriority = sigpriority,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsignaltype = sigtype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsymbol = symbol,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttimeframe = timfrm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset = dataset_5M,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindicator_name = ind_name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t#Add MACD Calculate Params AS Alpha Factor To Dataset:\n\t\t\t\t\tif ind_name == 'macd':\n\n\t\t\t\t\t\tind = MACD(parameters = ind_parameters, config = ind_config)\n\t\t\t\t\t\tind_calc = ind.calculator_macd()\n\n\t\t\t\t\t\tif timfrm == '5M':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_5M[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\telif timfrm == '1H':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_1H[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\tind_calc.index = ind_calc['index']\n\n\t\t\t\t\t\tcolumn_div = ind_parameters.elements['MACD_column_div']\n\t\t\t\t\t#///////////////////////////////////////\n\n\t\t\t\t\t#Add StochAstic Calculate Params AS Alpha Factor To Dataset:\n\t\t\t\t\telif ind_name == 'stochastic':\n\n\t\t\t\t\t\tind = StochAstic(parameters = ind_parameters, config = ind_config)\n\t\t\t\t\t\tind_calc = ind.calculator_StochAstic()\n\n\t\t\t\t\t\tif timfrm == '5M':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_5M[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\telif timfrm == '1H':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_1H[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\tind_calc.index = ind_calc['index']\n\n\t\t\t\t\t\tcolumn_div = ind_parameters.elements['StochAstic_column_div']\n\t\t\t\t\t#//////////////////////////////////////////////////////////\n\n\t\t\t\t\t#Add RSI Calculate Params AS Alpha Factor To Dataset:\n\t\t\t\t\telif ind_name == 'rsi':\n\n\t\t\t\t\t\tind = RSI(parameters = ind_parameters, config = ind_config)\n\t\t\t\t\t\tind_calc = ind.calculator_rsi()\n\n\t\t\t\t\t\tif timfrm == '5M':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_5M[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\telif timfrm == '1H':\n\t\t\t\t\t\t\tind_calc['time'] = dataset_1H[symbol]['time']\n\t\t\t\t\t\t\tind_calc['index'] = ind_calc.index\n\t\t\t\t\t\t\tind_calc.index = ind_calc['time']\n\n\t\t\t\t\t\tind_calc.index = ind_calc['index']\n\n\t\t\t\t\t\tcolumn_div = 'rsi'\n\t\t\t\t\t#////////////////////////////////////////////////////////////\n\n\n\n\t\t\t\t\tdivergence = Divergence(parameters = div_parameters, config = div_config)\n\n\t\t\t\t\tif timfrm == '1H':\n\t\t\t\t\t\tsignal, _, _ = divergence.divergence(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsigtype = sigtype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsigpriority = sigpriority,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindicator = ind_calc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn_div = column_div,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tind_name = ind_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_5M = dataset_1H,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_1H = dataset_1H,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsymbol = symbol,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflaglearn = False,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflagtest = False\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\tsignal = signal.drop_duplicates(subset = ['time_low_front'])\n\t\t\t\t\t\tsignal.index = signal['time_low_front']\n\n\t\t\t\t\t\tdivergence_pattern['pattern_' + ind_name + '_div_' + '1h_' + sigtype + '_' + sigpriority] = signal['signal']\n\n\n\t\t\t\t\telif timfrm == '5M':\n\t\t\t\t\t\tsignal, _, _ = divergence.divergence(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsigtype = sigtype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsigpriority = sigpriority,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindicator = ind_calc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumn_div = column_div,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tind_name = ind_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_5M = dataset_5M,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_1H = dataset_5M,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsymbol = symbol,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflaglearn = False,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tflagtest = False\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\tsignal = signal.drop_duplicates(subset = ['time_low_front'])\n\t\t\t\t\t\tsignal.index = signal['time_low_front']\n\n\t\t\t\t\t\tdivergence_pattern['pattern_' + ind_name + '_div_' + '5m_' + sigtype + '_' + sigpriority] = signal['signal']\n\n\t\t\t\t\tif bar_config.cfg['show_bar']:\n\t\t\t\t\t\tbar.next()\n\n\t\treturn divergence_pattern\n\t#/////////////////////\n\n\tdef Run(self, dataset, symbol, dataset_5M, dataset_1H):\n\t\t\n\t\tdatasetio = DatasetIO()\n\n\t\tpattern = pd.DataFrame(index = dataset.index)\n\n\t\tif self.CandlePatternFlag == True:\n\t\t\tcandle_pattern = self.CandlePatterns(dataset = dataset, symbol = symbol)\n\t\t\tpattern = pattern.join(candle_pattern, how = 'right')\n\n\t\tif self.DailyPatternFlag == True:\n\t\t\tdaily_pattern = self.DailyPatterns(dataset = dataset, symbol = symbol)\n\t\t\tpattern = pattern.join(daily_pattern, how = 'right')\n\n\t\tif self.DivergencePatternFlag == True:\n\t\t\tdivergence_pattern = self.DivergencePatterns(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset = dataset, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_5M = dataset_5M, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataset_1H = dataset_1H, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsymbol = symbol\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\tpattern = pattern.join(divergence_pattern, how = 'right')\n\n\t\tdatasetio.Write(name = 'pattern', dataset = pattern, symbol = symbol)\n\n\t\treturn pattern\n\n\n\tdef Get(self, dataset, symbol, mode = None, dataset_5M = {}, dataset_1H = {}):\n\n\t\tdatasetio = DatasetIO()\n\n\t\tpattern = pd.DataFrame(index = dataset.index)\n\t\t\n\t\tif mode == None:\n\t\t\tpattern = datasetio.Read(name = 'pattern', symbol = symbol)\n\n\t\t\tif pattern.empty == False:\n\t\t\t\treturn pattern\n\n\t\t\telse:\n\t\t\t\treturn self.Run(\n\t\t\t\t\t\t\tdataset = dataset, \n\t\t\t\t\t\t\tsymbol = symbol, \n\t\t\t\t\t\t\tdataset_5M = dataset_5M, \n\t\t\t\t\t\t\tdataset_1H = dataset_1H\n\t\t\t\t\t\t\t)\n\n\t\tif mode == 'Run':\n\t\t\tdatasetio.Delete(name = 'pattern', symbol = symbol)\n\n\t\t\treturn self.Run(\n\t\t\t\t\t\t\tdataset = dataset, \n\t\t\t\t\t\t\tsymbol = symbol, \n\t\t\t\t\t\t\tdataset_5M = dataset_5M, \n\t\t\t\t\t\t\tdataset_1H = dataset_1H\n\t\t\t\t\t\t\t)\n\t\t\t\n", "description": null, "category": "math", "imports": ["from src.indicators.StochAstic.StochAstic import StochAstic", "from src.utils.Divergence.Divergence import Divergence", "from .ParameterReader import ParameterReader", "from src.indicators.MACD.MACD import MACD", "from src.indicators.RSI.RSI import RSI", "from .DatasetIO import DatasetIO", "from progress.bar import Bar", "from .Config import Config", "import pandas_ta as ind", "import pandas as pd", "import numpy as np"]}], [{"term": "def", "name": "mocked_validation", "data": "def mocked_validation(*args, **kwargs):\n\treturn True\n\n", "description": null, "category": "math", "imports": ["import unittest", "from unittest.mock import patch", "import pytest", "from app.calc import Calculator"]}, {"term": "class", "name": "TestCalculate", "data": "class TestCalculate(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.calc = Calculator()\n\n\tdef test_add_method_returns_correct_result(self):\n\t\tself.assertEqual(4, self.calc.add(2, 2))\n\t\tself.assertEqual(0, self.calc.add(2, -2))\n\t\tself.assertEqual(0, self.calc.add(-2, 2))\n\t\tself.assertEqual(1, self.calc.add(1, 0))\n\n\tdef test_divide_method_returns_correct_result(self):\n\t\tself.assertEqual(1, self.calc.divide(2, 2))\n\t\tself.assertEqual(1.5, self.calc.divide(3, 2))\n\n\tdef test_add_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.add, \"2\", 2)\n\t\tself.assertRaises(TypeError, self.calc.add, 2, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.add, \"2\", \"2\")\n\t\tself.assertRaises(TypeError, self.calc.add, None, 2)\n\t\tself.assertRaises(TypeError, self.calc.add, 2, None)\n\t\tself.assertRaises(TypeError, self.calc.add, object(), 2)\n\t\tself.assertRaises(TypeError, self.calc.add, 2, object())\n\n\tdef test_divide_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.divide, \"2\", 2)\n\t\tself.assertRaises(TypeError, self.calc.divide, 2, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.divide, \"2\", \"2\")\n\n\tdef test_divide_method_fails_with_division_by_zero(self):\n\t\tself.assertRaises(TypeError, self.calc.divide, 2, 0)\n\t\tself.assertRaises(TypeError, self.calc.divide, 2, -0)\n\t\tself.assertRaises(TypeError, self.calc.divide, 0, 0)\n\t\tself.assertRaises(TypeError, self.calc.divide, \"0\", 0)\n\n\t@patch('app.util.validate_permissions', side_effect=mocked_validation, create=True)\n\tdef test_multiply_method_returns_correct_result(self, _validate_permissions):\n\t\tself.assertEqual(4, self.calc.multiply(2, 2))\n\t\tself.assertEqual(0, self.calc.multiply(1, 0))\n\t\tself.assertEqual(0, self.calc.multiply(-1, 0))\n\t\tself.assertEqual(-2, self.calc.multiply(-1, 2))\n\n\tdef test_power_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.power, \"2\", 2)\n\t\tself.assertRaises(TypeError, self.calc.power, 2, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.power, \"2\", \"2\")\n\n\tdef test_power_method_returns_correct_result(self):\n\t\tself.assertEqual(0, self.calc.power(0, 2))\n\t\tself.assertEqual(1, self.calc.power(4, 0))\n\t\tself.assertEqual(64, self.calc.power(8, 2))\n\t\tself.assertEqual(64, self.calc.power(-8, 2))\n\t\tself.assertEqual(-27, self.calc.power(-3, 3))\n\t\tself.assertEqual(0.5, self.calc.power(2, -1))\n\n\tdef test_sqrt_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.sqrt, \"2\")\n\n\tdef test_sqrt_method_returns_correct_result(self):\n\t\tself.assertEqual(8, self.calc.sqrt(64))\n\n\tdef test_log10_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.log10, \"2\")\n\n\tdef test_log10_method_returns_correct_result(self):\n\t\tself.assertEqual(2, self.calc.log10(100))\n", "description": null, "category": "math", "imports": ["import unittest", "from unittest.mock import patch", "import pytest", "from app.calc import Calculator"]}], [{"term": "def", "name": "strip_calc_id", "data": "def strip_calc_id(fname):\n\tname = os.path.basename(fname)\n\treturn re.sub(r'_\\d+\\.', '.', name)\n\n", "description": null, "category": "math", "imports": ["import io", "import os", "import re", "import math", "import pandas", "import numpy.testing", "from openquake.baselib.hdf5 import read_csv", "from openquake.baselib.general import countby, gettemp", "from openquake.hazardlib import InvalidFile", "from openquake.commonlib.datastore import read", "from openquake.baselib.writers import write_csv", "from openquake.commonlib.util import max_rel_diff_index", "from openquake.commonlib.calc import gmvs_to_poes", "from openquake.calculators.views import view", "from openquake.calculators.export import export", "from openquake.calculators.extract import extract", "from openquake.calculators.event_based import get_mean_curves, compute_avg_gmf", "from openquake.calculators.tests import CalculatorTestCase", "from openquake.qa_tests_data.classical import case_18 as gmpe_tables", "from openquake.qa_tests_data.event_based import (", "from openquake.qa_tests_data.event_based.spatial_correlation import ("]}, {"term": "def", "name": "joint_prob_of_occurrence", "data": "def joint_prob_of_occurrence(gmvs_site_1, gmvs_site_2, gmv, time_span,\n\t\t\t\t\t\t\t num_ses, delta_gmv=0.1):\n\t\"\"\"\n\tCompute the Poissonian probability of a ground shaking value to be in the\n\trange [``gmv`` - ``delta_gmv`` / 2, ``gmv`` + ``delta_gmv`` / 2] at two\n\tdifferent locations within a given ``time_span``.\n\n\t:param gmvs_site_1, gmvs_site_2:\n\t\tLists of ground motion values (as floats) for two different sites.\n\t:param gmv:\n\t\tReference value for computing joint probability.\n\t:param time_span:\n\t\t`investigation_time` parameter from the calculation which produced\n\t\tthese ground motion values.\n\t:param num_ses:\n\t\t`ses_per_logic_tree_path` parameter from the calculation which produced\n\t\tthese ground motion values. In other words, the total number of\n\t\tstochastic event sets.\n\t:param delta_gmv:\n\t\tthe interval to consider\n\t\"\"\"\n\tassert len(gmvs_site_1) == len(gmvs_site_2)\n\thalf_delta = float(delta_gmv) / 2\n\n\tdef gmv_close(v):\n\t\treturn (gmv - half_delta <= v <= gmv + half_delta)\n\tcount = 0\n\tfor gmv_site_1, gmv_site_2 in zip(gmvs_site_1, gmvs_site_2):\n\t\tif gmv_close(gmv_site_1) and gmv_close(gmv_site_2):\n\t\t\tcount += 1\n\n\tprob = 1 - math.exp(- (float(count) / num_ses))\n\treturn prob\n\n", "description": "\n\tCompute the Poissonian probability of a ground shaking value to be in the\n\trange [``gmv`` - ``delta_gmv`` / 2, ``gmv`` + ``delta_gmv`` / 2] at two\n\tdifferent locations within a given ``time_span``.\n\n\t:param gmvs_site_1, gmvs_site_2:\n\t\tLists of ground motion values (as floats) for two different sites.\n\t:param gmv:\n\t\tReference value for computing joint probability.\n\t:param time_span:\n\t\t`investigation_time` parameter from the calculation which produced\n\t\tthese ground motion values.\n\t:param num_ses:\n\t\t`ses_per_logic_tree_path` parameter from the calculation which produced\n\t\tthese ground motion values. In other words, the total number of\n\t\tstochastic event sets.\n\t:param delta_gmv:\n\t\tthe interval to consider\n\t", "category": "math", "imports": ["import io", "import os", "import re", "import math", "import pandas", "import numpy.testing", "from openquake.baselib.hdf5 import read_csv", "from openquake.baselib.general import countby, gettemp", "from openquake.hazardlib import InvalidFile", "from openquake.commonlib.datastore import read", "from openquake.baselib.writers import write_csv", "from openquake.commonlib.util import max_rel_diff_index", "from openquake.commonlib.calc import gmvs_to_poes", "from openquake.calculators.views import view", "from openquake.calculators.export import export", "from openquake.calculators.extract import extract", "from openquake.calculators.event_based import get_mean_curves, compute_avg_gmf", "from openquake.calculators.tests import CalculatorTestCase", "from openquake.qa_tests_data.classical import case_18 as gmpe_tables", "from openquake.qa_tests_data.event_based import (", "from openquake.qa_tests_data.event_based.spatial_correlation import ("]}, {"term": "class", "name": "EventBasedTestCase", "data": "class EventBasedTestCase(CalculatorTestCase):\n\n\tdef check_avg_gmf(self):\n\t\t# checking avg_gmf with a single site\n\t\tmin_iml = self.calc.oqparam.min_iml\n\t\tdf = self.calc.datastore.read_df('gmf_data', 'sid')\n\t\tweights = self.calc.datastore['weights'][:]\n\t\trlzs = self.calc.datastore['events']['rlz_id']\n\t\t[(sid, avgstd)] = compute_avg_gmf(df, weights[rlzs], min_iml).items()\n\t\tavg_gmf = self.calc.datastore['avg_gmf'][:]  # 2, N, M\n\t\taac(avg_gmf[:, 0], avgstd)\n\n\tdef test_compute_avg_gmf(self):\n\t\tnumpy.random.seed(42)\n\t\tE = 1000\n\t\teids = numpy.arange(E)\n\t\tmin_iml = numpy.array([.05])\n\t\tgmvs = numpy.random.lognormal(mean=-2.0, sigma=.5, size=E)\n\t\tok = gmvs >= min_iml\n\t\tself.assertEqual(ok.sum(), 983)\n\t\tgmf_df = pandas.DataFrame(dict(eid=eids[ok], gmv_0=gmvs[ok]),\n\t\t\t\t\t\t\t\t  numpy.zeros(E, int)[ok])\n\t\tweights = numpy.ones(E)\n\t\t[(sid, avgstd)] = compute_avg_gmf(gmf_df, weights, min_iml).items()\n\t\t# aac(avgstd, [[0.13664978], [1.63127694]]) without cutting min_iml\n\t\t# aac(avgstd, [[0.14734], [1.475266]], atol=1E-6)  # cutting at .10\n\t\taac(avgstd, [[0.137023], [1.620616]], atol=1E-6)\n\n\tdef test_spatial_correlation(self):\n\t\texpected = {sc1: [0.99, 0.41],\n\t\t\t\t\tsc2: [0.99, 0.64],\n\t\t\t\t\tsc3: [0.99, 0.22]}\n\n\t\tfor case in expected:\n\t\t\tself.run_calc(case.__file__, 'job.ini')\n\t\t\toq = self.calc.oqparam\n\t\t\tself.assertEqual(list(oq.imtls), ['PGA'])\n\t\t\tdstore = read(self.calc.datastore.calc_id)\n\t\t\tgmf = dstore.read_df('gmf_data', 'sid')\n\t\t\tgmvs_site_0 = gmf.loc[0]['gmv_0']\n\t\t\tgmvs_site_1 = gmf.loc[1]['gmv_0']\n\t\t\tjoint_prob_0_5 = joint_prob_of_occurrence(\n\t\t\t\tgmvs_site_0, gmvs_site_1, 0.5, oq.investigation_time,\n\t\t\t\toq.ses_per_logic_tree_path)\n\t\t\tjoint_prob_1_0 = joint_prob_of_occurrence(\n\t\t\t\tgmvs_site_0, gmvs_site_1, 1.0, oq.investigation_time,\n\t\t\t\toq.ses_per_logic_tree_path)\n\n\t\t\tp05, p10 = expected[case]\n\t\t\taac(joint_prob_0_5, p05, atol=.1)\n\t\t\taac(joint_prob_1_0, p10, atol=.1)\n\n\tdef test_blocksize(self):\n\t\tout = self.run_calc(blocksize.__file__, 'job.ini',\n\t\t\t\t\t\t\tconcurrent_tasks='3', exports='csv')\n\t\t[fname, _, sitefile] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/gmf-data.csv', fname)\n\t\tself.assertEqualFiles('expected/sites.csv', sitefile)\n\n\t\tout = self.run_calc(blocksize.__file__, 'job.ini',\n\t\t\t\t\t\t\tconcurrent_tasks='4', exports='csv')\n\t\t[fname, sig_eps, _] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/gmf-data.csv', fname)\n\t\tself.assertEqualFiles('expected/sig-eps.csv', sig_eps)\n\n\tdef test_case_1(self):\n\t\tout = self.run_calc(case_1.__file__, 'job.ini', exports='csv,xml')\n\n\t\tetime = self.calc.datastore.get_attr('gmf_data', 'effective_time')\n\t\tself.assertEqual(etime, 80000.)  # ses_per_logic_tree_path = 80000\n\t\timts = self.calc.datastore.get_attr('gmf_data', 'imts')\n\t\tself.assertEqual(imts, 'PGA')\n\t\tself.check_avg_gmf()\n\n\t\t# make sure ses_id >= 65536 is valid\n\t\thigh_ses = (self.calc.datastore['events']['ses_id'] >= 65536).sum()\n\t\tself.assertGreater(high_ses, 1000)\n\n\t\t[fname] = export(('hcurves', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles(\n\t\t\t'expected/hazard_curve-smltp_b1-gsimltp_b1.csv', fname)\n\n\t\texport(('hcurves', 'xml'), self.calc.datastore)  # check it works\n\n\t\t[fname] = out['hcurves', 'xml']\n\t\tself.assertEqualFiles(\n\t\t\t'expected/hazard_curve-smltp_b1-gsimltp_b1-PGA.xml', fname)\n\n\t\t# compute hcurves in postprocessing and compare with inprocessing\n\t\t# take advantage of the fact that there is a single site\n\t\tdf = self.calc.datastore.read_df('gmf_data', 'sid')\n\t\toq = self.calc.datastore['oqparam']\n\t\tpoes = gmvs_to_poes(df, oq.imtls, oq.ses_per_logic_tree_path)\n\t\thcurve = self.calc.datastore['hcurves-stats'][0, 0]  # shape (M, L)\n\t\taac(poes, hcurve)\n\n\t\t# test gsim_by_imt\n\t\tout = self.run_calc(case_1.__file__, 'job.ini',\n\t\t\t\t\t\t\tses_per_logic_tree_path='30',\n\t\t\t\t\t\t\tgsim_logic_tree_file='gsim_by_imt_logic_tree.xml',\n\t\t\t\t\t\t\texports='csv')\n\n\t\t# testing event_info\n\t\teinfo = dict(extract(self.calc.datastore, 'event_info/0'))\n\t\tself.assertEqual(einfo['trt'], 'active shallow crust')\n\t\tself.assertEqual(einfo['rupture_class'],\n\t\t\t\t\t\t 'ParametricProbabilisticRupture')\n\t\tself.assertEqual(einfo['surface_class'], 'PlanarSurface')\n\t\tself.assertEqual(einfo['seed'], 1483155045)\n\t\tself.assertEqual(str(einfo['gsim']),\n\t\t\t\t\t\t '[MultiGMPE.\"PGA\".AkkarBommer2010]\\n'\n\t\t\t\t\t\t '[MultiGMPE.\"SA(0.1)\".SadighEtAl1997]')\n\t\tself.assertEqual(einfo['rlzi'], 0)\n\t\tself.assertEqual(einfo['trt_smr'], 0)\n\t\taac(einfo['occurrence_rate'], 0.6)\n\t\taac(einfo['hypo'], [0., 0., 4.])\n\n\t\t[fname, _, _] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/gsim_by_imt.csv', fname)\n\n\tdef test_case_1_ruptures(self):\n\t\tself.run_calc(case_1.__file__, 'job_ruptures.ini')\n\t\tself.assertEqual(len(self.calc.datastore['ruptures']), 2)\n\t\t[fname] = export(('events', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/events.csv', fname)\n\n\tdef test_minimum_intensity(self):\n\t\tout = self.run_calc(case_2.__file__, 'job.ini', exports='csv',\n\t\t\t\t\t\t\tminimum_intensity='0.2')\n\n\t\t[fname, _, _] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/minimum-intensity-gmf-data.csv', fname)\n\n\t\t# test gmf_data.hdf5 exporter\n\t\t[fname] = export(('gmf_data', 'hdf5'), self.calc.datastore)\n\t\tself.assertIn('gmf-data_', fname)\n\n\tdef test_case_2(self):\n\t\tout = self.run_calc(case_2.__file__, 'job.ini', exports='csv')\n\n\t\t[gmfs, sig_eps, _sitefile] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/gmf-data.csv', gmfs)\n\t\t# this is a case with truncation_level=0: sig-eps.csv must be empty\n\t\tself.assertEqualFiles('expected/sig-eps.csv', sig_eps)\n\n\t\t[fname] = out['hcurves', 'csv']\n\t\tself.assertEqualFiles(\n\t\t\t'expected/hazard_curve-smltp_b1-gsimltp_b1.csv', fname)\n\n\tdef test_case_2bis(self):  # oversampling\n\t\tout = self.run_calc(case_2.__file__, 'job_2.ini', exports='csv,xml')\n\t\t[fname, _, _] = out['gmf_data', 'csv']  # 2 realizations, 1 TRT\n\t\tself.assertEqualFiles('expected/gmf-data-bis.csv', fname)\n\t\tfor fname in out['hcurves', 'csv']:\n\t\t\tself.assertEqualFiles('expected/' + strip_calc_id(fname), fname,\n\t\t\t\t\t\t\t\t  delta=1E-6)\n\n\tdef test_case_3(self):  # 1 site, 1 rupture, 2 GSIMs, 10,000 years\n\t\tself.run_calc(case_3.__file__, 'job.ini')\n\t\t[f] = export(('avg_gmf', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/avg_gmf.csv', f)\n\n\t\t[f] = export(('ruptures', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/ruptures.csv', f)\n\n\t\t# check association events <-> GSIMs are 50-50 for full enum\n\t\trlzs = self.calc.datastore['full_lt'].get_realizations()\n\t\tgsim = [rlz.gsim_rlz.value[0] for rlz in rlzs]\n\t\tedf = self.calc.datastore.read_df('events', 'id')\n\t\tedf['gsim'] = [gsim[r] for r in edf.rlz_id]\n\t\tA, S = edf.groupby('gsim').rlz_id.count()\n\t\tself.assertEqual(A, 5191)  # AkkarBommer2010 assocs\n\t\tself.assertEqual(S, 4930)  # SadighEtAl1997 assocs\n\n\t\t# check association events <-> GSIMs are 90-10 for sampling\n\t\tself.run_calc(case_3.__file__, 'job.ini',\n\t\t\t\t\t  number_of_logic_tree_samples=10000,\n\t\t\t\t\t  ses_per_logic_tree_path=1)\n\t\trlzs = self.calc.datastore['full_lt'].get_realizations()\n\t\tgsim = [rlz.gsim_rlz.value[0] for rlz in rlzs]\n\t\tedf = self.calc.datastore.read_df('events', 'id')\n\t\tedf['gsim'] = [gsim[r] for r in edf.rlz_id]\n\t\tA, S = edf.groupby('gsim').rlz_id.count()\n\t\tself.assertEqual(A, 9130)  # AkkarBommer2010 assocs\n\t\tself.assertEqual(S, 991)   # SadighEtAl1997 assocs\n\n\tdef test_case_4(self):\n\t\tout = self.run_calc(case_4.__file__, 'job.ini', exports='csv')\n\t\t[fname] = out['hcurves', 'csv']\n\t\tself.assertEqualFiles(\n\t\t\t'expected/hazard_curve-smltp_b1-gsimltp_b1.csv', fname)\n\n\t\t# exercise preclassical\n\t\tself.run_calc(case_4.__file__, 'job.ini',\n\t\t\t\t\t  calculation_mode='preclassical')\n\n\tdef test_case_5(self):\n\t\tout = self.run_calc(case_5.__file__, 'job.ini', exports='csv')\n\t\t[fname, _, _] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/%s' % strip_calc_id(fname), fname,\n\t\t\t\t\t\t\t  delta=1E-6)\n\n\t\t[fname] = export(('ruptures', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/ruptures.csv', fname, delta=1E-6)\n\n\t\ttmp = gettemp(extract(self.calc.datastore, 'ruptures').array)\n\t\tself.assertEqualFiles('expected/ruptures_full.csv', tmp, delta=1E-6)\n\n\t\t# check MFD\n\t\taw = extract(self.calc.datastore, 'event_based_mfd?')\n\t\taac(aw.mag, [4.6, 4.7, 4.9, 5.1, 5.3, 5.7], atol=1E-6)\n\t\taac(aw.freq, [0.004444, 0.004444, 0.006667, 0.002222,\n\t\t\t\t\t  0.002222, 0.002222], atol=1E-4)\n\n\tdef test_case_6(self):\n\t\t# 2 models x 3 GMPEs, different weights\n\t\texpected = [\n\t\t\t'hazard_curve-mean.csv',\n\t\t\t'quantile_curve-0.1.csv',\n\t\t]\n\t\tout = self.run_calc(case_6.__file__, 'job.ini', exports='csv')\n\t\tfnames = out['hcurves', 'csv']\n\t\tfor exp, got in zip(expected, fnames):\n\t\t\tself.assertEqualFiles('expected/%s' % exp, got)\n\n\t\t[fname] = export(('realizations', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/realizations.csv', fname)\n\n\t\t# comparing with the full calculation\n\t\t# weights = [0.3 , 0.18, 0.12, 0.2 , 0.12, 0.08] for 6 realizations\n\t\tself.check_avg_gmf()\n\n\tdef test_case_7(self):\n\t\t# 2 models x 3 GMPEs, 1000 samples * 10 SES\n\t\texpected = [\n\t\t\t'hazard_curve-mean.csv',\n\t\t]\n\t\tout = self.run_calc(case_7.__file__, 'job.ini', exports='csv')\n\t\taw = extract(self.calc.datastore, 'realizations')\n\t\tdic = countby(aw.array, 'branch_path')\n\t\tself.assertEqual({b'A~A': 308,  # w = .6 * .5 = .30\n\t\t\t\t\t\t  b'A~B': 173,  # w = .6 * .3 = .18\n\t\t\t\t\t\t  b'A~C': 119,  # w = .6 * .2 = .12\n\t\t\t\t\t\t  b'B~A': 192,  # w = .4 * .5 = .20\n\t\t\t\t\t\t  b'B~B': 127,  # w = .4 * .3 = .12\n\t\t\t\t\t\t  b'B~C': 81},  # w = .4 * .2 = .08\n\t\t\t\t\t\t dic)\n\n\t\tfnames = out['hcurves', 'csv']\n\t\tmean_eb = get_mean_curves(self.calc.datastore, 'PGA')\n\t\tfor exp, got in zip(expected, fnames):\n\t\t\tself.assertEqualFiles('expected/%s' % exp, got)\n\t\tmean_cl = get_mean_curves(self.calc.cl.datastore, 'PGA')\n\t\treldiff, _index = max_rel_diff_index(\n\t\t\tmean_cl, mean_eb, min_value=0.1)\n\t\tself.assertLess(reldiff, 0.05)\n\n\tdef test_case_8(self):\n\t\tout = self.run_calc(case_8.__file__, 'job.ini', exports='csv')\n\t\t[fname] = out['ruptures', 'csv']\n\t\tself.assertEqualFiles('expected/rup_data.csv', fname, delta=1E-4)\n\n\tdef test_case_9(self):\n\t\t# example with correlation: the site collection must not be filtered\n\t\tself.run_calc(case_9.__file__, 'job.ini', exports='csv')\n\t\t# this is a case where there are 2 ruptures and 1 gmv per site\n\t\tself.assertEqual(len(self.calc.datastore['gmf_data/eid']), 14)\n\n\tdef test_case_10(self):\n\t\t# this is a case with multiple files in the smlt uncertaintyModel\n\t\t# and with sampling\n\t\tself.run_calc(case_10.__file__, 'job.ini')\n\t\t[fname] = export(('realizations', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/realizations.csv', fname)\n\n\tdef test_case_12(self):\n\t\tout = self.run_calc(case_12.__file__, 'job.ini', exports='csv')\n\t\t[fname] = out['hcurves', 'csv']\n\t\tself.assertEqualFiles(\n\t\t\t'expected/hazard_curve-smltp_b1-gsimltp_b1_b2.csv', fname)\n\n\tdef test_case_13(self):\n\t\tout = self.run_calc(case_13.__file__, 'job.ini', exports='csv')\n\t\t[fname, _, _] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/gmf-data.csv', fname)\n\n\t\t[fname] = out['hcurves', 'csv']\n\t\tself.assertEqualFiles(\n\t\t\t'expected/hazard_curve-smltp_b1-gsimltp_b1.csv', fname)\n\n\tdef test_case_14(self):\n\t\t# sampling of a logic tree of kind `is_source_specific`\n\t\tout = self.run_calc(case_14.__file__, 'job.ini', exports='csv')\n\t\t[fname, _, _] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/gmf-data.csv', fname)\n\n\tdef test_case_15(self):\n\t\t# an example for Japan testing also the XML rupture exporter\n\t\tself.run_calc(case_15.__file__, 'job.ini')\n\t\t[fname] = export(('ruptures', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/ruptures.csv', fname, delta=.004)\n\n\tdef test_case_16(self):\n\t\t# an example with site model raising warnings and autogridded exposure\n\t\t# and GMF amplification too\n\t\tself.run_calc(case_16.__file__, 'job.ini')\n\t\thid = str(self.calc.datastore.calc_id)\n\t\tself.run_calc(case_16.__file__, 'job.ini', hazard_calculation_id=hid)\n\t\ttmp = gettemp(view('global_gmfs', self.calc.datastore))\n\t\tself.assertEqualFiles('expected/global_gmfs.txt', tmp)\n\n\tdef test_case_17(self):  # oversampling\n\t\t# also, grp-00 does not produce ruptures\n\t\texpected = [\n\t\t\t'hazard_curve-mean.csv',\n\t\t\t'hazard_curve-rlz-001.csv',\n\t\t\t'hazard_curve-rlz-002.csv',\n\t\t\t'hazard_curve-rlz-003.csv',\n\t\t\t'hazard_curve-rlz-004.csv',\n\t\t]\n\t\t# test the --hc functionality, i.e. that ruptures are read correctly\n\t\tout = self.run_calc(case_17.__file__, 'job.ini,job.ini', exports='csv')\n\t\tfnames = out['hcurves', 'csv']\n\t\tfor exp, got in zip(expected, fnames):\n\t\t\tself.assertEqualFiles('expected/%s' % exp, got)\n\n\t\t# check that GMFs are not stored\n\t\twith self.assertRaises(KeyError):\n\t\t\tself.calc.datastore['gmf_data']\n\n\tdef test_case_18(self):  # oversampling, 3 realizations\n\t\tout = self.run_calc(case_18.__file__, 'job.ini', exports='csv')\n\t\t[fname, _, _] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/%s' % strip_calc_id(fname), fname,\n\t\t\t\t\t\t\t  delta=1E-6)\n\n\tdef test_case_19(self):  # test for Vancouver using the NRCan15SiteTerm\n\t\tself.run_calc(case_19.__file__, 'job.ini')\n\t\t[gmf, _, _] = export(('gmf_data', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/gmf-data.csv', gmf)\n\n\t\t# a test with grid and site model\n\t\tself.run_calc(case_19.__file__, 'job_grid.ini')\n\t\tself.assertEqual(len(self.calc.datastore['ruptures']), 2)\n\n\t\t# error for missing intensity_measure_types\n\t\twith self.assertRaises(InvalidFile) as ctx:\n\t\t\tself.run_calc(\n\t\t\t\tcase_19.__file__, 'job.ini',\n\t\t\t\thazard_calculation_id=str(self.calc.datastore.calc_id),\n\t\t\t\tintensity_measure_types='')\n\t\tself.assertIn('There are no intensity measure types in',\n\t\t\t\t\t  str(ctx.exception))\n\n\tdef test_case_20(self):  # test for Vancouver using the NRCan15SiteTerm\n\t\tself.run_calc(case_20.__file__, 'job.ini')\n\t\t[gmf, _, _] = export(('gmf_data', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/gmf-data.csv', gmf)\n\n\t\t# check the relevant_events\n\t\tE = extract(self.calc.datastore, 'num_events')['num_events']\n\t\te = len(extract(self.calc.datastore, 'events'))\n\t\tself.assertAlmostEqual(e/E, 0.2263374486)\n\n\t\t# run again the GMF calculation, but this time from stored ruptures\n\t\thid = str(self.calc.datastore.calc_id)\n\t\tself.run_calc(case_20.__file__, 'job.ini', hazard_calculation_id=hid)\n\t\t[gmf, _, _] = export(('gmf_data', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/gmf-data-from-ruptures.csv', gmf)\n\n\tdef test_case_21(self):\n\t\tself.run_calc(case_21.__file__, 'job.ini', exports='csv,xml')\n\t\tself.run_calc(case_21.__file__, 'job.ini',\n\t\t\t\t\t  ses_per_logic_tree_path='900',\n\t\t\t\t\t  number_of_logic_tree_samples='0')\n\n\tdef test_case_22(self):\n\t\tout = self.run_calc(case_22.__file__, 'job.ini', exports='csv')\n\t\t[fname, _, _] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/%s' % strip_calc_id(fname), fname,\n\t\t\t\t\t\t\t  delta=1E-6)\n\n\tdef test_case_23(self):\n\t\t# case with implicit grid and site model on a larger grid\n\t\tout = self.run_calc(case_23.__file__, 'job.ini', exports='csv')\n\t\t[fname] = out['ruptures', 'csv']\n\t\tself.assertEqualFiles('expected/%s' % strip_calc_id(fname), fname,\n\t\t\t\t\t\t\t  delta=1E-4)\n\t\tsio = io.StringIO()\n\t\twrite_csv(sio, self.calc.datastore['sitecol'].array)\n\t\ttmp = gettemp(sio.getvalue())\n\t\tself.assertEqualFiles('expected/sitecol.csv', tmp)\n\n\tdef test_case_24(self):\n\t\t# This is a test for shift_hypo = true - The expected results are the\n\t\t# same ones defined for the case_44 of the classical methodology\n\t\tself.run_calc(case_24.__file__, 'job.ini')\n\t\t[fname] = export(('hcurves', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/hazard_curve-mean-PGA.csv', fname)\n\n\tdef test_case_25(self):\n\t\t# logic tree common + extra\n\t\t# common1.xml contains \"5\" \"6\"\n\t\t# common2.xml contains \"1\" \"2\"\n\t\t# extra1.xml contains \"3\"\n\t\t# extra2.xml contains \"4\"\n\t\t# extra3.xml contains \"7\"\n\t\tself.run_calc(case_25.__file__, 'job.ini')\n\t\tmean, *others = export(('hcurves', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/hazard_curve-PGA.csv', mean)\n\n\t\tself.run_calc(case_25.__file__, 'job2.ini')\n\t\tmean, *others = export(('hcurves', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/hazard_curve-PGA.csv', mean)\n\n\t\t# test with common1.xml present into branchs and sampling\n\t\tself.run_calc(case_25.__file__, 'job_common.ini')\n\t\tmean, *others = export(('ruptures', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/ruptures.csv', mean)\n\n\tdef test_case_26_land(self):\n\t\t# cali landslide simplified\n\t\tself.run_calc(case_26.__file__, 'job_land.ini')\n\t\tdf = self.calc.datastore.read_df('gmf_data', 'sid')\n\t\tpd_mean = df[df.DispProb > 0].DispProb.mean()\n\t\tnd_mean = df[df.Disp > 0].Disp.mean()\n\t\tself.assertGreater(pd_mean, 0)\n\t\tself.assertGreater(nd_mean, 0)\n\t\t[fname, _, _] = export(('gmf_data', 'csv'), self.calc.datastore)\n\t\tarr = read_csv(fname)[:2]\n\t\tself.assertEqual(arr.dtype.names,\n\t\t\t\t\t\t ('site_id', 'event_id', 'gmv_PGA',\n\t\t\t\t\t\t  'sep_Disp', 'sep_DispProb'))\n\n\tdef test_case_26_liq(self):\n\t\t# cali liquefaction simplified\n\t\tself.run_calc(case_26.__file__, 'job_liq.ini')\n\t\t[fname] = export(('avg_gmf', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('avg_gmf.csv', fname)\n\n\tdef test_case_27(self):\n\t\t# splitting ruptures + gmf1 + gmf2\n\t\tself.run_calc(case_27.__file__, 'job.ini',\n\t\t\t\t\t  ground_motion_fields=\"false\")\n\t\tself.assertEqual(len(self.calc.datastore['ruptures']), 15)\n\t\thc_id = str(self.calc.datastore.calc_id)\n\n\t\tself.run_calc(case_27.__file__, 'job.ini', sites_slice=\"0:41\",\n\t\t\t\t\t  hazard_calculation_id=hc_id)\n\t\t[fname] = export(('avg_gmf', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/avg_gmf1.csv', fname)\n\n\t\tself.run_calc(case_27.__file__, 'job.ini', sites_slice=\"41:82\",\n\t\t\t\t\t  hazard_calculation_id=hc_id)\n\t\t[fname] = export(('avg_gmf', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/avg_gmf2.csv', fname)\n\n\tdef test_case_28(self):\n\t\tout = self.run_calc(case_28.__file__, 'job.ini', exports='csv')\n\t\t[fname, _, _] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/%s' % strip_calc_id(fname), fname,\n\t\t\t\t\t\t\t  delta=1E-6)\n\n\tdef test_overflow(self):\n\t\ttoo_many_imts = {'SA(%s)' % period: [0.1, 0.2, 0.3]\n\t\t\t\t\t\t for period in numpy.arange(0.1,  1, 0.001)}\n\t\twith self.assertRaises(ValueError) as ctx:\n\t\t\tself.run_calc(\n\t\t\t\tcase_2.__file__, 'job.ini',\n\t\t\t\tintensity_measure_types_and_levels=str(too_many_imts))\n\t\tself.assertEqual(str(ctx.exception),\n\t\t\t\t\t\t 'The event_based calculator is restricted '\n\t\t\t\t\t\t 'to 256 imts, got 900')\n\n\tdef test_mutex(self):\n\t\tout = self.run_calc(mutex.__file__, 'job.ini', exports='csv,xml')\n\t\t[fname] = out['ruptures', 'csv']\n\t\tself.assertEqualFiles('expected/ruptures.csv', fname, delta=1E-6)\n\n\tdef test_gmpe_tables(self):\n\t\tout = self.run_calc(\n\t\t\tgmpe_tables.__file__, 'job.ini',\n\t\t\tcalculation_mode='event_based',\n\t\t\tinvestigation_time='100',\n\t\t\texports='csv')\n\t\t[fname, _, _] = out['gmf_data', 'csv']\n\t\tself.assertEqualFiles('expected/gmf.csv', fname, delta=1E-6)\n", "description": null, "category": "math", "imports": ["import io", "import os", "import re", "import math", "import pandas", "import numpy.testing", "from openquake.baselib.hdf5 import read_csv", "from openquake.baselib.general import countby, gettemp", "from openquake.hazardlib import InvalidFile", "from openquake.commonlib.datastore import read", "from openquake.baselib.writers import write_csv", "from openquake.commonlib.util import max_rel_diff_index", "from openquake.commonlib.calc import gmvs_to_poes", "from openquake.calculators.views import view", "from openquake.calculators.export import export", "from openquake.calculators.extract import extract", "from openquake.calculators.event_based import get_mean_curves, compute_avg_gmf", "from openquake.calculators.tests import CalculatorTestCase", "from openquake.qa_tests_data.classical import case_18 as gmpe_tables", "from openquake.qa_tests_data.event_based import (", "from openquake.qa_tests_data.event_based.spatial_correlation import ("]}], [{"term": "def", "name": "test_aims_interface", "data": "def test_aims_interface():\n\timport tempfile\n\timport os\n\n\tfrom ase.calculators.aims import Aims\n\tfrom ase import Atoms\n\n\t# test the new command handling + legacy behavior\n\taims_command = 'aims.x'\n\taims_command_alternative = 'mpirun -np 4 fhiaims.x'\n\toutfilename = 'alternative_aims.out'\n\toutfilename_default = 'aims.out'\n\tcommand = '{0:s} > {1:s}'.format(aims_command, outfilename)\n\t#command_alternative = '{0:s} > {1:s}'.format(aims_command_alternative, outfilename)\n\tcommand_default = '{0:s} > {1:s}'.format(aims_command, outfilename_default)\n\tlegacy_command = 'aims.version.serial.x > aims.out'\n\tlegacy_aims_command = legacy_command.split('>')[0].strip()\n\tlegacy_outfilename = legacy_command.split('>')[-1].strip()\n\n\t# legacy behavior of empty init\n\tcalc = Aims()\n\tassert calc.command == legacy_command\n\tassert calc.outfilename == legacy_outfilename\n\tassert calc.aims_command == legacy_aims_command\n\n\t# behavior of empty init with env variable\n\tos.environ['ASE_AIMS_COMMAND'] = aims_command_alternative\n\tcalc = Aims()\n\tassert calc.command == '{0} > {1}'.format(aims_command_alternative, outfilename_default)\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command_alternative\n\n\t# legacy behavior of \"proper\" command\n\tcalc = Aims(run_command=command)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# legacy behavior of an \"improper\" command\n\tcalc = Aims(run_command=aims_command)\n\tassert calc.command == command_default\n\tassert calc.aims_command == aims_command\n\tassert calc.outfilename == outfilename_default\n\n\t# fixed \"command\"  behavior\n\tcalc = Aims(command=command)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# novel way to use aims_command, no specific outfile\n\tcalc = Aims(aims_command=aims_command)\n\tassert calc.command == command_default\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command\n\n\tcalc = Aims(aims_command=aims_command,\n\t\t\t\toutfilename=outfilename)\n\tassert calc.command == command\n\tassert calc.outfilename == outfilename\n\tassert calc.aims_command == aims_command\n\n\t# # testing the setters\n\tcalc.command = command_default\n\tassert calc.outfilename == outfilename_default\n\tassert calc.aims_command == aims_command\n\tassert calc.command == command_default\n\n\t#calc.set_aims_command(aims_command_alternative)\n\tcalc.aims_command = aims_command_alternative\n\tassert calc.aims_command == aims_command_alternative\n\tassert calc.outfilename == outfilename_default\n\tassert calc.command == '{} > {}'.format(aims_command_alternative, outfilename_default)\n\n\tcalc.outfilename = outfilename\n\tassert calc.command == '{} > {}'.format(aims_command_alternative, outfilename)\n\tassert calc.aims_command == aims_command_alternative\n\tassert calc.outfilename == outfilename\n\n\n\t# test writing files\n\ttmp_dir = tempfile.mkdtemp()\n\twater = Atoms('HOH', [(1, 0, 0), (0, 0, 0), (0, 1, 0)])\n\tcalc = Aims(xc='PBE',\n\t\t\t\toutput=['dipole'],\n\t\t\t\tsc_accuracy_etot=1e-6,\n\t\t\t\tsc_accuracy_eev=1e-3,\n\t\t\t\tsc_accuracy_rho=1e-6,\n\t\t\t\tspecies_dir=\"/data/rittmeyer/FHIaims/species_defaults/light/\",\n\t\t\t\tsc_accuracy_forces=1e-4,\n\t\t\t\tlabel=tmp_dir,\n\t\t\t\t)\n\ttry:\n\t\tcalc.prepare_input_files()\n\t\traise AssertionError\n\texcept ValueError:\n\t\tpass\n\n\tcalc.atoms = water\n\tcalc.prepare_input_files()\n\tfor f in ['control.in', 'geometry.in']:\n\t\tassert os.path.isfile(os.path.join(tmp_dir,f))\n", "description": null, "category": "math", "imports": ["\timport tempfile", "\timport os", "\tfrom ase.calculators.aims import Aims", "\tfrom ase import Atoms"]}], [{"term": "def", "name": "weight_fun", "data": "def weight_fun(x, a, b, c):\n\treturn a + b * np.cos(x) + c * np.sin(x)\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calc_weights", "data": "def calc_weights(num_classes, coeffs):\n\tk2PI = 2* np.pi\n\tx = np.linspace(0, k2PI, num_classes)\n\tdata_len = coeffs.shape[0]\n\tweights = np.zeros((data_len, num_classes))\n\tfor i in range(data_len):\n\t\tweights[i] = weight_fun(x, *coeffs[i])\n\treturn weights\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calc_argmaxs_distances", "data": "def calc_argmaxs_distances(pred_arg_maxs, calc_arg_maxs, num_class):\n\treturn calculate_deltas_signed(calc_arg_maxs, pred_arg_maxs, num_class)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics_from_file", "data": "def calculate_metrics_from_file(directory, num_classes):\n\tcalc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n\tpreds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n\treturn calculate_metrics(calc_w, preds_w, num_classes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics", "data": "def calculate_metrics(calc_w, preds_w, num_classes):\n\tpred_arg_maxs = np.argmax(preds_w, axis=1)\n\tcalc_arg_maxs = np.argmax(calc_w, axis=1)\n\n\tk2PI = 2 * np.pi\n\tcalc_pred_argmaxs_abs_distances = calculate_deltas_unsigned( pred_arg_maxs, calc_arg_maxs, num_classes)\n\tcalc_pred_argmaxs_signed_distances = calculate_deltas_signed(pred_arg_maxs, calc_arg_maxs, num_classes)\n\tcalc_pred_argmaxs_abs_distances_rad = calc_pred_argmaxs_abs_distances * k2PI/(1.0*num_classes)\n\t\n\tmean_deltas = np.mean(calc_pred_argmaxs_signed_distances, dtype=np.float64)\n\tmean_deltas_err = stats.sem(calc_pred_argmaxs_signed_distances)\n\tmean_deltas_rad = mean_deltas * k2PI/(1.0*num_classes)\n\tmean_deltas_err_rad = mean_deltas_err * k2PI/(1.0*num_classes)\n\n\tacc0 = (calc_pred_argmaxs_abs_distances <= 0).mean()\n\tacc1 = (calc_pred_argmaxs_abs_distances <= 1).mean()\n\tacc2 = (calc_pred_argmaxs_abs_distances <= 2).mean()\n\tacc3 = (calc_pred_argmaxs_abs_distances <= 3).mean()\n\n\tacc0_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.25).mean()\n\tacc1_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.50).mean()\n\tacc2_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.75).mean()\n\tacc3_rad = (calc_pred_argmaxs_abs_distances_rad <= 1.00).mean()\n\n\tl1_delta_w = np.mean(np.abs(calc_w - preds_w), dtype=np.float64)\n\tl2_delta_w = np.sqrt(np.mean((calc_w - preds_w)**2), dtype=np.float64)\n\t# problem with format, should not be array\n\tl2_delta_w_err = stats.sem((calc_w - preds_w)**2)\n\n\t# calc_w, preds_w normalisation to probability\n\tcalc_w_norm = calc_w / np.sum(calc_w, axis=1)[:, np.newaxis]\n\tpreds_w_norm = preds_w / np.sum(preds_w, axis=1)[:, np.newaxis]\n \n\tl1_delta_w_norm = np.mean(np.abs(calc_w_norm - preds_w_norm), dtype=np.float64)\n\tl2_delta_w_norm = np.sqrt(np.mean((calc_w_norm - preds_w_norm)**2), dtype=np.float64)\n\t# problem with format, should not be array\n\tl2_delta_w_norm_err = stats.sem((calc_w_norm - preds_w_norm)**2)\n  \n\t\n\treturn np.array([acc0, acc1, acc2, acc3, mean_deltas, l1_delta_w, l2_delta_w, mean_deltas_rad, acc0_rad, acc1_rad, acc2_rad, acc3_rad,l1_delta_w_norm, l2_delta_w_norm, mean_deltas_err, mean_deltas_err_rad, l2_delta_w_err, l2_delta_w_norm_err ]) \n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics_regr_c012s_from_file", "data": "def calculate_metrics_regr_c012s_from_file(directory, num_classes):\n\tcalc_c012s = np.load(os.path.join(directory,'test_regr_calc_c012s.npy'))\n\tpred_c012s = np.load(os.path.join(directory,'test_regr_preds_c012s.npy'))\n\n\treturn calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics_regr_c012s", "data": "def calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes):\n\tcalc_w  = calc_weights(num_classes, calc_c012s)\n\tpreds_w = calc_weights(num_classes, pred_c012s)\n\n\treturn calculate_metrics(calc_w, preds_w, num_classes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "get_filename_for_class", "data": "def get_filename_for_class(pathIN, class_num, subset=None):\n\td = '../monit_npy/nn_rhorho_Variant-All_Unweighted_False_NO_NUM_CLASSES_{class_num}'\n\tif subset:\n\t\td += \"_WEIGHTS_SUBS\" + str(subset)\n\treturn d\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "evaluate_roc_auc", "data": "def evaluate_roc_auc(preds, wa, wb):\n\tn = len(preds)\n\ttrue_labels = np.concatenate([np.ones(n), np.zeros(n)])\n\tpreds = np.concatenate([preds, preds])\n\tweights = np.concatenate([wa, wb])\n\t\n\treturn roc_auc_score(true_labels, preds, sample_weight=weights)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_roc_auc", "data": "def calculate_roc_auc(preds_w, calc_w, index_a, index_b):\n\tn, num_classes = calc_w.shape\n\ttrue_labels = np.concatenate([np.ones(n), np.zeros(n)])\n\tpreds = np.concatenate([preds_w[:, index_a], preds_w[:, index_a]])\n\tweights = np.concatenate([calc_w[:, index_a], calc_w[:, index_b]])\n\n\treturn roc_auc_score(true_labels, preds, sample_weight=weights)\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "test_roc_auc", "data": "def test_roc_auc(directory, num_class):\n\tcalc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n\tpreds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n\t\n\toracle_roc_auc = []\n\tpreds_roc_auc  = []\n\t\n\tfor i in range(0, num_class):\n\t\t oracle_roc_auc  += [calculate_roc_auc(calc_w, calc_w, 0, i)]\n\t\t preds_roc_auc   += [calculate_roc_auc(preds_w, calc_w, 0, i)]\n\t\t print(i,\n\t\t\t\t  'oracle_roc_auc: {}'.format(calculate_roc_auc(calc_w, calc_w, 0, i)),\n\t\t\t\t  'preds_roc_auc: {}'.format(calculate_roc_auc(preds_w, calc_w, 0, i)))\n\n\treturn oracle_roc_auc, preds_roc_auc\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}], [{"term": "def", "name": "calc_get_total", "data": "def calc_get_total():\n\t\"\"\"\n\t  Current total\n\t  return a list with 2 elements representing a rational number\n\t\"\"\"\n\treturn calc_total\n", "description": "\n\t  Current total\n\t  return a list with 2 elements representing a rational number\n\t", "category": "math", "imports": ["from domain.rational import *"]}, {"term": "def", "name": "undo", "data": "def undo():\n\t\"\"\"\n\t  Undo the last user operation\n\t  post: restore the previous current total\n\t\"\"\"\n\tglobal undolist\n\tglobal calc_total\n\tcalc_total = undolist[-1]\n\tundolist = undolist[:-1]\n", "description": "\n\t  Undo the last user operation\n\t  post: restore the previous current total\n\t", "category": "math", "imports": ["from domain.rational import *"]}, {"term": "def", "name": "calc_add", "data": "def calc_add(a, b):\n\t\"\"\"\n\t  add a rational number to the current total\n\t  a, b integer number, b<>0\n\t  post: add a/b to the current total\n\t\"\"\"\n\tglobal undolist\n\tglobal calc_total\n\t#add the current total to the undo list\n\tundolist.append(calc_total)\n\tcalc_total = rational_add (calc_total[0], calc_total[1], a, b)\n\n", "description": "\n\t  add a rational number to the current total\n\t  a, b integer number, b<>0\n\t  post: add a/b to the current total\n\t", "category": "math", "imports": ["from domain.rational import *"]}, {"term": "def", "name": "reset_calc", "data": "def reset_calc():\n\t\"\"\"\n\t  Reset the calculator\n\t  post: the curent total equal 0/1\n\t\"\"\"\n\tglobal calc_total\n\tcalc_total = [0, 1]\n\n\tglobal undolist\n\tundolist = []\n\n", "description": "\n\t  Reset the calculator\n\t  post: the curent total equal 0/1\n\t", "category": "math", "imports": ["from domain.rational import *"]}, {"term": "def", "name": "test_rational_add", "data": "def test_rational_add():\n\t\"\"\"\n\t  Test function for rational_add\n\t\"\"\"\n\tassert rational_add(1, 2, 1, 3) == [5, 6]\n\tassert rational_add(1, 2, 1, 2) == [1, 1]\n", "description": "\n\t  Test function for rational_add\n\t", "category": "math", "imports": ["from domain.rational import *"]}, {"term": "def", "name": "test_calculator_add", "data": "def test_calculator_add():\n\t\"\"\"\n\t  Test function for calculator_add\n\t\"\"\"\n\treset_calc()\n\tassert calc_get_total() == [0, 1]\n\tcalc_add(1, 2)\n\tassert calc_get_total() == [1, 2]\n\tcalc_add(1, 3)\n\tassert calc_get_total() == [5, 6]\n\tcalc_add(1, 6)\n\tassert calc_get_total() == [1, 1]\n", "description": "\n\t  Test function for calculator_add\n\t", "category": "math", "imports": ["from domain.rational import *"]}, {"term": "def", "name": "test_undo", "data": "def test_undo():\n\t\"\"\"\n\t  Test function for undo\n\t\"\"\"\n\treset_calc()\n\tcalc_add(1, 3)\n\tundo()\n\tassert calc_get_total() == [0, 1]\n\treset_calc()\n\tcalc_add(1, 3)\n\tcalc_add(1, 3)\n\tcalc_add(1, 3)\n\tundo()\n\tassert calc_get_total() == [2, 3]\n\n", "description": "\n\t  Test function for undo\n\t", "category": "math", "imports": ["from domain.rational import *"]}], [{"term": "def", "name": "LTsv_calc_GCM", "data": "def LTsv_calc_GCM(LTsv_calcL,LTsv_calcR):\n\tLTsv_GCMm,LTsv_GCMn=abs(int(LTsv_calcL)),abs(int(LTsv_calcR))\n\tif LTsv_GCMm < LTsv_GCMn:\n\t\tLTsv_GCMm,LTsv_GCMn=LTsv_GCMn,LTsv_GCMm\n\twhile LTsv_GCMn > 0:\n\t\tLTsv_GCMm,LTsv_GCMn=LTsv_GCMn,LTsv_GCMm%LTsv_GCMn\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import re", "import math", "\tfrom LTsv_printf import *", "\tfrom LTsv_file   import *"]}, {"term": "def", "name": "LTsv_calc_LCM", "data": "def LTsv_calc_LCM(LTsv_calcL,LTsv_calcR):\n\treturn abs(int(LTsv_calcL))*abs(int(LTsv_calcR))//LTsv_calc_GCM(LTsv_calcL,LTsv_calcR)\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import re", "import math", "\tfrom LTsv_printf import *", "\tfrom LTsv_file   import *"]}, {"term": "def", "name": "LTsv_calc_bracketsbalance", "data": "def LTsv_calc_bracketsbalance(LTsv_calcQbase):\n\tLTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t',''); LTsv_calcA=\"\"\n\tLTsv_bracketLR=0; LTsv_bracketCAP=0\n\tfor LTsv_Q in LTsv_calcQ:\n\t\tif LTsv_Q in LTsv_opechardic:\n\t\t\tLTsv_Q=LTsv_opechardic[LTsv_Q]\n\t\tif LTsv_Q in LTsv_calcusemark:\n\t\t\tLTsv_calcA+=LTsv_Q\n\t\tif LTsv_Q == '(':\n\t\t\tLTsv_bracketLR+=1\n\t\tif LTsv_Q == ')':\n\t\t\tLTsv_bracketLR-=1\n\t\t\tif LTsv_bracketLR 0:\n\t\tLTsv_calcA=LTsv_calcA+')'*abs(LTsv_bracketLR)\n\tif LTsv_bracketLR < 0:\n\t\tLTsv_calcA='('*abs(LTsv_bracketLR)+LTsv_calcA\n\tLTsv_calcA='('*abs(LTsv_bracketCAP)+LTsv_calcA+')'*abs(LTsv_bracketCAP)\n\tLTsv_calcA=LTsv_calcA.replace('y','('+str(math.pi)+')').replace('e','('+str(math.e)+')').replace('n','(n|0)')\n\tfor LTsv_opecase in LTsv_opemarkdic:\n\t\tif LTsv_opecase in LTsv_calcA:\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import re", "import math", "\tfrom LTsv_printf import *", "\tfrom LTsv_file   import *"]}, {"term": "def", "name": "LTsv_calc_decimalize", "data": "def LTsv_calc_decimalize(LTsv_calcQbase):\n\tLTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t','').replace('\\t',''); LTsv_calcA=\"n|0\"\n\tif not '|' in LTsv_calcQ:\n\t\tLTsv_calcQ+='|1'\n\tLTsv_calcQ=LTsv_calcQ.replace('/','|')\n\tLTsv_calcQsplits=LTsv_calcQ.split('|')\n\tLTsv_calcQmulti=LTsv_calcQsplits.pop(0)\n\tif 'n' in LTsv_calcQmulti:\n\t\tLTsv_calcQsplits=[0.0]\n\telse:\n\t\tLTsv_decinum=float(LTsv_calcQmulti)\n\tfor LTsv_calcQmulti in LTsv_calcQsplits:\n\t\tif float(LTsv_calcQmulti) == 0.0:\n\t\t\tbreak\n\t\tLTsv_decinum/=float(LTsv_calcQmulti)\n\telse:\n\t\tLTsv_calcA=str(LTsv_decinum)\n\treturn LTsv_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import re", "import math", "\tfrom LTsv_printf import *", "\tfrom LTsv_file   import *"]}, {"term": "def", "name": "LTsv_calc_fractalize", "data": "def LTsv_calc_fractalize(LTsv_calcQbase):\n\tLTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t','').replace('\\t',''); LTsv_calcA=\"n|0\"\n\tif not '|' in LTsv_calcQ:\n\t\tLTsv_calcQ+='|1'\n\tLTsv_calcQ=LTsv_calcQ.replace('/','|')\n\tLTsv_calcQsplits=LTsv_calcQ.split('|')\n\tLTsv_calcQmulti=LTsv_calcQsplits.pop(0)\n\tif 'n' in LTsv_calcQmulti:\n\t\tLTsv_calcQsplits=[\"0.0\"]\n\telse:\n\t\tLTsv_calcQmulti=LTsv_calcQmulti.replace('+','').replace('-','') if not '-' in LTsv_calcQmulti else '-'+LTsv_calcQmulti.replace('+','').replace('-','')\n\t\tLTsv_calcQmulti=LTsv_calcQmulti if '.' in LTsv_calcQmulti else LTsv_calcQmulti+'.'\n\t\tLTsv_fractdeno=int('1'+'0'*(len(LTsv_calcQmulti)-1-LTsv_calcQmulti.find('.')))\n\t\tLTsv_calcQmulti=LTsv_calcQmulti.replace('.','')\n\t\tLTsv_fractnum=int(LTsv_calcQmulti) if len(LTsv_calcQmulti) > 0 and LTsv_calcQmulti != \"-\" else 0\n\tfor LTsv_calcQmulti in LTsv_calcQsplits:\n\t\tLTsv_calcQmulti=LTsv_calcQmulti.replace('+','').replace('-','') if not '-' in LTsv_calcQmulti else '-'+LTsv_calcQmulti.replace('+','').replace('-','')\n\t\tLTsv_calcQmulti=LTsv_calcQmulti if '.' in LTsv_calcQmulti else LTsv_calcQmulti+'.'\n\t\tif LTsv_calcQmulti in [\".\",\"-.\"]:\n\t\t\tLTsv_calcQmulti=\"0.0\"\n\t\tif LTsv_calcQmulti.count('.') > 1:\n\t\t\tLTsv_calcQmulti=\"0.0\"\n\t\tif float(LTsv_calcQmulti) == 0.0:\n\t\t\tbreak\n\t\tLTsv_fractnum*=int('1'+'0'*(len(LTsv_calcQmulti)-1-LTsv_calcQmulti.find('.')))\n\t\tLTsv_calcQmulti=LTsv_calcQmulti.replace('.','')\n\t\tLTsv_fractdeno*=int(LTsv_calcQmulti) if len(LTsv_calcQmulti) > 0 else 0\n\telse:\n\t\tLTsv_GCM=LTsv_calc_GCM(LTsv_fractnum,LTsv_fractdeno)\n\t\tLTsv_fractdeno=LTsv_fractdeno//LTsv_GCM\n\t\tLTsv_fractnum=LTsv_fractnum//LTsv_GCM\n\t\tLTsv_calcA=str(LTsv_fractnum)+\"|\"+str(LTsv_fractdeno)\n\treturn LTsv_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import re", "import math", "\tfrom LTsv_printf import *", "\tfrom LTsv_file   import *"]}, {"term": "def", "name": "LTsv_calc", "data": "def LTsv_calc(LTsv_calcQbase):\n\tLTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t',''); LTsv_calcA=\"n|0\"\n\tLTsv_calcQ=LTsv_calc_bracketsbalance(LTsv_calcQbase); LTsv_calcA=LTsv_calcQ\n\tLTsv_bracketreg=re.compile(\"[(](?<=[(])[^()]*(?=[)])[)]\")\n\twhile \"(\" in LTsv_calcA:\n\t\tfor LTsv_func in re.findall(LTsv_bracketreg,LTsv_calcA):\n\t\t\tLTsv_calcA=LTsv_calcA.replace(LTsv_func,LTsv_calc_function(LTsv_func))\n\tLTsv_calcA=LTsv_calcA.replace(LTsv_calcA,LTsv_calc_function(LTsv_calcA))\n\tLTsv_calcA=LTsv_calc_fractalize(LTsv_calcA)\n\tif LTsv_calcA==LTsv_calcQ:\n\t\tLTsv_calcA=LTsv_calc_decimalize(LTsv_calcA)\n\treturn LTsv_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import re", "import math", "\tfrom LTsv_printf import *", "\tfrom LTsv_file   import *"]}, {"term": "def", "name": "LTsv_calc_function", "data": "def LTsv_calc_function(LTsv_calcQbase):\n\tLTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t','').replace('\\t',''); LTsv_calcA=\"\"\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import re", "import math", "\tfrom LTsv_printf import *", "\tfrom LTsv_file   import *"]}, {"term": "def", "name": "LTsv_calc_addition", "data": "def LTsv_calc_addition(LTsv_calcQbase,LTsv_Count):\n\tLTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t','').replace('\\t',''); LTsv_calcA=\"n|0\"\n\tLTsv_calcQ=LTsv_calcQ.replace('c',LTsv_Count)\n\tLTsv_calcQ=LTsv_calcQ.replace(\"++\",\"+\").replace(\"+-\",\"-\").replace(\"--\",\"+\").replace(\"-+\",\"-\")\n\tLTsv_calcQ=LTsv_calcQ.replace('+','\\t+').replace('-','\\t-')\n\tLTsv_fractnum,LTsv_fractdeno=0,1\n\tLTsv_calcQsplits=LTsv_calcQ.strip('\\t').split('\\t')\n\tfor LTsv_calcQmulti in LTsv_calcQsplits:\n\t\tLTsv_fractC='' if not '%' in LTsv_calcQmulti else '%'\n\t\tLTsv_calcR=LTsv_calc_multiplication(LTsv_calcQmulti.replace('%',''))\n\t\tLTsv_fractR=LTsv_calcR.split('|')\n\t\tif float(LTsv_fractR[1]) == 0.0:\n\t\t\tbreak\n\t\tif LTsv_fractC == '%':\n\t\t\tLTsv_fractnum=LTsv_fractnum*int(LTsv_fractR[1])*100+LTsv_fractnum*int(LTsv_fractR[0])\n\t\t\tLTsv_fractdeno*=int(LTsv_fractR[1])*100\n\t\telse:\n\t\t\tLTsv_fractnum=LTsv_fractnum*int(LTsv_fractR[1])+LTsv_fractdeno*int(LTsv_fractR[0])\n\t\t\tLTsv_fractdeno*=int(LTsv_fractR[1])\n\telse:\n\t\tif LTsv_fractdeno < 0:\n\t\t\tLTsv_fractnum,LTsv_fractdeno=-LTsv_fractnum,-LTsv_fractdeno\n\t\tLTsv_calcA=str(LTsv_fractnum)+'|'+str(LTsv_fractdeno)\n\treturn LTsv_calcA\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import re", "import math", "\tfrom LTsv_printf import *", "\tfrom LTsv_file   import *"]}, {"term": "def", "name": "LTsv_calc_multiplication", "data": "def LTsv_calc_multiplication(LTsv_calcQbase):\n\tLTsv_calcQ=LTsv_calcQbase.replace('\\n','\\t').replace('\\t','').replace('\\t',''); LTsv_calcA=\"n|0\"\n\tLTsv_calcQ=LTsv_calcQ.replace('*',\"\\t*\").replace('/',\"\\t/\").replace('\\\\',\"\\t\\\\\").replace('#',\"\\t#\").replace('L',\"\\tL\").replace('G',\"\\tG\")\n\tLTsv_calcQ=LTsv_calcQ.replace(\"+p\",\"+\").replace(\"+m\",\"-\").replace(\"-m\",\"+\").replace(\"-p\",\"-\")\n\tLTsv_calcQ=LTsv_calcQ.replace(\"p\",\"+\").replace(\"m\",\"-\")\n\tLTsv_fractnum,LTsv_fractdeno=1,1; LTsv_fractC='*'\n\tLTsv_calcQsplits=LTsv_calcQ.strip('\\t').split('\\t')\n\tfor LTsv_calcQfraction in LTsv_calcQsplits:\n\t\tLTsv_fractC=LTsv_calcQfraction[0] if len(LTsv_calcQfraction)>0 else '*'\n\t\tLTsv_calcR=LTsv_calc_fractalize(LTsv_calcQfraction.lstrip('*/\\\\#LG'))\n\t\tLTsv_fractR=LTsv_calcR.split('|')\n\t\tif LTsv_fractC == '/':\n\t\t\tif int(LTsv_fractR[0]) == 0:\n\t\t\t\tbreak\n\t\t\tLTsv_fractnum*=int(LTsv_fractR[1])\n\t\t\tLTsv_fractdeno*=int(LTsv_fractR[0])\n\t\telif LTsv_fractC == '\\\\':\n\t\t\tif int(LTsv_fractR[0]) == 0:\n\t\t\t\tbreak\n\t\t\tLTsv_fractnum*=int(LTsv_fractR[1])\n\t\t\tLTsv_fractdeno*=int(LTsv_fractR[0])\n\t\t\tLTsv_fractnum,LTsv_fractdeno=LTsv_fractnum//LTsv_fractdeno,1\n\t\telif LTsv_fractC == '#':\n\t\t\tif int(LTsv_fractR[0]) == 0 or int(LTsv_fractR[1]) == 0:\n\t\t\t\tbreak\n\t\t\tLTsv_fractnum=(LTsv_fractnum*int(LTsv_fractR[1]))%(LTsv_fractdeno*int(LTsv_fractR[0]))\n\t\t\tLTsv_fractdeno*=int(LTsv_fractR[1])\n\t\telif LTsv_fractC == 'L':\n\t\t\tif LTsv_fractdeno == int(LTsv_fractR[1]):\n\t\t\t\tLTsv_fractnum=LTsv_calc_LCM(LTsv_fractnum,int(LTsv_fractR[0]))\n\t\t\t\tLTsv_fractdeno=1\n\t\t\telse:\n\t\t\t\tbreak\n\t\telif LTsv_fractC == 'G':\n\t\t\tif LTsv_fractdeno == int(LTsv_fractR[1]):\n\t\t\t\tLTsv_fractnum=LTsv_calc_GCM(LTsv_fractnum,int(LTsv_fractR[0]))\n\t\t\t\tLTsv_fractdeno=1\n\t\t\telse:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tif int(LTsv_fractR[1]) == 0:\n\t\t\t\tbreak\n\t\t\tLTsv_fractnum*=int(LTsv_fractR[0])\n\t\t\tLTsv_fractdeno*=int(LTsv_fractR[1])\n\telse:\n\t\tLTsv_calcA=LTsv_calc_fractalize(str(LTsv_fractnum)+'|'+str(LTsv_fractdeno))\n\treturn LTsv_calcA\n\n", "description": null, "category": "math", "imports": ["from __future__ import division,print_function,absolute_import,unicode_literals", "import re", "import math", "\tfrom LTsv_printf import *", "\tfrom LTsv_file   import *"]}], [{"term": "class", "name": "TestCalc", "data": "class TestCalc(unittest.TestCase):\n\n\tdef test_add(self):\n\t\tself.assertEqual(calc.add(10, 5), 15)\n\t\tself.assertEqual(calc.add(10, -5), 5)\n\t\tself.assertEqual(calc.add(-5, -5), -10)\n\n\tdef test_substruct(self):\n\t\tself.assertEqual(calc.substruct(10, 5), 5)\n\t\tself.assertEqual(calc.substruct(10, -5), 15)\n\t\tself.assertEqual(calc.substruct(-5, -5), 0)\n\n\tdef test_multiply(self):\n\t\tself.assertEqual(calc.multiply(10, 5), 50)\n\t\tself.assertEqual(calc.multiply(10, -5), -50)\n\t\tself.assertEqual(calc.multiply(-5, -5), 25)\n\t\tself.assertEqual(calc.multiply(10, 0), 0)\n\n\tdef test_divison(self):\n\t\tself.assertEqual(calc.divison(10, 5), 2)\n\t\tself.assertEqual(calc.divison(1, -1), -1)\n\t\tself.assertEqual(calc.divison(-1, -1), 1)\n\t\tself.assertEqual(calc.divison(5, 2), 2.5)\n\n\t\twith self.assertRaises(ValueError):\n\t\t\tcalc.divison(10, 0)\n\n\tdef test_modulo(self):\n\t\tself.assertEqual(calc.modulo(11, 5), 1)\n\t\tself.assertEqual(calc.modulo(10, 5), 0)\n\t\tself.assertEqual(calc.modulo(-11, 5), 4)\n\t\tself.assertEqual(calc.modulo(11, -5), -4)\n\n\tdef test_power(self):\n\t\tself.assertEqual(calc.power(2, 2), 4)\n\t\tself.assertEqual(calc.power(10, 0), 1)\n\t\tself.assertEqual(calc.power(4, 0.5), 2)\n\t\tself.assertEqual(calc.power(4, -2), 0.0625)\n", "description": null, "category": "math", "imports": ["import unittest", "from unittest import result", "import calc"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await ultroid_bot.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "Actualiser", "data": "def Actualiser(txt):\n\ttry:\n\t\tif lib.textCalc == '0' and str(txt) in '0123456789':\n\t\t\tlib.textCalc = str(txt)\n\t\t\tcalcTxt.config(text=lib.textCalc)\n\t\t\treturn\n\t\tif txt == 'SUPPR' :\n\t\t\tif lib.textCalc == 'Error' :\n\t\t\t\tlib.textCalc = ''\n\t\t\t\tcalcTxt.config(text=lib.textCalc)\n\t\t\t\treturn\n\t\t\tif lib.textCalc == \"Error, result too long\" :\n\t\t\t\tlib.textCalc = ''\n\t\t\t\tcalcTxt.config(text=lib.textCalc)\n\t\t\t\treturn\n\t\t\tif lib.textCalc == '' :\n\t\t\t\treturn\n\t\t\tlib.textCalc = list(lib.textCalc)\n\t\t\tlib.textCalc.pop()\n\t\t\tlib.textCalc = ''.join(lib.textCalc)\n\t\t\tcalcTxt.config(text=lib.textCalc)\n\t\t\treturn\n\t\tif lib.textCalc == \"Error, result too long\" and str(txt) != '=' :\n\t\t\tlib.textCalc = str(txt)\n\t\t\tcalcTxt.config(text=lib.textCalc)\n\t\t\treturn\n\t\tif lib.textCalc == 'Error' and str(txt) != '=' :\n\t\t\tlib.textCalc = str(txt)\n\t\t\tcalcTxt.config(text=lib.textCalc)\n\t\t\treturn\n\t\tif txt == '=' :\n\t\t\tlib.textCalc = str(round(eval(lib.textCalc),3))\n\t\t\tif len(lib.textCalc) >= 21 :\n\t\t\t\tlib.textCalc = \"Error, result too long\"\n\t\t\tcalcTxt.config(text=lib.textCalc)\n\t\t\treturn\n\t\tif len(lib.textCalc) >= 21 :\n\t\t\treturn\n\t\tlib.textCalc += str(txt)\n\t\tcalcTxt.config(text=lib.textCalc)\n\texcept:\n\t\tlib.textCalc = \"Error\"\n\t\tcalcTxt.config(text=lib.textCalc)\n", "description": null, "category": "math", "imports": ["import tkinter", "from tkinter import ttk", "import tkinter.font as tkfont", "from functools import partial", "import lib"]}, {"term": "def", "name": "ChangeTheme", "data": "def ChangeTheme(*args):\n\tlib.buttonColor = colors[option.get()][0]\n\tlib.fenetreColor = colors[option.get()][1]\n\tlib.textColor = colors[option.get()][2]\n\tfenetre.configure(bg=lib.fenetreColor)\n\tcalcTxt.config(bg=lib.fenetreColor,fg=lib.textColor)\n\tfor key in h.keys():\n\t\th[key].config(highlightbackground=lib.buttonColor,\n\t\t\t\t   bg=lib.buttonColor,\n\t\t\t\t   fg=lib.textColor)\n", "description": null, "category": "math", "imports": ["import tkinter", "from tkinter import ttk", "import tkinter.font as tkfont", "from functools import partial", "import lib"]}], [{"term": "class", "name": "EvaluatorTest", "data": "class EvaluatorTest(unittest.TestCase):\n\t\"\"\"\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t\"\"\"\n\n\tdef test_number_input(self):\n\t\t\"\"\"\n\t\tTest different kinds of float inputs\n\n\t\tSee also\n\t\t  test_trailing_period (slightly different)\n\t\t  test_exponential_answer\n\t\t  test_si_suffix\n\t\t\"\"\"\n\t\teasy_eval = lambda x: calc.evaluator({}, {}, x)\n\n\t\tself.assertEqual(easy_eval(\"13\"), 13)\n\t\tself.assertEqual(easy_eval(\"3.14\"), 3.14)\n\t\tself.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n\t\tself.assertEqual(easy_eval(\"-13\"), -13)\n\t\tself.assertEqual(easy_eval(\"-3.14\"), -3.14)\n\t\tself.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n\tdef test_period(self):\n\t\t\"\"\"\n\t\tThe string '.' should not evaluate to anything.\n\t\t\"\"\"\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '.')\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '1+.')\n\n\tdef test_trailing_period(self):\n\t\t\"\"\"\n\t\tTest that things like '4.' will be 4 and not throw an error\n\t\t\"\"\"\n\t\tself.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n\tdef test_exponential_answer(self):\n\t\t\"\"\"\n\t\tTest for correct interpretation of scientific notation\n\t\t\"\"\"\n\t\tanswer = 50\n\t\tcorrect_responses = [\n\t\t\t\"50\", \"50.0\", \"5e1\", \"5e+1\",\n\t\t\t\"50e0\", \"50.0e0\", \"500e-1\"\n\t\t]\n\t\tincorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n\t\tfor input_str in correct_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\t\tfor input_str in incorrect_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to not equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertNotEqual(answer, result, msg=fail_msg)\n\n\tdef test_si_suffix(self):\n\t\t\"\"\"\n\t\tTest calc.py's unique functionality of interpreting si 'suffixes'.\n\n\t\tFor instance 'k' stand for 'kilo-' so '1k' should be 1,000\n\t\t\"\"\"\n\t\ttest_mapping = [\n\t\t\t('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n\t\t\t('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n\t\t\t('5.4m', 0.0054), ('8.7u', 0.0000087),\n\t\t\t('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n\t\t]\n\n\t\tfor (expr, answer) in test_mapping:\n\t\t\ttolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n\t\t\tfail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n\t\t\tfail_msg = fail_msg.format(expr[-1], expr, answer)\n\t\t\tself.assertAlmostEqual(\n\t\t\t\tcalc.evaluator({}, {}, expr), answer,\n\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t)\n\n\tdef test_operator_sanity(self):\n\t\t\"\"\"\n\t\tTest for simple things like '5+2' and '5/2'\n\t\t\"\"\"\n\t\tvar1 = 5.0\n\t\tvar2 = 2.0\n\t\toperators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n\t\tfor (operator, answer) in operators:\n\t\t\tinput_str = \"{0} {1} {2}\".format(var1, operator, var2)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n\t\t\t\toperator, input_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\tdef test_raises_zero_division_err(self):\n\t\t\"\"\"\n\t\tEnsure division by zero gives an error\n\t\t\"\"\"\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0.0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({'x': 0.0}, {}, '1/x')\n\n\tdef test_parallel_resistors(self):\n\t\t\"\"\"\n\t\tTest the parallel resistor operator ||\n\n\t\tThe formula is given by\n\t\t\ta || b || c ...\n\t\t\t= 1 / (1/a + 1/b + 1/c + ...)\n\t\tIt is the resistance of a parallel circuit of resistors with resistance\n\t\ta, b, c, etc&. See if this evaulates correctly.\n\t\t\"\"\"\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n\t\tself.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n\tdef test_parallel_resistors_with_zero(self):\n\t\t\"\"\"\n\t\tCheck the behavior of the || operator with 0\n\t\t\"\"\"\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n\tdef assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n\t\t\"\"\"\n\t\tHelper function to test many values at once\n\n\t\tTest the accuracy of evaluator's use of the function given by fname\n\t\tSpecifically, the equality of `fname(ins[i])` against outs[i].\n\t\tThis is used later to test a whole bunch of f(x) = y at a time\n\t\t\"\"\"\n\n\t\tfor (arg, val) in zip(ins, outs):\n\t\t\tinput_str = \"{0}({1})\".format(fname, arg)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n\t\t\t\tfname, input_str, val\n\t\t\t)\n\t\t\tself.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n\tdef test_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the trig functions provided in calc.py\n\n\t\twhich are: sin, cos, tan, arccos, arcsin, arctan\n\t\t\"\"\"\n\n\t\tangles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n\t\tcos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n\t\ttan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n\t\t# Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n\t\tself.assert_function_values('sin', angles, sin_values)\n\t\tself.assert_function_values('cos', angles, cos_values)\n\t\tself.assert_function_values('tan', angles, tan_values)\n\n\t\t# Include those where the real part is between -pi/2 and pi/2\n\t\tarcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n\t\tarcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n\t\tself.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n\t\t# Rather than a complex number, numpy.arcsin gives nan\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n\t\t# Include those where the real part is between 0 and pi\n\t\tarccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n\t\tarccos_angles = [0, 0.524, 0.628, 1 + 1j]\n\t\tself.assert_function_values('arccos', arccos_inputs, arccos_angles)\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n\t\t# Has the same range as arcsin\n\t\tarctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n\t\tarctan_angles = arcsin_angles\n\t\tself.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n\tdef test_reciprocal_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the reciprocal trig functions provided in calc.py\n\n\t\twhich are: sec, csc, cot, arcsec, arccsc, arccot\n\t\t\"\"\"\n\t\tangles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n\t\tcsc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n\t\tcot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n\t\tself.assert_function_values('sec', angles, sec_values)\n\t\tself.assert_function_values('csc', angles, csc_values)\n\t\tself.assert_function_values('cot', angles, cot_values)\n\n\t\tarcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n\t\tarcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n\t\tself.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n\t\tarccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n\t\tarccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n\t\tself.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n\t\t# Has the same range as arccsc\n\t\tarccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n\t\tarccot_angles = arccsc_angles\n\t\tself.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n\tdef test_hyperbolic_functions(self):\n\t\t\"\"\"\n\t\tTest the hyperbolic functions\n\n\t\twhich are: sinh, cosh, tanh, sech, csch, coth\n\t\t\"\"\"\n\t\tinputs = ['0', '0.5', '1', '2', '1+j']\n\t\tneg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n\t\tnegate = lambda x: [-k for k in x]\n\n\t\t# sinh is odd\n\t\tsinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n\t\tself.assert_function_values('sinh', inputs, sinh_vals)\n\t\tself.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n\t\t# cosh is even - do not negate\n\t\tcosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n\t\tself.assert_function_values('cosh', inputs, cosh_vals)\n\t\tself.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n\t\t# tanh is odd\n\t\ttanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n\t\tself.assert_function_values('tanh', inputs, tanh_vals)\n\t\tself.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n\t\t# sech is even - do not negate\n\t\tsech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n\t\tself.assert_function_values('sech', inputs, sech_vals)\n\t\tself.assert_function_values('sech', neg_inputs, sech_vals)\n\n\t\t# the following functions do not have 0 in their domain\n\t\tinputs = inputs[1:]\n\t\tneg_inputs = neg_inputs[1:]\n\n\t\t# csch is odd\n\t\tcsch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n\t\tself.assert_function_values('csch', inputs, csch_vals)\n\t\tself.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n\t\t# coth is odd\n\t\tcoth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n\t\tself.assert_function_values('coth', inputs, coth_vals)\n\t\tself.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n\tdef test_hyperbolic_inverses(self):\n\t\t\"\"\"\n\t\tTest the inverse hyperbolic functions\n\n\t\twhich are of the form arc[X]h\n\t\t\"\"\"\n\t\tresults = [0, 0.5, 1, 2, 1 + 1j]\n\n\t\tsinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n\t\tself.assert_function_values('arcsinh', sinh_vals, results)\n\n\t\tcosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n\t\tself.assert_function_values('arccosh', cosh_vals, results)\n\n\t\ttanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n\t\tself.assert_function_values('arctanh', tanh_vals, results)\n\n\t\tsech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n\t\tself.assert_function_values('arcsech', sech_vals, results)\n\n\t\tresults = results[1:]\n\t\tcsch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n\t\tself.assert_function_values('arccsch', csch_vals, results)\n\n\t\tcoth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n\t\tself.assert_function_values('arccoth', coth_vals, results)\n\n\tdef test_other_functions(self):\n\t\t\"\"\"\n\t\tTest the non-trig functions provided in calc.py\n\n\t\tSpecifically:\n\t\t  sqrt, log10, log2, ln, abs,\n\t\t  fact, factorial\n\t\t\"\"\"\n\n\t\t# Test sqrt\n\t\tself.assert_function_values(\n\t\t\t'sqrt',\n\t\t\t[0, 1, 2, 1024],  # -1\n\t\t\t[0, 1, 1.414, 32]  # 1j\n\t\t)\n\t\t# sqrt(-1) is NAN not j (!!).\n\n\t\t# Test logs\n\t\tself.assert_function_values(\n\t\t\t'log10',\n\t\t\t[0.1, 1, 3.162, 1000000, '1+j'],\n\t\t\t[-1, 0, 0.5, 6, 0.151 + 0.341j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'log2',\n\t\t\t[0.5, 1, 1.414, 1024, '1+j'],\n\t\t\t[-1, 0, 0.5, 10, 0.5 + 1.133j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'ln',\n\t\t\t[0.368, 1, 1.649, 2.718, 42, '1+j'],\n\t\t\t[-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n\t\t)\n\n\t\t# Test abs\n\t\tself.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n\t\t# Test factorial\n\t\tfact_inputs = [0, 1, 3, 7]\n\t\tfact_values = [1, 1, 6, 5040]\n\t\tself.assert_function_values('fact', fact_inputs, fact_values)\n\t\tself.assert_function_values('factorial', fact_inputs, fact_values)\n\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n\tdef test_constants(self):\n\t\t\"\"\"\n\t\tTest the default constants provided in calc.py\n\n\t\twhich are: j (complex number), e, pi, k, c, T, q\n\t\t\"\"\"\n\n\t\t# Of the form ('expr', python value, tolerance (or None for exact))\n\t\tdefault_variables = [\n\t\t\t('i', 1j, None),\n\t\t\t('j', 1j, None),\n\t\t\t('e', 2.7183, 1e-4),\n\t\t\t('pi', 3.1416, 1e-4),\n\t\t\t('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n\t\t\t('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n\t\t\t('T', 298.15, 0.01),  # Typical room temperature (Kelvin)\n\t\t\t('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n\t\t]\n\t\tfor (variable, value, tolerance) in default_variables:\n\t\t\tfail_msg = \"Failed on constant '{0}', not within bounds\".format(\n\t\t\t\tvariable\n\t\t\t)\n\t\t\tresult = calc.evaluator({}, {}, variable)\n\t\t\tif tolerance is None:\n\t\t\t\tself.assertEqual(value, result, msg=fail_msg)\n\t\t\telse:\n\t\t\t\tself.assertAlmostEqual(\n\t\t\t\t\tvalue, result,\n\t\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t\t)\n\n\tdef test_complex_expression(self):\n\t\t\"\"\"\n\t\tCalculate combinations of operators and default functions\n\t\t\"\"\"\n\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n\t\t\t10.180,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n\t\t\t1.6,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"10||sin(7+5)\"),\n\t\t\t-0.567, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"sin(e)\"),\n\t\t\t0.41, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"k*T/q\"),\n\t\t\t0.025, delta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"e^(j*pi)\"),\n\t\t\t-1, delta=1e-5\n\t\t)\n\n\tdef test_explicit_sci_notation(self):\n\t\t\"\"\"\n\t\tExpressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^-3\"),\n\t\t\t-0.0016\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n\t\t\t-0.0016\n\t\t)\n\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^3\"),\n\t\t\t-1600\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(3)\"),\n\t\t\t-1600\n\t\t)\n\n\tdef test_simple_vars(self):\n\t\t\"\"\"\n\t\tSubstitution of variables into simple equations\n\t\t\"\"\"\n\t\tvariables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n\t\t# Should not change value of constant\n\t\t# even with different numbers of variables...\n\t\tself.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n\t\t# Easy evaluation\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n\t\t# Test a simple equation\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, '3*x-y'),\n\t\t\t21.25, delta=0.01  # = 3 * 9.72 - 7.91\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, 'x*y'),\n\t\t\t76.89, delta=0.01\n\t\t)\n\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(\n\t\t\t\t{'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n\t\t\t\t{}, \"5\"\n\t\t\t),\n\t\t\t5\n\t\t)\n\n\tdef test_variable_case_sensitivity(self):\n\t\t\"\"\"\n\t\tTest the case sensitivity flag and corresponding behavior\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n\t\t\t8.0\n\t\t)\n\n\t\tvariables = {'t': 1.0}\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(variables, {}, \"t\", case_sensitive=True),\n\t\t\t1.0\n\t\t)\n\t\t# Recall 'T' is a default constant, with value 298.15\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, \"T\", case_sensitive=True),\n\t\t\t298, delta=0.2\n\t\t)\n\n\tdef test_simple_funcs(self):\n\t\t\"\"\"\n\t\tSubsitution of custom functions\n\t\t\"\"\"\n\t\tvariables = {'x': 4.712}\n\t\tfunctions = {'id': lambda x: x}\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n\t\tfunctions.update({'f': numpy.sin})\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, functions, 'f(x)'),\n\t\t\t-1, delta=1e-3\n\t\t)\n\n\tdef test_function_case_insensitive(self):\n\t\t\"\"\"\n\t\tTest case insensitive evaluation\n\n\t\tNormal functions with some capitals should be fine\n\t\t\"\"\"\n\t\tself.assertAlmostEqual(\n\t\t\t-0.28,\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n\t\t\tdelta=1e-3\n\t\t)\n\n\tdef test_function_case_sensitive(self):\n\t\t\"\"\"\n\t\tTest case sensitive evaluation\n\n\t\tIncorrectly capitilized should fail\n\t\tAlso, it should pick the correct version of a function.\n\t\t\"\"\"\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n\t\t# With case sensitive turned on, it should pick the right function\n\t\tfunctions = {'f': lambda x: x, 'F': lambda x: x + 1}\n\t\tself.assertEqual(\n\t\t\t6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n\t\t)\n\t\tself.assertEqual(\n\t\t\t7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n\t\t)\n\n\tdef test_undefined_vars(self):\n\t\t\"\"\"\n\t\tCheck to see if the evaluator catches undefined variables\n\t\t\"\"\"\n\t\tvariables = {'R1': 2.0, 'R3': 4.0}\n\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n\t\t\tcalc.evaluator({}, {}, \"5+7*QWSEKO\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n\t\t\tcalc.evaluator({'r1': 5}, {}, \"r1+r2\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n\t\t\tcalc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "description": "\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t", "category": "math", "imports": ["import unittest", "import numpy", "import calc", "from pyparsing import ParseException"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "TestCalcK", "data": "class TestCalcK(unittest.TestCase):\n\n\tdef test_calcK_with_invalid_axes_values(self):\n\t\taxes = [(-10, -5), (-1, -2), (-1, 2), (0, -2), (0, 2), (0, 0), (2, 3)]\n\t\tfor a, b in axes:\n\t\t\tself.assertRaises(AssertionError, calcK, a, b)\n\n\tdef test_calcK_with_valid_axes_values(self):\n\t\taxes = [(2, 1), (1, 1), (2, 2), (10, 1)]\n\t\tkVals = [0.866025403, 0, 0, 0.994987437]\n\t\tfor (a, b), k in zip(axes, kVals):\n\t\t\tself.assertAlmostEqual(k, calcK(a, b))\n\n", "description": null, "category": "math", "imports": ["from math import pi", "import unittest", "from mock import Mock, MagicMock, patch", "from anSol import calcK, calcR, calcQ, calcStresses, calcK1, calcK2, calcK3, calcAnSolWrapper"]}, {"term": "class", "name": "TestCalcR", "data": "class TestCalcR(unittest.TestCase):\n\n\tdef test_calcR_with_invalid_v_and_valid_k(self):\n\t\tk = 0.5\n\t\tfor v in [-2, -1, -0.5, 0, 0.51, 1]:\n\t\t\tself.assertRaises(AssertionError, calcR, k, v)\n\n\tdef test_calcR_with_valid_v_and_invalid_k(self):\n\t\tv = 0.3\n\t\tfor k in [-1, -0.1, 1, 2]:\n\t\t\tself.assertRaises(AssertionError, calcR, k, v)\n\n\tdef test_calcR_with_valid_v_and_nonzero_k(self):\n\t\tkv = [(0.1, 0.5), (0.5, 0.5), (0.9, 0.5),\n\t\t\t  (0.1, 0.3), (0.5, 0.3), (0.9, 0.3)]\n\t\tres = [0.20795543698, 0.6990718462014841, 1.3789606608181639,\n\t\t\t   0.28591552229, 0.71503219085390219, 1.1402245888836]\n\t\tfor (k, v), r in zip(kv, res):\n\t\t\tself.assertAlmostEqual(r, calcR(k, v))\n\n\tdef test_calcR_with_valid_v_and_zero_k(self):\n\t\tv = 0.3\n\t\tk = 0.0\n\t\texp = 2.0 / (pi * (1 - v))\n\t\tself.assertAlmostEqual(exp, calcR(k, v))\n\n", "description": null, "category": "math", "imports": ["from math import pi", "import unittest", "from mock import Mock, MagicMock, patch", "from anSol import calcK, calcR, calcQ, calcStresses, calcK1, calcK2, calcK3, calcAnSolWrapper"]}, {"term": "class", "name": "TestCalcQ", "data": "class TestCalcQ(unittest.TestCase):\n\n\tdef test_calcQ_with_invalid_v_and_valid_k(self):\n\t\tk = 0.5\n\t\tfor v in [-2, -1, -0.5, 0, 0.51, 1]:\n\t\t\tself.assertRaises(AssertionError, calcQ, k, v)\n\n\tdef test_calcQ_with_valid_v_and_invalid_k(self):\n\t\tv = 0.3\n\t\tfor k in [-1, -0.1, 1, 2]:\n\t\t\tself.assertRaises(AssertionError, calcQ, k, v)\n\n\tdef test_calcQ_with_valid_v_and_nonzero_k(self):\n\t\tkv = [(0.1, 0.5), (0.5, 0.5), (0.9, 0.5),\n\t\t\t  (0.1, 0.3), (0.5, 0.3), (0.9, 0.3)]\n\t\tres = [-0.3979963117, 1.67926764853912, 1.07298641382068,\n\t\t\t   -1.1170081642, 1.11413640688092, 0.998904358791297]\n\t\tfor (k, v), r in zip(kv, res):\n\t\t\tself.assertAlmostEqual(r, calcQ(k, v))\n\n\tdef test_calcQ_with_valid_v_and_zero_k(self):\n\t\tv = 0.3\n\t\tk = 0.0\n\t\texp = 2.0 / pi\n\t\tself.assertAlmostEqual(exp, calcQ(k, v))\n\n", "description": null, "category": "math", "imports": ["from math import pi", "import unittest", "from mock import Mock, MagicMock, patch", "from anSol import calcK, calcR, calcQ, calcStresses, calcK1, calcK2, calcK3, calcAnSolWrapper"]}, {"term": "class", "name": "TestCalcStresses", "data": "class TestCalcStresses(unittest.TestCase):\n\n\tdef test_calcStresses_with_gamma_less_or_equal_to_90_degrees(self):\n\t\ts_a = [(100, 0), (100, 30), (100, 60), (100, 90)]\n\t\tres = [(100, 0), (75, 43.301270189), (25, 43.301270189), (0, 0)]\n\t\tfor (stress, gamma), (exp_sigma, exp_tao) in zip(s_a, res):\n\t\t\tsigma, tao = calcStresses(stress, gamma)\n\t\t\tself.assertAlmostEqual(exp_sigma, sigma)\n\t\t\tself.assertAlmostEqual(exp_tao, tao)\n\n\tdef test_calcStresses_with_gamma_larger_than_or_equal_to_360_degrees(self):\n\t\ts_a = [(100, 360), (100, 390), (100, 420), (100, 450)]\n\t\tres = [(100, 0), (75, 43.301270189), (25, 43.301270189), (0, 0)]\n\t\tfor (stress, gamma), (exp_sigma, exp_tao) in zip(s_a, res):\n\t\t\tsigma, tao = calcStresses(stress, gamma)\n\t\t\tself.assertAlmostEqual(exp_sigma, sigma)\n\t\t\tself.assertAlmostEqual(exp_tao, tao)\n\n\tdef test_calcStress_with_gamma_larger_than_90_or_less_than_0(self):\n\t\ts_a = [(100, -10), (100, 130), (100, 200), (100, 350)]\n\t\tfor sigma, gamma in s_a:\n\t\t\tself.assertRaises(AssertionError, calcStresses, sigma, gamma)\n\n", "description": null, "category": "math", "imports": ["from math import pi", "import unittest", "from mock import Mock, MagicMock, patch", "from anSol import calcK, calcR, calcQ, calcStresses, calcK1, calcK2, calcK3, calcAnSolWrapper"]}, {"term": "class", "name": "TestCalcK1", "data": "class TestCalcK1(unittest.TestCase):\n\n\tdef test_calcK1_with_a20_b10_sigma100(self):\n\t\ta, b = 20, 10\n\t\tbetas = [0, 60, 90,\n\t\t\t\t 120, 180, 240,\n\t\t\t\t 270, 300, 360]\n\t\tsigma = 100\n\t\texpected = [247.6864593064, 345.116280255875, 350.28154996732,\n\t\t\t\t\t345.116280255875, 247.6864593064, 345.11628025587532,\n\t\t\t\t\t350.28154996732, 345.116280255875, 247.6864593064754]\n\t\tfor beta, k1 in zip(betas, expected):\n\t\t\tself.assertAlmostEqual(k1, calcK1(a, b, beta, sigma))\n\n\tdef test_calcK1_with_a20_b20_sigma100(self):\n\t\ta, b = 20, 20\n\t\tsigma = 100\n\t\tbetas = [0, 60, 90, 180, 240, 300, 360, 400]\n\t\texpected = 356.82482323055\n\t\tfor beta in betas:\n\t\t\tself.assertAlmostEqual(expected, calcK1(a, b, beta, sigma))\n\n\tdef test_calcK1_with_a10_b20_sigma100(self):\n\t\ta, b = 10, 20\n\t\tbetas = [0, 60, 90, 180, 240, 300, 360, 400]\n\t\tsigma = 100\n\t\tfor beta in betas:\n\t\t\tself.assertRaises(AssertionError, calcK1, a, b, beta, sigma)\n\n\tdef test_calcK1_with_a20_b10_sigma0(self):\n\t\ta, b = 20, 20\n\t\tbetas = [0, 60, 90, 180, 240, 300, 360, 400]\n\t\tsigma = 0\n\t\tfor beta in betas:\n\t\t\tself.assertAlmostEqual(0, calcK1(a, b, beta, sigma))\n\n", "description": null, "category": "math", "imports": ["from math import pi", "import unittest", "from mock import Mock, MagicMock, patch", "from anSol import calcK, calcR, calcQ, calcStresses, calcK1, calcK2, calcK3, calcAnSolWrapper"]}, {"term": "class", "name": "TestCalcK2", "data": "class TestCalcK2(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tself.v = 0.3\n\t\tself.tao = 100\n\t\tself.beta = 45\n\t\tself.omega = 60\n\n\tdef test_calcK2_with_a20_b10_tao100(self):\n\t\ta, b = 20, 10\n\t\tbetas = [0, 60, 90,\n\t\t\t\t 180, 240, 300,\n\t\t\t\t 360, 400]\n\t\texpected = [-151.81193289, -364.761525373456, -343.0689272125,\n\t\t\t\t\t151.81193289, 364.761525373456, 304.324782974556,\n\t\t\t\t\t-151.81193289388983, -369.32377154114926]\n\t\tfor beta, k2 in zip(betas, expected):\n\t\t\tself.assertAlmostEqual(\n\t\t\t\tk2,\n\t\t\t\tcalcK2(\n\t\t\t\t\ta,\n\t\t\t\t\tb,\n\t\t\t\t\tself.v,\n\t\t\t\t\tbeta,\n\t\t\t\t\tself.omega,\n\t\t\t\t\tself.tao))\n\n\tdef test_calcK2_with_a20_b20_tao100(self):\n\t\ta, b = 20, 20\n\t\texpected = -398.73343769\n\t\tself.assertAlmostEqual(\n\t\t\texpected,\n\t\t\tcalcK2(\n\t\t\t\ta,\n\t\t\t\tb,\n\t\t\t\tself.v,\n\t\t\t\tself.beta,\n\t\t\t\tself.omega,\n\t\t\t\tself.tao))\n\n\tdef test_calcK2_with_a20_b10_tao0(self):\n\t\ta, b = 20, 10\n\t\ttao = 0\n\t\texpected = 0\n\t\tself.assertAlmostEqual(\n\t\t\texpected,\n\t\t\tcalcK2(\n\t\t\t\ta,\n\t\t\t\tb,\n\t\t\t\tself.v,\n\t\t\t\tself.beta,\n\t\t\t\tself.omega,\n\t\t\t\ttao))\n\n\tdef test_calcK2_with_a10_b20_tao100(self):\n\t\ta, b = 10, 20\n\t\tself.assertRaises(AssertionError, calcK2,\n\t\t\t\t\t\t  a, b, self.v, self.beta, self.omega, self.tao)\n\n", "description": null, "category": "math", "imports": ["from math import pi", "import unittest", "from mock import Mock, MagicMock, patch", "from anSol import calcK, calcR, calcQ, calcStresses, calcK1, calcK2, calcK3, calcAnSolWrapper"]}, {"term": "class", "name": "TestCalcK3", "data": "class TestCalcK3(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tself.v = 0.3\n\t\tself.tao = 100\n\t\tself.beta = 45\n\t\tself.omega = 60\n\n\tdef test_calcK3_with_a20_b10_tao100(self):\n\t\ta, b = 20, 10\n\t\tbetas = [0, 60, 90,\n\t\t\t\t 180, 240, 300,\n\t\t\t\t 360, 400]\n\t\texpected = [-169.8104553924517, 112.75031034975231, 150.28614610002944,\n\t\t\t\t\t169.81045539245176, -112.7503103497523, -180.35231339102046,\n\t\t\t\t\t-169.81045539245181, 71.441969172512316]\n\t\tfor beta, k2 in zip(betas, expected):\n\t\t\tself.assertAlmostEqual(\n\t\t\t\tk2,\n\t\t\t\tcalcK3(\n\t\t\t\t\ta,\n\t\t\t\t\tb,\n\t\t\t\t\tself.v,\n\t\t\t\t\tbeta,\n\t\t\t\t\tself.omega,\n\t\t\t\t\tself.tao))\n\n\tdef test_calcK3_with_a20_b20_tao100(self):\n\t\ta, b = 20, 20\n\t\texpected = -26.80015418\n\t\tself.assertAlmostEqual(\n\t\t\texpected,\n\t\t\tcalcK3(\n\t\t\t\ta,\n\t\t\t\tb,\n\t\t\t\tself.v,\n\t\t\t\tself.beta,\n\t\t\t\tself.omega,\n\t\t\t\tself.tao))\n\n\tdef test_calcK3_with_a20_b10_tao0(self):\n\t\ta, b = 20, 10\n\t\ttao = 0\n\t\texpected = 0\n\t\tself.assertAlmostEqual(\n\t\t\texpected,\n\t\t\tcalcK3(\n\t\t\t\ta,\n\t\t\t\tb,\n\t\t\t\tself.v,\n\t\t\t\tself.beta,\n\t\t\t\tself.omega,\n\t\t\t\ttao))\n\n\tdef test_calcK3_with_a10_b20_tao100(self):\n\t\ta, b = 10, 20\n\t\tself.assertRaises(AssertionError, calcK3,\n\t\t\t\t\t\t  a, b, self.v, self.beta, self.omega, self.tao)\n\n", "description": null, "category": "math", "imports": ["from math import pi", "import unittest", "from mock import Mock, MagicMock, patch", "from anSol import calcK, calcR, calcQ, calcStresses, calcK1, calcK2, calcK3, calcAnSolWrapper"]}, {"term": "class", "name": "TestCalcAnSolWrapper", "data": "class TestCalcAnSolWrapper(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tself.betas = ['a', 'b', 'c']\n\t\tself.mockK1 = MagicMock(return_value=1)\n\t\tself.mockK2 = MagicMock(return_value=2)\n\t\tself.mockK3 = MagicMock(return_value=3)\n\t\tself.mockStr = MagicMock(return_value=('sigma', 'tao'))\n\t\tself.patches = [\n\t\t\tpatch(modulePrefix + 'calcK1', self.mockK1),\n\t\t\tpatch(modulePrefix + 'calcK2', self.mockK2),\n\t\t\tpatch(modulePrefix + 'calcK3', self.mockK3),\n\t\t\tpatch(modulePrefix + 'calcStresses', self.mockStr)]\n\t\tfor p in self.patches:\n\t\t\tp.start()\n\n\tdef tearDown(self):\n\t\tfor p in self.patches:\n\t\t\tp.stop()\n\n\tdef test_calcAnSolWrapper_with_K1_sifKey(self):\n\t\tres = calcAnSolWrapper('K1', 'a', 'b', 'v', self.betas,\n\t\t\t\t\t\t\t   'gamma', 'omega', 'stress')\n\t\tself.mockStr.assert_called_once_with(\n\t\t\ttensileStress='stress', gamma='gamma')\n\t\tself.assertEqual(len(self.betas), self.mockK1.call_count)\n\t\tself.assertEqual(len(self.betas) * [1], res)\n\t\tfor beta in self.betas:\n\t\t\tself.mockK1.assert_any_call(axisA='a', axisB='b',\n\t\t\t\t\t\t\t\t\t\tbeta=beta, sigma='sigma')\n\n\tdef test_calcAnSolWrapper_with_K2_sifKey(self):\n\t\tres = calcAnSolWrapper('K2', 'a', 'b', 'v', self.betas,\n\t\t\t\t\t\t\t   'gamma', 'omega', 'stress')\n\t\tself.mockStr.assert_called_once_with(\n\t\t\ttensileStress='stress', gamma='gamma')\n\t\tself.assertEqual(len(self.betas), self.mockK2.call_count)\n\t\tself.assertEqual(len(self.betas) * [2], res)\n\t\tfor beta in self.betas:\n\t\t\tself.mockK2.assert_any_call(axisA='a', axisB='b', v='v',\n\t\t\t\t\t\t\t\t\t\tbeta=beta, omega='omega', tao='tao')\n\n\tdef test_calcAnSolWrapper_with_K3_sifKey(self):\n\t\tres = calcAnSolWrapper('K3', 'a', 'b', 'v', self.betas,\n\t\t\t\t\t\t\t   'gamma', 'omega', 'stress')\n\t\tself.mockStr.assert_called_once_with(\n\t\t\ttensileStress='stress', gamma='gamma')\n\t\tself.assertEqual(len(self.betas), self.mockK3.call_count)\n\t\tself.assertEqual(len(self.betas) * [3], res)\n\t\tfor beta in self.betas:\n\t\t\tself.mockK3.assert_any_call(axisA='a', axisB='b', v='v',\n\t\t\t\t\t\t\t\t\t\tbeta=beta, omega='omega', tao='tao')\n\n\tdef test_calcAnSolWrapper_with_undefined_sifKey(self):\n\t\tself.assertRaises(\n\t\t\tKeyError,\n\t\t\tcalcAnSolWrapper,\n\t\t\t'unknown_sifKey',\n\t\t\t'a',\n\t\t\t'b',\n\t\t\t'v',\n\t\t\tself.betas,\n\t\t\t'gamma',\n\t\t\t'omega',\n\t\t\t'stress')\n", "description": null, "category": "math", "imports": ["from math import pi", "import unittest", "from mock import Mock, MagicMock, patch", "from anSol import calcK, calcR, calcQ, calcStresses, calcK1, calcK2, calcK3, calcAnSolWrapper"]}], [{"term": "def", "name": "testMockFunction", "data": "  def testMockFunction(self):\n\t@MockFunction\n\tdef calc(a, b, mult=1):\n\t  return (a + b) * mult\n\n\tself.assertTrue(*calc.CheckAndReset(0))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 1 call(s), got 0'), calc.CheckAndReset(1))\n\n\tself.assertEqual(20, calc(2, 3, mult=4))\n\tself.assertTrue(*calc.CheckAndReset(1))\n\tself.assertTrue(*calc.CheckAndReset(0))\n\n\tself.assertEqual(20, calc(2, 3, mult=4))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 0 call(s), got 1'), calc.CheckAndReset(0))\n\n\tself.assertEqual(3, calc(1, 2))\n\tself.assertEqual(0, calc(3, 4, mult=0))\n\tself.assertTrue(*calc.CheckAndReset(2))\n\tself.assertTrue(*calc.CheckAndReset(0))\n\n\tself.assertEqual(3, calc(1, 2))\n\tself.assertEqual(0, calc(3, 4, mult=0))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 3 call(s), got 2'), calc.CheckAndReset(3))\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock_function import MockFunction"]}], [{"term": "def", "name": "testMockFunction", "data": "  def testMockFunction(self):\n\t@MockFunction\n\tdef calc(a, b, mult=1):\n\t  return (a + b) * mult\n\n\tself.assertTrue(*calc.CheckAndReset(0))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 1 call(s), got 0'), calc.CheckAndReset(1))\n\n\tself.assertEqual(20, calc(2, 3, mult=4))\n\tself.assertTrue(*calc.CheckAndReset(1))\n\tself.assertTrue(*calc.CheckAndReset(0))\n\n\tself.assertEqual(20, calc(2, 3, mult=4))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 0 call(s), got 1'), calc.CheckAndReset(0))\n\n\tself.assertEqual(3, calc(1, 2))\n\tself.assertEqual(0, calc(3, 4, mult=0))\n\tself.assertTrue(*calc.CheckAndReset(2))\n\tself.assertTrue(*calc.CheckAndReset(0))\n\n\tself.assertEqual(3, calc(1, 2))\n\tself.assertEqual(0, calc(3, 4, mult=0))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 3 call(s), got 2'), calc.CheckAndReset(3))\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock_function import MockFunction"]}], [{"term": "class", "name": "TestCalc", "data": "class TestCalc(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.calc = Calc()\n\n\tdef test_suma(self):\n\t\tself.assertEqual(4, self.calc.sumar(2,2))\n\t\tself.assertEqual(13, self.calc.sumar(1,12))\n\t\tself.assertEqual(1100, self.calc.sumar(100,1000))\n\t\tself.assertEqual(0, self.calc.sumar(0,0))\n\t\tself.assertEqual(\"Invalid\", self.calc.sumar(1,-1))\n\n\n\tdef test_resta(self):\n\t\tself.assertEqual(0, self.calc.restar(2,2))\n\t\tself.assertEqual(11, self.calc.restar(12,1))\n\t\tself.assertEqual(900, self.calc.restar(1000,100))\n\t\tself.assertEqual(0, self.calc.restar(0,0))\n\t\tself.assertEqual(\"Invalid\", self.calc.restar(1,-1))\n\t\t\n\tdef test_multiplicar(self):\n\t\tself.assertEqual(4, self.calc.multiplicar(2,2))\n\t\tself.assertEqual(12, self.calc.multiplicar(1,12))\n\t\tself.assertEqual(100000, self.calc.multiplicar(100,1000))\n\t\tself.assertEqual(0, self.calc.multiplicar(0,0))\n\t\tself.assertEqual(\"Invalid\", self.calc.multiplicar(1,-1))\n\t\t\n\tdef test_dividir(self):\n\t\tself.assertEqual(1.0, self.calc.dividir(2,2))\n\t\tself.assertEqual(12.0, self.calc.dividir(12,1))\n\t\tself.assertEqual(10.0, self.calc.dividir(1000,100))\n\t\tself.assertEqual(\"Invalid\", self.calc.dividir(0,0))\n\t\tself.assertEqual(\"Invalid\", self.calc.dividir(2,-2))\n", "description": null, "category": "math", "imports": ["from calc import Calc", "import unittest", "from calc import Calc"]}], [{"term": "def", "name": "weight_fun", "data": "def weight_fun(x, a, b, c):\n\treturn a + b * np.cos(x) + c * np.sin(x)\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calc_weights", "data": "def calc_weights(num_classes, coeffs):\n\tk2PI = 2* np.pi\n\tx = np.linspace(0, k2PI, num_classes)\n\tdata_len = coeffs.shape[0]\n\tweights = np.zeros((data_len, num_classes))\n\tfor i in range(data_len):\n\t\tweights[i] = weight_fun(x, *coeffs[i])\n\treturn weights\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calc_argmaxs_distances", "data": "def calc_argmaxs_distances(pred_arg_maxs, calc_arg_maxs, num_class):\n\treturn calculate_deltas_signed(calc_arg_maxs, pred_arg_maxs, num_class)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics", "data": "def calculate_metrics(calc_w, preds_w, num_classes):\n\tpred_arg_maxs = np.argmax(preds_w, axis=1)\n\tcalc_arg_maxs = np.argmax(calc_w, axis=1)\n\n\tk2PI = 2 * np.pi\n\tcalc_pred_argmaxs_abs_distances = calculate_deltas_unsigned( pred_arg_maxs, calc_arg_maxs, num_classes)\n\tcalc_pred_argmaxs_signed_distances = calculate_deltas_signed(pred_arg_maxs, calc_arg_maxs, num_classes)\n\tcalc_pred_argmaxs_abs_distances_rad = calc_pred_argmaxs_abs_distances * k2PI/(1.0*num_classes)\n\t\n\tmean_deltas = np.mean(calc_pred_argmaxs_signed_distances, dtype=np.float64)\n\tmean_deltas_err = stats.sem(calc_pred_argmaxs_signed_distances)\n\tmean_deltas_rad = mean_deltas * k2PI/(1.0*num_classes)\n\tmean_deltas_err_rad = mean_deltas_err * k2PI/(1.0*num_classes)\n\n\tacc0 = (calc_pred_argmaxs_abs_distances <= 0).mean()\n\tacc1 = (calc_pred_argmaxs_abs_distances <= 1).mean()\n\tacc2 = (calc_pred_argmaxs_abs_distances <= 2).mean()\n\tacc3 = (calc_pred_argmaxs_abs_distances <= 3).mean()\n\n\tacc0_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.25).mean()\n\tacc1_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.50).mean()\n\tacc2_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.75).mean()\n\tacc3_rad = (calc_pred_argmaxs_abs_distances_rad <= 1.00).mean()\n\n\tl1_delta_w = np.mean(np.abs(calc_w - preds_w), dtype=np.float64)\n\tl2_delta_w = np.sqrt(np.mean((calc_w - preds_w)**2), dtype=np.float64)\n\t# problem with format, should not be array\n\tl2_delta_w_err = stats.sem((calc_w - preds_w)**2)\n\n\t# calc_w, preds_w normalisation to probability\n\tcalc_w_norm = calc_w / np.sum(calc_w, axis=1)[:, np.newaxis]\n\tpreds_w_norm = preds_w / np.sum(preds_w, axis=1)[:, np.newaxis]\n \n\tl1_delta_w_norm = np.mean(np.abs(calc_w_norm - preds_w_norm), dtype=np.float64)\n\tl2_delta_w_norm = np.sqrt(np.mean((calc_w_norm - preds_w_norm)**2), dtype=np.float64)\n\t# problem with format, should not be array\n\tl2_delta_w_norm_err = stats.sem((calc_w_norm - preds_w_norm)**2)\n  \n\t\n\treturn np.array([acc0, acc1, acc2, acc3, mean_deltas, l1_delta_w, l2_delta_w, mean_deltas_rad, acc0_rad, acc1_rad, acc2_rad, acc3_rad,l1_delta_w_norm, l2_delta_w_norm, mean_deltas_err, mean_deltas_err_rad, l2_delta_w_err, l2_delta_w_norm_err ]) \n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics_regr_c012s_from_file", "data": "def calculate_metrics_regr_c012s_from_file(directory, num_classes):\n\tcalc_c012s = np.load(os.path.join(directory,'test_regr_calc_c012s.npy'))\n\tpred_c012s = np.load(os.path.join(directory,'test_regr_preds_c012s.npy'))\n\n\treturn calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics_regr_c012s", "data": "def calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes):\n\tcalc_w  = calc_weights(num_classes, calc_c012s)\n\tpreds_w = calc_weights(num_classes, pred_c012s)\n\n\treturn calculate_metrics(calc_w, preds_w, num_classes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "get_filename_for_class", "data": "def get_filename_for_class(pathIN, class_num, subset=None):\n\td = '../monit_npy/nn_rhorho_Variant-All_Unweighted_False_NO_NUM_CLASSES_{class_num}'\n\tif subset:\n\t\td += \"_WEIGHTS_SUBS\" + str(subset)\n\treturn d\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "evaluate_roc_auc", "data": "def evaluate_roc_auc(preds, wa, wb):\n\tn = len(preds)\n\ttrue_labels = np.concatenate([np.ones(n), np.zeros(n)])\n\tpreds = np.concatenate([preds, preds])\n\tweights = np.concatenate([wa, wb])\n\t\n\treturn roc_auc_score(true_labels, preds, sample_weight=weights)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_roc_auc", "data": "def calculate_roc_auc(preds_w, calc_w, index_a, index_b):\n\tn, num_classes = calc_w.shape\n\ttrue_labels = np.concatenate([np.ones(n), np.zeros(n)])\n\tpreds = np.concatenate([preds_w[:, index_a], preds_w[:, index_a]])\n\tweights = np.concatenate([calc_w[:, index_a], calc_w[:, index_b]])\n\n\treturn roc_auc_score(true_labels, preds, sample_weight=weights)\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "test_roc_auc", "data": "def test_roc_auc(directory, num_class):\n\tcalc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n\tpreds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n\t\n\toracle_roc_auc = []\n\tpreds_roc_auc  = []\n\t\n\tfor i in range(0, num_class):\n\t\t oracle_roc_auc  += [calculate_roc_auc(calc_w, calc_w, 0, i)]\n\t\t preds_roc_auc   += [calculate_roc_auc(preds_w, calc_w, 0, i)]\n\t\t print(i,\n\t\t\t\t  'oracle_roc_auc: {}'.format(calculate_roc_auc(calc_w, calc_w, 0, i)),\n\t\t\t\t  'preds_roc_auc: {}'.format(calculate_roc_auc(preds_w, calc_w, 0, i)))\n\n\treturn oracle_roc_auc, preds_roc_auc\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}], [{"term": "class", "name": "classBestFirstSearchPlanner:", "data": "class BestFirstSearchPlanner:\n\n\tdef __init__(self, ox, oy, reso, rr):\n\t\t\"\"\"\n\t\tInitialize grid map for greedy best-first planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t\"\"\"\n\n\t\tself.reso = reso\n\t\tself.rr = rr\n\t\tself.calc_obstacle_map(ox, oy)\n\t\tself.motion = self.get_motion_model()\n\n\tclass Node:\n\t\tdef __init__(self, x, y, cost, pind, parent):\n\t\t\tself.x = x  # index of grid\n\t\t\tself.y = y  # index of grid\n\t\t\tself.cost = cost\n\t\t\tself.pind = pind\n\t\t\tself.parent = parent\n\n\t\tdef __str__(self):\n\t\t\treturn str(self.x) + \",\" + str(self.y) + \",\" + str(\n\t\t\t\tself.cost) + \",\" + str(self.pind)\n\n\tdef planning(self, sx, sy, gx, gy):\n\t\t\"\"\"\n\t\tGreedy Best-First search\n\n\t\tinput:\n\t\t\ts_x: start x position [m]\n\t\t\ts_y: start y position [m]\n\t\t\tgx: goal x position [m]\n\t\t\tgy: goal y position [m]\n\n\t\toutput:\n\t\t\trx: x position list of the final path\n\t\t\try: y position list of the final path\n\t\t\"\"\"\n\n\t\tnstart = self.Node(self.calc_xyindex(sx, self.minx),\n\t\t\t\t\t\t   self.calc_xyindex(sy, self.miny), 0.0, -1, None)\n\t\tngoal = self.Node(self.calc_xyindex(gx, self.minx),\n\t\t\t\t\t\t  self.calc_xyindex(gy, self.miny), 0.0, -1, None)\n\n\t\topen_set, closed_set = dict(), dict()\n\t\topen_set[self.calc_grid_index(nstart)] = nstart\n\n\t\twhile 1:\n\t\t\tif len(open_set) == 0:\n\t\t\t\tprint(\"Open set is empty..\")\n\t\t\t\tbreak\n\n\t\t\tc_id = min(\n\t\t\t\topen_set,\n\t\t\t\tkey=lambda o: self.calc_heuristic(ngoal, open_set[o]))\n\n\t\t\tcurrent = open_set[c_id]\n\n\t\t\t# show graph\n\t\t\tif show_animation:  # pragma: no cover\n\t\t\t\tplt.plot(self.calc_grid_position(current.x, self.minx),\n\t\t\t\t\t\t self.calc_grid_position(current.y, self.miny), \"xc\")\n\t\t\t\t# for stopping simulation with the esc key.\n\t\t\t\tplt.gcf().canvas.mpl_connect('key_release_event',\n\t\t\t\t\t\t\t\t\t\t\t lambda event:\n\t\t\t\t\t\t\t\t\t\t\t [exit(0)\n\t\t\t\t\t\t\t\t\t\t\t  if event.key == 'escape'\n\t\t\t\t\t\t\t\t\t\t\t  else None])\n\t\t\t\tif len(closed_set.keys()) % 10 == 0:\n\t\t\t\t\tplt.pause(0.001)\n\n\t\t\t# Remove the item from the open set\n\t\t\tdel open_set[c_id]\n\n\t\t\t# Add it to the closed set\n\t\t\tclosed_set[c_id] = current\n\n\t\t\tif current.x == ngoal.x and current.y == ngoal.y:\n\t\t\t\tprint(\"Found goal\")\n\t\t\t\tngoal.pind = current.pind\n\t\t\t\tngoal.cost = current.cost\n\t\t\t\tbreak\n\n\t\t\t# expand_grid search grid based on motion model\n\t\t\tfor i, _ in enumerate(self.motion):\n\t\t\t\tnode = self.Node(current.x + self.motion[i][0],\n\t\t\t\t\t\t\t\t current.y + self.motion[i][1],\n\t\t\t\t\t\t\t\t current.cost + self.motion[i][2],\n\t\t\t\t\t\t\t\t c_id, current)\n\n\t\t\t\tn_id = self.calc_grid_index(node)\n\n\t\t\t\t# If the node is not safe, do nothing\n\t\t\t\tif not self.verify_node(node):\n\t\t\t\t\tcontinue\n\n\t\t\t\tif n_id in closed_set:\n\t\t\t\t\tcontinue\n\n\t\t\t\tif n_id not in open_set:\n\t\t\t\t\topen_set[n_id] = node\n\t\t\t\telse:\n\t\t\t\t\tif open_set[n_id].cost > node.cost:\n\t\t\t\t\t\topen_set[n_id] = node\n\t\tclosed_set[ngoal.pind] = current\n\t\trx, ry = self.calc_final_path(ngoal, closed_set)\n\t\treturn rx, ry\n\n\tdef calc_final_path(self, ngoal, closedset):\n\t\t# generate final course\n\t\trx, ry = [self.calc_grid_position(ngoal.x, self.minx)], [\n\t\t\tself.calc_grid_position(ngoal.y, self.miny)]\n\t\tn = closedset[ngoal.parent_index]\n\t\twhile n is not None:\n\t\t\trx.append(self.calc_grid_position(n.x, self.minx))\n\t\t\try.append(self.calc_grid_position(n.y, self.miny))\n\t\t\tn = n.parent\n\n\t\treturn rx, ry\n\n\t@staticmethod\n\tdef calc_heuristic(n1, n2):\n\t\tw = 1.0  # weight of heuristic\n\t\td = w * math.hypot(n1.x - n2.x, n1.y - n2.y)\n\t\treturn d\n\n\tdef calc_grid_position(self, index, minp):\n\t\t\"\"\"\n\t\tcalc grid position\n\n\t\t:param index:\n\t\t:param minp:\n\t\t:return:\n\t\t\"\"\"\n\t\tpos = index * self.reso + minp\n\t\treturn pos\n\n\tdef calc_xyindex(self, position, min_pos):\n\t\treturn round((position - min_pos) / self.reso)\n\n\tdef calc_grid_index(self, node):\n\t\treturn (node.y - self.miny) * self.xwidth + (node.x - self.minx)\n\n\tdef verify_node(self, node):\n\t\tpx = self.calc_grid_position(node.x, self.minx)\n\t\tpy = self.calc_grid_position(node.y, self.miny)\n\n\t\tif px < self.minx:\n\t\t\treturn False\n\t\telif py < self.miny:\n\t\t\treturn False\n\t\telif px >= self.maxx:\n\t\t\treturn False\n\t\telif py >= self.maxy:\n\t\t\treturn False\n\n\t\t# collision check\n\t\tif self.obmap[node.x][node.y]:\n\t\t\treturn False\n\n\t\treturn True\n\n\tdef calc_obstacle_map(self, ox, oy):\n\n\t\tself.minx = round(min(ox))\n\t\tself.miny = round(min(oy))\n\t\tself.maxx = round(max(ox))\n\t\tself.maxy = round(max(oy))\n\t\tprint(\"min_x:\", self.minx)\n\t\tprint(\"min_y:\", self.miny)\n\t\tprint(\"max_x:\", self.maxx)\n\t\tprint(\"max_y:\", self.maxy)\n\n\t\tself.xwidth = round((self.maxx - self.minx) / self.reso)\n\t\tself.ywidth = round((self.maxy - self.miny) / self.reso)\n\t\tprint(\"x_width:\", self.xwidth)\n\t\tprint(\"y_width:\", self.ywidth)\n\n\t\t# obstacle map generation\n\t\tself.obmap = [[False for _ in range(self.ywidth)]\n\t\t\t\t\t  for _ in range(self.xwidth)]\n\t\tfor ix in range(self.xwidth):\n\t\t\tx = self.calc_grid_position(ix, self.minx)\n\t\t\tfor iy in range(self.ywidth):\n\t\t\t\ty = self.calc_grid_position(iy, self.miny)\n\t\t\t\tfor iox, ioy in zip(ox, oy):\n\t\t\t\t\td = math.hypot(iox - x, ioy - y)\n\t\t\t\t\tif d <= self.rr:\n\t\t\t\t\t\tself.obmap[ix][iy] = True\n\t\t\t\t\t\tbreak\n\n\t@staticmethod\n\tdef get_motion_model():\n\t\t# dx, dy, cost\n\t\tmotion = [[1, 0, 1],\n\t\t\t\t  [0, 1, 1],\n\t\t\t\t  [-1, 0, 1],\n\t\t\t\t  [0, -1, 1],\n\t\t\t\t  [-1, -1, math.sqrt(2)],\n\t\t\t\t  [-1, 1, math.sqrt(2)],\n\t\t\t\t  [1, -1, math.sqrt(2)],\n\t\t\t\t  [1, 1, math.sqrt(2)]]\n\n\t\treturn motion\n\n", "description": "\n\t\tInitialize grid map for greedy best-first planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t", "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():\n\tprint(__file__ + \" start!!\")\n\n\t# start and goal position\n\tsx = 10.0  # [m]\n\tsy = 10.0  # [m]\n\tgx = 50.0  # [m]\n\tgy = 50.0  # [m]\n\tgrid_size = 2.0  # [m]\n\trobot_radius = 1.0  # [m]\n\n\t# set obstacle positions\n\tox, oy = [], []\n\tfor i in range(-10, 60):\n\t\tox.append(i)\n\t\toy.append(-10.0)\n\tfor i in range(-10, 60):\n\t\tox.append(60.0)\n\t\toy.append(i)\n\tfor i in range(-10, 61):\n\t\tox.append(i)\n\t\toy.append(60.0)\n\tfor i in range(-10, 61):\n\t\tox.append(-10.0)\n\t\toy.append(i)\n\tfor i in range(-10, 40):\n\t\tox.append(20.0)\n\t\toy.append(i)\n\tfor i in range(0, 40):\n\t\tox.append(40.0)\n\t\toy.append(60.0 - i)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(ox, oy, \".k\")\n\t\tplt.plot(sx, sy, \"og\")\n\t\tplt.plot(gx, gy, \"xb\")\n\t\tplt.grid(True)\n\t\tplt.axis(\"equal\")\n\n\tgreedybestfirst = BestFirstSearchPlanner(ox, oy, grid_size, robot_radius)\n\trx, ry = greedybestfirst.planning(sx, sy, gx, gy)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(rx, ry, \"-r\")\n\t\tplt.pause(0.01)\n\t\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}], [{"term": "def", "name": "insert_number_in_calc_result", "data": "def insert_number_in_calc_result(button_number):\r\n\tglobal last_operator_index , last_dot_index\r\n\tcurrent = lbl_calc_result['text']\r\n\r\n\tif button_number in ['+', '-' , '*']:\r\n\t\tlast_operator_index = len(current)\r\n\r\n\tif button_number == 'C':\r\n\t\tlbl_calc_result['text'] = '0'\r\n\t\tlast_operator_index, last_dot_index = -1,-1\r\n\telif current == '0': \r\n\t\tlbl_calc_result['text'] = button_number\r\n\telif button_number == '=':\r\n\t\tlbl_calc_result['text'] = f'{eval(current)}'\r\n\t\tlast_operator_index = -1\r\n\t\tif '.' in lbl_calc_result['text']:\r\n\t\t\tlast_dot_index = len(lbl_calc_result['text'])\r\n\telse:\r\n\t\tif button_number == '.':\r\n\t\t\tif last_dot_index > last_operator_index:\r\n\t\t\t\tpass\r\n\t\t\telif current[-1] == '.':\r\n\t\t\t\tpass\r\n\t\t\telse:\r\n\t\t\t\tlbl_calc_result['text'] += button_number\r\n\t\t\t\tlast_dot_index = len(current)\r\n\r\n\t\telif button_number in ['+', '-' , '*']:\r\n\t\t\tif current[-1] in ['+', '-' , '*']:\r\n\t\t\t\tlbl_calc_result['text'] = current[:-1] + button_number\r\n\t\t\telse:\r\n\t\t\t\tlbl_calc_result['text'] += button_number\r\n\t\telse:\r\n\t\t\tlbl_calc_result['text'] += button_number\r\n\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r"]}], [], [{"term": "class", "name": "classSpline:", "data": "class Spline:\n\t\"\"\"\n\tCubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.b, self.c, self.d, self.w = [], [], [], []\n\n\t\tself.x = x\n\t\tself.y = y\n\n\t\tself.nx = len(x)  # dimension of x\n\t\th = np.diff(x)\n\n\t\t# calc coefficient c\n\t\tself.a = [iy for iy in y]\n\n\t\t# calc coefficient c\n\t\tA = self.__calc_A(h)\n\t\tB = self.__calc_B(h)\n\t\tself.c = np.linalg.solve(A, B)\n\t\t#  print(self.c1)\n\n\t\t# calc spline coefficient b and d\n\t\tfor i in range(self.nx - 1):\n\t\t\tself.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n\t\t\ttb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n\t\t\t\t(self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n\t\t\tself.b.append(tb)\n\n\tdef calc(self, t):\n\t\t\"\"\"\n\t\tCalc position\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.a[i] + self.b[i] * dx + \\\n\t\t\tself.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n\t\treturn result\n\n\tdef calcd(self, t):\n\t\t\"\"\"\n\t\tCalc first derivative\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n\t\treturn result\n\n\tdef calcdd(self, t):\n\t\t\"\"\"\n\t\tCalc second derivative\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n\t\treturn result\n\n\tdef __search_index(self, x):\n\t\t\"\"\"\n\t\tsearch data segment index\n\t\t\"\"\"\n\t\treturn bisect.bisect(self.x, x) - 1\n\n\tdef __calc_A(self, h):\n\t\t\"\"\"\n\t\tcalc matrix A for spline coefficient c\n\t\t\"\"\"\n\t\tA = np.zeros((self.nx, self.nx))\n\t\tA[0, 0] = 1.0\n\t\tfor i in range(self.nx - 1):\n\t\t\tif i != (self.nx - 2):\n\t\t\t\tA[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n\t\t\tA[i + 1, i] = h[i]\n\t\t\tA[i, i + 1] = h[i]\n\n\t\tA[0, 1] = 0.0\n\t\tA[self.nx - 1, self.nx - 2] = 0.0\n\t\tA[self.nx - 1, self.nx - 1] = 1.0\n\t\t#  print(A)\n\t\treturn A\n\n\tdef __calc_B(self, h):\n\t\t\"\"\"\n\t\tcalc matrix B for spline coefficient c\n\t\t\"\"\"\n\t\tB = np.zeros(self.nx)\n\t\tfor i in range(self.nx - 2):\n\t\t\tB[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n\t\t\t\th[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n\t\treturn B\n\n", "description": "\n\tCubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "class", "name": "classSpline2D:", "data": "class Spline2D:\n\t\"\"\"\n\t2D Cubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.s = self.__calc_s(x, y)\n\t\tself.sx = Spline(self.s, x)\n\t\tself.sy = Spline(self.s, y)\n\n\tdef __calc_s(self, x, y):\n\t\tdx = np.diff(x)\n\t\tdy = np.diff(y)\n\t\tself.ds = np.hypot(dx, dy)\n\t\ts = [0]\n\t\ts.extend(np.cumsum(self.ds))\n\t\treturn s\n\n\tdef calc_position(self, s):\n\t\t\"\"\"\n\t\tcalc position\n\t\t\"\"\"\n\t\tx = self.sx.calc(s)\n\t\ty = self.sy.calc(s)\n\n\t\treturn x, y\n\n\tdef calc_curvature(self, s):\n\t\t\"\"\"\n\t\tcalc curvature\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tddx = self.sx.calcdd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tddy = self.sy.calcdd(s)\n\t\tk = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n\t\treturn k\n\n\tdef calc_yaw(self, s):\n\t\t\"\"\"\n\t\tcalc yaw\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tyaw = math.atan2(dy, dx)\n\t\treturn yaw\n\n", "description": "\n\t2D Cubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "calc_spline_course", "data": "def calc_spline_course(x, y, ds=0.1):\n\tsp = Spline2D(x, y)\n\ts = list(np.arange(0, sp.s[-1], ds))\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\treturn rx, ry, ryaw, rk, s\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():  # pragma: no cover\n\tprint(\"Spline 2D test\")\n\timport matplotlib.pyplot as plt\n\tx = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n\ty = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n\tds = 0.1  # [m] distance of each interpolated points\n\n\tsp = Spline2D(x, y)\n\ts = np.arange(0, sp.s[-1], ds)\n\t\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\t\n\tplt.plot(rx,ry)\n\tplt.show()\n\tplt.close()\n\n\tplt.subplots(1)\n\tplt.plot(x, y, \"xb\", label=\"input\")\n\tplt.plot(rx, ry, \"-r\", label=\"spline\")\n\tplt.grid(True)\n\tplt.axis(\"equal\")\n\tplt.xlabel(\"x[m]\")\n\tplt.ylabel(\"y[m]\")\n\tplt.legend()\n\n\tplt.subplots(1)\n\tplt.plot(s, [np.rad2deg(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"yaw angle[deg]\")\n\n\tplt.subplots(1)\n\tplt.plot(s, rk, \"-r\", label=\"curvature\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"curvature [1/m]\")\n\n\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}], [{"term": "class", "name": "TestCalc", "data": "class TestCalc(unittest.TestCase):\n\n\tdef test_add(self):\n\t\tself.assertEqual(calc.add(10, 5), 15)\n\t\tself.assertEqual(calc.add(-1, 1), 0)\n\t\tself.assertEqual(calc.add(-1, -1), -2)\n\n\tdef test_subtract(self):\n\t\tself.assertEqual(calc.subtract(10, 5), 5)\n\t\tself.assertEqual(calc.subtract(-1, 1), -2)\n\t\tself.assertEqual(calc.subtract(-1, -1), 0)\n\n\tdef test_multiply(self):\n\t\tself.assertEqual(calc.multiply(10, 5), 50)\n\t\tself.assertEqual(calc.multiply(-1, 1), -1)\n\t\tself.assertEqual(calc.multiply(-1, -1), 1)\n\n\tdef test_divide(self):\n\t\tself.assertEqual(calc.divide(10, 5), 2)\n\t\tself.assertEqual(calc.divide(-1, 1), -1)\n\t\tself.assertEqual(calc.divide(-1, -1), 1)\n\t\tself.assertEqual(calc.divide(5, 2), 2.5)\n\n\t\twith self.assertRaises(ValueError):\n\t\t\tcalc.divide(10, 0)\n\n", "description": null, "category": "math", "imports": ["import unittest", "import calc"]}], [{"term": "class", "name": "TestCalc", "data": "class TestCalc(unittest.TestCase):\r\n\r\n\tdef test_add(self):\r\n\t\tself.assertEqual(calc.add(10, 5), 15)\r\n\t\tself.assertEqual(calc.add(-1, 1), 0)\r\n\t\tself.assertEqual(calc.add(-1, -1), -2)\r\n\r\n\tdef test_subtract(self):\r\n\t\tself.assertEqual(calc.subtract(10, 5), 5)\r\n\t\tself.assertEqual(calc.subtract(-1, 1), -2)\r\n\t\tself.assertEqual(calc.subtract(-1, -1), 0)\r\n\r\n\tdef test_multiply(self):\r\n\t\tself.assertEqual(calc.multiply(10, 5), 50)\r\n\t\tself.assertEqual(calc.multiply(-1, 1), -1)\r\n\t\tself.assertEqual(calc.multiply(-1, -1), 1)\r\n\r\n\tdef test_divide(self):\r\n\t\tself.assertEqual(calc.divide(10, 5), 2)\r\n\t\tself.assertEqual(calc.divide(-1, 1), -1)\r\n\t\tself.assertEqual(calc.divide(-1, -1), 1)\r\n\t\tself.assertEqual(calc.divide(5, 2), 2.5)\r\n\r\n\t\twith self.assertRaises(ValueError):\r\n\t\t\tcalc.divide(10, 0)\r\n\r\n", "description": null, "category": "math", "imports": ["import unittest\r", "import calc\r"]}], [{"term": "def", "name": "main", "data": "def main():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tarray.add_elements_from_file(r\"..\\array_elements.txt\")\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\tdist_s = array.calc_distances_betweeen_elements()\r\n\tprint(min(dist_s))\r\n\tprint(max(dist_s))\r\n\r\n\timport json\r\n\twith open(r\"..\\ribs.json\",'r') as f:\r\n\t\tribs_phantom = json.loads(f.read())\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\tcalc_field.set_nodes_num(241, 1, 301)\r\n\tcalc_field.set_grid_bottom(-100.0e-03, 0.0e-03, 5.0e-03)\r\n\tcalc_field.set_grid_top(100.0e-03, 0.0e-03, 130.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n\t# array.switch_off_elements_from_file(r\"..\\switched_off.txt\")\r\n\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\t# rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n\trayleigh.RayCalc(calc_field, array, med, 500).doit()\r\n\t# rayleigh.RayCalcIdealRibs(calc_field, array, med, 300, ribs_phantom).doit()\r\n\t# rayleigh.RayCalcIdealFull(calc_field, array, med, 500).doit()\r\n\t# rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n\t# rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n\t# calc_field = output.restore_field_from_disk(\"field_plane\")\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\t# ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import ribs\r", "import rayleigh\r", "import analytic_calc\r", "\timport json\r", "\timport analytic_calc_skull\r", "\timport json\r", "\timport numpy\r", "\timport ribs\r", "\timport angular_spectrum\r"]}, {"term": "def", "name": "main_skull", "data": "def main_skull():\r\n\timport analytic_calc_skull\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tarray.add_elements_from_file(r\"..\\array_elements.txt\")\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\t\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\t# calc_field.set_nodes_num(201, 1, 130)\r\n\t# calc_field.set_grid_bottom(-100.0e-03, 0.0e-03, 5.0e-03)\r\n\t# calc_field.set_grid_top(100.0e-03, 0.0e-03, 130.0e-03)\r\n\tcalc_field.set_nodes_num(1, 1, 11)\r\n\tcalc_field.set_grid_bottom(0.0e-03, 0.0e-03, 125.0e-03)\r\n\tcalc_field.set_grid_top(0.0e-03, 0.0e-03, 135.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\r\n\r\n\t# ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n\t# array.switch_off_elements_from_file(r\"..\\switched_off.txt\")\r\n\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\tanalytic_calc_skull.calc_field_analytically(calc_field, array, med)\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\t# rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n\t# rayleigh.RayCalc(calc_field, array, med, 500).doit()\r\n\t# rayleigh.RayCalcIdealRibs(calc_field, array, med, 300, ribs_phantom).doit()\r\n\t# rayleigh.RayCalcIdealFull(calc_field, array, med, 500).doit()\r\n\t# rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n\t# rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n\t# calc_field = output.restore_field_from_disk(\"field_plane\")\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\t# ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import ribs\r", "import rayleigh\r", "import analytic_calc\r", "\timport json\r", "\timport analytic_calc_skull\r", "\timport json\r", "\timport numpy\r", "\timport ribs\r", "\timport angular_spectrum\r"]}, {"term": "def", "name": "main_one_el_test", "data": "def main_one_el_test():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tarray.add_elements_from_file(r\"..\\array_elements.txt\")\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\tdist_s = array.calc_distances_betweeen_elements()\r\n\tprint(min(dist_s))\r\n\tprint(max(dist_s))\r\n\r\n\timport json\r\n\twith open(r\"..\\ribs.json\",'r') as f:\r\n\t\tribs_phantom = json.loads(f.read())\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\tcalc_field.set_nodes_num(101, 101, 1)\r\n\tcalc_field.set_grid_bottom(-25.0e-03, -25.0e-03, 130.0e-03)\r\n\tcalc_field.set_grid_top(25.0e-03, 25.0e-03, 130.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n\t# array.switch_off_elements_from_file(r\"..\\switched_off.txt\")\r\n\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\t# rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n\trayleigh.RayCalc(calc_field, array, med, 500).doit()\r\n\t# rayleigh.RayCalcIdealRibs(calc_field, array, med, 300, ribs_phantom).doit()\r\n\t# rayleigh.RayCalcIdealFull(calc_field, array, med, 500).doit()\r\n\t# rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n\t# rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n\t# calc_field = output.restore_field_from_disk(\"field_plane\")\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\t# ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import ribs\r", "import rayleigh\r", "import analytic_calc\r", "\timport json\r", "\timport analytic_calc_skull\r", "\timport json\r", "\timport numpy\r", "\timport ribs\r", "\timport angular_spectrum\r"]}, {"term": "def", "name": "main_from_field", "data": "def main_from_field():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tarray.add_elements_from_file(r\"..\\array_elements.txt\")\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n\tribs_phantom = {\r\n\t\t# \u0420\u0435\u0431\u0440\u0430 - \u043f\u043b\u043e\u0441\u043a\u0438\u0435 \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u043e\u043b\u043e\u0441\u043a\u0438 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u043e\u0439 \u0442\u043e\u043b\u0449\u0438\u043d\u044b\r\n\r\n\t\t# \u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u0438 \u0440\u0435\u0431\u0435\u0440 \u043e\u0442 \u0440\u0435\u0448\u0435\u0442\u043a\u0438\r\n\t\t'dist_to_ribs_plane': 45.0e-03,\r\n\t\t# 'dist_to_ribs_plane': 65.0e-03,\r\n\r\n\t\t# \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0435\u0431\u0435\u0440\r\n\t\t'ribs_count': 5,\r\n\r\n\t\t# \u0428\u0438\u0440\u0438\u043d\u0430 \u0440\u0435\u0431\u0440\u0430\r\n\t\t'rib_width': 18.0e-03,\r\n\r\n\t\t# \u0428\u0438\u0440\u0438\u043d\u0430 \u0449\u0435\u043b\u0438 \u043c\u0435\u0436\u0434\u0443 \u0440\u0435\u0431\u0440\u0430\u043c\u0438\r\n\t\t'gap_width': 14.0e-03,\r\n\r\n\t\t# \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 Y \u043d\u0438\u0436\u043d\u0435\u0439 \u0433\u0440\u0430\u043d\u0438 \u043d\u0438\u0436\u043d\u0435\u0433\u043e \u0440\u0435\u0431\u0440\u0430\r\n\t\t'bottom_coord': 14.0e-03\r\n\t}\r\n\r\n\tfield_init = output.restore_field_from_disk(r\"..\\field_plane_ribs\")\r\n\tclean_field_on_ribs(field_init, ribs_phantom)\r\n\toutput.save_field_on_disk(field_init, r\"..\\field_plane_ribs_clean\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\t# calc_field.set_nodes_num(121, 121, 1)\r\n\t# calc_field.set_grid_bottom(-15.0e-03, -15.0e-03, 130.0e-03)\r\n\t# calc_field.set_grid_top(15.0e-03, 15.0e-03, 130.0e-03)\r\n\tcalc_field.set_nodes_num(241, 241, 1)\r\n\tcalc_field.set_grid_bottom(-120.0e-03, -120.0e-03, 130.0e-03)\r\n\tcalc_field.set_grid_top(120.0e-03, 120.0e-03, 130.0e-03)\r\n\t# calc_field.set_nodes_num(1, 201, 1)\r\n\t# calc_field.set_grid_bottom(0.0e-03, -25.0e-03, 130.0e-03)\r\n\t# calc_field.set_grid_top(0.0e-03, 25.0e-03, 130.0e-03)\r\n\t# calc_field.set_nodes_num(1000, 1000, 1)\r\n\t# calc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n\t# array.switch_off_elements_from_file(r\"..\\switched_off.txt\")\r\n\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\t# rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n\t# rayleigh.RayCalc(calc_field, array, med, 500).doit()\r\n\t# rayleigh.RayCalcIdealRibs(calc_field, array, med, 500, ribs_phantom).doit()\r\n\trayleigh.RayCalcFromField(calc_field, array, med, field_init).doit()\r\n\t# rayleigh.RayCalcIdealFull(calc_field, array, med, 300).doit()\r\n\t# rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n\t# rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\t# ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import ribs\r", "import rayleigh\r", "import analytic_calc\r", "\timport json\r", "\timport analytic_calc_skull\r", "\timport json\r", "\timport numpy\r", "\timport ribs\r", "\timport angular_spectrum\r"]}, {"term": "def", "name": "clean_field_on_ribs", "data": "def clean_field_on_ribs(field, ribs_phantom):\r\n\timport numpy\r\n\timport ribs\r\n\tsh = numpy.shape(field.p)\r\n\tfor j in range(0, sh[1]):\r\n\t\tfield_x, field_y, field_z = field.get_cartesian_coords(0, j, 0)\r\n\t\tif ribs.is_point_on_ribs(ribs_phantom, field_y):\r\n\t\t\tfield.p[:, j, :] = 0 + 1j*0\r\n\t\t\tfield.vn[:, j, :] = 0 + 1j*0\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import ribs\r", "import rayleigh\r", "import analytic_calc\r", "\timport json\r", "\timport analytic_calc_skull\r", "\timport json\r", "\timport numpy\r", "\timport ribs\r", "\timport angular_spectrum\r"]}, {"term": "def", "name": "main_spectrum_focus", "data": "def main_spectrum_focus():\r\n\timport angular_spectrum\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tarray.add_elements_from_file(r\"..\\array_elements.txt\")\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\tcalc_field.set_nodes_num(101, 101, 1)\r\n\tcalc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 130.0e-03)\r\n\tcalc_field.set_grid_top(100.0e-03, 100.0e-03, 130.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n\t# array.switch_off_elements_from_file(r\"..\\switched_off.txt\")\r\n\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\t# rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n\t# rayleigh.RayCalc(calc_field, array, med, 500).doit()\r\n\t# rayleigh.RayCalcIdealRibs(calc_field, array, med, 500, ribs_phantom).doit()\r\n\tfield_ribs = output.restore_field_from_disk(r\"..\\field_plane_ribs\")\r\n\t# \u0413\u0434\u0435 \u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043f\u043e\u043b\u0435\r\n\tz = -(130.0e-03 - 45.0e-03)\r\n\tp_f, v_f = angular_spectrum.propagate_cartesian(field_ribs.p[:, :, 0], 0.66e-03, 0.66e-03, array.frequency, med.density, med.speed_of_sound, z)\r\n\r\n\tcalc_field.p[:,:,0] = p_f\r\n\tcalc_field.vn[:,:,0] = v_f\r\n\t# rayleigh.RayCalcIdealFull(calc_field, array, med, 300).doit()\r\n\t# rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n\t# rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\t# ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import ribs\r", "import rayleigh\r", "import analytic_calc\r", "\timport json\r", "\timport analytic_calc_skull\r", "\timport json\r", "\timport numpy\r", "\timport ribs\r", "\timport angular_spectrum\r"]}, {"term": "def", "name": "main_one_el", "data": "def main_one_el():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\t# array = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tarray = transducer.Transducer(\"Test\", 185.0e-03, 130.0e-03, 6.0e-03, 1.0e06, 10.0e-03)\r\n\t# array.add_element(\"0\", 0.0, 0.0)\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\tcalc_field.set_nodes_num(241, 1, 1)\r\n\tcalc_field.set_grid_bottom(-3.0e-03, 0.0e-03, 130.0e-03)\r\n\tcalc_field.set_grid_top(3.0e-03, 0.0e-03, 130.0e-03)\r\n\t# calc_field.set_nodes_num(341, 341, 1)\r\n\t# calc_field.set_grid_bottom(-85.0e-03, -85.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(85.0e-03, 85.0e-03, 45.0e-03)\r\n\t# calc_field.set_nodes_num(1000, 1000, 1)\r\n\t# calc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n\t# array.switch_off_elements_from_file(r\"switched_off.txt\")\r\n\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\t# rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n\t# rayleigh.RayCalc(calc_field, array, med, 1000).doit()\r\n\trayleigh.reference_anal_calc_in_focal_plane(calc_field, array, med)\r\n\t# rayleigh.RayCalcIdealRibs(calc_field, array, med, 1300, ribs_phantom).doit()\r\n\t# rayleigh.RayCalcIdealFull(calc_field, array, med, 300).doit()\r\n\t# rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n\t# rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n\t# calc_field = output.restore_field_from_disk(\"field_plane\")\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\t# ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import ribs\r", "import rayleigh\r", "import analytic_calc\r", "\timport json\r", "\timport analytic_calc_skull\r", "\timport json\r", "\timport numpy\r", "\timport ribs\r", "\timport angular_spectrum\r"]}, {"term": "def", "name": "main_ideal_ref", "data": "def main_ideal_ref():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\t# array.add_element(\"0\", 0.0, 0.0)\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\t# calc_field.set_nodes_num(1, 1, 801)\r\n\t# calc_field.set_grid_bottom(0.0e-03, 0.0e-03, 110.0e-03)\r\n\t# calc_field.set_grid_top(0.0e-03, 0.0e-03, 150.0e-03)\r\n\tcalc_field.set_nodes_num(201, 1, 1)\r\n\tcalc_field.set_grid_bottom(-5.0e-03, 0.0e-03, 130.0e-03)\r\n\tcalc_field.set_grid_top(5.0e-03, 0.0e-03, 130.0e-03)\r\n\t# calc_field.set_nodes_num(1000, 1000, 1)\r\n\t# calc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n\t# array.switch_off_elements_from_file(r\"switched_off.txt\")\r\n\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\t# rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\r\n\t# rayleigh.RayCalc(calc_field, array, med, 1000).doit()\r\n\t# rayleigh.reference_anal_calc_on_axis(calc_field, array, med)\r\n\t# rayleigh.reference_anal_calc_in_focal_plane(calc_field, array, med)\r\n\t# rayleigh.RayCalcIdealRibs(calc_field, array, med, 1300, ribs_phantom).doit()\r\n\trayleigh.RayCalcIdealFull(calc_field, array, med, 1500).doit()\r\n\t# rayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n\t# rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n\t# calc_field = output.restore_field_from_disk(\"field_plane\")\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\t# ribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import ribs\r", "import rayleigh\r", "import analytic_calc\r", "\timport json\r", "\timport analytic_calc_skull\r", "\timport json\r", "\timport numpy\r", "\timport ribs\r", "\timport angular_spectrum\r"]}, {"term": "def", "name": "prepare_logging", "data": "def prepare_logging():\r\n\tlogging.basicConfig(\r\n\t\tfilename='log.txt',\r\n\t\tfilemode='w',\r\n\t\tformat='%(asctime)s %(message)s',\r\n\t\tdatefmt='%Y/%m/%d %H:%M:%S',\r\n\t\tlevel=logging.INFO\r\n\t)\r\n\tconsole = logging.StreamHandler(stream=sys.stdout)\r\n\tconsole.setLevel(logging.INFO)\r\n\tconsole.setFormatter(logging.Formatter('%(message)s'))\r\n\tlogging.getLogger('').addHandler(console)\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import ribs\r", "import rayleigh\r", "import analytic_calc\r", "\timport json\r", "\timport analytic_calc_skull\r", "\timport json\r", "\timport numpy\r", "\timport ribs\r", "\timport angular_spectrum\r"]}, {"term": "def", "name": "new_work_dir_with_time_stamp", "data": "def new_work_dir_with_time_stamp():\r\n\tpath = os.getcwd()\r\n\tpath += \"\\\\\" + time.strftime(\"%Y-%m-%d_%H-%M-%S\", time.localtime())\r\n\tos.mkdir(path)\r\n\tos.chdir(path)\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import ribs\r", "import rayleigh\r", "import analytic_calc\r", "\timport json\r", "\timport analytic_calc_skull\r", "\timport json\r", "\timport numpy\r", "\timport ribs\r", "\timport angular_spectrum\r"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [], [], [{"term": "def", "name": "insert_number_in_calc_result", "data": "def insert_number_in_calc_result(button_number):\r\n\tcurrent = lbl_calc_result['text']\r\n\tif current == '0': \r\n\t\tlbl_calc_result['text'] = button_number\r\n\telif button_number == '=':\r\n\t\tlbl_calc_result['text'] = f'{eval(current)}'\r\n\telse:\r\n\t\tlbl_calc_result['text'] += button_number\r\n\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "weight_fun", "data": "def weight_fun(x, a, b, c):\n\treturn a + b * np.cos(x) + c * np.sin(x)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from glob import glob", "import os, errno", "from scipy import optimize, stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calc_weights", "data": "def calc_weights(num_classes, coeffs):\n\tk2PI = 2* np.pi\n\tx = np.linspace(0, k2PI, num_classes)\n\tdata_len = coeffs.shape[0]\n\tweights = np.zeros((data_len, num_classes))\n\tfor i in range(data_len):\n\t\tweights[i] = weight_fun(x, *coeffs[i])\n\treturn weights\n", "description": null, "category": "math", "imports": ["import numpy as np", "from glob import glob", "import os, errno", "from scipy import optimize, stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calc_argmaxs_distances", "data": "def calc_argmaxs_distances(pred_arg_maxs, calc_arg_maxs, num_class):\n\treturn calculate_deltas_signed(calc_arg_maxs, pred_arg_maxs, num_class)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from glob import glob", "import os, errno", "from scipy import optimize, stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics_from_file", "data": "def calculate_metrics_from_file(directory, num_classes):\n\tcalc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n\tpreds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n\treturn calculate_metrics(calc_w, preds_w, num_classes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from glob import glob", "import os, errno", "from scipy import optimize, stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics", "data": "def calculate_metrics(calc_w, preds_w, num_classes):\n\tpred_arg_maxs = np.argmax(preds_w, axis=1)\n\tcalc_arg_maxs = np.argmax(calc_w, axis=1)\n\n\tk2PI = 2 * np.pi\n\tcalc_pred_argmaxs_abs_distances = calculate_deltas_unsigned( pred_arg_maxs, calc_arg_maxs, num_classes)\n\tcalc_pred_argmaxs_signed_distances = calculate_deltas_signed(pred_arg_maxs, calc_arg_maxs, num_classes)\n\tcalc_pred_argmaxs_abs_distances_rad = calc_pred_argmaxs_abs_distances * k2PI/(1.0*num_classes)\n\t\n\tmean_deltas = np.mean(calc_pred_argmaxs_signed_distances, dtype=np.float64)\n\tmean_deltas_err = stats.sem(calc_pred_argmaxs_signed_distances)\n\tmean_deltas_rad = mean_deltas * k2PI/(1.0*num_classes)\n\tmean_deltas_err_rad = mean_deltas_err * k2PI/(1.0*num_classes)\n\n\tacc0 = (calc_pred_argmaxs_abs_distances <= 0).mean()\n\tacc1 = (calc_pred_argmaxs_abs_distances <= 1).mean()\n\tacc2 = (calc_pred_argmaxs_abs_distances <= 2).mean()\n\tacc3 = (calc_pred_argmaxs_abs_distances <= 3).mean()\n\n\tacc0_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.25).mean()\n\tacc1_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.50).mean()\n\tacc2_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.75).mean()\n\tacc3_rad = (calc_pred_argmaxs_abs_distances_rad <= 1.00).mean()\n\n\tl1_delta_w = np.mean(np.abs(calc_w - preds_w), dtype=np.float64)\n\tl2_delta_w = np.sqrt(np.mean((calc_w - preds_w)**2), dtype=np.float64)\n\n\t# calc_w, preds_w normalisation to probability\n\tcalc_w_norm = calc_w / np.sum(calc_w, axis=1)[:, np.newaxis]\n\tpreds_w_norm = preds_w / np.sum(preds_w, axis=1)[:, np.newaxis]\n \n\tl1_delta_w_norm = np.mean(np.abs(calc_w_norm - preds_w_norm), dtype=np.float64)\n\tl2_delta_w_norm = np.sqrt(np.mean((calc_w_norm - preds_w_norm)**2), dtype=np.float64)\n  \n\t\n\treturn np.array([acc0, acc1, acc2, acc3, mean_deltas, l1_delta_w, l2_delta_w, mean_deltas_rad, acc0_rad, acc1_rad, acc2_rad, acc3_rad,l1_delta_w_norm, l2_delta_w_norm, mean_deltas_err, mean_deltas_err_rad, ]) \n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from glob import glob", "import os, errno", "from scipy import optimize, stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics_regr_popts_from_file", "data": "def calculate_metrics_regr_popts_from_file(directory, num_classes):\n\tcalc_popts = np.load(os.path.join(directory,'test_regr_calc_popts.npy'))\n\tpred_popts = np.load(os.path.join(directory,'test_regr_preds_popts.npy'))\n\n\treturn calculate_metrics_regr_popts(calc_popts, pred_popts, num_classes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from glob import glob", "import os, errno", "from scipy import optimize, stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics_regr_popts", "data": "def calculate_metrics_regr_popts(calc_popts, pred_popts, num_classes):\n\tcalc_w  = calc_weights(num_classes, calc_popts)\n\tpreds_w = calc_weights(num_classes, pred_popts)\n\n\treturn calculate_metrics(calc_w, preds_w, num_classes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from glob import glob", "import os, errno", "from scipy import optimize, stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "get_filename_for_class", "data": "def get_filename_for_class(pathIN, class_num, subset=None):\n\td = '../monit_npy/nn_rhorho_Variant-All_Unweighted_False_NO_NUM_CLASSES_{class_num}'\n\tif subset:\n\t\td += \"_WEIGHTS_SUBS\" + str(subset)\n\treturn d\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from glob import glob", "import os, errno", "from scipy import optimize, stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "evaluate_roc_auc", "data": "def evaluate_roc_auc(preds, wa, wb):\n\tn = len(preds)\n\ttrue_labels = np.concatenate([np.ones(n), np.zeros(n)])\n\tpreds = np.concatenate([preds, preds])\n\tweights = np.concatenate([wa, wb])\n\t\n\treturn roc_auc_score(true_labels, preds, sample_weight=weights)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from glob import glob", "import os, errno", "from scipy import optimize, stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_roc_auc", "data": "def calculate_roc_auc(preds_w, calc_w, index_a, index_b):\n\tn, num_classes = calc_w.shape\n\ttrue_labels = np.concatenate([np.ones(n), np.zeros(n)])\n\tpreds = np.concatenate([preds_w[:, index_a], preds_w[:, index_a]])\n\tweights = np.concatenate([calc_w[:, index_a], calc_w[:, index_b]])\n\n\treturn roc_auc_score(true_labels, preds, sample_weight=weights)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from glob import glob", "import os, errno", "from scipy import optimize, stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "test_roc_auc", "data": "def test_roc_auc(directory, num_class):\n\tcalc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n\tpreds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n\t\n\toracle_roc_auc = []\n\tpreds_roc_auc  = []\n\t\n\tfor i in range(0, num_class):\n\t\t oracle_roc_auc  += [calculate_roc_auc(calc_w, calc_w, 0, i)]\n\t\t preds_roc_auc   += [calculate_roc_auc(preds_w, calc_w, 0, i)]\n\t\t print(i,\n\t\t\t\t  'oracle_roc_auc: {}'.format(calculate_roc_auc(calc_w, calc_w, 0, i)),\n\t\t\t\t  'preds_roc_auc: {}'.format(calculate_roc_auc(preds_w, calc_w, 0, i)))\n\n\treturn oracle_roc_auc, preds_roc_auc\n", "description": null, "category": "math", "imports": ["import numpy as np", "from glob import glob", "import os, errno", "from scipy import optimize, stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}], [{"term": "def", "name": "np2num", "data": "def np2num(a, typecode=None):\n\tif num.__version__ > '23.8':\n\t\treturn num.array(a, typecode)\n\tif typecode is None:\n\t\ttypecode = num.Float\n\tb = num.fromstring(a.tostring(), typecode)\n\tb.shape = a.shape\n\treturn b\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.old import OldASEListOfAtomsWrapper", "\timport Numeric as num", "\t\t\tfrom Dacapo import Dacapo", "\t\tfrom Dacapo import Dacapo", "\t\t\tfrom ASE import Atom, ListOfAtoms"]}, {"term": "def", "name": "restart", "data": "def restart(filename, **kwargs):\n\tcalc = Dacapo(filename, **kwargs)\n\tatoms = calc.get_atoms()\n\treturn atoms, calc\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.old import OldASEListOfAtomsWrapper", "\timport Numeric as num", "\t\t\tfrom Dacapo import Dacapo", "\t\tfrom Dacapo import Dacapo", "\t\t\tfrom ASE import Atom, ListOfAtoms"]}, {"term": "class", "name": "classDacapo:", "data": "class Dacapo:\n\tdef __init__(self, filename=None, stay_alive=False, stress=False,\n\t\t\t\t **kwargs):\n\n\t\tself.kwargs = kwargs\n\t\tself.stay_alive = stay_alive\n\t\tself.stress = stress\n\t\t\n\t\tif filename is not None:\n\t\t\tfrom Dacapo import Dacapo\n\t\t\tself.loa = Dacapo.ReadAtoms(filename, **kwargs)\n\t\t\tself.calc = self.loa.GetCalculator()\n\t\telse:\n\t\t\tself.loa = None\n\t\t\tself.calc = None\n\n\t\tself.pps = []\n\t\t\n\tdef set_pp(self, Z, path):\n\t\tself.pps.append((Z, path))\n\n\tdef set_txt(self, txt):\n\t\tif self.calc is None:\n\t\t\tself.kwargs['txtout'] = txt\n\t\telse:\n\t\t\tself.calc.SetTxtFile(txt)\n\n\tdef set_nc(self, nc):\n\t\tif self.calc is None:\n\t\t\tself.kwargs['out'] = nc\n\t\telse:\n\t\t\tself.calc.SetNetCDFFile(nc)\n\n\tdef update(self, atoms):\n\t\tfrom Dacapo import Dacapo\n\t\tif self.calc is None:\n\t\t\tif 'nbands' not in self.kwargs:\n\t\t\t\tn = sum([valence[atom.symbol] for atom in atoms])\n\t\t\t\tself.kwargs['nbands'] = int(n * 0.65) + 4\n\n\t\t\tmagmoms = atoms.get_initial_magnetic_moments()\n\t\t\tif magmoms.any():\n\t\t\t\tself.kwargs['spinpol'] = True\n\n\t\t\tself.calc = Dacapo(**self.kwargs)\n\n\t\t\tif self.stay_alive:\n\t\t\t\tself.calc.StayAliveOn()\n\t\t\telse:\n\t\t\t\tself.calc.StayAliveOff()\n\n\t\t\tif self.stress:\n\t\t\t\tself.calc.CalculateStress()\n\n\t\t\tfor Z, path in self.pps:\n\t\t\t\tself.calc.SetPseudoPotential(Z, path)\n\n\t\tif self.loa is None:\n\t\t\tfrom ASE import Atom, ListOfAtoms\n\t\t\tnumbers = atoms.get_atomic_numbers()\n\t\t\tpositions = atoms.get_positions()\n\t\t\tmagmoms = atoms.get_initial_magnetic_moments()\n\t\t\tself.loa = ListOfAtoms([Atom(Z=numbers[a],\n\t\t\t\t\t\t\t\t\t\t position=positions[a],\n\t\t\t\t\t\t\t\t\t\t magmom=magmoms[a])\n\t\t\t\t\t\t\t\t\tfor a in range(len(atoms))],\n\t\t\t\t\t\t\t\t   cell=np2num(atoms.get_cell()),\n\t\t\t\t\t\t\t\t   periodic=tuple(atoms.get_pbc()))\n\t\t\tself.loa.SetCalculator(self.calc)\n\t\telse:\n\t\t\tself.loa.SetCartesianPositions(np2num(atoms.get_positions()))\n\t\t\tself.loa.SetUnitCell(np2num(atoms.get_cell()), fix=True)\n\t\t\t\n\tdef get_atoms(self):\n\t\tatoms = OldASEListOfAtomsWrapper(self.loa).copy()\n\t\tatoms.set_calculator(self)\n\t\treturn atoms\n\t\n\tdef get_potential_energy(self, atoms):\n\t\tself.update(atoms)\n\t\treturn self.calc.GetPotentialEnergy()\n\n\tdef get_forces(self, atoms):\n\t\tself.update(atoms)\n\t\treturn np.array(self.calc.GetCartesianForces())\n\n\tdef get_stress(self, atoms):\n\t\tself.update(atoms)\n\t\tstress = np.array(self.calc.GetStress())\n\t\tif stress.ndim == 2:\n\t\t\treturn stress.ravel()[[0, 4, 8, 5, 2, 1]]\n\t\telse:\n\t\t\treturn stress\n\n\tdef calculation_required(self, atoms, quantities):\n\t\tif self.calc is None:\n\t\t\treturn True\n\n\t\tif atoms != self.get_atoms():\n\t\t\treturn True\n\n\t\treturn False\n\t\t\n\tdef get_number_of_bands(self):\n\t\treturn self.calc.GetNumberOfBands()\n\n\tdef get_k_point_weights(self):\n\t\treturn np.array(self.calc.GetIBZKPointWeights())\n\n\tdef get_number_of_spins(self):\n\t\treturn 1 + int(self.calc.GetSpinPolarized())\n\n\tdef get_eigenvalues(self, kpt=0, spin=0):\n\t\treturn np.array(self.calc.GetEigenvalues(kpt, spin))\n\n\tdef get_fermi_level(self):\n\t\treturn self.calc.GetFermiLevel()\n\n\tdef get_magnetic_moment(self):\n\t\treturn self.calc.GetMagneticMoment()\n\n\tdef get_number_of_electrons(self):\n\t\treturn self.calc.GetValenceElectrons()\n\n\tdef get_number_of_grid_points(self):\n\t\treturn np.array(self.get_pseudo_wave_function(0, 0, 0).shape)\n\n\tdef get_pseudo_density(self, spin=0):\n\t\treturn np.array(self.calc.GetDensityArray(spin))\n\t\n\tdef get_pseudo_wave_function(self, band=0, kpt=0, spin=0, pad=True):\n\t\tkpt_c = self.get_bz_k_points()[kpt]\n\t\tstate = self.calc.GetElectronicStates().GetState(band=band, spin=spin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t kptindex=kpt)\n\n\t\t# Get wf, without bloch phase (Phase = True doesn't do anything!)\n\t\twave = state.GetWavefunctionOnGrid(phase=False)\n\n\t\t# Add bloch phase if this is not the Gamma point\n\t\tif np.all(kpt_c == 0):\n\t\t\treturn wave\n\t\tcoord = state.GetCoordinates()\n\t\tphase = coord[0] * kpt_c[0] + coord[1] * kpt_c[1] + coord[2] * kpt_c[2]\n\t\treturn np.array(wave) * np.exp(-2.j * np.pi * phase) # sign! XXX\n\n\t\t#return np.array(self.calc.GetWaveFunctionArray(n, k, s)) # No phase!\n\n\tdef get_bz_k_points(self):\n\t\treturn np.array(self.calc.GetBZKPoints())\n\n\tdef get_ibz_k_points(self):\n\t\treturn np.array(self.calc.GetIBZKPoints())\n\n\tdef get_wannier_localization_matrix(self, nbands, dirG, kpoint,\n\t\t\t\t\t\t\t\t\t\tnextkpoint, G_I, spin):\n\t\treturn np.array(self.calc.GetWannierLocalizationMatrix(\n\t\t\tG_I=G_I.tolist(), nbands=nbands, dirG=dirG.tolist(),\n\t\t\tkpoint=kpoint, nextkpoint=nextkpoint, spin=spin))\n\t\n\tdef initial_wannier(self, initialwannier, kpointgrid, fixedstates,\n\t\t\t\t\t\tedf, spin):\n\t\t# Use initial guess to determine U and C\n\t\tinit = self.calc.InitialWannier(initialwannier, self.atoms,\n\t\t\t\t\t\t\t\t\t\tnp2num(kpointgrid, num.Int))\n\n\t\tstates = self.calc.GetElectronicStates()\n\t\twaves = [[state.GetWaveFunction()\n\t\t\t\t  for state in states.GetStatesKPoint(k, spin)]\n\t\t\t\t for k in self.calc.GetIBZKPoints()]\n\n\t\tinit.SetupMMatrix(waves, self.calc.GetBZKPoints())\n\t\tc, U = init.GetListOfCoefficientsAndRotationMatrices(\n\t\t\t(self.calc.GetNumberOfBands(), fixedstates, edf))\n\t\tU = np.array(U)\n\t\tfor k in range(len(c)):\n\t\t\tc[k] = np.array(c[k])\n\t\treturn c, U\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase.old import OldASEListOfAtomsWrapper", "\timport Numeric as num", "\t\t\tfrom Dacapo import Dacapo", "\t\tfrom Dacapo import Dacapo", "\t\t\tfrom ASE import Atom, ListOfAtoms"]}], [{"term": "class", "name": "WorkbookProperties", "data": "class WorkbookProperties(Serialisable):\n\n\ttagname = \"workbookPr\"\n\n\tdate1904 = Bool(allow_none=True)\n\tdateCompatibility = Bool(allow_none=True)\n\tshowObjects = NoneSet(values=(['all', 'placeholders']))\n\tshowBorderUnselectedTables = Bool(allow_none=True)\n\tfilterPrivacy = Bool(allow_none=True)\n\tpromptedSolutions = Bool(allow_none=True)\n\tshowInkAnnotation = Bool(allow_none=True)\n\tbackupFile = Bool(allow_none=True)\n\tsaveExternalLinkValues = Bool(allow_none=True)\n\tupdateLinks = NoneSet(values=(['userSet', 'never', 'always']))\n\tcodeName = String(allow_none=True)\n\thidePivotFieldList = Bool(allow_none=True)\n\tshowPivotChartFilter = Bool(allow_none=True)\n\tallowRefreshQuery = Bool(allow_none=True)\n\tpublishItems = Bool(allow_none=True)\n\tcheckCompatibility = Bool(allow_none=True)\n\tautoCompressPictures = Bool(allow_none=True)\n\trefreshAllConnections = Bool(allow_none=True)\n\tdefaultThemeVersion = Integer(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t date1904=None,\n\t\t\t\t dateCompatibility=None,\n\t\t\t\t showObjects=None,\n\t\t\t\t showBorderUnselectedTables=None,\n\t\t\t\t filterPrivacy=None,\n\t\t\t\t promptedSolutions=None,\n\t\t\t\t showInkAnnotation=None,\n\t\t\t\t backupFile=None,\n\t\t\t\t saveExternalLinkValues=None,\n\t\t\t\t updateLinks=None,\n\t\t\t\t codeName=None,\n\t\t\t\t hidePivotFieldList=None,\n\t\t\t\t showPivotChartFilter=None,\n\t\t\t\t allowRefreshQuery=None,\n\t\t\t\t publishItems=None,\n\t\t\t\t checkCompatibility=None,\n\t\t\t\t autoCompressPictures=None,\n\t\t\t\t refreshAllConnections=None,\n\t\t\t\t defaultThemeVersion=None,\n\t\t\t\t):\n\t\tself.date1904 = date1904\n\t\tself.dateCompatibility = dateCompatibility\n\t\tself.showObjects = showObjects\n\t\tself.showBorderUnselectedTables = showBorderUnselectedTables\n\t\tself.filterPrivacy = filterPrivacy\n\t\tself.promptedSolutions = promptedSolutions\n\t\tself.showInkAnnotation = showInkAnnotation\n\t\tself.backupFile = backupFile\n\t\tself.saveExternalLinkValues = saveExternalLinkValues\n\t\tself.updateLinks = updateLinks\n\t\tself.codeName = codeName\n\t\tself.hidePivotFieldList = hidePivotFieldList\n\t\tself.showPivotChartFilter = showPivotChartFilter\n\t\tself.allowRefreshQuery = allowRefreshQuery\n\t\tself.publishItems = publishItems\n\t\tself.checkCompatibility = checkCompatibility\n\t\tself.autoCompressPictures = autoCompressPictures\n\t\tself.refreshAllConnections = refreshAllConnections\n\t\tself.defaultThemeVersion = defaultThemeVersion\n\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}, {"term": "class", "name": "CalcProperties", "data": "class CalcProperties(Serialisable):\n\n\ttagname = \"calcPr\"\n\n\tcalcId = Integer()\n\tcalcMode = NoneSet(values=(['manual', 'auto', 'autoNoTable']))\n\tfullCalcOnLoad = Bool(allow_none=True)\n\trefMode = NoneSet(values=(['A1', 'R1C1']))\n\titerate = Bool(allow_none=True)\n\titerateCount = Integer(allow_none=True)\n\titerateDelta = Float(allow_none=True)\n\tfullPrecision = Bool(allow_none=True)\n\tcalcCompleted = Bool(allow_none=True)\n\tcalcOnSave = Bool(allow_none=True)\n\tconcurrentCalc = Bool(allow_none=True)\n\tconcurrentManualCount = Integer(allow_none=True)\n\tforceFullCalc = Bool(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t calcId=124519,\n\t\t\t\t calcMode=None,\n\t\t\t\t fullCalcOnLoad=True,\n\t\t\t\t refMode=None,\n\t\t\t\t iterate=None,\n\t\t\t\t iterateCount=None,\n\t\t\t\t iterateDelta=None,\n\t\t\t\t fullPrecision=None,\n\t\t\t\t calcCompleted=None,\n\t\t\t\t calcOnSave=None,\n\t\t\t\t concurrentCalc=None,\n\t\t\t\t concurrentManualCount=None,\n\t\t\t\t forceFullCalc=None,\n\t\t\t\t):\n\t\tself.calcId = calcId\n\t\tself.calcMode = calcMode\n\t\tself.fullCalcOnLoad = fullCalcOnLoad\n\t\tself.refMode = refMode\n\t\tself.iterate = iterate\n\t\tself.iterateCount = iterateCount\n\t\tself.iterateDelta = iterateDelta\n\t\tself.fullPrecision = fullPrecision\n\t\tself.calcCompleted = calcCompleted\n\t\tself.calcOnSave = calcOnSave\n\t\tself.concurrentCalc = concurrentCalc\n\t\tself.concurrentManualCount = concurrentManualCount\n\t\tself.forceFullCalc = forceFullCalc\n\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}, {"term": "class", "name": "FileVersion", "data": "class FileVersion(Serialisable):\n\n\ttagname = \"fileVersion\"\n\n\tappName = String(allow_none=True)\n\tlastEdited = String(allow_none=True)\n\tlowestEdited = String(allow_none=True)\n\trupBuild = String(allow_none=True)\n\tcodeName = Guid(allow_none=True)\n\n\tdef __init__(self,\n\t\t\t\t appName=None,\n\t\t\t\t lastEdited=None,\n\t\t\t\t lowestEdited=None,\n\t\t\t\t rupBuild=None,\n\t\t\t\t codeName=None,\n\t\t\t\t):\n\t\tself.appName = appName\n\t\tself.lastEdited = lastEdited\n\t\tself.lowestEdited = lowestEdited\n\t\tself.rupBuild = rupBuild\n\t\tself.codeName = codeName\n", "description": null, "category": "math", "imports": ["from openpyxl.descriptors.serialisable import Serialisable", "from openpyxl.descriptors import (", "from openpyxl.descriptors.excel import Guid"]}], [{"term": "class", "name": "Riskreport", "data": "class Riskreport(object):\n\tdef __init__(self,df_expo,df_w,df_covm,df_specrisk,ls_industryfactor,ls_stylefactor):\n\t\tself.df_expo=df_expo\n\t\tself.df_w=df_w\n\t\tself.df_covm=df_covm\n\t\tself.df_specrisk=df_specrisk\n\t\tself.ls_industryfactor=ls_industryfactor\n\t\tself.ls_stylefactor=ls_stylefactor\n\n\tdef calcX(self):\n\t\treturn (self.df_expo.T).dot(self.df_w)\n\n\tdef calcPortCommonRisk(self):\n\t\tself.calcX()[np.isnan(self.calcX())]=0\n\t\treturn float((((self.calcX().T).dot(self.df_covm)).dot(self.calcX())).ix[0,0])\n\n\tdef calcPortSpecificRisk(self):\n\t\treturn float((((self.df_w.T).dot(self.df_specrisk)).dot(self.df_w)).ix[0,0])\n\n\tdef calcTotalRisk(self):\n\t\treturn (self.calcPortCommonRisk()+self.calcPortSpecificRisk())\n\n\tdef calcSigmaRisk(self):\n\t\treturn (mt.sqrt(self.calcTotalRisk()))\n\n\tdef calcTotalRiskall(self,f_varp,columnname):\n\t\tf_var =self.calcTotalRisk()\n\t\tf_sigma = self.calcSigmaRisk()\n\t\ttry:\n\t\t\tf_percent = f_var/f_varp\n\t\texcept:\n\t\t\tf_percent=np.nan\n\t\tdf_riskall = pd.DataFrame(data=([[f_var,f_sigma,f_percent]]),columns=columnname)\n\t\treturn df_riskall\n\n\tdef calcFMCR(self):\n\t\ttry:\n\t\t\txpa =self.calcX()\n\t\t\txpa[np.isnan(xpa)]=0\n\t\t\tdf_allcovm =self.df_covm\n\t\t\tls_allfactor=self.ls_industryfactor+self.ls_stylefactor\n\n\t\t\tdict_factorcontrib = [pd.DataFrame(data=float((((xpa.T[[i]]).dot(df_allcovm[df_allcovm.index == i])).dot(xpa)).ix[0,0]),index=[i],columns=['value'])  for i in ls_allfactor]\n\t\t\tdf_fmcar=pd.concat(dict_factorcontrib,axis=0)\n\n\t\t\tdf_sigmafmcar=pd.DataFrame(df_fmcar['value'].apply(lambda x:np.sqrt(x) if x>= 0 else np.nan))\n\n\t\t\tdf_fmcar_raw=self.df_covm.dot(self.calcX())/self.calcSigmaRisk()\n\t\t\tdf_percenfmcar = self.calcX() * df_fmcar_raw/self.calcSigmaRisk()\n\n\t\t\tdf_fmcar.rename(columns={'value':'FMCAR'},inplace=True)\n\t\t\tdf_sigmafmcar.rename(columns={'value':'sigmaFMCAR'},inplace=True)\n\t\t\tdf_percenfmcar.rename(columns={'Wa':'percenFMCAR'},inplace=True)\n\t\t\tdf_fmcarall=pd.concat([df_fmcar,df_sigmafmcar,df_percenfmcar],axis=1)\n\n\t\t\treturn df_fmcarall\n\t\texcept:\n\t\t\treturn np.nan\n\n\tdef calcIndustryFMCAR(self):\n\t\treturn (self.calcFMCR().reindex(self.ls_industryfactor))\n\n\tdef calcstyleFMCAR(self):\n\t\treturn (self.calcFMCR().reindex(self.ls_stylefactor))\n\n\tdef calcPortCommonRiskall(self,f_vara,indexname):\n\t\tf_varfactor = self.calcPortCommonRisk()\n\t\tf_sigmafactor = mt.sqrt(f_varfactor)\n\t\ttry:\n\t\t\tf_percenfactor = f_varfactor/f_vara\n\t\texcept:\n\t\t\tf_percenfactor=np.nan\n\n\t\tdf_factor=pd.DataFrame(data=[[f_varfactor,f_sigmafactor,f_percenfactor]],columns=['VarFactor','sigmaFactor','percenFactor'])\n\t\treturn df_factor\n\n\tdef calcPortSpecRiskall(self,f_vara,indexname):\n\t\tf_varss = self.calcPortSpecificRisk()\n\t\tf_sigmass = mt.sqrt(f_varss)\n\t\ttry:\n\t\t\tf_percenss = f_varss/f_vara\n\t\texcept:\n\t\t\tf_percenss=np.nan\n\n\t\tdf_ss=pd.DataFrame(data=[[f_varss,f_sigmass,f_percenss]],columns=['VarSS','sigmaSS','percenSS'])\n\t\treturn df_ss\n", "description": null, "category": "math", "imports": ["from lib.gftTools import gftIO", "from lib.gftTools import gftIO", "from lib.gftTools import gsConst", "import numpy as np", "import pandas as pd", "from functools import reduce", "import math as mt", "from lib.gftTools import gftIO", "from lib.gftTools import gftIO"]}, {"term": "class", "name": "Riskmodel", "data": "class Riskmodel(object):\n\n\tdef __init__(self,data,dt_selecteddate,allsymbol):\n\t\tself.data=data\n\t\tself.selectedate=dt_selecteddate\n\t\tself.allsymbol=allsymbol\n\n\tdef getfactorlist(self,i):\n\t\treturn (self.data[gftIO.gidInt2Str(self.data['osets'].asColumnTab().ix[i,0])].asColumnTab()['O0']).apply(lambda x:gftIO.gidInt2Str(x)).tolist()\n\n\tdef factorcnt(self):\n\t\treturn len(self.data['osets'].asColumnTab())\n\n\tdef getallFactor(self):\n\t\tallfactor=[]\n\t\tfor i in range(self.factorcnt()):\n\t\t\tallfactor.extend(self.getfactorlist(i))\n\t\treturn allfactor\n\n\tdef selectData(self):\n\t\tdict_fexpo=dict([(factorname,self.data[factorname].asMatrix().reindex(columns=self.allsymbol)) for factorname in self.getallFactor()])\n\t\treturn dict_fexpo\n\n\tdef Fexpomerge(self):\n\t\tdt_latest = self.selectedate\n\t\tls_raw_df_fexpo=[self.selectData()[factorname].reindex(index=[dt_latest]).rename(index={dt_latest:factorname}) for factorname in self.getallFactor()]\n\t\tdf_fexpo_onedate=pd.concat(ls_raw_df_fexpo,axis=0).fillna(0)\n\t\tdf_fexpo_onedate.index=list(gftIO.strSet2Np(np.array(df_fexpo_onedate.index)))\n\t\treturn df_fexpo_onedate.T\n", "description": null, "category": "math", "imports": ["from lib.gftTools import gftIO", "from lib.gftTools import gftIO", "from lib.gftTools import gsConst", "import numpy as np", "import pandas as pd", "from functools import reduce", "import math as mt", "from lib.gftTools import gftIO", "from lib.gftTools import gftIO"]}, {"term": "def", "name": "calcRiskAttribution", "data": "def calcRiskAttribution(dict_riskmodel,df_portwgt, df_benchwgt, dt_startdate,dt_enddate):\n\t########################step1:parameter description########################\n\n\n\t#dict_riskmodel:type:dict:dict_riskmodel=x0\n\t#df_portwgt:type:dataframe df_portwgt=x1\n\t#df_benchwgt:type:dataframe  df_benchwgt=x2\n\t#dt_startdate:type:timestamp:dt_startdate=x3\n\t#dt_enddate type:dt_enddate =x4\n\n\n\n\t########################step2:portfolio,benchmark,portfolio active data prepare########################\n\n\t##part1:get portfolio,benchmark,portfolio active weight\n\tdf_wp =df_portwgt.asColumnTab().rename(columns={'value':'Wp'})\n\tdf_wb =df_benchwgt.asColumnTab().rename(columns={'value':'Wb'})\n\tdf_wa=pd.merge(df_wp,df_wb,on=['idname','variable'],how='outer')\n\tdf_wa.fillna(0,inplace=True)\n\tdf_wa.set_index('variable',inplace=True)\n\tdf_wa['Wa']=df_wa['Wp']-df_wa['Wb']\n\t##part2:get portfolio,benchmark,portfolio active stock pool\n\tls_aname=list(set(df_portwgt.asMatrix().columns).union(set(df_benchwgt.asMatrix().columns)))\n\tls_aname.remove('idname')\n\n\n\n\n\t########################step2:data preprocessing########################\n\t##part1:date preprocessing\n\t##get factor name\n\trmodelobj=Riskmodel(dict_riskmodel,dt_startdate,ls_aname)\n\n\tif rmodelobj.factorcnt() < 2:\n\t\tls_stylefactor=list(gftIO.strSet2Np(np.array(rmodelobj.getfactorlist(0))))\n\t\tls_industryfactor=[]\n\telse:\n\t\tls_industryfactor = list(gftIO.strSet2Np(np.array(rmodelobj.getfactorlist(0))))\n\t\tls_stylefactor=list(gftIO.strSet2Np(np.array(rmodelobj.getfactorlist(1))))\n\n\tls_allfactor=list(gftIO.strSet2Np(np.array(rmodelobj.getallFactor())))\n\n\n\t##part2:factor loading preprocessing\n\tdict_risk_expo_new = {factorname: dict_riskmodel[factorname].asMatrix().dropna(how='all') for factorname in list(np.array(rmodelobj.getallFactor()))}\n\tls_ls_fexpodate=list([dict_risk_expo_new[factorname].index.tolist() for factorname in dict_risk_expo_new.keys()])\n\tls_alldates_fexpo=reduce(np.intersect1d,ls_ls_fexpodate)\n\n\n\n\n\t##part3:covM preprocessing\n\tdf_covm = dict_riskmodel['ret_cov']##factor covariance matrix\n\tdf_covm=df_covm.reset_index().reindex(columns=['factorid1','factorid2','value','date'])\n\n\tdf_covm=df_covm[df_covm['factorid1'].isin(ls_allfactor)][df_covm['factorid2'].isin(ls_allfactor)]\n\n\n\n\t##part4:specRisk preprocessing\n\tdf_specrisk_raw = dict_riskmodel['specificRisk']\n\n\t## make sure all the data source have the same date range\n\t#ls_date_range_new=list(pd.period_range(dt_startdate, dt_enddate, freq='D').to_timestamp()) ##for date range check\n\t#df_date_range=pd.DataFrame(data=ls_date_range_new,columns=['needdate'])\n\n\n\tls_port_wgt=df_portwgt.asMatrix().index\n\n\tsourceDates=sorted(list(ls_port_wgt[(ls_port_wgt <= dt_enddate) & (ls_port_wgt >= dt_startdate)]))\n\n\n\n\t###align daterange\n\t##covm specrisk align\n\ttargetDates=sorted(list(np.unique(df_covm['date'])))\n\tdf_date_map_covm = pd.DataFrame({'targetDate':targetDates}, index=targetDates)\n\tdf_date_map_covm = df_date_map_covm.reindex(sourceDates, method='ffill').dropna(how='any')\n\tdict_date_map_covm={df_date_map_covm.index[i]:df_date_map_covm.targetDate[i] for i in range(len(df_date_map_covm))}\n\n\n\n\n\t##factor align\n\ttargetDates=sorted(list(ls_alldates_fexpo))\n\tdf_date_map_expo = pd.DataFrame({'targetDate':targetDates}, index=targetDates)\n\tdf_date_map_expo = df_date_map_expo.reindex(sourceDates, method='ffill').dropna(how='any')\n\tdict_date_map_expo={df_date_map_expo.index[i]:df_date_map_expo.targetDate[i] for i in range(len(df_date_map_expo))}\n\n\n\n\n\tls_date_range=list(set(dict_date_map_covm.keys()).intersection(set(dict_date_map_expo.keys())))\n\n\tif len(ls_date_range) == 0:\n\t\traise Exception(\"date length is null,risk model and risk decom didn't match\")\n\n\t##covm\n\tdict_df_covm=dict([(dt_selecteddate,df_covm[df_covm['date'] == dict_date_map_covm[dt_selecteddate]].pivot_table(values='value', index='factorid1', columns='factorid2')) for dt_selecteddate in ls_date_range])\n\n\n\t##specrisk\n\tdf_specrisk_raw=df_specrisk_raw.reset_index().pivot('date','symbol','specificrisk')\n\tdf_specrisk_raw1=df_specrisk_raw.reindex(columns=ls_aname).T\n\tdf_specrisk= df_specrisk_raw1.fillna(df_specrisk_raw1.mean(axis=0,skipna=True))\n\tdict_df_specrisk={date:pd.DataFrame(np.diag(df_specrisk[dict_date_map_covm[date]].tolist()),index=ls_aname,columns=ls_aname) for date in ls_date_range}\n\n\n\t##weight\n\tdict_df_wa={date:df_wa[df_wa.idname == date].reindex(ls_aname).fillna(0) for date in ls_date_range}\n\n\n\t##factor exposure\n\tdict_rmodelobj=dict([(dt_selecteddate,Riskmodel(dict_riskmodel,dict_date_map_expo[dt_selecteddate],ls_aname)) for dt_selecteddate in ls_date_range])\n\tdict_df_fexpo =dict([(dt_selecteddate,dict_rmodelobj[dt_selecteddate].Fexpomerge()) for dt_selecteddate in dict_rmodelobj.keys()])\n\tdict_final_return={}\n\n\t##create date-strdate dictionary\n\tfor date in ls_date_range:\n\t\t##part4:slice portfolio active\u00e7\u0161\u201e specific risk\n\t\tdf_specriska_singledate=dict_df_specrisk[date].fillna(0)\n\t\tdf_wa_singledate=dict_df_wa[date]\n\t\tdf_covm_singledate=dict_df_covm[date]\n\t\tdict_df_fexpo_singledate=dict_df_fexpo[date]\n\t\t##part5:calculate portfolio,benchmark,portfolio active risk\n\n\n\t\tp_riskreport=Riskreport(dict_df_fexpo_singledate,df_wa_singledate[['Wp']],df_covm_singledate,df_specriska_singledate,ls_industryfactor,ls_stylefactor)\n\t\tb_riskreport=Riskreport(dict_df_fexpo_singledate,df_wa_singledate[['Wb']],df_covm_singledate,df_specriska_singledate,ls_industryfactor,ls_stylefactor)\n\t\ta_riskreport=Riskreport(dict_df_fexpo_singledate,df_wa_singledate[['Wa']],df_covm_singledate,df_specriska_singledate,ls_industryfactor,ls_stylefactor)\n\n\t\t##portfolio total risk\n\t\tf_varp =p_riskreport.calcTotalRisk()\n\t\tf_vara =a_riskreport.calcTotalRisk()\n\t\t##interaction risk\n\t\tf_varinter = f_varp - b_riskreport.calcTotalRisk() - f_vara\n\t\tif f_varinter < 0:\n\t\t\tf_sigmainter=np.nan\n\t\telse:\n\t\t\tf_sigmainter = mt.sqrt(f_varinter)\n\n\t\ttry:\n\t\t\tf_perceninter = f_varinter/f_varp\n\t\texcept:\n\t\t\tf_perceninter=np.nan\n\n\t\tdf_inter = pd.DataFrame(data=([[f_varinter,f_sigmainter,f_perceninter]]),columns=['VarInter','sigmaInter','percenInter'])\n\n\t\txpa =a_riskreport.calcX()\n\t\txpa[np.isnan(xpa)]=0\n\t\tdf_allcovm =a_riskreport.df_covm\n\t\tdict_factorcontrib = [pd.DataFrame(data=float((((xpa.T[[i]]).dot(df_allcovm[df_allcovm.index == i])).dot(xpa)).ix[0,0]),index=[i],columns=['value'])  for i in ls_allfactor]\n\t\tdf_l_factorcontrib=pd.concat(dict_factorcontrib,axis=0)\n\n\t\tif len(ls_industryfactor) >0:\n\t\t\tdf_TotIndustryFMCAR=pd.DataFrame(data=df_l_factorcontrib.reindex(index=ls_industryfactor).sum(),columns=['FMCAR'])\n\t\t\tdf_TotIndustryFMCAR['percenFMCAR']=df_TotIndustryFMCAR['FMCAR']/a_riskreport.calcTotalRisk()\n\t\t\tif df_TotIndustryFMCAR['FMCAR'][0] >= 0:\n\t\t\t\tdf_TotIndustryFMCAR['sigmaFMCAR'] = np.sqrt(df_TotIndustryFMCAR['FMCAR'][0])\n\t\t\telse:\n\t\t\t\tdf_TotIndustryFMCAR['sigmaFMCAR']=np.nan\n\n\t\t\tdf_TotStyleFMCAR=pd.DataFrame(data=df_l_factorcontrib.reindex(index=ls_stylefactor).sum(),columns=['FMCAR'])\n\t\t\tdf_TotStyleFMCAR['percenFMCAR']=df_TotStyleFMCAR['FMCAR']/a_riskreport.calcTotalRisk()\n\t\t\tif df_TotStyleFMCAR['FMCAR'][0] >= 0:\n\t\t\t\tdf_TotStyleFMCAR['sigmaFMCAR'] = np.sqrt(df_TotStyleFMCAR['FMCAR'][0])\n\t\t\telse:\n\t\t\t\tdf_TotStyleFMCAR['sigmaFMCAR']=np.nan\n\n\n\t\t\tdict_final_return[date]= {gsConst.Const.PortRisk:p_riskreport.calcTotalRiskall(f_varp,['VarP','sigmaP','percentP']),gsConst.Const.BenchmarkRisk:b_riskreport.calcTotalRiskall(f_varp,['VarB','sigmaB','percentB']),\n\tgsConst.Const.PortActiveRisk:a_riskreport.calcTotalRiskall(f_varp,['VarA','sigmaA','percentA']),gsConst.Const.InteractionRisk:df_inter,gsConst.Const.FactorRisk:a_riskreport.calcPortCommonRiskall(f_vara,['VarFactor','sigmaFactor','percenFactor']),\n\t\t\t\t   gsConst.Const.SpecificRisk:a_riskreport.calcPortSpecRiskall(f_vara,['VarSS','sigmaSS','percenSS']),gsConst.Const.IndustryFMCAR:a_riskreport.calcIndustryFMCAR().reset_index(),gsConst.Const.StyleFMCAR:a_riskreport.calcstyleFMCAR().reset_index(),\n\t\t\t\t   gsConst.Const.IndStyleFMCAR:a_riskreport.calcFMCR().reset_index(),gsConst.Const.PortExpo:p_riskreport.calcX().reset_index(),gsConst.Const.BenchmarkExpo:b_riskreport.calcX().reset_index(),\n\n\t\t\t\t   gsConst.Const.PortExpoInd:p_riskreport.calcX().reindex(index=ls_industryfactor).reset_index(),gsConst.Const.PortExpoSty:p_riskreport.calcX().reindex(index=ls_stylefactor).reset_index(),\n\t\t\t\t   gsConst.Const.BenchmarkExpoInd:b_riskreport.calcX().reindex(index=ls_industryfactor).reset_index(),gsConst.Const.BenchmarkExpoSty:b_riskreport.calcX().reindex(index=ls_stylefactor).reset_index(),\n\t\t\t\t   gsConst.Const.TotIndustryFMCAR:df_TotIndustryFMCAR,gsConst.Const.TotStyleFMCAR:df_TotStyleFMCAR\n\n\t\t\t\t   }\n\t\telse:\n\n\t\t\tdf_TotStyleFMCAR=pd.DataFrame(data=df_l_factorcontrib.reindex(index=ls_stylefactor).sum(),columns=['FMCAR'])\n\t\t\tdf_TotStyleFMCAR['percenFMCAR']=df_TotStyleFMCAR['FMCAR']/a_riskreport.calcTotalRisk()\n\t\t\tif df_TotStyleFMCAR['FMCAR'][0] >= 0:\n\t\t\t\tdf_TotStyleFMCAR['sigmaFMCAR'] = np.sqrt(df_TotStyleFMCAR['FMCAR'][0])\n\t\t\telse:\n\t\t\t\tdf_TotStyleFMCAR['sigmaFMCAR']=np.nan\n\n\n\n\t\t\tdict_final_return[date]= {gsConst.Const.PortRisk:p_riskreport.calcTotalRiskall(f_varp,['VarP','sigmaP','percentP']),gsConst.Const.BenchmarkRisk:b_riskreport.calcTotalRiskall(f_varp,['VarB','sigmaB','percentB']),\n\tgsConst.Const.PortActiveRisk:a_riskreport.calcTotalRiskall(f_varp,['VarA','sigmaA','percentA']),gsConst.Const.InteractionRisk:df_inter,gsConst.Const.FactorRisk:a_riskreport.calcPortCommonRiskall(f_vara,['VarFactor','sigmaFactor','percenFactor']),\n\t\t\t\t   gsConst.Const.SpecificRisk:a_riskreport.calcPortSpecRiskall(f_vara,['VarSS','sigmaSS','percenSS']),gsConst.Const.StyleFMCAR:a_riskreport.calcstyleFMCAR().reset_index(),\n\t\t\t\t   gsConst.Const.IndStyleFMCAR:a_riskreport.calcFMCR().reset_index(),gsConst.Const.PortExpo:p_riskreport.calcX().reset_index(),gsConst.Const.BenchmarkExpo:b_riskreport.calcX().reset_index(),\n\n\t\t\t\t   gsConst.Const.TotStyleFMCAR:df_TotStyleFMCAR\n\n\t\t\t\t   }\n\n\n\n\n\tdict_final_return_new={}\n\tfor i in list(dict_final_return[ls_date_range[0]].keys()):\n\t\tls_final_return=[dict_final_return[date][i].assign(date=date) for date in ls_date_range]\n\t\tdict_final_return_new[i]=pd.concat(ls_final_return,axis=0)\n\n\n\n\n\treturn dict_final_return_new\n\n\n\n\n\n\n\n\n", "description": null, "category": "math", "imports": ["from lib.gftTools import gftIO", "from lib.gftTools import gftIO", "from lib.gftTools import gsConst", "import numpy as np", "import pandas as pd", "from functools import reduce", "import math as mt", "from lib.gftTools import gftIO", "from lib.gftTools import gftIO"]}, {"term": "def", "name": "debug__gsWrapper__", "data": "def debug__gsWrapper__():\n\tcontext = gftIO.zload(\"/home/gft/data/context.pkl\")\n\tx0 = gftIO.zload(\"/home/gft/data/x0.pkl\")\n\tx1 = gftIO.zload(\"/home/gft/data/x1.pkl\")\n\tx2 = gftIO.zload(\"/home/gft/data/x2.pkl\")\n\tx3 = gftIO.zload(\"/home/gft/data/x3.pkl\")\n\tx4 = gftIO.zload(\"/home/gft/data/x4.pkl\")\n\t__gsWrapper__(context, x0, x1, x2, x3, x4)\n\n\n\n", "description": null, "category": "math", "imports": ["from lib.gftTools import gftIO", "from lib.gftTools import gftIO", "from lib.gftTools import gsConst", "import numpy as np", "import pandas as pd", "from functools import reduce", "import math as mt", "from lib.gftTools import gftIO", "from lib.gftTools import gftIO"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "class", "name": "classSpline:", "data": "class Spline:\n\t\"\"\"\n\tCubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.b, self.c, self.d, self.w = [], [], [], []\n\n\t\tself.x = x\n\t\tself.y = y\n\n\t\tself.nx = len(x)  # dimension of x\n\t\th = np.diff(x)\n\n\t\t# calc coefficient c\n\t\tself.a = [iy for iy in y]\n\n\t\t# calc coefficient c\n\t\tA = self.__calc_A(h)\n\t\tB = self.__calc_B(h)\n\t\tself.c = np.linalg.solve(A, B)\n\t\t#  print(self.c1)\n\n\t\t# calc spline coefficient b and d\n\t\tfor i in range(self.nx - 1):\n\t\t\tself.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n\t\t\ttb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n\t\t\t\t(self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n\t\t\tself.b.append(tb)\n\n\tdef calc(self, t):\n\t\t\"\"\"\n\t\tCalc position\n\n\t\tif t is outside of the input x, return None\n\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.a[i] + self.b[i] * dx + \\\n\t\t\tself.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n\t\treturn result\n\n\tdef calcd(self, t):\n\t\t\"\"\"\n\t\tCalc first derivative\n\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n\t\treturn result\n\n\tdef calcdd(self, t):\n\t\t\"\"\"\n\t\tCalc second derivative\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n\t\treturn result\n\n\tdef __search_index(self, x):\n\t\t\"\"\"\n\t\tsearch data segment index\n\t\t\"\"\"\n\t\treturn bisect.bisect(self.x, x) - 1\n\n\tdef __calc_A(self, h):\n\t\t\"\"\"\n\t\tcalc matrix A for spline coefficient c\n\t\t\"\"\"\n\t\tA = np.zeros((self.nx, self.nx))\n\t\tA[0, 0] = 1.0\n\t\tfor i in range(self.nx - 1):\n\t\t\tif i != (self.nx - 2):\n\t\t\t\tA[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n\t\t\tA[i + 1, i] = h[i]\n\t\t\tA[i, i + 1] = h[i]\n\n\t\tA[0, 1] = 0.0\n\t\tA[self.nx - 1, self.nx - 2] = 0.0\n\t\tA[self.nx - 1, self.nx - 1] = 1.0\n\t\t#  print(A)\n\t\treturn A\n\n\tdef __calc_B(self, h):\n\t\t\"\"\"\n\t\tcalc matrix B for spline coefficient c\n\t\t\"\"\"\n\t\tB = np.zeros(self.nx)\n\t\tfor i in range(self.nx - 2):\n\t\t\tB[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n\t\t\t\th[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n\t\treturn B\n\n", "description": "\n\tCubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "class", "name": "classSpline2D:", "data": "class Spline2D:\n\t\"\"\"\n\t2D Cubic Spline class\n\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.s = self.__calc_s(x, y)\n\t\tself.sx = Spline(self.s, x)\n\t\tself.sy = Spline(self.s, y)\n\n\tdef __calc_s(self, x, y):\n\t\tdx = np.diff(x)\n\t\tdy = np.diff(y)\n\t\tself.ds = np.hypot(dx, dy)\n\t\ts = [0]\n\t\ts.extend(np.cumsum(self.ds))\n\t\treturn s\n\n\tdef calc_position(self, s):\n\t\t\"\"\"\n\t\tcalc position\n\t\t\"\"\"\n\t\tx = self.sx.calc(s)\n\t\ty = self.sy.calc(s)\n\n\t\treturn x, y\n\n\tdef calc_curvature(self, s):\n\t\t\"\"\"\n\t\tcalc curvature\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tddx = self.sx.calcdd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tddy = self.sy.calcdd(s)\n\t\tk = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n\t\treturn k\n\n\tdef calc_yaw(self, s):\n\t\t\"\"\"\n\t\tcalc yaw\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tyaw = math.atan2(dy, dx)\n\t\treturn yaw\n\n", "description": "\n\t2D Cubic Spline class\n\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "calc_spline_course", "data": "def calc_spline_course(x, y, ds=0.1):\n\tsp = Spline2D(x, y)\n\ts = list(np.arange(0, sp.s[-1], ds))\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\treturn rx, ry, ryaw, rk, s\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():  # pragma: no cover\n\tprint(\"Spline 2D test\")\n\timport matplotlib.pyplot as plt\n\tx = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n\ty = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n\tds = 0.1  # [m] distance of each intepolated points\n\n\tsp = Spline2D(x, y)\n\ts = np.arange(0, sp.s[-1], ds)\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\tplt.subplots(1)\n\tplt.plot(x, y, \"xb\", label=\"input\")\n\tplt.plot(rx, ry, \"-r\", label=\"spline\")\n\tplt.grid(True)\n\tplt.axis(\"equal\")\n\tplt.xlabel(\"x[m]\")\n\tplt.ylabel(\"y[m]\")\n\tplt.legend()\n\n\tplt.subplots(1)\n\tplt.plot(s, [np.rad2deg(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"yaw angle[deg]\")\n\n\tplt.subplots(1)\n\tplt.plot(s, rk, \"-r\", label=\"curvature\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"curvature [1/m]\")\n\n\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}], [{"term": "class", "name": "CalculatorTest", "data": "class CalculatorTest(unittest.TestCase):\n\tdef testAdd(self):\n\t\tself.assertEqual(calc_add(2,2), 4)\n\t\tself.assertEqual(calc_add(8,3), 11)\n\t\tself.assertEqual(calc_add(-6,20), 14)\n\t\tself.assertEqual(calc_add(-8,-12), -20)\n\t\tself.assertEqual(calc_add(4,-9), -5)\n\t\tself.assertEqual(calc_add(8.68, 7.256), 15.936)\n\t\t\n\tdef testSubtract(self):  \n\t\tself.assertEqual(calc_subtract(8,3), 5)\n\t\tself.assertEqual(calc_subtract(3,5), -2)\n\t\tself.assertEqual(calc_subtract(4,-9), 13)\n\t\tself.assertEqual(calc_subtract(-6,20), -26)\n\t\tself.assertEqual(calc_subtract(-8,-12), 4)\n\t\tself.assertAlmostEqual(calc_subtract(8.68, 7.256), 1.424)\n\t\t\t\t\t\n\tdef testMultiply(self):  \n\t\tself.assertEqual(calc_multiply(5,3), 15)\n\t\tself.assertEqual(calc_multiply(4,-2), -8)\n\t\tself.assertEqual(calc_multiply(-4,6), -24)  \n\t\tself.assertEqual(calc_multiply(-7,-8), 56) \n\t\tself.assertEqual(calc_multiply(6,0), 0) \n\t\tself.assertEqual(calc_multiply(0,6), 0)\t  \n\t\t\n\tdef testDivide(self):\n\t\tself.assertEqual(calc_divide(8,2), 4)\n\t\tself.assertEqual(calc_divide(10,-2), -5)\n\t\tself.assertEqual(calc_divide(-32,4), -8)\n\t\tself.assertEqual(calc_divide(-10,-2), 5)\t\t\n\t\tself.assertEqual(calc_divide(25.0, 2),12.5) \n\t\tself.assertAlmostEqual(calc_divide(12.45,3.87), 3.21705426) \n\t\tself.assertEqual(calc_divide(4,0), 'Divide by Zero Error!') \n\t   \n\tdef testExp(self):\n\t\tself.assertEqual(calc_exp(5,2), 25)\n\t\tself.assertEqual(calc_exp(5,3), 125)\n\t\tself.assertEqual(calc_exp(2,4), 16) \n\t\tself.assertEqual(calc_exp(-2,4), 16)\n\t\tself.assertEqual(calc_exp(3,0), 1)\n\t\tself.assertEqual(calc_exp(5,-3),.008 )\n\t\tself.assertAlmostEqual(calc_exp(5,3.66),361.60149376)\n\t\tself.assertAlmostEqual(calc_exp(4.876,3),115.92873337)\n\t\t \n\tdef testSquareroot(self):\n\t\tself.assertEqual(calc_squareroot(25), 5)\n\t\tself.assertEqual(calc_squareroot(-5), 'Number Error!') \n\t\tself.assertEqual(calc_squareroot(36), 6)\n\t\tself.assertEqual(calc_squareroot(144), 12)\n\t\tself.assertEqual(calc_squareroot(0), 0)\n\t\tself.assertAlmostEqual(calc_squareroot(150.5), 12.26784414639)\n\t\t\n\tdef testSquare(self):\n\t\tself.assertEqual(calc_square(5), 25)\n\t\tself.assertEqual(calc_square(-5), 25)\n\t\tself.assertEqual(calc_square(0), 0)\n\t\tself.assertAlmostEqual(calc_square(12.26), 150.3076)\n\t\t\n\tdef testCube(self):\n\t\tself.assertEqual(calc_cube(5), 125)\n\t\tself.assertEqual(calc_cube(-5), -125)\n\t\tself.assertEqual(calc_cube(0), 0)\n\t\tself.assertAlmostEqual(calc_cube(2.34), 12.812904)\n  \n\tdef testSine(self):\n\t\tself.assertEqual(calc_sine(0), 0.0)\n\t\tself.assertAlmostEqual(calc_sine(30), 0.5)\n\t\tself.assertAlmostEqual(calc_sine(60), 0.86602540)\n\t\tself.assertAlmostEqual(calc_sine(90), 1.0)\n\t\tself.assertAlmostEqual(calc_sine(125), 0.81915204)\n\t\tself.assertEqual(calc_sine(180), 0.00)\n\t\tself.assertAlmostEqual(calc_sine(270), -1.0)\n\t\tself.assertEqual(calc_sine(360), 0.0)\n\t\tself.assertAlmostEqual(calc_sine(390), 0.5)\t  \n\t\tself.assertEqual(calc_sine(540), 0.0)\n\t\tself.assertAlmostEqual(calc_sine(-30), -0.5)\n\t\tself.assertEqual(calc_sine(-180), 0.0)\n\t\tself.assertAlmostEqual(calc_sine(305.75), -0.81157398)\t\n\t\t\n\tdef testCosine(self):\n\t\tself.assertAlmostEqual(calc_cosine(0), 1)\n\t\tself.assertAlmostEqual(calc_cosine(30), 0.86602540)\n\t\tself.assertAlmostEqual(calc_cosine(60), 0.5)\n\t\tself.assertEqual(calc_cosine(90), 0.0)\n\t\tself.assertAlmostEqual(calc_cosine(125), -0.57357643)\n\t\tself.assertAlmostEqual(calc_cosine(180), -1.0)\n\t\tself.assertEqual(calc_cosine(270), 0.0)\n\t\tself.assertAlmostEqual(calc_cosine(360), 1.0)\n\t\tself.assertAlmostEqual(calc_cosine(390), 0.86602540)\n\t\tself.assertAlmostEqual(calc_cosine(540), -1.0)\n\t\tself.assertAlmostEqual(calc_cosine(-30), 0.86602540)\n\t\tself.assertAlmostEqual(calc_cosine(-180), -1.0)\n\t\tself.assertAlmostEqual(calc_cosine(305.75), 0.58424966)\t\n\t\t\n", "description": null, "category": "math", "imports": ["import unittest", "from functions_calculator import *"]}], [{"term": "class", "name": "generalclasswide,producttable,algebraic,identityandquantumemulationtests", "data": "general class wide, product table, algebraic, identity and quantum emulation tests\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "run_test", "data": "def run_test(test_class):\n\tstream = StringIO()\n\trunner = unittest.TextTestRunner(stream=stream)\n\tresult = runner.run(unittest.makeSuite(test_class))\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "random_vector", "data": "def random_vector(obj):\n\treturn obj([random() for i in range(dim(obj))])\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "random_imaginary_vector", "data": "def random_imaginary_vector(obj):\n\treturn obj([0] + [random() for i in range(dim(obj)-1)])\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "unit_list", "data": "def unit_list (obj):\n\td = 2 ** len(obj.dp)\n\treturn [ obj( ( [0]*i + [1] + [0]*(d-i-1) )) for i in range(d) ]\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "fgenerate_table", "data": "#def generate_table (obj):\n\t#\"\"\"create a multiplication table for a given Algebra object in n\u00d7n matrix format (n=dimensions)\"\"\"\n\t#units  = unit_list(obj)\n\t#return [ [j*i for i in units] for j in units]\n", "description": "create a multiplication table for a given Algebra object in n\u00d7n matrix format (n=dimensions)", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "fgenerate_str", "data": "#def generate_str (obj):\n\t#\"\"\"create a multiplication table for a given Algebra object and return the elements in string format\"\"\"\n\t#print('here')\n\t#units  = unit_list(obj)\n\t#print('here')\n\t#return [ [str(j*i) for i in units] for j in units]\n\n", "description": "create a multiplication table for a given Algebra object and return the elements in string format", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "generate_str", "data": "def generate_str (obj):\n\t\"\"\"create a multiplication table for a given Algebra object and return the elements in string format\"\"\"\n\td = obj.dim(obj)\n\tunits = [ obj( ( [zer]*i + [one] + [zer]*(d-i-1) )) for i in range(d) ]\n\ttable = []\n\traw_table = []\n\tfor j in units:\n\t\ttable.append([])\n\t\traw_table.append([])\n\t\tfor i in units:\n\t\t\tif DEBUG: raw_table[-1].append(str(j*i))\n\t\t\ttable[-1].append(str(obj([c.name_in(s) for c in (j*i).state])))\n\t\t\tif DEBUG: print('{} \u00d7 {} = {}'.format(j,i,j*i))\n\treturn table\n\t\t\n", "description": "create a multiplication table for a given Algebra object and return the elements in string format", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "dim", "data": "def dim (obj):\n\t\"\"\"the expected number of dimensions given the number of doubling products of this object\"\"\"\n\treturn 2**len(obj.dp)\n", "description": "the expected number of dimensions given the number of doubling products of this object", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "two_square_identity", "data": "def two_square_identity (x,y):\n\ta,b = x\n\tc,d = y\n\treturn [a*c - d*b, d*a + b*c]\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "four_square_identity", "data": "def four_square_identity (x,y):\n\ta,b,c,d = x\n\te,f,g,h = y\n\n\tr = a*e - b*f - c*g - d*h\n\ts = a*f + b*e + c*h - d*g\n\tt = a*g - b*h + c*e + d*f\n\tu = a*h + b*g - c*f + d*e\n\treturn [r,s,t,u]\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "eight_square_identity", "data": "def eight_square_identity (x,y):\n\ta,b,c,d,e,f,g,h = x\n\ti,j,k,l,m,n,o,p = y\n\n\t# assuming i^2 = -1 ...\n\tz1 = a*i - b*j - c*k - d*l - m*e - n*f - o*g - p*h\n\tz2 = a*j + b*i + c*l - d*k - m*f + n*e + o*h - p*g\n\tz3 = a*k - b*l + c*i + d*j - m*g - n*h + o*e + p*f\n\tz4 = a*l + b*k - c*j + d*i - m*h + n*g - o*f + p*e\n\tz5 = m*a - n*b - o*c - p*d + e*i + f*j + g*k + h*l\n\tz6 = m*b + n*a + o*d - p*c - e*j + f*i - g*l + h*k\n\tz7 = m*c - n*d + o*a + p*b - e*k + f*l + g*i - h*j\n\tz8 = m*d + n*c - o*b + p*a - e*l - f*k + g*j + h*i\n\treturn [z1,z2,z3,z4,z5,z6,z7,z8]\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "sixteen_square_identity", "data": "def sixteen_square_identity (x,y):\n\ta1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16 = x\n\tb1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16 = y\n\t# assuming i^2 = -1 ...\n\tz1  = a1 * b1  - a2  * b2  - a3  * b3  - a4  * b4  - b5  * a5  - b6  * a6  - b7  * a7  - b8  * a8  - b9  * a9  - b10 * a10 - b11 * a11 - b12 * a12 - a13 * b13 - a14 * b14 - a15 * b15 - a16 * b16\n\tz2  = a1 * b2  + a2  * b1  + a3  * b4  - a4  * b3  - b5  * a6  + b6  * a5  + b7  * a8  - b8  * a7  - b9  * a10 + b10 * a9  + b11 * a12 - b12 * a11 - a13 * b14 + a14 * b13 + a15 * b16 - a16 * b15\n\tz3  = a1 * b3  - a2  * b4  + a3  * b1  + a4  * b2  - b5  * a7  - b6  * a8  + b7  * a5  + b8  * a6  - b9  * a11 - b10 * a12 + b11 * a9  + b12 * a10 - a13 * b15 - a14 * b16 + a15 * b13 + a16 * b14\n\tz4  = a1 * b4  + a2  * b3  - a3  * b2  + a4  * b1  - b5  * a8  + b6  * a7  - b7  * a6  + b8  * a5  - b9  * a12 + b10 * a11 - b11 * a10 + b12 * a9  - a13 * b16 + a14 * b15 - a15 * b14 + a16 * b13\n\tz5  = b5 * a1  - b6  * a2  - b7  * a3  - b8  * a4  + a5  * b1  + a6  * b2  + a7  * b3  + a8  * b4  - a13 * b9  - a14 * b10 - a15 * b11 - a16 * b12 + b13 * a9  + b14 * a10 + b15 * a11 + b16 * a12\n\tz6  = b5 * a2  + b6  * a1  + b7  * a4  - b8  * a3  - a5  * b2  + a6  * b1  - a7  * b4  + a8  * b3  + a13 * b10 - a14 * b9  + a15 * b12 - a16 * b11 - b13 * a10 + b14 * a9  - b15 * a12 + b16 * a11\n\tz7  = b5 * a3  - b6  * a4  + b7  * a1  + b8  * a2  - a5  * b3  + a6  * b4  + a7  * b1  - a8  * b2  + a13 * b11 - a14 * b12 - a15 * b9  + a16 * b10 - b13 * a11 + b14 * a12 + b15 * a9  - b16 * a10\n\tz8  = b5 * a4  + b6  * a3  - b7  * a2  + b8  * a1  - a5  * b4  - a6  * b3  + a7  * b2  + a8  * b1  + a13 * b12 + a14 * b11 - a15 * b10 - a16 * b9  - b13 * a12 - b14 * a11 + b15 * a10 + b16 * a9\n\tz9  = b9 * a1  - b10 * a2  - b11 * a3  - b12 * a4  - a5  * b13 - a6  * b14 - a7  * b15 - a8  * b16 + a9  * b1  + a10 * b2  + a11 * b3  + a12 * b4  + b5  * a13 + b6  * a14 + b7  * a15 + b8  * a16\n\tz10 = b9 * a2  + b10 * a1  + b11 * a4  - b12 * a3  - a5  * b14 + a6  * b13 + a7  * b16 - a8  * b15 - a9  * b2  + a10 * b1  - a11 * b4  + a12 * b3  + b5  * a14 - b6  * a13 - b7  * a16 + b8  * a15\n\tz11 = b9 * a3  - b10 * a4  + b11 * a1  + b12 * a2  - a5  * b15 - a6  * b16 + a7  * b13 + a8  * b14 - a9  * b3  + a10 * b4  + a11 * b1  - a12 * b2  + b5  * a15 + b6  * a16 - b7  * a13 - b8  * a14\n\tz12 = b9 * a4  + b10 * a3  - b11 * a2  + b12 * a1  - a5  * b16 + a6  * b15 - a7  * b14 + a8  * b13 - a9  * b4  - a10 * b3  + a11 * b2  + a12 * b1  + b5  * a16 - b6  * a15 + b7  * a14 - b8  * a13\n\tz13 = a5 * b9  - a6  * b10 - a7  * b11 - a8  * b12 + b13 * a1  + b14 * a2  + b15 * a3  + b16 * a4  - b5  * a9  + b6  * a10 + b7  * a11 + b8  * a12 + a13 * b1  - a14 * b2  - a15 * b3  - a16 * b4\n\tz14 = a5 * b10 + a6  * b9  + a7  * b12 - a8  * b11 - b13 * a2  + b14 * a1  - b15 * a4  + b16 * a3  - b5  * a10 - b6  * a9  - b7  * a12 + b8  * a11 + a13 * b2  + a14 * b1  + a15 * b4  - a16 * b3\n\tz15 = a5 * b11 - a6  * b12 + a7  * b9  + a8  * b10 - b13 * a3  + b14 * a4  + b15 * a1  - b16 * a2  - b5  * a11 + b6  * a12 - b7  * a9  - b8  * a10 + a13 * b3  - a14 * b4  + a15 * b1  + a16 * b2\n\tz16 = a5 * b12 + a6  * b11 - a7  * b10 + a8  * b9  - b13 * a4  - b14 * a3  + b15 * a2  + b16 * a1  - b5  * a12 - b6  * a11 + b7  * a10 - b8  * a9  + a13 * b4  + a14 * b3  - a15 * b2  + a16 * b1\n\treturn [z1,z2,z3,z4,z5,z6,z7,z8,z9,z10,z11,z12,z13,z14,z15,z16]\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_test_unit_multiplication", "data": "def _test_unit_multiplication (self,expect,calc):\n\t\"generic unit product table\"\n\timaginaries = '1ijklmnopqrstuvw'\n\t#n  = 2**len(self.obj.dp)\n\tn  = self.obj.dim(self.obj)\n\til = list(imaginaries[:n])\n\n\tif DEBUG: print(\"\\ncalc:   {0}\\nexpect: {1}\\nil: {2}\".format(calc, expect, il))\n\n\tif VERBOSE: \n\t\tprint(_verbose_unit_multiplication().format(\n\t\t\tobject\t\t   = self.obj.__name__,\n\t\t\texpected_table   = pd.DataFrame( expect, index = il, columns = il ),\n\t\t\tcalculated_table = pd.DataFrame(   calc, index = il, columns = il )\n\t\t))\n\tself.assertListEqual(calc, expect)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_claim_equal", "data": "def _claim_equal (calc,expect):\n\tprint(\"\"\"\n", "description": "\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_quaternion_metric_space", "data": "def _verbose_quaternion_metric_space ():\n\treturn \"\"\"\n", "description": "\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_quaternion_dot_product", "data": "def _verbose_quaternion_dot_product ():\n\treturn \"\"\"\n", "description": "\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_weak_alternative", "data": "def _verbose_weak_alternative ():\n\treturn \"\"\"\n", "description": "\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_diophantus", "data": "def _verbose_diophantus ():\n\treturn \"\"\"\n", "description": "\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_split_quaternion_nilpotent", "data": "def _verbose_split_quaternion_nilpotent ():\n\treturn \"\"\"\n", "description": "\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_split_quaternion_idempotent", "data": "def _verbose_split_quaternion_idempotent ():\n\treturn \"\"\"\n", "description": "\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_split_octonion_conjugation", "data": "def _verbose_split_octonion_conjugation ():\n\treturn \"\"\" \n", "description": " \n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_octonion_conjugation", "data": "def _verbose_octonion_conjugation ():\n\treturn \"\"\" \n", "description": " \n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_quaternion_conjugation", "data": "def _verbose_quaternion_conjugation ():\n\treturn \"\"\" \n", "description": " \n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_commutative", "data": "def _verbose_commutative ():\n\treturn \"\"\"\n", "description": "\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_moufang_condition", "data": "def _verbose_moufang_condition ():\n\treturn \"\"\"\n", "description": "\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_power_associative", "data": "def _verbose_power_associative ():\n\treturn \"\"\"\n", "description": "\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_verbose_split_quaternion_conjugate", "data": "def _verbose_split_quaternion_conjugate ():\n\treturn \"\"\"\n", "description": "\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "_debug_power_associative", "data": "def _debug_power_associative ():\n\treturn \"\"\"\n\t   x: {0}\n", "description": "\n\t   x: {0}\n", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TestComplex", "data": "class TestComplex(unittest.TestCase):\n\tobj = Complex\n\n\tdef test_unit_multiplication (self):\n\t\t\"Complex number unit product table\"\n\t\texpect = [ a.split() for a in complex_table.strip().split(\"\\n\") ]\n\t\tprint('expect:',expect)\n\t\tcalc = generate_str(self.obj)\n\t\t_test_unit_multiplication(self, expect=expect, calc=calc)\n\n\tdef Xtest_abs_results (self):\n\t\t\"various absolute results\"\n\t\tfor row in complex_abs_record:\n\t\t\tinput, expect = row\n\t\t\tcalc = abs(input)\n\t\t\tif DEBUG or VERBOSE:\n\t\t\t\tprint(\"\\n=== Complex Absolute Value tests\")\n\t\t\t\tprint(\"\\n|{0}| =\\nexpect = {1}\\n  calc = {2}\".format(input, expect, calc))\n\t\t\tself.assertEqual(calc, expect)\n\n\tdef Xtest_add_results (self):\n\t\t\"various addition results\"\n\t\tfor row in complex_add_record:\n\t\t\ta,b,expect = row\n\t\t\tcalc = a+b\n\t\t\tif DEBUG or VERBOSE:\n\t\t\t\tprint(\"\\n=== Complex Addition tests\")\n\t\t\t\tprint(\"\\n{0} + {1} =\\nexpect = {2}\\n  calc = {3}\".format(a, b, expect, calc))\n\t\t\tself.assertEqual(expect,calc)\n\t\t\tself.assertIsInstance(expect, Complex)\n\n\tdef Xtest_sub_results (self):\n\t\t\"various subtraction results\"\n\t\tfor row in complex_sub_record:\n\t\t\ta,b,expect = row\n\t\t\tcalc = a-b\n\t\t\tif DEBUG or VERBOSE:\n\t\t\t\tprint(\"\\n=== Complex Difference tests\")\n\t\t\t\tprint(\"\\n{0} - {1} =\\nexpect = {2}\\n  calc = {3}\".format(a, b, expect, calc))\n\t\t\tself.assertEqual(expect, calc)\n\t\t\tself.assertIsInstance(expect, Complex)\n\n\tdef Xtest_product_results (self):\n\t\t\"various product results\"\n\t\tfor row in complex_product_record:\n\t\t\ta,b,expect = row\n\t\t\tcalc = a*b\n\t\t\tif DEBUG or VERBOSE:\n\t\t\t\tprint(\"\\n=== Complex Product tests\")\n\t\t\t\tprint(\"\\n{0} \u00d7 {1} =\\nexpect = {2}\\n  calc = {3}\".format(a, b, expect, calc))\n\t\t\tself.assertEqual(expect, calc)\n\t\t\tself.assertIsInstance(expect, Complex)\n\n\tdef Xtest_division_results (self):\n\t\t\"various division results\"\n\t\tfor row in complex_division_record:\n\t\t\ta,b,expect = row\n\t\t\tcalc = a/b\n\t\t\tif DEBUG or VERBOSE:\n\t\t\t\tprint(\"\\n=== Complex Division tests\")\n\t\t\t\tprint(\"\\n{0} / {1} =\\nexpect = {2}\\n  calc = {3}\".format(a, b, expect, calc))\n\t\t\tself.assertEqual(expect, calc)\n\t\t\tself.assertIsInstance(expect, Complex)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TestDual", "data": "class TestDual(unittest.TestCase):\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "ftest_unit_multiplication", "data": "\tdef test_unit_multiplication (self):\n\t\t\"Dual number unit product table\"\n\t\texpect = [ a.split() for a in dual_table.strip().split(\"\\n\") ]\n\t\tcalc = generate_str(self.obj)\n\t\t_test_unit_multiplication(self, expect=expect, calc=calc)\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "fXtest_abs_results", "data": "\tdef Xtest_abs_results (self):\n\t\t\"various absolute results\"\n\t\tif DEBUG or VERBOSE:\n\t\t\tprint()\n\t\tfor row in dual_abs_record:\n\t\t\tinput, expect = row\n\t\t\tcalc = abs(input)\n\t\t\tif DEBUG or VERBOSE:\n\t\t\t\tprint(\"\\n=== Dual Absolute Value tests\\n\")\n\t\t\t\tprint(\"|%s| =\\nexpect = %s\\n  calc = %s\" % (input, expect, calc))\n\t\t\tself.assertEqual(calc, expect)\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "fXtest_add_results", "data": "\tdef Xtest_add_results (self):\n\t\t\"various addition results\"\n\t\tif DEBUG or VERBOSE:\n\t\t\tprint()\n\t\tfor row in dual_add_record:\n\t\t\ta,b,expect = row\n\t\t\tcalc = a+b\n\t\t\tif DEBUG or VERBOSE:\n\t\t\t\tprint(\"\\n=== Dual Addition tests\\n\")\n\t\t\t\tprint(\"\\n%s + %s =\\nexpect = %s\\n  calc = %s\" % (a,b, expect, calc))\n\t\t\tself.assertEqual(expect,calc)\n\t\t\tself.assertIsInstance(expect, self.obj)\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "fXtest_sub_results", "data": "\tdef Xtest_sub_results (self):\n\t\t\"various subtraction results\"\n\t\tif DEBUG or VERBOSE:\n\t\t\tprint()\n\t\tfor row in dual_sub_record:\n\t\t\ta,b,expect = row\n\t\t\tcalc = a-b\n\t\t\tif DEBUG or VERBOSE:\n\t\t\t\tprint(\"\\n=== Dual Difference tests\\n\")\n\t\t\t\tprint(\"\\n%s - %s =\\nexpect = %s\\n  calc = %s\" % (a,b, expect, calc))\n\t\t\tself.assertEqual(expect,calc)\n\t\t\tself.assertIsInstance(expect, self.obj)\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "fXtest_product_results", "data": "\tdef Xtest_product_results (self):\n\t\t\"various product results\"\n\t\tif DEBUG or VERBOSE:\n\t\t\tprint()\n\t\tfor row in dual_product_record:\n\t\t\ta,b,expect = row\n\t\t\tcalc = a*b\n\t\t\tif DEBUG or VERBOSE:\n\t\t\t\tprint(\"\\n=== Dual Product tests\\n\")\n\t\t\t\tprint(\"\\n%s \u00d7 %s =\\nexpect = %s\\n  calc = %s\" % (a,b, expect, calc))\n\t\t\tself.assertEqual(expect,calc)\n\t\t\tself.assertIsInstance(expect, self.obj)\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "def", "name": "fXtest_division_results", "data": "\tdef Xtest_division_results (self):\n\t\t\"various division results\"\n\t\tif DEBUG or VERBOSE:\n\t\t\tprint()\n\t\tfor row in dual_division_record:\n\t\t\ta,b,expect = row\n\t\t\tcalc = a/b\n\t\t\tif DEBUG or VERBOSE:\n\t\t\t\tprint(\"\\n=== Dual Division tests\\n\")\n\t\t\t\tprint(\"\\n%s / %s =\\nexpect = %s\\n  calc = %s\" % (a,b, expect, calc))\n\t\t\tself.assertEqual(expect,calc)\n\t\t\tself.assertIsInstance(expect, self.obj)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TestSplit", "data": "class TestSplit(unittest.TestCase):\n\tobj = Split\n\n\tdef test_unit_multiplication (self):\n\t\t\"Split number unit product table\"\n\t\texpect = [ a.split() for a in split_table.strip().split(\"\\n\") ]\n\t\tcalc = generate_str(self.obj)\n\t\t_test_unit_multiplication(self, expect=expect, calc=calc)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TestQuaternion", "data": "class TestQuaternion(unittest.TestCase):\n\tobj = Quaternion\n\n\tdef test_unit_multiplication (self):\n\t\t\"Quaternion unit product table\"\n\t\texpect\t  = [ a.split() for a in quaternion_table.strip().split(\"\\n\") ]\n\t\tcalc\t\t= generate_str(self.obj)\n\t\t_test_unit_multiplication(self, expect=expect, calc=calc)\n\n\tdef Xtest_conjugation (self):\n\t\t\"Long form congugation\"\n\t\tloops = 100\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor n in range(loops):\n\t\t\tx = random_vector(self.obj)\n\t\t\tcalc = x.conj()\n\t\t\to,i,j,k = unit_list(self.obj)\n\t\t\texpect = -1/2*( x + (i*x)*i + (j*x)*j + (k*x)*k )\n\t\t\tif DEBUG:\n\t\t\t\t_claim_equal(repr(calc),repr(expect))\n\t\t\tself.assertEqual(calc,expect)\n\t\tif VERBOSE: \n\t\t\tprint(_verbose_quaternion_conjugation())\n\t\t\t_claim_equal(calc,expect)\n\n\tdef Xtest_conjugate_product (self):\n\t\t\"the product of a vector with its conjugate is the multidimensional Pythagarus formula\"\n\t\tloops = 100\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\t\tprint(\"\\n=== Quaternion Conjugate Product test\\n\")\n\t\tfor n in range(loops):\n\t\t\tx = random_vector(self.obj)\n\t\t\tcalc = x*x.conj()\n\t\t\texpect = sum([a ** 2 for a in x])\n\t\t\tself.assertEqual(calc,expect)\n\t\tif DEBUG: \n\t\t\t_claim_equal(repr(calc),repr(expect))\n\t\tif VERBOSE:\n\t\t\t_claim_equal(calc,expect)\n\n\tdef Xtest_addition_metric_space (self):\n\t\t\"Test addition is continuous in Quaternion metric topology\"\n\t\tobject = Quaternion\n\t\tloops = 100\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor n in range(loops):\n\t\t\tp1 = random_vector(self.obj)\n\t\t\tp2 = random_vector(self.obj)\n\t\t\tq1 = random_vector(self.obj)\n\t\t\tq2 = random_vector(self.obj)\n\t\t\ta  = uniform(0,10)\n\t\t\tcalc   = abs((p1 + a*p2 + q1 + a*q2) - (p1+q1))\n\t\t\texpect = a*abs(p2+q2)\n\t\t\tif DEBUG:\n\t\t\t\tprint(_verbose_quaternion_metric_space().format( p1, q1, p2, q2, a, repr(calc), repr(expect)))\n\t\t\tself.assertAlmostEqual(calc,expect)\n\t\tif VERBOSE:\n\t\t\tprint(_verbose_quaternion_metric_space().format( p1, q1, p2, q2, a, repr(calc), repr(expect)))\n\n\tdef Xtest_dot_product (self):\n\t\t\"Component vs component free dot product\"\n\t\tobject = Quaternion\n\t\tloops = 100\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor n in range(loops):\n\t\t\tp = random_imaginary_vector(self.obj)\n\t\t\tq = random_imaginary_vector(self.obj)\n\t\t\tb1,c1,d1 = p[1:]\n\t\t\tb2,c2,d2 = q[1:]\n\t\t\tcalc1 = 1/2*(p.conj()*q + q.conj()*p)\n\t\t\tcalc2 = 1/2*(p*q.conj() + q*p.conj())\n\t\t\texpect = b1*b2 + c1*c2 + d1*d2\n\t\t\tif DEBUG:\n\t\t\t\tprint(_verbose_quaternion_dot_product().format(p, q, calc1, calc2, expect))\n\t\t\tself.assertAlmostEqual(calc1,expect)\n\t\t\tself.assertAlmostEqual(calc2,expect)\n\t\t\tself.assertAlmostEqual(calc1,calc2)\n\t\tif VERBOSE:\n\t\t\tprint(_verbose_quaternion_dot_product().format(p, q, calc1, calc2, expect))\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TestOctonion", "data": "class TestOctonion(unittest.TestCase):\n\tobj = Octonion\n\n\tdef test_unit_multiplication (self):\n\t\t\"Octonion unit product table\"\n\t\texpect = [ a.split() for a in octonion_table.strip().split(\"\\n\") ]\n\t\tcalc = generate_str(self.obj)\n\t\t_test_unit_multiplication(self,expect=expect,calc=calc)\n\n\tdef Xtest_conjugation (self):\n\t\t\"Long form congugation\"\n\t\tloops = 100\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor n in range(loops):\n\t\t\tx = random_vector(self.obj)\n\t\t\tcalc = x.conj()\n\t\t\to,i,j,k,l,m,n,o = unit_list(self.obj)\n\t\t\texpect = -1/6*( x + (i*x)*i + (j*x)*j + (k*x)*k + (l*x)*l + (m*x)*m + (n*x)*n + (o*x)*o )\n\t\t\tif DEBUG:\n\t\t\t\tprint(\"   calc = %r\" % (calc))\n\t\t\t\tprint(\" expect = %r\" % (expect))\n\t\t\tself.assertEqual(calc,expect)\n\t\tif VERBOSE: \n\t\t\tprint(_verbose_octonion_conjugation())\n\t\t\t_claim_equal(calc,expect)\n\n\tdef Xtest_conjugate_product (self):\n\t\t\"the product of a vector with its conjugate is the multidimensional Pythagarus formula\"\n\t\tloops = 100\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor n in range(loops):\n\t\t\tx = random_vector(self.obj)\n\t\t\tcalc = x*x.conj()\n\t\t\texpect = sum([a ** 2 for a in x])\n\t\t\tself.assertEqual(calc,expect)\n\t\tif DEBUG: \n\t\t\t_claim_equal(repr(calc),repr(expect))\n\t\tif VERBOSE:\n\t\t\t_claim_equal(calc,expect)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TestSedenion", "data": "class TestSedenion(unittest.TestCase):\n\tobj = Sedenion\n\n\tdef test_unit_multiplication (self):\n\t\t\"Sedenion unit product table\"\n\t\texpect = [ a.split() for a in sedenion_table.strip().split(\"\\n\") ]\n\t\tcalc = generate_str(self.obj)\n\t\t_test_unit_multiplication(self,expect=expect,calc=calc)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TestSplitQuaternion", "data": "class TestSplitQuaternion(unittest.TestCase):\n\tobj = SplitQuaternion\n\n\tdef test_unit_multiplication (self):\n\t\t\"Split Quaternion unit product table\"\n\t\texpect = [ a.split() for a in split_quaternion_table.strip().split(\"\\n\") ]\n\t\tcalc = generate_str(self.obj)\n\t\t_test_unit_multiplication(self,expect=expect,calc=calc)\n\n\tdef Xtest_split_complex_generation (self):\n\t\t\"Generation Split Quaternion from split-complex numbers\"\n\t\tloops = 100\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tif DEBUG or VERBOSE: \n\t\t\tprint()\n\t\tfor n in range(loops):\n\t\t\tq = random_vector(self.obj)\n\t\t\ta = Split(q[:2])\n\t\t\tb = Split(q[2:])\n\t\t\tw,z = a\n\t\t\ty,x = b\n\t\t\tpre_calc = w**2 + x**2 - y**2 - z**2\n\t\t\tcalc = Split([pre_calc,0])\n\t\t\texpect = a*a.conj() - b*b.conj()\n\t\t\tif DEBUG:\n\t\t\t\t_claim_equal(repr(calc),repr(expect))\n\t\t\tself.assertEqual(calc,expect)\n\t\tif VERBOSE:\n\t\t\tprint(_verbose_split_quaternion_conjugate())\n\t\t\t_claim_equal(calc,expect)\n\n\tdef Xtest_nilpotent(self):\n\t\t\"Test Split Quaternion nilpotent - a number whose square is zero\"\n\t\to,i,j,k = unit_list(self.obj)\n\t\tfor unit in [-k, -j, k, j]:\n\t\t\tq = i-unit\n\t\t\tcalc = q*q\n\t\t\texpect = self.obj([0,0,0,0])\n\t\t\tif VERBOSE:\n\t\t\t\tprint(_verbose_split_quaternion_nilpotent().format(q, calc, expect))\n\t\t\tself.assertAlmostEqual(calc,expect)\n\n\tdef Xtest_idempotent(self):\n\t\t\"Test Split Quaternion nilpotent - a number whose square is zero\"\n\t\to,i,j,k = unit_list(self.obj)\n\n\t\t# todo: There must be more of these...\n\n\t\tq = 1/2*(o+j)\n\t\tcalc = q*q\n\t\texpect = q\n\t\tif DEBUG:\n\t\t\tprint(\"\\n%8s = %r\" % ('q',q))\n\t\t\tprint(\"\\n%8s = %r\" % ('q\u00d7q',calc))\n\t\tif VERBOSE:\n\t\t\tprint(_verbose_split_quaternion_idempotent().format(q, calc, expect))\n\t\tself.assertAlmostEqual(calc,expect)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TestSplitOctonion", "data": "class TestSplitOctonion(unittest.TestCase):\n\tobj = SplitOctonion\n\n\tdef test_unit_multiplication (self):\n\t\t\"SplitOctonion unit product table\"\n\t\texpect = [ a.split() for a in split_octonion_table.strip().split(\"\\n\") ]\n\t\tcalc = generate_str(self.obj)\n\t\t_test_unit_multiplication(self,expect=expect,calc=calc)\n\n\tdef Xtest_conjugation (self):\n\t\t\"Long form congugation\"\n\t\tloops = 100\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor _ in range(loops):\n\t\t\tz = random_vector(self.obj)\n\t\t\tcalc = z.conj()\n\t\t\tx,i,j,k,l,m,n,o = unit_list(self.obj)\n\t\t\texpect = x*z[0] - i*z[1] - j*z[2] - k*z[3]- l*z[4] - m*z[5] - n*z[6] - o*z[7]\n\t\t\tif DEBUG:\n\t\t\t\t_claim_equal(repr(calc),repr(expect))\n\t\t\tself.assertEqual(calc,expect)\n\t\tif VERBOSE: \n\t\t\tprint(_verbose_split_octonion_conjugation())\n\t\t\t_claim_equal(calc,expect)\n\n\tdef Xtest_conjugate_product (self):\n\t\t\"the product of a vector with its conjugate is the multidimensional Pythagarus formula\"\n\t\tloops = 100\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor n in range(loops):\n\t\t\tx = random_vector(self.obj)\n\t\t\tcalc = x*x.conj()\n\t\t\texpect = sum([a ** 2 for a in x[:4]]) - sum([a ** 2 for a in x[4:]])\n\t\t\tself.assertEqual(calc,expect)\n\t\tif DEBUG: \n\t\t\t_claim_equal(repr(calc),repr(expect))\n\t\tif VERBOSE:\n\t\t\t_claim_equal(calc,expect)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TestDualComplex", "data": "class TestDualComplex(unittest.TestCase):\n\tobj = DualComplex\n\n\tdef test_unit_multiplication (self):\n\t\t\"DualComplex unit product table\"\n\t\texpect = [ a.split() for a in dual_complex_table.strip().split(\"\\n\") ]\n\t\tcalc = generate_str(self.obj)\n\t\t_test_unit_multiplication(self,expect=expect,calc=calc)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TestDualQuaternion", "data": "class TestDualQuaternion(unittest.TestCase):\n\tobj = DualQuaternion\n\n\tdef test_unit_multiplication (self):\n\t\t\"DualQuaternion unit product table\"\n\t\texpect = [ a.split() for a in dual_quaternion_table.strip().split(\"\\n\") ]\n\t\tcalc = generate_str(self.obj)\n\t\t_test_unit_multiplication(self,expect=expect,calc=calc)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TestHyperbolicQuaternion", "data": "class TestHyperbolicQuaternion(unittest.TestCase):\n\tobj = HyperbolicQuaternion\n\n\tdef test_unit_multiplication (self):\n\t\t\"HyperbolicQuaternion unit product table\"\n\t\texpect = [ a.split() for a in hyperbolic_quaternion_table.strip().split(\"\\n\") ]\n\t\tcalc = generate_str(self.obj)\n\t\t_test_unit_multiplication(self,expect=expect,calc=calc)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "Commutative", "data": "class Commutative():\n\t\"\"\"Commutative Product tests\"\"\"\n\n\tdef _is_commutative(self, obj, loops=100):\n\t\td = dim(obj)\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor n in range(loops):\n\t\t\tx = random_vector(obj)\n\t\t\ty = random_vector(obj)\n\t\t\tx * y\n\t\t\tif d > 2:\n\t\t\t\tself.assertNotEqual(x*y,y*x)\n\t\t\telse:\n\t\t\t\tself.assertEqual(x*y,y*x)\n\t\tif DEBUG: \n\t\t\tprint(\"x \u00d7 y = %r\" % (x*y))\n\t\t\tprint(\"y \u00d7 x = %r\" % (y*x))\n\t\tif VERBOSE:\n\t\t\tprint(_verbose_commutative().format((' NOT' if d>2 else ''),x*y,y*x,obj.__name__))\n\n\tdef test_complex(self):\n\t\tself._is_commutative(Complex, loops=5000)\n\n\tdef test_quaternion(self):\n\t\tself._is_commutative(Quaternion, loops=1000)\n\n\tdef test_octonion(self):\n\t\tself._is_commutative(Octonion, loops=300)\n\n\tdef test_sedenion(self):\n\t\tself._is_commutative(Sedenion)\n\n\tdef test_cd32(self):\n\t\tself._is_commutative(Cd32,loops=50)\n\n", "description": "Commutative Product tests", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "WeakAlternative", "data": "class WeakAlternative():\n\n\tdef _is_weak_alternative(self, obj, loops=100):\n\t\t\"Weak Alternative Condition tests\"\n\t\td = dim(obj)\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor n in range(loops):\n\t\t\tx = random_vector(obj)\n\t\t\ty = random_vector(obj)\n\t\t\tif d < 16:\n\t\t\t\tself.assertEqual((y*x)*x, y*(x*x))\n\t\t\t\tself.assertEqual((x*y)*x, x*(y*x))\n\t\t\t\tself.assertEqual((x*x)*y, x*(x*y))\n\t\t\t\tself.assertEqual((x*y)*y, x*(y*y))\n\t\t\t\tself.assertEqual((y*x)*y, y*(x*y))\n\t\t\t\tself.assertEqual((y*y)*x, y*(y*x))\n\t\t\telse:\n\t\t\t\tself.assertEqual((x*y)*x, x*(y*x))\n\t\t\t\tself.assertEqual((y*x)*y, y*(x*y))\n\t\t\t\tself.assertNotEqual((y*x)*x, y*(x*x))\n\t\t\t\tself.assertNotEqual((x*x)*y, x*(x*y))\n\t\t\t\tself.assertNotEqual((x*y)*y, x*(y*y))\n\t\t\t\tself.assertNotEqual((y*y)*x, y*(y*x))\n\t\tif VERBOSE:\n\t\t\tprint(_verbose_weak_alternative().format(x,y,(y*x)*x,y*(x*x),(x*y)*x,x*(y*x),(x*x)*y,x*(x*y),(x*y)*y,x*(y*y),(y*x)*y,y*(x*y),(y*y)*x,y*(y*x),(' NOT' if d>8 else ''),obj.__name__))\n\n\tdef test_complex(self):\n\t\tself._is_weak_alternative(Complex,loops=1000)\n\n\tdef test_quaternion(self):\n\t\tself._is_weak_alternative(Quaternion, loops=300)\n\n\tdef test_octonion(self):\n\t\tself._is_weak_alternative(Octonion)\n\n\tdef test_sedenion(self):\n\t\tself._is_weak_alternative(Sedenion,loops=15)\n\n\tdef test_32ion(self):\n\t\tself._is_weak_alternative(Cd32,loops=10)\n\n", "description": null, "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "DiophantusIdentity", "data": "class DiophantusIdentity():\n\t\"\"\"\n\tDiophantus identity test\n\tBrahmagupta\u2013Fibonacci / Diophantus identity\n\t\"\"\"\n\n\tdef _is_diophantus_identity(self, obj, loops=100):\n\t\t\"Diophantus identity test\"\n\t\tPRECISION = 10**-9\n\t\td = dim(obj)\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor n in range(loops):\n\t\t\tx = random_vector(obj)\n\t\t\ty = random_vector(obj)\n\t\t\tif d > 8:\n\t\t\t\tself.assertNotAlmostEqual(abs(x) * abs(y), abs(x*y), delta=PRECISION)\n\t\t\telse:\n\t\t\t\tself.assertAlmostEqual(abs(x) * abs(y), abs(x*y), delta=PRECISION)\n\n\t\tif VERBOSE:\n\t\t\tprint(_verbose_diophantus().format(x,y,abs(x),abs(y),(' NOT' if d>8 else ''),abs(x)*abs(y),abs(x*y)))\n\n\tdef test_complex(self):\n\t\tself._is_diophantus_identity(Complex,loops=20000)\n\n\tdef test_quaternion(self):\n\t\tself._is_diophantus_identity(Quaternion, loops=1000)\n\n\tdef test_octonion(self):\n\t\tself._is_diophantus_identity(Octonion, loops=1000)\n\n\t#def test_sedenion(self):\n\t\t#self._is_diophantus_identity(Sedenion,loops=300)\n\n\t#def test_32ion(self):\n\t\t#self._is_diophantus_identity(Cd32,loops=200)\n\n\t#def test_split_octonion(self):\n\t\t#self._is_diophantus_identity(SplitOctonion, loops=300)\n\n", "description": "\n\tDiophantus identity test\n\tBrahmagupta\u2013Fibonacci / Diophantus identity\n\t", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "MoufangCondition", "data": "class MoufangCondition():\n\t\"\"\"Moufang condition tests\"\"\"\n\n\tdef _is_moufang_condition(self, obj, loops=100):\n\t\t\"Moufang condition tests\"\n\t\tdm = dim(obj)\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor n in range(loops):\n\t\t\tx = random_vector(obj)\n\t\t\ty = random_vector(obj)\n\t\t\tz = random_vector(obj)\n\t\t\ta = z*(x*(z*y))\n\t\t\tb = ((z*x)*z)*y\n\t\t\tc = x*(z*(y*z))\n\t\t\td = ((x*z)*y)*z\n\t\t\te = (z*x)*(y*z)\n\t\t\tf = (z*(x*y))*z\n\t\t\tg = (z*x)*(y*z)\n\t\t\th = z*((x*y)*z)\n\t\t\tif dm > 8:\n\t\t\t\tself.assertNotEqual(a,b)\n\t\t\t\tself.assertNotEqual(c,d)\n\t\t\t\tself.assertNotEqual(e,f)\n\t\t\t\tself.assertNotEqual(g,h)\n\t\t\telse:\n\t\t\t\tself.assertEqual(a,b)\n\t\t\t\tself.assertEqual(c,d)\n\t\t\t\tself.assertEqual(e,f)\n\t\t\t\tself.assertEqual(g,h)\n\t\tif DEBUG:\n\t\t\tprint(\"%8s: %r\\n\" % ('x',x))\n\t\t\tprint(\"%8s: %r\\n\" % ('y',y))\n\t\t\tprint(\"%8s: %r\\n\" % ('z',z))\n\t\tif VERBOSE:\n\t\t\ta = z*(x*(z*y))\n\t\t\tb = ((z*x)*z)*y\n\t\t\tc = x*(z*(y*z))\n\t\t\td = ((x*z)*y)*z\n\t\t\te = (z*x)*(y*z)\n\t\t\tf = (z*(x*y))*z\n\t\t\tg = (z*x)*(y*z)\n\t\t\th = z*((x*y)*z)\n\t\t\tprint(_verbose_moufang_condition().format(x,y,z,a,b,c,d,e,f,g,h,' NOT' if dm>8 else '', obj.__name__))\n\n\tdef test_complex(self):\n\t\tself._is_moufang_condition(Complex,loops=500)\n\n\tdef test_quaternion(self):\n\t\tself._is_moufang_condition(Quaternion, loops=150)\n\n\tdef test_octonion(self):\n\t\tself._is_moufang_condition(Octonion, loops=50)\n\n\tdef test_sedenion(self):\n\t\tself._is_moufang_condition(Sedenion,loops=15)\n\n\tdef test_32ion(self):\n\t\tself._is_moufang_condition(Cd32,loops=10)\n\n\t#def test_split_octonion(self):\n\t\t#self._is_moufang_condition(SplitOctonion, loops=300)\n\n", "description": "Moufang condition tests", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "PowerAssociative", "data": "class PowerAssociative():\n\t\"\"\"Power Associative tests\"\"\"\n\n\tdef _is_power_associative(self, obj, loops=100):\n\t\tPRECISION = 10**-9\n\t\td = dim(obj)\n\t\tif VERBOSE or DEBUG: \n\t\t\tprint(loops, 'loops')\n\t\tfor n in range(loops):\n\t\t\tx = random_vector(obj).normalize()\n\t\t\ty = random_vector(obj).normalize()\n\t\t\tz = x * y\n\t\t\tself.assertAlmostEqual(abs(x),1,delta=PRECISION)\n\t\t\tself.assertAlmostEqual(abs(y),1,delta=PRECISION)\n\t\t\tif d > 8:\n\t\t\t\t# this logic is questionable!!!\n\t\t\t\tself.assertAlmostEqual(abs(z),1,delta=10**-1)\n\t\t\telse:\n\t\t\t\tself.assertAlmostEqual(abs(z),1,delta=PRECISION)\n\t\tif DEBUG or 1:\n\t\t\tprint(_debug_power_associative().format(repr(x), repr(y), repr(x*y)))\n\t\t\t# why these don't work...\n\t\t\t#print(_debug_power_associative().format( tuple(repr(i) for i in (x,y,x*y)) ))\n\t\t\t#print(_debug_power_associative().format( tuple([repr(i) for i in (x,y,x*y)]) ))\n\t\t\t#print(_debug_power_associative().format( (repr(i) for i in (x,y,x*y)]) ))\n\n\t\tif VERBOSE:\n\t\t\tprint( _verbose_power_associative().format(x,y,z,abs(x),abs(y),abs(z),abs(z)-1) )\n\n\t#def test_complex(self):\n\t\t#self._is_power_associative(Complex,loops=8000)\n\n\t#def test_quaternion(self):\n\t\t#self._is_power_associative(Quaternion, loops=2400)\n\n\t#def test_octonion(self):\n\t\t#self._is_power_associative(Octonion, loops=800)\n\n\t#def test_sedenion(self):\n\t\t#self._is_power_associative(Sedenion,loops=120)\n\n\t#def test_32ion(self):\n\t\t#self._is_power_associative(Cd32,loops=80)\n\n\t#def test_split_octonion(self):\n\t\t#self._is_power_associative(SplitOctonion, loops=300)\n\n", "description": "Power Associative tests", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "TwoSquareIdentity", "data": "class TwoSquareIdentity():\n\t\"\"\"Two square identity\"\"\"\n\n\tdef test_two_square_identity(self):\n\t\tobj = Complex\n\t\tx = random_vector(obj)\n\t\ty = random_vector(obj)\n\t\tcalc = x*y\n\t\tformula = obj(two_square_identity(x,y))\n\t\tself.assertEqual(formula, calc)\n\t\tif VERBOSE:\n\t\t\tprint(_verbose_square_identity(x,y,formula,calc,\"Brahmagupta-Fibonacci's Two\"))\n\n", "description": "Two square identity", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "FourSquareIdentity", "data": "class FourSquareIdentity():\n\t\"\"\"Four square identity\"\"\"\n\n\tdef test_four_square_identity(self):\n\t\tobj = Quaternion\n\t\tx = random_vector(obj)\n\t\ty = random_vector(obj)\n\t\tcalc = x*y\n\t\tformula = obj(four_square_identity(x,y))\n\t\tself.assertEqual(formula, calc)\n\t\tif VERBOSE:\n\t\t\tprint(_verbose_square_identity(x,y,formula,calc,\"Euler's Four\"))\n\n", "description": "Four square identity", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "EightSquareIdentity", "data": "class EightSquareIdentity():\n\t\"\"\"Eight square identity\"\"\"\n\n\tdef test_eight_square_identity(self):\n\t\tobj = Octonion\n\t\tx = random_vector(obj)\n\t\ty = random_vector(obj)\n\t\tcalc = x*y\n\t\tformula = obj(eight_square_identity(x,y))\n\t\tself.assertEqual(formula, calc)\n\t\tif VERBOSE:\n\t\t\tprint(_verbose_square_identity(x,y,formula,calc,\"Degen's Eight\"))\n\n", "description": "Eight square identity", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}, {"term": "class", "name": "SixteenSquareIdentity", "data": "class SixteenSquareIdentity():\n\t\"\"\"Sixteen square identity\"\"\"\n\n\tdef test_sixteen_square_identity(self):\n\t\tobj = Sedenion\n\t\tx = random_vector(obj)\n\t\ty = random_vector(obj)\n\t\tcalc = x*y\n\t\tformula = obj(sixteen_square_identity(x,y))\n\t\tself.assertAlmostEqual(formula, calc)\n\t\tif VERBOSE:\n\t\t\tprint(_verbose_square_identity(x,y,formula,calc,\"Pfister's Sixteen\"))\n\n", "description": "Sixteen square identity", "category": "math", "imports": ["from involution.algebra import *", "from surreal import creation", "import unittest", "import pandas as pd", "from math import sqrt", "from random import random, uniform", "from io import StringIO"]}], [{"term": "class", "name": "classSpline:", "data": "class Spline:\n\t\"\"\"\n\tCubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.b, self.c, self.d, self.w = [], [], [], []\n\n\t\tself.x = x\n\t\tself.y = y\n\n\t\tself.nx = len(x)  # dimension of x\n\t\th = np.diff(x)\n\n\t\t# calc coefficient c\n\t\tself.a = [iy for iy in y]\n\n\t\t# calc coefficient c\n\t\tA = self.__calc_A(h)\n\t\tB = self.__calc_B(h)\n\t\tself.c = np.linalg.solve(A, B)\n\n\t\t# calc spline coefficient b and d\n\t\tfor i in range(self.nx - 1):\n\t\t\tself.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n\t\t\ttb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n\t\t\t\t (self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n\t\t\tself.b.append(tb)\n\n\tdef calc(self, t):\n\t\t\"\"\"\n\t\tCalc position\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.a[i] + self.b[i] * dx + self.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n\t\treturn result\n\n\tdef calc_d(self, t):\n\t\t\"\"\"\n\t\tCalc first derivative\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n\t\treturn result\n\n\tdef calc_dd(self, t):\n\t\t\"\"\"\n\t\tCalc second derivative\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n\t\treturn result\n\n\tdef __search_index(self, x):\n\t\treturn bisect.bisect(self.x, x) - 1\n\n\tdef __calc_A(self, h):\n\t\tA = np.zeros((self.nx, self.nx))\n\t\tA[0, 0] = 1.0\n\t\tfor i in range(self.nx - 1):\n\t\t\tif i != (self.nx - 2):\n\t\t\t\tA[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n\t\t\tA[i + 1, i] = h[i]\n\t\t\tA[i, i + 1] = h[i]\n\n\t\tA[0, 1] = 0.0\n\t\tA[self.nx - 1, self.nx - 2] = 0.0\n\t\tA[self.nx - 1, self.nx - 1] = 1.0\n\t\t#  print(A)\n\t\treturn A\n\n\tdef __calc_B(self, h):\n\t\t\"\"\"\n\t\tcalc matrix B for spline coefficient c\n\t\t\"\"\"\n\t\tB = np.zeros(self.nx)\n\t\tfor i in range(self.nx - 2):\n\t\t\tB[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n\t\t\t\t\t   h[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n\t\t#  print(B)\n\t\treturn B\n\n\tdef calc_curvature(self, t):\n\t\tj = int(math.floor(t))\n\t\tif j < 0:\n\t\t\tj = 0\n\t\telif j >= len(self.a):\n\t\t\tj = len(self.a) - 1\n\n\t\tdt = t - j\n\t\tdf = self.b[j] + 2.0 * self.c[j] * dt + 3.0 * self.d[j] * dt * dt\n\t\tddf = 2.0 * self.c[j] + 6.0 * self.d[j] * dt\n\t\tk = ddf / ((1 + df ** 2) ** 1.5)\n\t\treturn k\n\n", "description": "\n\tCubic Spline class\n\t", "category": "math", "imports": ["import bisect", "import math", "import numpy as np", "\timport matplotlib.pyplot as plt", "\timport matplotlib.pyplot as plt"]}, {"term": "class", "name": "classSpline2D:", "data": "class Spline2D:\n\t\"\"\"\n\t2D Cubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.s = self.__calc_s(x, y)\n\t\tself.sx = Spline(self.s, x)\n\t\tself.sy = Spline(self.s, y)\n\n\tdef __calc_s(self, x, y):\n\t\tdx = np.diff(x)\n\t\tdy = np.diff(y)\n\t\tself.ds = [math.sqrt(idx ** 2 + idy ** 2)\n\t\t\t\t   for (idx, idy) in zip(dx, dy)]\n\t\ts = [0.0]\n\t\ts.extend(np.cumsum(self.ds))\n\t\treturn s\n\n\tdef calc_position(self, s):\n\t\t\"\"\"\n\t\tcalc position\n\t\t\"\"\"\n\t\tx = self.sx.calc(s)\n\t\ty = self.sy.calc(s)\n\n\t\treturn x, y\n\n\tdef calc_curvature(self, s):\n\t\t\"\"\"\n\t\tcalc curvature\n\t\t\"\"\"\n\t\tdx = self.sx.calc_d(s)\n\t\tddx = self.sx.calc_dd(s)\n\t\tdy = self.sy.calc_d(s)\n\t\tddy = self.sy.calc_dd(s)\n\t\tk = (ddy * dx - ddx * dy) / (dx ** 2 + dy ** 2) ** 1.5\n\t\treturn k\n\n\tdef calc_yaw(self, s):\n\t\t\"\"\"\n\t\tcalc yaw\n\t\t\"\"\"\n\t\tdx = self.sx.calc_d(s)\n\t\tdy = self.sy.calc_d(s)\n\t\tyaw = math.atan2(dy, dx)\n\t\treturn yaw\n\n", "description": "\n\t2D Cubic Spline class\n\t", "category": "math", "imports": ["import bisect", "import math", "import numpy as np", "\timport matplotlib.pyplot as plt", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "calc_2d_spline_interpolation", "data": "def calc_2d_spline_interpolation(x, y, num=100):\n\t\"\"\"\n\tCalc 2d spline course with interpolation\n\t:param x: interpolated x positions\n\t:param y: interpolated y positions\n\t:param num: number of path points\n\t:return:\n\t\t- x\t : x positions\n\t\t- y\t : y positions\n\t\t- yaw   : yaw angle list\n\t\t- k\t : curvature list\n\t\t- s\t : Path length from start point\n\t\"\"\"\n\tsp = Spline2D(x, y)\n\ts = np.linspace(0, sp.s[-1], num+1)[:-1]\n\n\tr_x, r_y, r_yaw, r_k = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\tr_x.append(ix)\n\t\tr_y.append(iy)\n\t\tr_yaw.append(sp.calc_yaw(i_s))\n\t\tr_k.append(sp.calc_curvature(i_s))\n\n\ttravel = np.cumsum([np.hypot(dx, dy) for dx, dy in zip(np.diff(r_x), np.diff(r_y))]).tolist()\n\ttravel = np.concatenate([[0.0], travel])\n\n\treturn r_x, r_y, r_yaw, r_k, travel\n\n", "description": "\n\tCalc 2d spline course with interpolation\n\t:param x: interpolated x positions\n\t:param y: interpolated y positions\n\t:param num: number of path points\n\t:return:\n\t\t- x\t : x positions\n\t\t- y\t : y positions\n\t\t- yaw   : yaw angle list\n\t\t- k\t : curvature list\n\t\t- s\t : Path length from start point\n\t", "category": "math", "imports": ["import bisect", "import math", "import numpy as np", "\timport matplotlib.pyplot as plt", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "test_spline2d", "data": "def test_spline2d():\n\tprint(\"Spline 2D test\")\n\timport matplotlib.pyplot as plt\n\tinput_x = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n\tinput_y = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n\n\tx, y, yaw, k, travel = calc_2d_spline_interpolation(input_x, input_y, num=200)\n\n\tplt.subplots(1)\n\tplt.plot(input_x, input_y, \"xb\", label=\"input\")\n\tplt.plot(x, y, \"-r\", label=\"spline\")\n\tplt.grid(True)\n\tplt.axis(\"equal\")\n\tplt.xlabel(\"x[m]\")\n\tplt.ylabel(\"y[m]\")\n\tplt.legend()\n\n\tplt.subplots(1)\n\tplt.plot(travel, [math.degrees(i_yaw) for i_yaw in yaw], \"-r\", label=\"yaw\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"yaw angle[deg]\")\n\n\tplt.subplots(1)\n\tplt.plot(travel, k, \"-r\", label=\"curvature\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"curvature [1/m]\")\n\n\tplt.show()\n", "description": null, "category": "math", "imports": ["import bisect", "import math", "import numpy as np", "\timport matplotlib.pyplot as plt", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "calc_spline_course", "data": "def calc_spline_course(x, y, ds=0.1):\n\tsp = Spline2D(x, y)\n\ts = list(np.arange(0, sp.s[-1], ds))\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\treturn rx, ry, ryaw, rk, s\n\n", "description": null, "category": "math", "imports": ["import bisect", "import math", "import numpy as np", "\timport matplotlib.pyplot as plt", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "test_spline", "data": "def test_spline():\n\tprint(\"Spline test\")\n\timport matplotlib.pyplot as plt\n\tx = [-0.5, 0.0, 0.5, 1.0, 1.5]\n\ty = [3.2, 2.7, 6, 5, 6.5]\n\n\tspline = Spline(x, y)\n\trx = np.arange(-2.0, 4, 0.01)\n\try = [spline.calc(i) for i in rx]\n\n\tplt.plot(x, y, \"xb\")\n\tplt.plot(rx, ry, \"-r\")\n\tplt.grid(True)\n\tplt.axis(\"equal\")\n\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import bisect", "import math", "import numpy as np", "\timport matplotlib.pyplot as plt", "\timport matplotlib.pyplot as plt"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "insert_number_in_calc_result", "data": "def insert_number_in_calc_result(button_number):\r\n\tglobal last_operator_index , last_dot_index\r\n\tcurrent = lbl_calc_result['text']\r\n\r\n\tif button_number in ['+', '-' , '*']:\r\n\t\tlast_operator_index = len(current)\r\n\r\n\tif button_number == 'C':\r\n\t\tlbl_calc_result['text'] = '0'\r\n\t\tlast_operator_index, last_dot_index = -1,-1\r\n\telif current == '0': \r\n\t\tlbl_calc_result['text'] = button_number\r\n\telif button_number == '=':\r\n\t\tif current[-1] in ['+', '-' , '*']:\r\n\t\t\tcurrent = current[:-1]\t  \r\n\t\tresult = f'{eval(current)}'\r\n\t\tlbl_calc_result['text'] = result \r\n\t\tlast_operator_index , last_dot_index = -1 , -1\r\n\t\tif '.' in lbl_calc_result['text']:\r\n\t\t\tlast_dot_index = result.index('.')\r\n\telse:\r\n\t\tif button_number == '.':\r\n\t\t\tif last_dot_index > last_operator_index:\r\n\t\t\t\tpass\r\n\t\t\telif current[-1] == '.':\r\n\t\t\t\tpass\r\n\t\t\telse:\r\n\t\t\t\tlbl_calc_result['text'] += button_number\r\n\t\t\t\tlast_dot_index = len(current)\r\n\r\n\t\telif button_number in ['+', '-' , '*']:\r\n\t\t\tif current[-1] in ['+', '-' , '*']:\r\n\t\t\t\tlbl_calc_result['text'] = current[:-1] + button_number\r\n\t\t\telse:\r\n\t\t\t\tlbl_calc_result['text'] += button_number\r\n\t\telse:\r\n\t\t\tlbl_calc_result['text'] += button_number\r\n\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r"]}], [{"term": "def", "name": "gen_nucleus", "data": "def gen_nucleus(calc_dir,Z):\n\tcmds = [Rnucleus(Z=Z,A=172,neutralMass=171.936368659,I=0,NDM=0,NQM=0,rms_radius = 5.294,thickness = 2.18)]\n\treturn [cmd.execute(workdir = calc_dir) for cmd in cmds]\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *"]}, {"term": "def", "name": "angular_integration", "data": "def angular_integration(calc_dir):\n\treturn Rangular().execute(workdir = calc_dir)\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *"]}, {"term": "def", "name": "estimate_wavefunctions", "data": "def estimate_wavefunctions(calc_dir,previous_rwfn, grid):\n\treturn Rwfnestimate(grid = grid, orbdict = {'*': previous_rwfn},fallback = 'Thomas-Fermi').execute(workdir = calc_dir)\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *"]}, {"term": "def", "name": "run_hartree_fock_save", "data": "def run_hartree_fock_save(calc_dir,grid,orbs = ['*'],specorbs = ['*'],integration_method = None,calc_name = None):\n\t#out = Rmcdhf(asfidx = [[1],[1],[1],[1,2],[1,2],[1,2],[1],[1,2],[1]],orbs = orbs, specorbs = specorbs, runs = 20000, weighting_method = 'Standard',integration_method = integration_method,grid = grid).execute(workdir = calc_dir)\n\tout = Rmcdhf(asfidx = [[1],[1],[1],[1,2],[1,2],[1,2,3,4,5],[1],[1,2,3,4],[1,2,3,4],[1,2,3]],orbs = orbs, specorbs = specorbs, runs = 20000, weighting_method = 'Standard',integration_method = integration_method,grid = grid).execute(workdir = calc_dir)\n\n\tif calc_name is not None:\n\t\tRsave(calc_name).execute(workdir = calc_dir)\n\t\treturn os.path.join(calc_dir,calc_name) + '.w'\n\telse:\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *"]}, {"term": "def", "name": "csfs_open_maxn", "data": "def csfs_open_maxn(calc_dir,write_csf,maxn,exc):\n\t# max_n: a list of 4 quantum numbers representing the maximum s,p,d, and f shells.\n\t# 4f14 6s2  with 6s excitable\n\t# 4f14 6s 6p with 6p excitable\n\t# 4f14 6s 5d with 5d excitable\n\t# 4f13 6s2 5d with 4f excitable\n\tmr =   [Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(2,*)',\n\t\t\tactiveset=[maxn[0],5,4,4],jlower=0,jhigher=2,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)6p(1,*)',\t\t activeset = [6,maxn[1],5,4],jlower=0,jhigher=4,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)5d(1,*)',\t\t activeset = [6,5,maxn[2],4],jlower=2,jhigher=6,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(13,*)6s(2,i)5d(1,i)',\t\t activeset = [6,5,5,maxn[3]],jlower=4,jhigher=10,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf)]\n\tcombined = mr[0] + mr[1] + mr[2] + mr[3]\n\treturn combined.execute(workdir = calc_dir)\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *"]}, {"term": "def", "name": "csfs_maxn", "data": "def csfs_maxn(calc_dir,write_csf,maxn,exc):\n\t# max_n: a list of 4 quantum numbers representing the maximum s,p,d, and f shells.\n\t# 4f14 6s1 + [6s,6p,5d,5f] base configurations. for each config: allow promotion of one electron to max n.\n\tmr =   [Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(2,*)',\n\t\t\tactiveset=[maxn[0],5,4,4],jlower=0,jhigher=2,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)6p(1,*)',\t\t activeset = [6,maxn[1],4,4],jlower=0,jhigher=4,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)5d(1,*)',\t\t activeset = [6,5,maxn[2],4],jlower=2,jhigher=6,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)5f(1,*)',\t\t activeset = [6,5,4,maxn[3]],jlower=4,jhigher=8,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf)]\n\tcombined = mr[0] + mr[1] + mr[2] + mr[3]\n\treturn combined.execute(workdir = calc_dir)\n\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *"]}], [{"term": "def", "name": "close", "data": "def close(val, reference, releps=releps, abseps=abseps):\n\tprint(val, reference)\n\tassert np.abs(val - reference) < max(np.abs(releps * reference), abseps)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "array_close", "data": "def array_close(val, reference, releps=releps, abseps=abseps):\n\tvalflat = val.flatten()\n\trefflat = reference.flatten()\n\tfor i, vali in enumerate(valflat):\n\t\tclose(vali, refflat[i], releps, abseps)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "system", "data": "def system():\n\treturn create_s22_system('Adenine-thymine_complex_stack')\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_forces", "data": "def test_forces(factory, system):\n\t# do all non-periodic calculations with Adenine-Thymine complex\n\n\t# Default is D3(zero)\n\tsystem.calc = factory.calc()\n\tclose(system.get_potential_energy(), -0.6681154466652238)\n\n\t# Only check forces once, for the default settings.\n\tf_ref = np.array(\n\t\t[[0.0088385621657399, -0.0118387210205813, -0.0143242057174889],\n\t\t [-0.0346912282737323, 0.0177797757792533, -0.0442349785529711],\n\t\t [0.0022759961575945, -0.0087458217241648, -0.0051887171699909],\n\t\t [-0.0049317224619103, -0.0215152368018880, -0.0062290998430756],\n\t\t [-0.0013032612752381, -0.0356240144088481, 0.0203401124180720],\n\t\t [-0.0110305568118348, -0.0182773178473497, -0.0023730575217145],\n\t\t [0.0036258610447203, -0.0074994162928053, -0.0144058177906650],\n\t\t [0.0005289754841564, -0.0035901842246731, -0.0103580836569947],\n\t\t [0.0051775352510856, -0.0051076755874038, -0.0103428268442285],\n\t\t [0.0011299493448658, -0.0185829345539878, -0.0087205807334006],\n\t\t [0.0128459160503721, -0.0248356605575975, 0.0007946691695359],\n\t\t [-0.0063194401470256, -0.0058117310787239, -0.0067932156139914],\n\t\t [0.0013749100498893, -0.0118259631230572, -0.0235404547526578],\n\t\t [0.0219558160992901, -0.0087512938555865, -0.0226017156485839],\n\t\t [0.0001168268736984, -0.0138384169778581, -0.0014850073023105],\n\t\t [0.0037893625607261, 0.0117649062330659, 0.0162375798918204],\n\t\t [0.0011352730068862, 0.0142002748861793, 0.0129337874676760],\n\t\t [-0.0049945288501837, 0.0073929058490670, 0.0088391871214417],\n\t\t [0.0039715118075548, 0.0186949615105239, 0.0114822052853407],\n\t\t [-0.0008003587963147, 0.0161735976004718, 0.0050357997715004],\n\t\t [-0.0033142342134453, 0.0153658921418049, -0.0026233088963388],\n\t\t [-0.0025451124688653, 0.0067994927521733, -0.0017127589489137],\n\t\t [-0.0010451311609669, 0.0067173068779992, 0.0044413725566098],\n\t\t [-0.0030829302438095, 0.0112138539867057, 0.0151213034444885],\n\t\t [0.0117240581287903, 0.0161749855643631, 0.0173269837053235],\n\t\t [-0.0025949288306356, 0.0158830629834040, 0.0155589787340858],\n\t\t [0.0083784268665834, 0.0082132824775010, 0.0090603749323848],\n\t\t [-0.0019694065480327, 0.0115576523485515, 0.0083901101633852],\n\t\t [-0.0020036820791533, 0.0109276020920431, 0.0204922407855956],\n\t\t [-0.0062424587308054, 0.0069848349714167, 0.0088791235460659]])\n\n\tarray_close(system.get_forces(), f_ref)\n\n\t# calculate numerical forces, but use very loose comparison criteria!\n\t# dftd3 doesn't print enough digits to stdout to get good convergence\n\tf_numer = system.calc.calculate_numerical_forces(system, d=1e-4)\n\tarray_close(f_numer, f_ref, releps=1e-2, abseps=1e-3)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_d2_old", "data": "def test_d2_old(factory, system):\n\tsystem.calc = factory.calc(old=True)\n\tclose(system.get_potential_energy(), -0.8923443424663762)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_d3_bj", "data": "def test_d3_bj(factory, system):\n\tsystem.calc = factory.calc(damping='bj')\n\tclose(system.get_potential_energy(), -1.211193213979179)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_d3_zerom", "data": "def test_d3_zerom(factory, system):\n\tsystem.calc = factory.calc(damping='zerom')\n\tclose(system.get_potential_energy(), -2.4574447613705717)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_d3_bjm", "data": "def test_d3_bjm(factory, system):\n\tsystem.calc = factory.calc(damping='bjm')\n\tclose(system.get_potential_energy(), -1.4662085277005799)\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_alternative_tz", "data": "def test_alternative_tz(factory, system):\n\tsystem.calc = factory.calc(tz=True)\n\tclose(system.get_potential_energy(), -0.6160295884482619)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_d3_zero_abc", "data": "def test_d3_zero_abc(factory, system):\n\tsystem.calc = factory.calc(abc=True)\n\tclose(system.get_potential_energy(), -0.6528640090262864)\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_d3_zero_revpbe", "data": "def test_d3_zero_revpbe(factory, system):\n\tsystem.calc = factory.calc(xc='revpbe')\n\tclose(system.get_potential_energy(), -1.5274869363442936)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_custom_damping", "data": "def test_custom_damping(factory, system):\n\tsystem.calc = factory.calc(s6=1.1, sr6=1.1, s8=0.6, sr8=0.9, alpha6=13.0)\n\tclose(system.get_potential_energy(), -1.082846357973487)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_d3_bj_abc", "data": "def test_d3_bj_abc(factory, system):\n\t# A couple of combinations, but not comprehensive\n\tsystem.calc = factory.calc(damping='bj', abc=True)\n\tclose(system.get_potential_energy(), -1.1959417763402416)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_d3_zerom_b3lyp", "data": "def test_d3_zerom_b3lyp(factory, system):\n\tsystem.calc = factory.calc(damping='zerom', xc='b3-lyp')\n\tclose(system.get_potential_energy(), -1.3369234231047677)\n\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}, {"term": "def", "name": "test_diamond_stress", "data": "def test_diamond_stress(factory, system):\n\tsystem = bulk('C')\n\n\tsystem.calc = factory.calc()\n\tclose(system.get_potential_energy(), -0.2160072476277501)\n\n\t# Do one stress for the default settings\n\ts_ref = np.array([0.0182329043326,\n\t\t\t\t\t  0.0182329043326,\n\t\t\t\t\t  0.0182329043326,\n\t\t\t\t\t  -3.22757439831e-14,\n\t\t\t\t\t  -3.22766949320e-14,\n\t\t\t\t\t  -3.22766949320e-14])\n\n\tarray_close(system.get_stress(), s_ref)\n\n\t# As with numerical forces, numerical stresses will not be very well\n\t# converged due to the limited number of digits printed to stdout\n\t# by dftd3. So, use very loose comparison criteria.\n\ts_numer = system.calc.calculate_numerical_stress(system, d=1e-4)\n\tarray_close(s_numer, s_ref, releps=1e-2, abseps=1e-3)\n", "description": null, "category": "math", "imports": ["import pytest", "import numpy as np", "from ase.data.s22 import create_s22_system", "from ase.build import bulk"]}], [{"term": "def", "name": "is_last_number_decimal", "data": "def is_last_number_decimal(current):\r\n\tfor char in current[::-1]:\r\n\t\tif char == '.':\r\n\t\t\treturn True\r\n\t\tif char in ['+', '-' , '*']:\r\n\t\t\treturn False\r\n\treturn False \r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r"]}, {"term": "def", "name": "insert_number_in_calc_result", "data": "def insert_number_in_calc_result(button_number):\r\n\tcurrent = lbl_calc_result['text']\r\n\tif button_number == 'C':\r\n\t\tlbl_calc_result['text'] = '0'\r\n\telif current == '0': \r\n\t\tlbl_calc_result['text'] = button_number\r\n\telif button_number == '=':\r\n\t\tif current[-1] in ['+', '-' , '*']:\r\n\t\t\tcurrent = current[:-1]\t  \r\n\t\tresult = f'{eval(current)}'\r\n\t\tlbl_calc_result['text'] = result \r\n\telif button_number == '.':\r\n\t\tif not is_last_number_decimal(current):\r\n\t\t\tlbl_calc_result['text'] += button_number\r\n\telif button_number in ['+', '-' , '*'] and current[-1] in ['+', '-' , '*']:\r\n\t\tlbl_calc_result['text'] = current[:-1] + button_number\r\n\telif current[-1] in ['+', '-' , '*'] and button_number == '0':\r\n\t\tpass\r\n\telse:\r\n\t\tlbl_calc_result['text'] += button_number\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r"]}], [{"term": "def", "name": "is_last_number_decimal", "data": "def is_last_number_decimal(current):\r\n\tfor char in current[::-1]:\r\n\t\tif char == '.':\r\n\t\t\treturn True\r\n\t\tif char in ['+', '-' , '*']:\r\n\t\t\treturn False\r\n\treturn False \r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r"]}, {"term": "def", "name": "insert_number_in_calc_result", "data": "def insert_number_in_calc_result(button_number):\r\n\tcurrent = lbl_calc_result['text']\r\n\tif button_number == 'C':\r\n\t\tlbl_calc_result['text'] = '0'\r\n\telif current == '0': \r\n\t\tlbl_calc_result['text'] = button_number\r\n\telif button_number == '=':\r\n\t\tif current[-1] in ['+', '-' , '*']:\r\n\t\t\tcurrent = current[:-1]\t  \r\n\t\tresult = f'{eval(current)}'\r\n\t\tlbl_calc_result['text'] = result \r\n\telif button_number == '.':\r\n\t\tif not is_last_number_decimal(current):\r\n\t\t\tlbl_calc_result['text'] += button_number\r\n\telif button_number in ['+', '-' , '*'] and current[-1] in ['+', '-' , '*']:\r\n\t\tlbl_calc_result['text'] = current[:-1] + button_number\r\n\telif current[-1] in ['+', '-' , '*'] and button_number == '0':\r\n\t\tpass\r\n\telse:\r\n\t\tlbl_calc_result['text'] += button_number\r\n", "description": null, "category": "math", "imports": ["import tkinter as tk\r"]}], [{"term": "def", "name": "is_last_number_decimal", "data": "def is_last_number_decimal(current):\r\n\tfor char in current[::-1]:\r\n\t\tif char == '.':\r\n\t\t\treturn True\r\n\t\tif char in ['+', '-' , '*']:\r\n\t\t\treturn False\r\n\treturn False \r\n", "description": null, "category": "math", "imports": ["from ast import Return\r", "import tkinter as tk\r"]}, {"term": "def", "name": "insert_number_in_calc_result", "data": "def insert_number_in_calc_result(button_number):\r\n\tcurrent = lbl_calc_result['text']\r\n\tif button_number == 'C':\r\n\t\tlbl_calc_result['text'] = '0'\r\n\telif current == '0': \r\n\t\tlbl_calc_result['text'] = button_number\r\n\telif button_number == '=':\r\n\t\tif current[-1] in ['+', '-' , '*']:\r\n\t\t\tcurrent = current[:-1]\t  \r\n\t\tresult = f'{eval(current)}'\r\n\t\tlbl_calc_result['text'] = result \r\n\telif button_number == '.':\r\n\t\tif not is_last_number_decimal(current):\r\n\t\t\tlbl_calc_result['text'] += button_number\r\n\telif button_number in ['+', '-' , '*'] and current[-1] in ['+', '-' , '*']:\r\n\t\tlbl_calc_result['text'] = current[:-1] + button_number\r\n\telse:\r\n\t\tlbl_calc_result['text'] += button_number\r\n", "description": null, "category": "math", "imports": ["from ast import Return\r", "import tkinter as tk\r"]}], [{"term": "def", "name": "test_validate_rarity", "data": "def test_validate_rarity():\n\tassert artifact_calc.validate_rarity(\"4\") == True\n\tassert artifact_calc.validate_rarity(\"s\") == False\n\tassert artifact_calc.validate_rarity(4) == False\n\tassert artifact_calc.validate_rarity(\"5\") == True\n\tassert artifact_calc.validate_rarity(\"3\") == True\n\tassert artifact_calc.validate_rarity(\"2\") == False\n\tassert artifact_calc.validate_rarity(\"1\") == False\n\tassert artifact_calc.validate_rarity(\"6\") == False\n", "description": null, "category": "math", "imports": ["import re", "import io", "import artifact_calc"]}, {"term": "def", "name": "test_validate_artifact_slots", "data": "def test_validate_artifact_slots():\n\tassert artifact_calc.validate_artifact_slot(\"circlet\") == True\n\tassert artifact_calc.validate_artifact_slot(\"goble\") == False\n\tassert artifact_calc.validate_artifact_slot(\"goblett\") == False\n\tassert artifact_calc.validate_artifact_slot(1) == False\n\tassert artifact_calc.validate_artifact_slot(\"time-piece\") == False\n", "description": null, "category": "math", "imports": ["import re", "import io", "import artifact_calc"]}, {"term": "def", "name": "test_validate_main_stat", "data": "def test_validate_main_stat():\n\tassert artifact_calc.validate_main_stat(\"circlet\", \"hp%\") == True\n\tassert artifact_calc.validate_main_stat(\"timepiece\", \"recharge\") == True\n\tassert artifact_calc.validate_main_stat(\"goblet\", \"physical damage\") == True\n\tassert artifact_calc.validate_main_stat(\"circlet\", \"elemental damage\") == False\n\tassert artifact_calc.validate_main_stat(\"timepiece\", \"crit rate\") == False\n\tassert artifact_calc.validate_main_stat(\"goblet\", \"crit rate\") == False\n\t\n", "description": null, "category": "math", "imports": ["import re", "import io", "import artifact_calc"]}, {"term": "def", "name": "test_validate_set_selection", "data": "def test_validate_set_selection():\n\tassert artifact_calc.validate_set_selection(5, \"gladiator's\") == True\n\tassert artifact_calc.validate_set_selection(5, \"resolution of sojourner\") == False\n\tassert artifact_calc.validate_set_selection(4, \"bloodstained chivalry\") == True\n\tassert artifact_calc.validate_set_selection(4, \"instructor\") == True\n\tassert artifact_calc.validate_set_selection(4, \"5\") == False\n", "description": null, "category": "math", "imports": ["import re", "import io", "import artifact_calc"]}, {"term": "def", "name": "test_validate_off_stats", "data": "def test_validate_off_stats():\n\tassert artifact_calc.validate_off_stats(\"crit rate\", [], \"atk%\") == True\n\tassert artifact_calc.validate_off_stats(\"crit rate\", [], \"crit rate\") == False\n\tassert artifact_calc.validate_off_stats(\"crit rate\", [\"crit rate\"], \"atk%\") == False\n\tassert artifact_calc.validate_off_stats(\"\", [], \"atk%\") == False\n\n", "description": null, "category": "math", "imports": ["import re", "import io", "import artifact_calc"]}], [{"term": "def", "name": "mocked_validation", "data": "def mocked_validation(*args, **kwargs):\n\treturn True\n\n", "description": null, "category": "math", "imports": ["import unittest", "from unittest.mock import patch", "import pytest", "from app.calc import Calculator"]}, {"term": "class", "name": "TestCalculate", "data": "class TestCalculate(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.calc = Calculator()\n\n\t#CORRECT RESULTS SECTION\n\tdef test_add_method_returns_correct_result(self):\n\t\tself.assertEqual(4, self.calc.add(2, 2))\n\t\tself.assertEqual(0, self.calc.add(2, -2))\n\t\tself.assertEqual(0, self.calc.add(-2, 2))\n\t\tself.assertEqual(1, self.calc.add(1, 0))\n\t\n\tdef test_substract_method_returns_correct_result(self):\n\t\tself.assertEqual(0, self.calc.substract(2, 2))\n\t\tself.assertEqual(4, self.calc.substract(2, -2))\n\t\tself.assertEqual(-4, self.calc.substract(-2, 2))\n\t\tself.assertEqual(0, self.calc.substract(-2, -2))\n\t\tself.assertEqual(1, self.calc.substract(1, 0))\n\t\n\tdef test_multiply_method_returns_correct_result(self):\n\t\tself.assertEqual(4, self.calc.multiply(2, 2))\n\t\tself.assertEqual(-4, self.calc.multiply(2, -2))\n\t\tself.assertEqual(-4, self.calc.multiply(-2, 2))\n\t\tself.assertEqual(4, self.calc.multiply(-2, -2))\n\t\tself.assertEqual(0, self.calc.multiply(1, 0))\n\n\tdef test_divide_method_returns_correct_result(self):\n\t\tself.assertEqual(1, self.calc.divide(2, 2))\n\t\tself.assertEqual(1.5, self.calc.divide(3, 2))\n\t\n\tdef test_power_method_returns_correct_result(self):\n\t\tself.assertEqual(4, self.calc.power(2, 2))\n\t\tself.assertEqual(531441, self.calc.power(3, 12))\n\t\tself.assertAlmostEqual(2.838, self.calc.power(2, 1.5), delta=0.0000001)\n\t\n\tdef test_square_method_returns_correct_result(self):\n\t\tself.assertEqual(3, self.calc.square(9))\n\t\tself.assertEqual(9, self.calc.square(81))\n\t\tself.assertAlmostEqual(1.2247, self.calc.square(1.5), delta=0.0000001)\n\t\n\tdef test_log10_method_returns_correct_result(self):\n\t\tself.assertEqual(1, self.calc.log10(10))\n\t\tself.assertAlmostEqual(1.3010, self.calc.log10(20), delta=0.0000001)\n\t\tself.assertAlmostEqual(2.3979, self.calc.log10(250), delta=0.0000001)\n\n\t#FAILS WITH NON PARAMETER SECTION\n\tdef test_add_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.add, \"2\", 2)\n\t\tself.assertRaises(TypeError, self.calc.add, 2, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.add, \"2\", \"2\")\n\t\tself.assertRaises(TypeError, self.calc.add, None, 2)\n\t\tself.assertRaises(TypeError, self.calc.add, 2, None)\n\t\tself.assertRaises(TypeError, self.calc.add, object(), 2)\n\t\tself.assertRaises(TypeError, self.calc.add, 2, object())\n\n\tdef test_substract_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.substract, \"2\", 2)\n\t\tself.assertRaises(TypeError, self.calc.substract, 2, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.substract, \"2\", \"2\")\n\t\tself.assertRaises(TypeError, self.calc.substract, None, 2)\n\t\tself.assertRaises(TypeError, self.calc.substract, 2, None)\n\t\tself.assertRaises(TypeError, self.calc.substract, object(), 2)\n\t\tself.assertRaises(TypeError, self.calc.substract, 2, object())\n\n\tdef test_divide_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.divide, \"2\", 2)\n\t\tself.assertRaises(TypeError, self.calc.divide, 2, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.divide, \"2\", \"2\")\n\t\n\tdef test_power_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.power, \"2\", 2)\n\t\tself.assertRaises(TypeError, self.calc.power, 2, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.power, \"2\", \"2\")\n\t\tself.assertRaises(TypeError, self.calc.power, None, 2)\n\t\tself.assertRaises(TypeError, self.calc.power, 2, None)\n\t\tself.assertRaises(TypeError, self.calc.power, object(), 2)\n\t\tself.assertRaises(TypeError, self.calc.power, 2, object())\n\n\tdef test_square_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.square, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.square, None)\n\t\tself.assertRaises(TypeError, self.calc.square, object())\n\t\n\tdef test_log10_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.log10, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.log10, None)\n\t\tself.assertRaises(TypeError, self.calc.log10, object())\n\n\tdef test_divide_method_fails_with_division_by_zero(self):\n\t\tself.assertRaises(TypeError, self.calc.divide, 2, 0)\n\t\tself.assertRaises(TypeError, self.calc.divide, 2, -0)\n\t\tself.assertRaises(TypeError, self.calc.divide, 0, 0)\n\t\tself.assertRaises(TypeError, self.calc.divide, \"0\", 0)\n\n\tdef test_square_method_fails_with_negative_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.square, -0)\n\t\tself.assertRaises(TypeError, self.calc.square, 0)\n\t\tself.assertRaises(TypeError, self.calc.square, \"0\")\n\t\tself.assertRaises(TypeError, self.calc.square, -5)\n\n\tdef test_log10_method_fails_with_negative_or_zero_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.log10, -0)\n\t\tself.assertRaises(TypeError, self.calc.log10, 0)\n\t\tself.assertRaises(TypeError, self.calc.log10, \"0\")\n\t\tself.assertRaises(TypeError, self.calc.log10, -5)\n\t\tself.assertRaises(TypeError, self.calc.log10, -10)\n\t\tself.assertRaises(TypeError, self.calc.log10, \"-5\")\n\n\t@patch('app.util.validate_permissions', side_effect=mocked_validation, create=True)\n\tdef test_multiply_method_returns_correct_result(self, _validate_permissions):\n\t\tself.assertEqual(4, self.calc.multiply(2, 2))\n\t\tself.assertEqual(0, self.calc.multiply(1, 0))\n\t\tself.assertEqual(0, self.calc.multiply(-1, 0))\n\t\tself.assertEqual(-2, self.calc.multiply(-1, 2))\n\t\n\t@patch('app.util.validate_permissions', side_effect=mocked_validation, create=True)\n\tdef test_multiply_method_fails_with_nan_parameter(self):\n\t\tself.assertRaises(TypeError, self.calc.multiply, \"2\", 2)\n\t\tself.assertRaises(TypeError, self.calc.multiply, 2, \"2\")\n\t\tself.assertRaises(TypeError, self.calc.multiply, \"2\", \"2\")\n\t\tself.assertRaises(TypeError, self.calc.multiply, None, 2)\n\t\tself.assertRaises(TypeError, self.calc.multiply, 2, None)\n\t\tself.assertRaises(TypeError, self.calc.multiply, object(), 2)\n\t\tself.assertRaises(TypeError, self.calc.multiply, 2, object())\n\n", "description": null, "category": "math", "imports": ["import unittest", "from unittest.mock import patch", "import pytest", "from app.calc import Calculator"]}], [{"term": "def", "name": "ValCalc", "data": "def ValCalc(target, s):\n\tif (int(target) == 0):\n\t\ts.sendline (\"2\")\n\t\ts.sendline (\"40\")\n\t\ts.sendline (\"40\")\n\telse:\n\t\ts.sendline (\"1\")\n\t\ts.sendline (str(int(target)-40))\n\t\ts.sendline (\"40\")\n", "description": null, "category": "math", "imports": ["from pwn import *"]}], [{"term": "def", "name": "gen_nucleus", "data": "def gen_nucleus(calc_dir,Z):\n\tcmds = [Rnucleus(Z=Z,A=172,neutralMass=171.936368659,I=0,NDM=0,NQM=0,rms_radius = 5.294,thickness = 2.18)]\n\treturn [cmd.execute(workdir = calc_dir) for cmd in cmds]\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *", "import numpy as np"]}, {"term": "def", "name": "angular_integration", "data": "def angular_integration(calc_dir):\n\treturn Rangular().execute(workdir = calc_dir)\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *", "import numpy as np"]}, {"term": "def", "name": "estimate_wavefunctions", "data": "def estimate_wavefunctions(calc_dir,previous_rwfn, grid):\n\treturn Rwfnestimate(grid = grid, orbdict = {'*': previous_rwfn},fallback = 'Thomas-Fermi').execute(workdir = calc_dir)\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *", "import numpy as np"]}, {"term": "def", "name": "run_hartree_fock_save", "data": "def run_hartree_fock_save(calc_dir,grid,orbs = ['*'],specorbs = ['*'],integration_method = None,calc_name = None):\n\t#out = Rmcdhf(asfidx = [[1],[1],[1],[1,2],[1,2],[1,2],[1],[1,2],[1]],orbs = orbs, specorbs = specorbs, runs = 20000, weighting_method = 'Standard',integration_method = integration_method,grid = grid).execute(workdir = calc_dir)\n\tout = Rmcdhf(asfidx = [[1],[1],[1],[1,2],[1,2],[1,2,3,4,5],[1],[1,2,3,4],[1,2,3,4],[1,2,3]],orbs = orbs, specorbs = specorbs, runs = 20000, weighting_method = 'Standard',integration_method = integration_method,grid = grid).execute(workdir = calc_dir)\n\n\tif calc_name is not None:\n\t\tRsave(calc_name).execute(workdir = calc_dir)\n\t\treturn os.path.join(calc_dir,calc_name) + '.w'\n\telse:\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *", "import numpy as np"]}, {"term": "def", "name": "run_ci", "data": "def run_ci(calc_dir,calc_name,largest_n):\n\treturn Rci(calcname = calc_name,\n\t\t\t   includetransverse=True,\n\t\t\t   modifyfreq=True,\n\t\t\t   scalefactor='1.d-6',\n\t\t\t   includevacpol = True,\n\t\t\t   includenms= False,\n\t\t\t   includesms = False,\n\t\t\t   estselfenergy= True,\n\t\t\t   largestn = largest_n,\n\t\t\t   asfidx = [[1],[1],[1],[1,2],[1,2],[1,2,3,4,5],[1],[1,2,3,4],[1,2,3,4],[1,2,3]]).execute(workdir = calc_dir)\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *", "import numpy as np"]}, {"term": "def", "name": "csfs_open_maxn", "data": "def csfs_open_maxn(calc_dir,write_csf,maxn,exc):\n\t# max_n: a list of 4 quantum numbers representing the maximum s,p,d, and f shells.\n\t# 4f14 6s2  with 6s excitable\n\t# 4f14 6s 6p with 6p excitable\n\t# 4f14 6s 5d with 5d excitable\n\t# 4f13 6s2 5d with 4f excitable\n\tmr =   [Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(2,*)',\n\t\t\tactiveset=[maxn[0],5,4,4],jlower=0,jhigher=2,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)6p(1,*)',\t\t activeset = [6,maxn[1],5,4],jlower=0,jhigher=4,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)5d(1,*)',\t\t activeset = [6,5,maxn[2],4],jlower=2,jhigher=6,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(13,*)6s(2,i)5d(1,i)',\t\t activeset = [6,5,5,maxn[3]],jlower=4,jhigher=10,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf)]\n\tcombined = mr[0] + mr[1] + mr[2] + mr[3]\n\treturn combined.execute(workdir = calc_dir)\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *", "import numpy as np"]}, {"term": "def", "name": "csfs_open_maxn_safronova", "data": "def csfs_open_maxn_safronova(calc_dir,write_csf,maxn,exc):\n\t# max_n: a list of 4 quantum numbers representing the maximum s,p,d, and f shells.\n\t# 4f14 6s2  with 6s excitable\n\t# 4f14 6s 6p with 6p excitable\n\t# 4f14 6s 5d with 5d excitable\n\t# 4f13 6s2 5d with 4f excitable\n\t# 4f13 6s2 6p with 6p,4f excitable\n\tmr =   [Rcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(2,*)',\n\t\t\tactiveset=[maxn[0],5,4,4],jlower=0,jhigher=2,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)6p(1,*)',\t\t activeset = [6,maxn[1],5,4],jlower=0,jhigher=4,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(14,i)6s(1,i)5d(1,*)',\t\t activeset = [6,5,maxn[2],4],jlower=2,jhigher=6,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(13,*)6s(2,i)5d(1,i)',\t\t activeset = [6,5,5,maxn[3]],jlower=4,jhigher=10,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf),\n\t\t\tRcsfgenerate('Kr','4d(10,c)5s(2,i)5p(6,i)4f(13,*)6s(2,i)6p(1,*)',\t\t activeset = [6,maxn[1],4,maxn[3]],jlower=0,jhigher=4,exc=exc,\n\t\t\tordering = 'User specified',write_csf = write_csf)]\n\tcombined = mr[0] + mr[1] + mr[2] + mr[3] + mr[4]\n\treturn combined.execute(workdir = calc_dir)\n", "description": null, "category": "math", "imports": ["from graspy.grasp import *", "import numpy as np"]}], [{"term": "def", "name": "update_ordinary_income", "data": "def update_ordinary_income(behavioral_effect, calc_y):\n\tdelta_inc = np.where(calc_y.records.c00100 > 0, behavioral_effect, 0.)\n\n\t# Attribute the behavioral effects across itemized deductions,\n\t# wages, and other income.\n\n\titemized = np.where(calc_y.records.c04470 < calc_y.records._standard,\n\t\t\t\t\t\t0.,\n\t\t\t\t\t\tcalc_y.records.c04470)\n\n\tdelta_wages = np.where(calc_y.records.c00100 + itemized > 0,\n\t\t\t\t\t\t   (delta_inc * calc_y.records.e00200 /\n\t\t\t\t\t\t\t(calc_y.records.c00100 + itemized)),\n\t\t\t\t\t\t   0.)\n\n\tother_inc = calc_y.records.c00100 - calc_y.records.e00200\n\n\tdelta_other_inc = np.where(calc_y.records.c00100 + itemized > 0,\n\t\t\t\t\t\t\t   (delta_inc * other_inc /\n\t\t\t\t\t\t\t\t(calc_y.records.c00100 + itemized)),\n\t\t\t\t\t\t\t   0.)\n\n\tdelta_itemized = np.where(calc_y.records.c00100 + itemized > 0,\n\t\t\t\t\t\t\t  (delta_inc * itemized /\n\t\t\t\t\t\t\t   (calc_y.records.c00100 + itemized)),\n\t\t\t\t\t\t\t  0.)\n\n\tcalc_y.records.e00200 = calc_y.records.e00200 + delta_wages\n\n\tcalc_y.records.e00300 = calc_y.records.e00300 + delta_other_inc\n\n\tcalc_y.records.e19570 = np.where(itemized > 0,\n\t\t\t\t\t\t\t\t\t calc_y.records.e19570 + delta_itemized,\n\t\t\t\t\t\t\t\t\t 0.)\n\t# TODO, we should create a behavioral modification\n\t# variable instead of using e19570\n\n\treturn calc_y\n\n", "description": null, "category": "math", "imports": ["import copy", "import numpy as np", "from .policy import Policy", "from .parameters_base import ParametersBase"]}, {"term": "def", "name": "update_cap_gain_income", "data": "def update_cap_gain_income(cap_gain_behavioral_effect, calc_y):\n\tcalc_y.records.p23250 = calc_y.records.p23250 + cap_gain_behavioral_effect\n\treturn calc_y\n\n", "description": null, "category": "math", "imports": ["import copy", "import numpy as np", "from .policy import Policy", "from .parameters_base import ParametersBase"]}, {"term": "def", "name": "behavior", "data": "def behavior(calc_x, calc_y):\n\t\"\"\"\n\tModify plan Y records to account for micro-feedback effect that arrise\n\tfrom moving from plan X to plan Y.\n\t\"\"\"\n\n\t# Calculate marginal tax rates for plan x and plan y.\n\twage_mtr_x, wage_mtr_y = mtr_xy(calc_x, calc_y,\n\t\t\t\t\t\t\t\t\tmtr_of='e00200p',\n\t\t\t\t\t\t\t\t\tliability_type='combined')\n\n\tCG_mtr_x, CG_mtr_y = mtr_xy(calc_x, calc_y,\n\t\t\t\t\t\t\t\tmtr_of='p23250',\n\t\t\t\t\t\t\t\tliability_type='iitax')\n\n\t# Calculate the percent change in after-tax rate for wage and capital gain.\n\twage_pctdiff = ((1 - wage_mtr_y) - (1 - wage_mtr_x)) / (1 - wage_mtr_x)\n\tCG_pctdiff = ((1 - CG_mtr_y) - (1 - CG_mtr_x)) / (1 - CG_mtr_x)\n\n\t# Calculate the magnitude of the substitution and income effects\n\t# Calculate the magnitude of behavior changes on cap gain\n\tsubstitution_effect = (calc_y.behavior.BE_sub * wage_pctdiff *\n\t\t\t\t\t\t   (calc_x.records.c04800))\n\n\tincome_effect = calc_y.behavior.BE_inc * (calc_y.records._combined -\n\t\t\t\t\t\t\t\t\t\t\t  calc_x.records._combined)\n\n\tcombined_behavioral_effect = income_effect + substitution_effect\n\n\tcap_gain_behavioral_effect = (calc_y.behavior.BE_CG_per * CG_pctdiff *\n\t\t\t\t\t\t\t\t  (calc_x.records.p23250))\n\n\t# Add the behavior changes to income sources\n\tcalc_y_behavior = copy.deepcopy(calc_y)\n\tcalc_y_behavior = update_ordinary_income(combined_behavioral_effect,\n\t\t\t\t\t\t\t\t\t\t\t calc_y_behavior)\n\tcalc_y_behavior = update_cap_gain_income(cap_gain_behavioral_effect,\n\t\t\t\t\t\t\t\t\t\t\t calc_y_behavior)\n\n\t# Takes all income updates into considaration\n\tcalc_y_behavior.calc_all()\n\n\treturn calc_y_behavior\n\n", "description": "\n\tModify plan Y records to account for micro-feedback effect that arrise\n\tfrom moving from plan X to plan Y.\n\t", "category": "math", "imports": ["import copy", "import numpy as np", "from .policy import Policy", "from .parameters_base import ParametersBase"]}, {"term": "def", "name": "mtr_xy", "data": "def mtr_xy(calc_x, calc_y, mtr_of='e00200p', liability_type='combined'):\n\n\tpayroll_x, iitax_x, combined_x = calc_x.mtr(mtr_of)\n\tpayroll_y, iitax_y, combined_y = calc_y.mtr(mtr_of)\n\n\tif liability_type == 'combined':\n\t\treturn (combined_x, combined_y)\n\telif liability_type == 'payroll':\n\t\treturn (payroll_x, payroll_y)\n\telif liability_type == 'iitax':\n\t\treturn (iitax_x, iitax_y)\n\telse:\n\t\traise ValueError('Choose from combined, iitax, and payroll.')\n\n", "description": null, "category": "math", "imports": ["import copy", "import numpy as np", "from .policy import Policy", "from .parameters_base import ParametersBase"]}, {"term": "class", "name": "Behavior", "data": "class Behavior(ParametersBase):\n\n\tJSON_START_YEAR = Policy.JSON_START_YEAR\n\tDEFAULTS_FILENAME = 'behavior.json'\n\tDEFAULT_NUM_YEARS = Policy.DEFAULT_NUM_YEARS\n\n\tdef __init__(self, behavior_dict=None,\n\t\t\t\t start_year=JSON_START_YEAR,\n\t\t\t\t num_years=DEFAULT_NUM_YEARS,\n\t\t\t\t inflation_rates=None):\n\t\tif behavior_dict:\n\t\t\tif not isinstance(behavior_dict, dict):\n\t\t\t\traise ValueError('behavior_dict is not a dictionary')\n\t\t\tself._vals = behavior_dict\n\t\telse:  # if None, read defaults\n\t\t\tself._vals = self._params_dict_from_json_file()\n\t\tif inflation_rates is not None:\n\t\t\traise ValueError('inflation_rates != None in Behavior.__init__')\n\t\tself.initialize(start_year, num_years)\n\n\tdef update_behavior(self, revisions):\n\t\t\"\"\"\n\t\tUpdate behavior for given revisions, a dictionary consisting\n\t\tof year:modification dictionaries.\n\t\tFor example: {2014: {'_BE_inc': [0.4, 0.3]}}\n\t\t\"\"\"\n\t\tself.set_default_vals()\n\t\tif self.current_year != self.start_year:\n\t\t\tself.set_year(self.start_year)\n\t\tfor year in revisions:\n\t\t\tif year != self.start_year:\n\t\t\t\tself.set_year(year)\n\t\t\tself._update({year: revisions[year]})\n", "description": "\n\t\tUpdate behavior for given revisions, a dictionary consisting\n\t\tof year:modification dictionaries.\n\t\tFor example: {2014: {'_BE_inc': [0.4, 0.3]}}\n\t\t", "category": "math", "imports": ["import copy", "import numpy as np", "from .policy import Policy", "from .parameters_base import ParametersBase"]}], [], [], [{"term": "def", "name": "_set_webhook", "data": "def _set_webhook():\n\tstatus = bot.set_webhook(WEBHOOK_URL)\n\tif not status:\n\t\tprint('Webhook setup failed')\n\t\tsys.exit(1)\n\telse:\n\t\tprint('Your webhook URL has been set to \"{}\"'.format(WEBHOOK_URL))\n\n", "description": null, "category": "math", "imports": ["import sys", "from io import BytesIO", "import telegram", "from flask import Flask, request, send_file", "from fsm import TocMachine"]}, {"term": "def", "name": "webhook_handler", "data": "def webhook_handler():\n\tupdate = telegram.Update.de_json(request.get_json(force=True), bot)\n\tmachine.advance(update)\n\treturn 'ok'\n\n", "description": null, "category": "math", "imports": ["import sys", "from io import BytesIO", "import telegram", "from flask import Flask, request, send_file", "from fsm import TocMachine"]}, {"term": "def", "name": "show_fsm", "data": "def show_fsm():\n\tbyte_io = BytesIO()\n\tmachine.graph.draw(byte_io, prog='dot', format='png')\n\tbyte_io.seek(0)\n\treturn send_file(byte_io, attachment_filename='fsm.png', mimetype='image/png')\n\n", "description": null, "category": "math", "imports": ["import sys", "from io import BytesIO", "import telegram", "from flask import Flask, request, send_file", "from fsm import TocMachine"]}], [{"term": "class", "name": "CalcTest", "data": "class CalcTest(unittest.TestCase):\n\t\"test class for calc.calc\"\n\n\tdef setUp(self):\n\t\t\"before each test\"\n\t\tpass\n\n\tdef test_calc(self):\n\t\t\"function calc exists\"\n\t\tself.assertTrue(\"calc\" in dir(calc))\n\n\tdef test_calc_add(self):\n\t\t\"addition\"\n\t\tself.assertEqual(3.0, calc.calc(\"1\", \"+\", \"2\"))\n\n\tdef test_calc_sub(self):\n\t\t\"subtraction\"\n\t\tself.assertEqual(2.0, calc.calc(\"3\", \"-\", \"1\"))\n\n\tdef test_calc_mul(self):\n\t\t\"multiplication\"\n\t\tself.assertEqual(6.0, calc.calc(\"2\", \"*\", \"3\"))\n\n\tdef test_calc_div(self):\n\t\t\"division\"\n\t\tself.assertEqual(2.0, calc.calc(\"6\", \"/\", \"3\"))\n\n\tdef test_calc_add_multi(self):\n\t\t\"add many different combinations\"\n\t\tfor x in range(1, 10):\n\t\t\tfor y in range(1, 10):\n\t\t\t\terg = calc.calc(str(x), \"+\", str(y))\n\t\t\t\tself.assertEqual(float(x+y), erg)\n\n\tdef test_calc_number_fail(self):\n\t\t\"conversion error on numbers\"\n\t\ttry:\n\t\t\terg = calc.calc(\"bla\", \"+\", \"schlonz\")\n\t\t\tif isinstance(erg, (int, float)):\n\t\t\t\tself.fail(\"must not succeed\")\n\t\texcept:\n\t\t\tpass\n\n\tdef test_calc_op_fail(self):\n\t\t\"no result on unknown op\"\n\t\ttry:\n\t\t\terg = calc.calc(\"1\", \"?\", \"2\")\n\t\t\tif isinstance(erg, (int, float)):\n\t\t\t\tself.fail(\"must not succeed\")\n\t\texcept:\n\t\t\tpass\n", "description": null, "category": "math", "imports": ["import unittest", "import calc"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "system", "data": "def system():\n\treturn bulk('Al', 'fcc', a=4.5, cubic=True)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_vasp_net_charge", "data": "def test_vasp_net_charge(factory, system):\n\t\"\"\"\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied net charge (via the deprecated net_charge parameter) works\n\tcorrectly. This is conditional on the existence of the VASP_COMMAND or\n\tVASP_SCRIPT environment variables.\n\n\tThis is mainly a slightly reduced duplicate of the vasp_charge test, but with\n\tflipped signs and with checks that ensure FutureWarning is emitted.\n\n\tShould be removed along with the net_charge parameter itself at some point.\n\t\"\"\"\n\n\t# Dummy calculation to let VASP determine default number of electrons\n\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\tlcharg=False)\n\tcalc.calculate(system)\n\tdefault_nelect_from_vasp = calc.get_number_of_electrons()\n\tassert default_nelect_from_vasp == 12\n\n\t# Compare VASP's output nelect from before + net charge to default nelect\n\t# determined by us + net charge\n\twith pytest.warns(FutureWarning):\n\t\tnet_charge = -2\n\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\tnet_charge=net_charge)\n\t\tcalc.initialize(system)\n\t\tcalc.write_input(system)\n\t\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] == default_nelect_from_vasp + net_charge\n\n\t# Test that conflicts between explicitly given nelect and net charge are\n\t# detected\n\twith pytest.raises(ValueError):\n\t\twith pytest.warns(FutureWarning):\n\t\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\t\tnelect=default_nelect_from_vasp + net_charge +\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tnet_charge=net_charge)\n\t\t\tcalc.calculate(system)\n\n\t# Test that conflicts between charge and net_charge are detected\n\twith pytest.raises(ValueError):\n\t\twith pytest.warns(FutureWarning):\n\t\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\t\tcharge=-net_charge - 1,\n\t\t\t\t\t\t\t\tnet_charge=net_charge)\n\t\t\tcalc.calculate(system)\n\n\t# Test that nothing is written if net charge is 0 and nelect not given\n\twith pytest.warns(FutureWarning):\n\t\tcalc = factory.calc(xc='LDA',\n\t\t\t\t\t\t\tnsw=-1,\n\t\t\t\t\t\t\tibrion=-1,\n\t\t\t\t\t\t\tnelm=1,\n\t\t\t\t\t\t\tlwave=False,\n\t\t\t\t\t\t\tlcharg=False,\n\t\t\t\t\t\t\tnet_charge=0)\n\t\tcalc.initialize(system)\n\t\tcalc.write_input(system)\n\t\tcalc.read_incar('INCAR')\n\tassert calc.float_params['nelect'] is None\n", "description": "\n\tRun VASP tests to ensure that determining number of electrons from\n\tuser-supplied net charge (via the deprecated net_charge parameter) works\n\tcorrectly. This is conditional on the existence of the VASP_COMMAND or\n\tVASP_SCRIPT environment variables.\n\n\tThis is mainly a slightly reduced duplicate of the vasp_charge test, but with\n\tflipped signs and with checks that ensure FutureWarning is emitted.\n\n\tShould be removed along with the net_charge parameter itself at some point.\n\t", "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}], [{"term": "def", "name": "test_calc_mean", "data": "def test_calc_mean():\n\tassert calc_mean([1,2,3]) == 2\n\tassert calc_mean([4,2,3,3]) == 3\n", "description": null, "category": "math", "imports": ["from pytest import approx", "from calculations_functions import calc_mean, calc_sdv, calc_mode"]}, {"term": "def", "name": "test_calc_sdv", "data": "def test_calc_sdv():\n\tassert calc_sdv([10, 12, 23, 23, 16, 23, 21, 16] , 18) == approx(4.8989, 0.04)\n\tassert calc_sdv([234, 5443, 1 ,10, 12, 23, 23] , 820) == approx(1888.52, 0.02)\n", "description": null, "category": "math", "imports": ["from pytest import approx", "from calculations_functions import calc_mean, calc_sdv, calc_mode"]}, {"term": "def", "name": "test_calc_mode", "data": "def test_calc_mode():\n\tassert calc_mode([1,1,1,2,3,4,5]) == 1\n", "description": null, "category": "math", "imports": ["from pytest import approx", "from calculations_functions import calc_mean, calc_sdv, calc_mode"]}], [{"term": "class", "name": "Day03Tests", "data": "class Day03Tests(unittest.TestCase):\n\tdef test_load_diagnostics(self):\n\t\tself.assertEqual([\n\t\t\t\"00100\",\n\t\t\t\"11110\",\n\t\t\t\"10110\",\n\t\t\t\"10111\",\n\t\t\t\"10101\",\n\t\t\t\"01111\",\n\t\t\t\"00111\",\n\t\t\t\"11100\",\n\t\t\t\"10000\",\n\t\t\t\"11001\",\n\t\t\t\"00010\",\n\t\t\t\"01010\",\n\t\t], load_diagnostics('data/day03_diagnostics_test.txt'))\n\n\tdef test_calc_gamma_rate(self):\n\t\tself.assertEqual(31, calc_gamma_rate([\"11111\"]))\n\t\tself.assertEqual(0, calc_gamma_rate([\"00000\"]))\n\t\tself.assertEqual(10, calc_gamma_rate([\"11111\", \"00000\", \"01010\"]))\n\n\t\tself.assertEqual(\n\t\t\t22,\n\t\t\tcalc_gamma_rate(load_diagnostics('data/day03_diagnostics_test.txt'))\n\t\t)\n\n\t\tself.assertEqual(\n\t\t\t1816,\n\t\t\tcalc_gamma_rate(load_diagnostics('data/day03_diagnostics_tm.txt'))\n\t\t)\n\n\tdef test_calc_epsilon_rate(self):\n\t\tself.assertEqual(9, calc_epsilon_rate(load_diagnostics('data/day03_diagnostics_test.txt')))\n\t\tself.assertEqual(2279, calc_epsilon_rate(load_diagnostics('data/day03_diagnostics_tm.txt')))\n\n\tdef test_calc_oxygen_generator_rating(self):\n\t\tself.assertEqual(23, calc_oxygen_generator_rating(load_diagnostics('data/day03_diagnostics_test.txt')))\n\t\tself.assertEqual(2031, calc_oxygen_generator_rating(load_diagnostics('data/day03_diagnostics_tm.txt')))\n\n\tdef test_calc_co2_scrubber_rating(self):\n\t\tself.assertEqual(10, calc_co2_scrubber_rating(load_diagnostics('data/day03_diagnostics_test.txt')))\n\t\tself.assertEqual(2104, calc_co2_scrubber_rating(load_diagnostics('data/day03_diagnostics_tm.txt')))\n", "description": null, "category": "math", "imports": ["import unittest", "from src.day03 import calc_oxygen_generator_rating, calc_co2_scrubber_rating, load_diagnostics, calc_gamma_rate, calc_epsilon_rate"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [], [], [{"term": "def", "name": "get_wavenumber", "data": "def get_wavenumber(idx: int, total_num: int) -> int:\n\tif idx <= total_num // 2:\n\t\treturn idx\n\treturn idx - total_num\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_energy_spectrum", "data": "def calc_energy_spectrum(Q: np.ndarray) -> np.ndarray:\n\t\"\"\"\n\tE(k) = 1/2 \\sum |q|^2 / (k^2 + l^2) k d\\theta\n\tassuming the domain is [0, 2 \\pi] x [0, 2\\pi]\n\t\"\"\"\n\tS = np.fft.fft2(Q)  # spectral data\n\tene_spectrum = np.zeros(sum(S.shape))\n\n\tmax_idx = 0\n\tfor i in range(S.shape[0]):\n\t\tkx = get_wavenumber(i, S.shape[0])\n\t\tfor j in range(S.shape[1]):\n\t\t\tky = get_wavenumber(j, S.shape[1])\n\n\t\t\tk2 = kx ** 2 + ky ** 2\n\t\t\tif k2 == 0:\n\t\t\t\tcontinue  # kx and ky == 0, so zero-division will occur\n\n\t\t\tidx = int(np.sqrt(k2) + 0.5)\n\t\t\tene_spectrum[idx] += np.abs(S[i, j]) ** 2 / k2\n\t\t\tif idx > max_idx:\n\t\t\t\tmax_idx = idx\n\n\t# The denominator is a normalization constant due to numpy fft\n\treturn 0.5 * ene_spectrum[:max_idx] / (S.shape[0] * S.shape[1]) ** 2\n\n", "description": "\n\tE(k) = 1/2 \\sum |q|^2 / (k^2 + l^2) k d\\theta\n\tassuming the domain is [0, 2 \\pi] x [0, 2\\pi]\n\t", "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_energy_spectrum_from_uv", "data": "def calc_energy_spectrum_from_uv(U: np.ndarray, V: np.ndarray) -> np.ndarray:\n\t\"\"\"\n\tE(k) = 1/2 \\sum (|U|^2 + |V|^2) k d\\theta\n\tassuming the domain is [0, 2 \\pi] x [0, 2\\pi]\n\t\"\"\"\n\tassert U.shape == V.shape\n\tassert len(U.shape) == 2\n\tSU = np.fft.fft2(U)  # spectral data\n\tSV = np.fft.fft2(V)  # spectral data\n\tene_spectrum = np.zeros(sum(SU.shape))\n\n\tmax_idx = 0\n\tfor i in range(SU.shape[0]):\n\t\tkx = get_wavenumber(i, SU.shape[0])\n\t\tfor j in range(SU.shape[1]):\n\t\t\tky = get_wavenumber(j, SU.shape[1])\n\n\t\t\tk2 = kx ** 2 + ky ** 2\n\t\t\tidx = int(np.sqrt(k2) + 0.5)\n\n\t\t\tene_spectrum[idx] += np.abs(SU[i, j]) ** 2 + np.abs(SV[i, j]) ** 2\n\t\t\tif idx > max_idx:\n\t\t\t\tmax_idx = idx\n\n\t# The denominator is a normalization constant due to numpy fft\n\treturn 0.5 * ene_spectrum[:max_idx] / (SU.shape[0] * SU.shape[1]) ** 2\n\n", "description": "\n\tE(k) = 1/2 \\sum (|U|^2 + |V|^2) k d\\theta\n\tassuming the domain is [0, 2 \\pi] x [0, 2\\pi]\n\t", "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_enstrophy_spectrum", "data": "def calc_enstrophy_spectrum(Q: np.ndarray) -> np.ndarray:\n\t\"\"\"\n\tZ(k) = 1/2 \\sum |q|^2 k d\\theta\n\tassuming the domain is [0, 2 \\pi] x [0, 2\\pi]\n\t\"\"\"\n\tS = np.fft.fft2(Q)  # spectral data\n\tens_spectrum = np.zeros(sum(S.shape))\n\n\tmax_idx = 0\n\tfor i in range(S.shape[0]):\n\t\tkx = get_wavenumber(i, S.shape[0])\n\t\tfor j in range(S.shape[1]):\n\t\t\tky = get_wavenumber(j, S.shape[1])\n\n\t\t\tk2 = kx ** 2 + ky ** 2\n\t\t\tif k2 == 0:\n\t\t\t\tcontinue  # kx and ky == 0\n\n\t\t\tidx = int(np.sqrt(k2) + 0.5)\n\t\t\tens_spectrum[idx] += np.abs(S[i, j]) ** 2\n\t\t\tif idx > max_idx:\n\t\t\t\tmax_idx = idx\n\n\t# The denominator is a normalization constant due to numpy fft\n\treturn 0.5 * ens_spectrum[:max_idx] / (S.shape[0] * S.shape[1]) ** 2\n\n", "description": "\n\tZ(k) = 1/2 \\sum |q|^2 k d\\theta\n\tassuming the domain is [0, 2 \\pi] x [0, 2\\pi]\n\t", "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_Re", "data": "def calc_Re(vortex_field: np.ndarray, nu: float) -> float:\n\tene_spec = calc_energy_spectrum(vortex_field[:, :])\n\tens_spec = calc_enstrophy_spectrum(vortex_field[:, :])\n\tu = np.sqrt(np.sum(ene_spec))  # sqrt of spatial average of kinetic energy\n\tl = u / np.sqrt(np.sum(ens_spec))  # integral length scale\n\tre = u * l / nu\n\treturn re\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_stream_function", "data": "def calc_stream_function(Z: np.ndarray) -> np.ndarray:\n\tS = np.fft.fft2(Z)  # spectral data\n\tPSI = np.zeros_like(S)\n\tfor i in range(S.shape[0]):\n\t\tkx = get_wavenumber(i, S.shape[0])\n\t\tfor j in range(S.shape[1]):\n\t\t\tky = get_wavenumber(j, S.shape[1])\n\n\t\t\tk2 = np.abs(kx ** 2 + ky ** 2)\n\t\t\tif k2 == 0:\n\t\t\t\tPSI[i, j] = 0.0\n\t\t\telse:\n\t\t\t\tPSI[i, j] = -S[i, j] / k2  # stream function\n\n\treturn np.real(np.fft.ifft2(PSI))\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_velocity", "data": "def calc_velocity(Z: np.ndarray, is_xcomponent: bool) -> np.ndarray:\n\tS = np.fft.fft2(Z)  # spectral data\n\tV = np.zeros_like(S)\n\tfor i in range(S.shape[0]):\n\t\tkx = get_wavenumber(i, S.shape[0])\n\t\tfor j in range(S.shape[1]):\n\t\t\tky = get_wavenumber(j, S.shape[1])\n\n\t\t\tk2 = np.abs(kx ** 2 + ky ** 2)\n\t\t\tif k2 == 0:\n\t\t\t\tV[i, j] = 0.0\n\t\t\t\tcontinue  # kx and ky == 0\n\n\t\t\tpsi = -S[i, j] / k2  # stream function\n\n\t\t\tif is_xcomponent:\n\t\t\t\tV[i, j] = -(ky * 1j) * psi\n\t\t\telse:\n\t\t\t\tV[i, j] = (kx * 1j) * psi\n\treturn np.real(np.fft.ifft2(V))\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_derivative", "data": "def calc_derivative(G: np.ndarray, is_x: bool) -> np.ndarray:\n\tS = np.fft.fft2(G)  # spectral data\n\tD = np.zeros_like(S)\n\tfor i in range(S.shape[0]):\n\t\tkx = get_wavenumber(i, S.shape[0])\n\t\tfor j in range(S.shape[1]):\n\t\t\tky = get_wavenumber(j, S.shape[1])\n\n\t\t\tif is_x:\n\t\t\t\tD[i, j] = (kx * 1j) * S[i, j]\n\t\t\telse:\n\t\t\t\tD[i, j] = (ky * 1j) * S[i, j]\n\treturn np.real(np.fft.ifft2(D))\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "reflect", "data": "def reflect(Z: np.ndarray) -> np.ndarray:\n\tassert len(Z.shape) == 2\n\n\treflected = np.zeros((Z.shape[0], (Z.shape[1] - 1) * 2))\n\treflected[:, : Z.shape[1]] = Z\n\treflected[:, Z.shape[1] :] = -Z[:, ::-1][:, 1:-1]\n\n\treturn reflected\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_velocity_using_sine_transform", "data": "def calc_velocity_using_sine_transform(Z: np.ndarray, is_xcomponent: bool) -> np.ndarray:\n\treflected = reflect(Z)\n\tvelocity = calc_velocity(reflected, is_xcomponent)\n\tvelocity = velocity[:, : Z.shape[1]]\n\tassert velocity.shape == Z.shape\n\treturn velocity\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "reflect_velocity", "data": "def reflect_velocity(data: np.ndarray, is_u: bool) -> np.ndarray:\n\tassert len(data.shape) == 2\n\n\treflected = np.zeros((data.shape[0], (2 * data.shape[1] - 1)))\n\treflected[:, : data.shape[1]] = data\n\n\tif is_u:\n\t\treflected[:, data.shape[1] :] = data[:, ::-1][:, 1:]  # for cosine transform\n\telse:\n\t\treflected[:, data.shape[1] :] = -data[:, ::-1][:, 1:]  # for sine transform\n\n\treturn reflected\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_vorticity_using_sine_cosine_transform", "data": "def calc_vorticity_using_sine_cosine_transform(u: np.ndarray, v: np.ndarray) -> np.ndarray:\n\tassert u.shape == v.shape\n\tassert len(u.shape) == 2\n\n\t_u = reflect_velocity(u, is_u=True)\n\t_v = reflect_velocity(v, is_u=False)\n\t_z = calc_derivative(_v, is_x=True) - calc_derivative(_u, is_x=False)\n\tz = _z[:, : u.shape[1]]\n\n\tassert z.shape == u.shape\n\n\treturn z\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_vorticity", "data": "def calc_vorticity(uv):\n\tassert len(uv.shape) == 3\n\tassert uv.shape[0] == 2\n\tu, v = uv[0, :, :], uv[1, :, :]\n\tz = calc_derivative(v, is_x=True) - calc_derivative(u, is_x=False)\n\treturn z\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_energy_spectrum_from_uv_after_scaling", "data": "def calc_energy_spectrum_from_uv_after_scaling(uv: np.ndarray, config: dict) -> np.ndarray:\n\tassert len(uv.shape) == 3\n\tassert uv.shape[0] == 2\n\n\t_uv = uv * config[\"data\"][\"velocity_std\"] + config[\"data\"][\"velocity_mean\"]\n\tene_spec_from_V = calc_energy_spectrum_from_uv(_uv[0], _uv[1])\n\n\treturn ene_spec_from_V\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_energy_spectrum_from_z_after_scaling", "data": "def calc_energy_spectrum_from_z_after_scaling(z: np.ndarray, config: dict) -> np.ndarray:\n\tassert len(z.shape) == 2\n\n\t_z = z * config[\"data\"][\"vortex_std\"] + config[\"data\"][\"vortex_mean\"]\n\tene_spec_from_Z = calc_energy_spectrum(_z)\n\n\treturn ene_spec_from_Z\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_enstrophy_spectrum_from_uv_after_scaling", "data": "def calc_enstrophy_spectrum_from_uv_after_scaling(uv: np.ndarray, config: dict) -> np.ndarray:\n\tassert len(uv.shape) == 3\n\tassert uv.shape[0] == 2\n\n\t_uv = uv * config[\"data\"][\"velocity_std\"] + config[\"data\"][\"velocity_mean\"]\n\tz = calc_vorticity(_uv)\n\tens_spec = calc_enstrophy_spectrum(z)\n\n\treturn ens_spec\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_enstrophy_spectrum_from_z_after_scaling", "data": "def calc_enstrophy_spectrum_from_z_after_scaling(z: np.ndarray, config: dict) -> np.ndarray:\n\tassert len(z.shape) == 2\n\n\t_z = z * config[\"data\"][\"vortex_std\"] + config[\"data\"][\"vortex_mean\"]\n\tens_spec = calc_enstrophy_spectrum(_z)\n\n\treturn ens_spec\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_spectrum_set_from_z_after_scaling", "data": "def calc_spectrum_set_from_z_after_scaling(z: np.ndarray, config: dict) -> dict:\n\tassert len(z.shape) == 2\n\n\t_z = z * config[\"data\"][\"vortex_std\"] + config[\"data\"][\"vortex_mean\"]\n\n\tens_spec = calc_enstrophy_spectrum(_z)\n\tene_spec = calc_energy_spectrum(_z)\n\tassert len(ens_spec) == len(ene_spec)\n\n\tks = np.arange(len(ene_spec))\n\n\treturn {\n\t\t\"energy_spectrum\": ene_spec,\n\t\t\"enstrophy_spectrum\": ens_spec,\n\t\t\"energy_spectrum_xk\": ene_spec * ks,\n\t\t\"enstrophy_spectrum_xk\": ens_spec * ks,\n\t}\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_spectrum_set_from_uv_after_scaling", "data": "def calc_spectrum_set_from_uv_after_scaling(uv: np.ndarray, config: dict) -> dict:\n\tassert len(uv.shape) == 3\n\tassert uv.shape[0] == 2\n\n\t_uv = uv * config[\"data\"][\"velocity_std\"] + config[\"data\"][\"velocity_mean\"]\n\tz = calc_vorticity(_uv)\n\tens_spec = calc_enstrophy_spectrum(z)\n\tene_spec = calc_energy_spectrum_from_uv(_uv[0], _uv[1])\n\n\tassert len(ens_spec) == len(ene_spec)\n\n\tks = np.arange(len(ene_spec))\n\n\treturn {\n\t\t\"energy_spectrum\": ene_spec,\n\t\t\"enstrophy_spectrum\": ens_spec,\n\t\t\"energy_spectrum_xk\": ene_spec * ks,\n\t\t\"enstrophy_spectrum_xk\": ens_spec * ks,\n\t}\n\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_spectrum_set_from_z_after_scaling_using_sine_transform", "data": "def calc_spectrum_set_from_z_after_scaling_using_sine_transform(\n", "description": null, "category": "math", "imports": ["import numpy as np"]}, {"term": "def", "name": "calc_spectrum_set_from_uv_after_scaling_using_sine_cosine_transform", "data": "def calc_spectrum_set_from_uv_after_scaling_using_sine_cosine_transform(\n", "description": null, "category": "math", "imports": ["import numpy as np"]}], [{"term": "class", "name": "#ThisclassdefinesacompletegenericvisitorforaparsetreeproducedbyCalcParser.", "data": "# This class defines a complete generic visitor for a parse tree produced by CalcParser.\n", "description": null, "category": "math", "imports": ["from antlr4 import *", "\tfrom .CalcParser import CalcParser", "\tfrom CalcParser import CalcParser"]}, {"term": "class", "name": "CalcVisitor", "data": "class CalcVisitor(ParseTreeVisitor):\n\n\t# Visit a parse tree produced by CalcParser#parse.\n\tdef visitParse(self, ctx:CalcParser.ParseContext):\n\t\treturn self.visitChildren(ctx)\n\n\n\t# Visit a parse tree produced by CalcParser#EquationExpression.\n\tdef visitEquationExpression(self, ctx:CalcParser.EquationExpressionContext):\n\t\treturn self.visitChildren(ctx)\n\n\n\t# Visit a parse tree produced by CalcParser#assignment.\n\tdef visitAssignment(self, ctx:CalcParser.AssignmentContext):\n\t\treturn self.visitChildren(ctx)\n\n\n\t# Visit a parse tree produced by CalcParser#comment.\n\tdef visitComment(self, ctx:CalcParser.CommentContext):\n\t\treturn self.visitChildren(ctx)\n\n\n\t# Visit a parse tree produced by CalcParser#ArithmeticExpressionPow.\n\tdef visitArithmeticExpressionPow(self, ctx:CalcParser.ArithmeticExpressionPowContext):\n\t\treturn self.visitChildren(ctx)\n\n\n\t# Visit a parse tree produced by CalcParser#ArithmeticExpressionParens.\n\tdef visitArithmeticExpressionParens(self, ctx:CalcParser.ArithmeticExpressionParensContext):\n\t\treturn self.visitChildren(ctx)\n\n\n\t# Visit a parse tree produced by CalcParser#ArithmeticExpressionNumericEntity.\n\tdef visitArithmeticExpressionNumericEntity(self, ctx:CalcParser.ArithmeticExpressionNumericEntityContext):\n\t\treturn self.visitChildren(ctx)\n\n\n\t# Visit a parse tree produced by CalcParser#ArithmeticExpressionMultDiv.\n\tdef visitArithmeticExpressionMultDiv(self, ctx:CalcParser.ArithmeticExpressionMultDivContext):\n\t\treturn self.visitChildren(ctx)\n\n\n\t# Visit a parse tree produced by CalcParser#ArithmeticExpressionPlusMinus.\n\tdef visitArithmeticExpressionPlusMinus(self, ctx:CalcParser.ArithmeticExpressionPlusMinusContext):\n\t\treturn self.visitChildren(ctx)\n\n\n\t# Visit a parse tree produced by CalcParser#NumericConst.\n\tdef visitNumericConst(self, ctx:CalcParser.NumericConstContext):\n\t\treturn self.visitChildren(ctx)\n\n\n\t# Visit a parse tree produced by CalcParser#NumericVariable.\n\tdef visitNumericVariable(self, ctx:CalcParser.NumericVariableContext):\n\t\treturn self.visitChildren(ctx)\n\n\n", "description": null, "category": "math", "imports": ["from antlr4 import *", "\tfrom .CalcParser import CalcParser", "\tfrom CalcParser import CalcParser"]}], [{"term": "class", "name": "classConverter:", "data": "class Converter:\n\tdef __init__(self):\n\n\t\t# formatting variables\n\t\tbackground_colour = \"light blue\"\n\n\t\t# Initialise list to hold calculation history\n\t\t# In later versions list will be populated with user calculations\n\t\tself.all_calc_list = [\"0 degrees F is -17.8 degrees C\",\n\t\t\t\t\t\t\t  \"0 degrees C is 32 degrees F\",\n\t\t\t\t\t\t\t  \"100 degrees F is 37.8 degrees C\"]\n\n\t\t# Converter Main Screen GUI\n\t\tself.converter_frame = Frame(width=300, height=300,\n\t\t\t\t\t\t\t\t\t bg=background_colour, pady=10)\n\t\tself.converter_frame.grid()\n\n\t\t# Temperature Conversion Heading (row 0)\n\t\tself.temp_converter_label = Label(self.converter_frame,\n\t\t\t\t\t\t\t\t\t\t  text=\"Temperature Converter\",\n\t\t\t\t\t\t\t\t\t\t  font=(\"Arial\", \"16\", \"bold\"),\n\t\t\t\t\t\t\t\t\t\t  bg=background_colour,\n\t\t\t\t\t\t\t\t\t\t  padx=10, pady=10)\n\t\tself.temp_converter_label.grid(row=0)\n\n\t\t# history Button (row 1)\n\t\tself.history_button = Button(self.converter_frame, text=\"History\",\n\t\t\t\t\t\t\t\t  font=(\"Arial\", \"14\"), padx=10, pady=10,\n\t\t\t\t\t\t\t\t  command=lambda: self.history(self.all_calc_list))\n\t\tself.history_button.grid(row=1)\n\n\tdef history(self, calc_history):\n\t\tHistory(self, calc_history)\n", "description": null, "category": "math", "imports": ["from tkinter import *", "from functools import partial  # To prevent unwanted windows"]}, {"term": "class", "name": "classHistory:", "data": "class History:\n\tdef __init__(self, partner, calc_history):\n\t\tbackground = \"#f5e7b5\"  # beige\n\n\t\t# disable history button\n\t\tpartner.history_button.config(state=DISABLED)\n\n\t\t# sets up child window (ie. history box)\n\t\tself.history_box = Toplevel()\n\n\t\t# if users press cross at top, closes history and 'releases' history button\n\t\tself.history_box.protocol('WM_DELETE_WINDOW', partial(self.close_history,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   partner))\n\n\t\t# set up GUI frame\n\t\tself.history_frame = Frame(self.history_box, width=300, bg=background)\n\t\tself.history_frame.grid()\n\n\t\t# set up history heading (row 0)\n\t\tself.hist_heading = Label(self.history_frame, text=\"Calculate History\",\n\t\t\t\t\t\t\t\t  font=\"Arial 18 bold\", bg=background)\n\t\tself.hist_heading.grid(row=0)\n\n\t\t# history text (label, row 1)\n\t\tself.history_text = Label(self.history_frame,\n\t\t\t\t\t\t\t\t  text=\"Here are your most recent \"\n\t\t\t\t\t\t\t\t\t   \"calculations. Please use the export \"\n\t\t\t\t\t\t\t\t\t   \"button to create a text file of all \"\n\t\t\t\t\t\t\t\t\t   \"your calculations for this session\",\n\t\t\t\t\t\t\t\t  font=\"Arial 10 italic\", wrap=250,\n\t\t\t\t\t\t\t\t  justify=LEFT, width=40, bg=background,\n\t\t\t\t\t\t\t\t  padx=10, pady=10)\n\t\tself.history_text.grid(row=1)\n\n\t\t# History output goes here (row 2)\n\t\thistory_string = \"\"\n\t\tif len(calc_history) >= 7:\n\t\t\tfor item in range(0, 7):\n\t\t\t\thistory_string += calc_history[len(calc_history)-item-1]+\"\\n\"\n\n\t\telse:\n\t\t\tfor item in calc_history:\n\t\t\t\thistory_string += calc_history[len(calc_history) -\n\t\t\t\t\t\t\t\t\t\t\t   calc_history.index(item)-1]+\"\\n\"\n\t\t\t\tself.history_text.config(text=\"Here is your calculation \"\n\t\t\t\t\t\t\t\t\t\t\t  \"history. You can use the \"\n\t\t\t\t\t\t\t\t\t\t\t  \"export button to save this \"\n\t\t\t\t\t\t\t\t\t\t\t  \"data to a text file if desired\")\n\t\t# Label to display calculation history to user\n\t\tself.calc_label = Label(self.history_frame, text=history_string,\n\t\t\t\t\t\t\t\tbg=background, font=\"Arial 12\", justify=LEFT)\n\t\tself.calc_label.grid(row=2)\n\n\t\t# Export / Dismiss button frame\n\t\tself.export_dismiss_frame = Frame(self.history_frame)\n\t\tself.export_dismiss_frame.grid(row=3, pady=10)\n\n\t\t# Export Button\n\t\tself.export_btn = Button(self.export_dismiss_frame, text=\"Export\",\n\t\t\t\t\t\t\t\t font=\"Arial 12 bold\")\n\t\tself.export_btn.grid(row=0, column=0)\n\n\t\t# Dismiss Button\n\t\tself.dismiss_btn = Button(self.export_dismiss_frame, text=\"Dismiss\",\n\t\t\t\t\t\t\t\t font=\"Arial 12 bold\",\n\t\t\t\t\t\t\t\t command=partial(self.close_history, partner))\n\t\tself.dismiss_btn.grid(row=0, column=1)\n\n\tdef close_history(self, partner):\n\t\t# Put history button back to normal...\n\t\tpartner.history_button.config(state=NORMAL)\n\t\tself.history_box.destroy()\n\n", "description": null, "category": "math", "imports": ["from tkinter import *", "from functools import partial  # To prevent unwanted windows"]}], [{"term": "def", "name": "open_Task1", "data": "def open_Task1():\n\twindow.close()\n\twindow1.show()\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "open_Task2", "data": "def open_Task2():\n\twindow.close()\n\twindow2.show()\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "open_Task3", "data": "def open_Task3():\n\twindow.close()\n\twindow3.show()\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "open_Task3_2", "data": "def open_Task3_2():\n\twindow3.close()\n\twindow3_2.show()\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "open_Task3_1", "data": "def open_Task3_1():\n\twindow3_2.close()\n\twindow3.show()\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "open_Task4", "data": "def open_Task4():\n\twindow.close()\n\twindow4.show()\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "task1_calc", "data": "def task1_calc():\n\tu_method = form1.comboBMethod.currentText()\n\tu_algorithm = form1.comboBAlgorithm.currentText()\n\tu_n = form1.spinN.value()\n\ta = 0.5\n\tb = 1.3\n\te = 10**(-6)\n\tres = 0\n\tif u_algorithm == '\u0421 \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u044b\u043c \u0448\u0430\u0433\u043e\u043c':\n\t\tif u_method == '\u041c\u0435\u0442\u043e\u0434 \u043b\u0435\u0432\u044b\u0445 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432':\n\t\t\tres = calc.LH_rect_method_CONST_h(a, b, u_n)\n\t\telif u_method == '\u041c\u0435\u0442\u043e\u0434 \u043f\u0440\u0430\u0432\u044b\u0445 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432':\n\t\t\tres = calc.RH_rect_method(a, b, u_n)\n\t\telif u_method == '\u041c\u0435\u0442\u043e\u0434 \u0442\u0440\u0430\u043f\u0435\u0446\u0438\u0439':\n\t\t\tres = calc.trapezoid_method(a, b, u_n)\n\t\telif u_method == '\u041c\u0435\u0442\u043e\u0434 \u043f\u0430\u0440\u0430\u0431\u043e\u043b':\n\t\t\tres = calc.parabola_method(a, b, u_n)\n\t\telse:\n\t\t\tres = '\u0412\u0432\u0435\u0434\u0451\u043d \u043d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434'\n\telif u_algorithm == '\u0421 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u043c \u0448\u0430\u0433\u043e\u043c':\n\t\tif u_method == '\u041c\u0435\u0442\u043e\u0434 \u043b\u0435\u0432\u044b\u0445 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432':\n\t\t\tres = calc.rect_method_remainder(a, b, u_n, e)\n\t\telse:\n\t\t\tres = '\u0410\u043b\u0433\u043e\u0440\u0438\u0442\u043c \u0441 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u043c \u0448\u0430\u0433\u043e\u043c \\n\u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u043e \u043c\u0435\u0442\u043e\u0434\u0443 \\n\u043b\u0435\u0432\u044b\u0445 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432'\n\telse:\n\t\tres = '\u0412\u0432\u0435\u0434\u0451\u043d \u043d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c'\n\n\tform1.lOutputRes.setText(f'{res}')\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "task2_calc", "data": "def task2_calc():\n\tu_nx = form2.sbn_x.value()\n\tu_ny = form2.sbn_y.value()\n\ta = 0\n\tc = 0\n\tb = math.pi / 2\n\td = math.pi / 2\n\thx = calc.step_calc(a, b, u_nx)\n\thy = calc.step_calc(c, d, u_ny)\n\tform2.dsh_x.setValue(hx)\n\tform2.dsh_y.setValue(hy)\n\tform2.lResult.setText(f'{calc.mult_integrals(a, b, c, d, hx, hy)}')\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "task3_eps_calc", "data": "def task3_eps_calc():\n\ta = []\n\ta.append(form3.DSA0_eps.value())\n\ta.append(form3.DSA1_eps.value())\n\ta.append(form3.DSA2_eps.value())\n\ta.append(form3.DSA3_eps.value())\n\ta.append(form3.DSA4_eps.value())\n\ta.append(form3.DSA5_eps.value())\n\ta.append(form3.DSA6_eps.value())\n\ta.append(form3.DSA7_eps.value())\n\te = int(form3.eps_coef_eps.text()) * 10**int(form3.power_of_ten_eps.text())\n\tx = form3.DSX_eps.value()\n\tform3.lResult_eps.setText(f'{calc.calc_eps_func(a, e, x)}')\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "task3_sin_calc", "data": "def task3_sin_calc():\n\ta = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\ta[1] = form3.DSA1_sin.value()\n\ta[3] = form3.DSA3_sin.value()\n\ta[5] = form3.DSA5_sin.value()\n\ta[7] = form3.DSA7_sin.value()\n\ta[9] = form3.DSA9_sin.value()\n\te = int(form3.eps_coef.text()) * 10**int(form3.power_of_ten_sin.text())\n\tx = int(form3.pi_coef.text()) * math.pi / int(form3.inverse_pi_coef.text())\n\tform3.lResult_sin.setText(f'{calc.calc_sin_func(a, e, x)}')\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "task3_2_calc", "data": "def task3_2_calc():\n\te = int(form3_2.eps_coef.text()) * 10**int(form3_2.power_of_ten.text())\n\tx = form3_2.DSX.value()\n\ty0 = form3_2.DSY.value()\n\tform3_2.lResult.setText(f'{calc.iteration_1(x, y0, e)}')\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "task3_2_calc_2", "data": "def task3_2_calc_2():\n\te = float(form3_2.eps_coef_2.text()) * 10**int(\n\t\tform3_2.power_of_ten_2.text())\n\tx = float(form3_2.DSX_2.value())\n\ty0 = float(form3_2.DSY_2.value())\n\tform3_2.lResult_2.setText(f'{calc.iteration_2(x, y0, e)}')\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "task4_calc", "data": "def task4_calc():\n\tex = form4.CBExample.currentText()\n\tmethod = form4.CBMethod.currentText()\n\te = int(form4.eps_coef.text()) * 10**int(form4.power_of_ten.text())\n\tif ex == \"\u0418\u043d\u0434\u0438\u0432\u0438\u0434\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440\":\n\t\ta = form4.dsh_a.value() * math.pi\n\t\tb = form4.dsh_b.value() * math.pi\n\t\tif method == \"\u041c\u0435\u0442\u043e\u0434 \u043a\u0430\u0441\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0445\":\n\t\t\tform4.lResult.setText(f\"{calc.newtons_method_ind(a, b, e)}\")\n\t\telif method == \"\u0414\u0435\u043b\u0435\u043d\u0438\u0435 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u043f\u043e\u043f\u043e\u043b\u0430\u043c\":\n\t\t\tform4.lResult.setText(f\"{calc.separation_ind(a, b, e)}\")\n\t\telif method == \"\u041e\u0442\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u0440\u043d\u0435\u0439 \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f\":\n\t\t\tform4.lResult.setText(f\"{calc.division_ind(a, b, e)}\")\n\t\telse:\n\t\t\tform4.lResult.setText(f\"{calc.chord_ind(a, b, e)}\")\n\telif ex == \"\u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440\":\n\t\ta = form4.dsh_a.value()\n\t\tb = form4.dsh_b.value()\n\t\tif method == \"\u041c\u0435\u0442\u043e\u0434 \u043a\u0430\u0441\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0445\":\n\t\t\tform4.lResult.setText(f\"{calc.newtons_method_ctrl(a, b, e)}\")\n\t\telif method == \"\u0414\u0435\u043b\u0435\u043d\u0438\u0435 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u043f\u043e\u043f\u043e\u043b\u0430\u043c\":\n\t\t\tform4.lResult.setText(f\"{calc.division_ctrl(a, b, e)}\")\n\t\telif method == \"\u041e\u0442\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u0440\u043d\u0435\u0439 \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f\":\n\t\t\tform4.lResult.setText(f\"{calc.separation_ctrl(a, b, e)}\")\n\t\telse:\n\t\t\tform4.lResult.setText(f\"{calc.chord_ctrl(a, b, e)}\")\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "return_from_Task1", "data": "def return_from_Task1():\n\twindow1.close()\n\twindow.show()\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "return_from_Task2", "data": "def return_from_Task2():\n\twindow2.close()\n\twindow.show()\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "return_from_Task3", "data": "def return_from_Task3():\n\twindow3.close()\n\twindow.show()\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "return_from_Task3_2", "data": "def return_from_Task3_2():\n\twindow3_2.close()\n\twindow.show()\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "return_from_Task4", "data": "def return_from_Task4():\n\twindow4.close()\n\twindow.show()\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}, {"term": "def", "name": "show_Example", "data": "def show_Example():\n\tif form4.CBExample.currentText() == \"\u041a\u043e\u043d\u0442\u0440\u043e\u043b\u044c\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440\":\n\t\tform4.label.setPixmap(QPixmap(\"ctrlTask4.png\"))\n\t\tform4.pi_a.setText(\"\")\n\t\tform4.pi_b.setText(\"\")\n\t\tform4.dsh_a.setValue(0.5)\n\t\tform4.dsh_b.setValue(1)\n\telif form4.CBExample.currentText() == \"\u0418\u043d\u0434\u0438\u0432\u0438\u0434\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0440\u0438\u043c\u0435\u0440\":\n\t\tform4.label.setPixmap(QPixmap(\"individTask4.png\"))\n\t\tform4.pi_a.setText(\"* \u03c0\")\n\t\tform4.pi_b.setText(\"* \u03c0\")\n\t\tform4.dsh_a.setValue(-2)\n\t\tform4.dsh_b.setValue(2)\n\telse:\n\t\tform4.label.setPixmap(QPixmap(\"\"))\n\t\tform4.pi_a.setText(\"\")\n\t\tform4.pi_b.setText(\"\")\n\t\tform4.dsh_a.setValue(0)\n\t\tform4.dsh_b.setValue(0)\n\n", "description": null, "category": "math", "imports": ["from PyQt5 import uic", "from PyQt5.QtWidgets import QApplication", "from PyQt5.QtGui import QPixmap", "import calculations as calc", "import math"]}], [{"term": "def", "name": "calc", "data": "def calc(key):\n\tstr2 = \"0123456789\"\n", "description": null, "category": "math", "imports": ["from tkinter import *", "from tkinter import messagebox", "from tkinter import ttk"]}], [{"term": "class", "name": "Test_teaser", "data": "class Test_teaser(object):\n\t\"\"\"Unit Tests for TEASER\"\"\"\n\n\tglobal prj\n\n\tdef test_calc_vdi_room1(self):\n\t\t\"\"\"Parameter Verification for rouvel room1\"\"\"\n\t\timport teaser.examples.verification.verification_VDI_6007_room1 as room1\n\n\t\troom1_prj = room1.parameter_room1()\n\t\tzone_attr = room1_prj.buildings[0].thermal_zones[0].model_attr\n\n\t\t# parameters inner wall Typraum S\n\n\t\tassert round(zone_attr.r1_iw, 13) == 0.0005956934075\n\t\tassert round(zone_attr.c1_iw / 1000, 7) == 14836.3546282\n\t\tassert round(zone_attr.area_iw, 1) == 75.5\n\t\tassert round(zone_attr.alpha_conv_inner_iw, 13) == 2.23642384105960\n\n\t\t# paremeters outer wall Typraum S\n\t\tr_rest = zone_attr.r_rest_ow + 1 / (\n\t\t\tzone_attr.alpha_comb_outer_ow * zone_attr.area_ow\n\t\t)\n\t\tassert round(r_rest, 13) == 0.0427687193786\n\t\tassert round(zone_attr.r1_ow, 13) == 0.0043679129367\n\t\tassert round(zone_attr.c1_ow / 1000, 7) == 1600.8489399\n\t\tassert round(zone_attr.area_ow, 1) == 3.5\n\t\tassert round(zone_attr.area_win, 1) == 7.0\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 1) == 2.7\n\t\tassert round(zone_attr.alpha_comb_outer_ow, 1) == 25.0\n\n\tdef test_calc_vdi_room3(self):\n\t\t\"\"\"Parameter Verification for room 3\"\"\"\n\t\timport teaser.examples.verification.verification_VDI_6007_room3 as room3\n\n\t\troom3_prj = room3.parameter_room3()\n\t\tzone_attr = room3_prj.buildings[0].thermal_zones[0].model_attr\n\n\t\t# parameters inner wall Typraum L\n\n\t\tassert round(zone_attr.r1_iw, 13) == 0.003385649748\n\t\tassert round(zone_attr.c1_iw / 1000, 7) == 7445.3648976\n\t\tassert round(zone_attr.area_iw, 1) == 75.5\n\t\tassert round(zone_attr.alpha_conv_inner_iw, 13) == 2.23642384105960\n\n\t\t# parameters outer wall Typraum L\n\t\tr_rest = zone_attr.r_rest_ow + 1 / (\n\t\t\tzone_attr.alpha_comb_outer_ow * zone_attr.area_ow\n\t\t)\n\t\tassert round(r_rest, 13) == 0.0431403889233\n\t\tassert round(zone_attr.r1_ow, 13) == 0.004049351608\n\t\tassert round(zone_attr.c1_ow / 1000, 7) == 47.8617641\n\t\tassert round(zone_attr.area_ow, 1) == 3.5\n\t\tassert round(zone_attr.area_win, 1) == 7.0\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 1) == 2.7\n\t\tassert round(zone_attr.alpha_comb_outer_ow, 1) == 25.0\n\n\tdef test_calc_vdi_room8(self):\n\t\t\"\"\"Parameter Verification for room 8\"\"\"\n\t\timport teaser.examples.verification.verification_VDI_6007_room8 as room8\n\n\t\troom8_prj = room8.parameter_room8()\n\t\tzone_attr = room8_prj.buildings[0].thermal_zones[0].model_attr\n\n\t\tassert round(zone_attr.r1_iw, 13) == 0.0006688956391\n\t\tassert round(zone_attr.c1_iw / 1000, 7) == 12391.3638631\n\t\tassert round(zone_attr.area_iw, 1) == 60.5\n\t\tassert round(zone_attr.alpha_conv_inner_iw, 13) == 2.1214876033058\n\t\tr_rest = zone_attr.r_rest_ow + 1 / (\n\t\t\tzone_attr.alpha_comb_outer_ow * zone_attr.area_ow\n\t\t)\n\t\tassert round(r_rest, 13) == 0.0207059264866\n\t\tassert round(zone_attr.r1_ow, 13) == 0.0017362530106\n\t\tassert round(zone_attr.c1_ow / 1000, 7) == 5259.932231\n\t\tassert round(zone_attr.area_ow, 1) == 11.5\n\t\tassert round(zone_attr.area_win, 1) == 14.0\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 1) == 2.7\n\t\tassert round(zone_attr.alpha_comb_outer_ow, 1) == 25.0\n\t\tassert round(zone_attr.weightfactor_ow[1], 13) == 0.1324989973869\n\t\tassert round(zone_attr.weightfactor_win[0], 13) == 0.4047663456282\n\n\t# EBC Calculation Verification, with parameters from TEASER3\n\n\tdef test_calc_ebc(self):\n\t\t\"\"\"\n\t\tParameter Verification for ebc calculation method. Values are compared\n\t\twith TEASER3 values.\n\t\t\"\"\"\n\t\tprj.set_default()\n\t\tprj.load_project(\n\t\t\tutilities.get_full_path(\"examples/examplefiles/unitTestCalc.json\")\n\t\t)\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.buildings[0].calc_building_parameter()\n\t\tzone_attr = prj.buildings[0].thermal_zones[0].model_attr\n\n\t\tassert round(zone_attr.r1_iw, 11) == 4.62113e-06\n\t\tassert round(zone_attr.c1_iw, 2) == 1209810287.22\n\t\tassert round(zone_attr.area_iw, 5) == 9866.66667\n\t\tassert round(zone_attr.alpha_conv_inner_iw, 5) == 2.37568\n\n\t\tassert round(zone_attr.r_rest_ow, 5) == 0.00181\n\t\tassert round(zone_attr.r1_ow, 10) == 3.06155e-05\n\t\tassert round(zone_attr.c1_ow, 3) == 226923157.846\n\t\tassert round(zone_attr.area_ow, 5) == 920.0\n\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 5) == 1.83043\n\n\t\tassert round(zone_attr.alpha_conv_outer_ow, 5) == 20.0\n\t\tassert round(zone_attr.alpha_comb_outer_ow, 5) == 25.0\n\t\tassert round(zone_attr.alpha_conv_inner_win, 5) == 2.7\n\t\tassert round(zone_attr.alpha_conv_outer_win, 5) == 20.0\n\t\tassert round(zone_attr.alpha_comb_outer_win, 5) == 25.0\n\n\t\tassert round(zone_attr.weightfactor_ow[0], 5) == 0.04588\n\t\tassert round(zone_attr.weightfactor_win[0], 5) == 0.33333\n\t\tassert round(zone_attr.weightfactor_ground, 5) == 0.54398\n\n\tdef test_type_bldg_office_with_calc(self):\n\t\t\"\"\"\n\t\tVerification of the type building generation of an office building.\n\t\tValues are compared with TEASER3 values.\n\t\t\"\"\"\n\t\tfrom teaser.logic.archetypebuildings.bmvbs.office import Office\n\n\t\tprj.set_default()\n\t\ttest_office = Office(\n\t\t\tparent=prj,\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=3,\n\t\t\theight_of_floors=3,\n\t\t\tnet_leased_area=2500,\n\t\t)\n\n\t\ttest_office.generate_archetype()\n\n\t\t# general parameters\n\n\t\tassert len(test_office.thermal_zones) == 6\n\n\t\t# zone specific parameters\n\n\t\tfor zone in test_office.thermal_zones:\n\t\t\tif zone.name == \"Meeting\":\n\t\t\t\tassert zone.area == 100\n\t\t\tif zone.name == \"Storage\":\n\t\t\t\tassert zone.area == 375\n\t\t\tif zone.name == \"Office\":\n\t\t\t\tassert zone.area == 1250\n\t\t\tif zone.name == \"Restroom\":\n\t\t\t\tassert zone.area == 100\n\t\t\tif zone.name == \"ICT\":\n\t\t\t\tassert zone.area == 50\n\t\t\tif zone.name == \"Floor\":\n\t\t\t\tassert zone.area == 625\n\n\t\t# facade specific parameters\n\n\t\tassert round(test_office.get_outer_wall_area(-2), 0) == 958\n\t\tassert round(test_office.get_outer_wall_area(-1), 0) == 958\n\t\tassert round(test_office.get_outer_wall_area(0), 0) == 437\n\t\tassert round(test_office.get_outer_wall_area(180), 0) == 437\n\t\tassert round(test_office.get_outer_wall_area(90), 0) == 77\n\t\tassert round(test_office.get_outer_wall_area(270), 0) == 77\n\t\tassert round(test_office.get_window_area(0), 0) == 158\n\t\tassert round(test_office.get_window_area(180), 0) == 158\n\t\tassert round(test_office.get_window_area(90), 0) == 28\n\t\tassert round(test_office.get_window_area(270), 0) == 28\n\n\t\tprj.set_default()\n\t\ttest_office = Office(\n\t\t\tparent=prj,\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=3,\n\t\t\theight_of_floors=3,\n\t\t\tnet_leased_area=2500,\n\t\t\toffice_layout=1,\n\t\t\twindow_layout=1,\n\t\t\tconstruction_type=\"light\",\n\t\t)\n\n\t\ttest_office.generate_archetype()\n\n\t\t# facade specific parameters\n\n\t\tassert round(test_office.get_outer_wall_area(-2), 0) == 958\n\t\tassert round(test_office.get_outer_wall_area(-1), 0) == 958\n\t\tassert round(test_office.get_outer_wall_area(0), 0) == 446\n\t\tassert round(test_office.get_outer_wall_area(180), 0) == 446\n\t\tassert round(test_office.get_outer_wall_area(90), 0) == 79\n\t\tassert round(test_office.get_outer_wall_area(270), 0) == 79\n\t\tassert round(test_office.get_window_area(0), 0) == 149\n\t\tassert round(test_office.get_window_area(180), 0) == 149\n\t\tassert round(test_office.get_window_area(90), 0) == 26\n\t\tassert round(test_office.get_window_area(270), 0) == 26\n\n\t\tprj.set_default()\n\t\ttest_office = Office(\n\t\t\tparent=prj,\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=3,\n\t\t\theight_of_floors=3,\n\t\t\tnet_leased_area=2500,\n\t\t\toffice_layout=2,\n\t\t\twindow_layout=2,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\n\t\ttest_office.generate_archetype()\n\n\t\t# facade specific parameters\n\n\t\tassert round(test_office.get_outer_wall_area(-2), 0) == 958\n\t\tassert round(test_office.get_outer_wall_area(-1), 0) == 958\n\t\tassert round(test_office.get_outer_wall_area(0), 0) == 283\n\t\tassert round(test_office.get_outer_wall_area(180), 0) == 283\n\t\tassert round(test_office.get_outer_wall_area(90), 0) == 67\n\t\tassert round(test_office.get_outer_wall_area(270), 0) == 67\n\t\tassert round(test_office.get_window_area(0), 0) == 283\n\t\tassert round(test_office.get_window_area(180), 0) == 283\n\t\tassert round(test_office.get_window_area(90), 0) == 67\n\t\tassert round(test_office.get_window_area(270), 0) == 67\n\n\t\tprj.set_default()\n\t\ttest_office = Office(\n\t\t\tparent=prj,\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=3,\n\t\t\theight_of_floors=3,\n\t\t\tnet_leased_area=2500,\n\t\t\toffice_layout=3,\n\t\t\twindow_layout=3,\n\t\t\tconstruction_type=\"light\",\n\t\t)\n\n\t\ttest_office.generate_archetype()\n\n\t\t# facade specific parameters\n\n\t\tassert round(test_office.get_outer_wall_area(-2), 0) == 958\n\t\tassert round(test_office.get_outer_wall_area(-1), 0) == 958\n\t\tassert round(test_office.get_outer_wall_area(0), 0) == 35\n\t\tassert round(test_office.get_outer_wall_area(180), 0) == 35\n\t\tassert round(test_office.get_outer_wall_area(90), 0) == 35\n\t\tassert round(test_office.get_outer_wall_area(270), 0) == 35\n\t\tassert round(test_office.get_window_area(0), 0) == 315\n\t\tassert round(test_office.get_window_area(180), 0) == 315\n\t\tassert round(test_office.get_window_area(90), 0) == 315\n\t\tassert round(test_office.get_window_area(270), 0) == 315\n\n\tdef test_type_bldg_institute4_with_calc(self):\n\t\t\"\"\"\n\t\tVerification of the type building generation of an office building.\n\t\tValues are compared with TEASER3 values.\n\t\t\"\"\"\n\t\tfrom teaser.logic.archetypebuildings.bmvbs.custom.institute4 import Institute4\n\n\t\tprj.set_default()\n\t\ttest_institute4 = Institute4(\n\t\t\tparent=prj,\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=3,\n\t\t\theight_of_floors=3,\n\t\t\tnet_leased_area=2500,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\n\t\ttest_institute4.generate_archetype()\n\n\t\t# general parameters\n\n\t\tassert len(test_institute4.thermal_zones) == 7\n\n\t\t# zone specific parameters\n\n\t\tfor zone in test_institute4.thermal_zones:\n\t\t\tif zone.name == \"Meeting\":\n\t\t\t\tassert zone.area == 100\n\t\t\tif zone.name == \"Storage\":\n\t\t\t\tassert round(zone.area) == 700\n\t\t\tif zone.name == \"Office\":\n\t\t\t\tassert zone.area == 550\n\t\t\tif zone.name == \"Restroom\":\n\t\t\t\tassert zone.area == 100\n\t\t\tif zone.name == \"ICT\":\n\t\t\t\tassert zone.area == 50\n\t\t\tif zone.name == \"Floor\":\n\t\t\t\tassert zone.area == 500\n\t\t\tif zone.name == \"Laboratory\":\n\t\t\t\tassert zone.area == 500\n\n\t\t# facade specific parameters\n\n\t\tassert round(test_institute4.get_outer_wall_area(-2), 0) == 958\n\t\tassert round(test_institute4.get_outer_wall_area(-1), 0) == 958\n\t\tassert round(test_institute4.get_outer_wall_area(0), 0) == 742\n\t\tassert round(test_institute4.get_outer_wall_area(180), 0) == 742\n\t\tassert round(test_institute4.get_outer_wall_area(90), 0) == 131\n\t\tassert round(test_institute4.get_outer_wall_area(270), 0) == 131\n\t\tassert round(test_institute4.get_window_area(0), 0) == 158\n\t\tassert round(test_institute4.get_window_area(180), 0) == 158\n\t\tassert round(test_institute4.get_window_area(90), 0) == 28\n\t\tassert round(test_institute4.get_window_area(270), 0) == 28\n\n\tdef test_type_bldg_institute8_with_calc(self):\n\t\t\"\"\"\n\t\tVerification of the type building generation of an office building.\n\t\tValues are compared with TEASER3 values.\n\t\t\"\"\"\n\t\tfrom teaser.logic.archetypebuildings.bmvbs.custom.institute8 import Institute8\n\n\t\tprj.set_default()\n\t\ttest_institute8 = Institute8(\n\t\t\tparent=prj,\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=3,\n\t\t\theight_of_floors=3,\n\t\t\tnet_leased_area=2500,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\n\t\ttest_institute8.generate_archetype()\n\n\t\t# general parameters\n\n\t\tassert len(test_institute8.thermal_zones) == 7\n\n\t\t# zone specific parameters\n\n\t\tfor zone in test_institute8.thermal_zones:\n\t\t\tif zone.name == \"Meeting\":\n\t\t\t\tassert zone.area == 100\n\t\t\tif zone.name == \"Storage\":\n\t\t\t\tassert zone.area == 750\n\t\t\tif zone.name == \"Office\":\n\t\t\t\tassert zone.area == 100\n\t\t\tif zone.name == \"Restroom\":\n\t\t\t\tassert zone.area == 100\n\t\t\tif zone.name == \"ICT\":\n\t\t\t\tassert zone.area == 50\n\t\t\tif zone.name == \"Floor\":\n\t\t\t\tassert zone.area == 150\n\t\t\tif zone.name == \"Laboratory\":\n\t\t\t\tassert zone.area == 1250\n\n\t\t# facade specific parameters\n\n\t\tassert round(test_institute8.get_outer_wall_area(-2), 0) == 958\n\t\tassert round(test_institute8.get_outer_wall_area(-1), 0) == 958\n\t\tassert round(test_institute8.get_outer_wall_area(0), 0) == 742\n\t\tassert round(test_institute8.get_outer_wall_area(180), 0) == 742\n\t\tassert round(test_institute8.get_outer_wall_area(90), 0) == 131\n\t\tassert round(test_institute8.get_outer_wall_area(270), 0) == 131\n\t\tassert round(test_institute8.get_window_area(0), 0) == 158\n\t\tassert round(test_institute8.get_window_area(180), 0) == 158\n\t\tassert round(test_institute8.get_window_area(90), 0) == 28\n\t\tassert round(test_institute8.get_window_area(270), 0) == 28\n\n\tdef test_type_bldg_institute_with_calc(self):\n\t\t\"\"\"\n\t\tVerification of the type building generation of an office building.\n\t\tValues are compared with TEASER3 values.\n\t\t\"\"\"\n\t\tfrom teaser.logic.archetypebuildings.bmvbs.custom.institute import Institute\n\n\t\tprj.set_default()\n\t\ttest_institute = Institute(\n\t\t\tparent=prj,\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=3,\n\t\t\theight_of_floors=3,\n\t\t\tnet_leased_area=2500,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\n\t\ttest_institute.generate_archetype()\n\n\t\t# general parameters\n\n\t\tassert len(test_institute.thermal_zones) == 7\n\n\t\t# zone specific parameters\n\n\t\tfor zone in test_institute.thermal_zones:\n\t\t\tif zone.name == \"Meeting\":\n\t\t\t\tassert zone.area == 100\n\t\t\tif zone.name == \"Storage\":\n\t\t\t\tassert zone.area == 1000\n\t\t\tif zone.name == \"Office\":\n\t\t\t\tassert zone.area == 400\n\t\t\tif zone.name == \"Restroom\":\n\t\t\t\tassert zone.area == 100\n\t\t\tif zone.name == \"ICT\":\n\t\t\t\tassert zone.area == 50\n\t\t\tif zone.name == \"Floor\":\n\t\t\t\tassert zone.area == 475\n\t\t\tif zone.name == \"Laboratory\":\n\t\t\t\tassert zone.area == 375\n\n\t\t# facade specific parameters\n\n\t\tassert round(test_institute.get_outer_wall_area(-2), 0) == 958\n\t\tassert round(test_institute.get_outer_wall_area(-1), 0) == 958\n\t\tassert round(test_institute.get_outer_wall_area(0), 0) == 836\n\t\tassert round(test_institute.get_outer_wall_area(180), 0) == 836\n\t\tassert round(test_institute.get_outer_wall_area(90), 0) == 147\n\t\tassert round(test_institute.get_outer_wall_area(270), 0) == 147\n\t\tassert round(test_institute.get_window_area(0), 0) == 158\n\t\tassert round(test_institute.get_window_area(180), 0) == 158\n\t\tassert round(test_institute.get_window_area(90), 0) == 28\n\t\tassert round(test_institute.get_window_area(270), 0) == 28\n\n\tdef test_type_bldg_residential_with_calc(self):\n\t\t\"\"\"\n\t\tVerification of the type building generation of an office building.\n\t\tValues are compared with TEASER3 values.\n\t\t\"\"\"\n\t\tfrom teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling import (\n\t\t\tSingleFamilyDwelling,\n\t\t)\n\n\t\tprj.set_default()\n\t\ttest_residential = SingleFamilyDwelling(\n\t\t\tparent=prj,\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=3,\n\t\t\theight_of_floors=3,\n\t\t\tnet_leased_area=2500,\n\t\t)\n\n\t\ttest_residential.generate_archetype()\n\n\t\t# general parameters\n\n\t\tassert len(test_residential.thermal_zones) == 1\n\n\t\t# zone specific parameters\n\n\t\tfor zone in test_residential.thermal_zones:\n\t\t\tif zone.name == \"SingleDwelling\":\n\t\t\t\tassert zone.area == 2500\n\n\t\t# facade specific parameters\n\n\t\tassert round(test_residential.get_outer_wall_area(-2), 0) == 1108\n\t\tassert round(test_residential.get_outer_wall_area(-1), 0) == 1108\n\t\tassert round(test_residential.get_outer_wall_area(0), 0) == 312\n\t\tassert round(test_residential.get_outer_wall_area(180), 0) == 312\n\t\tassert round(test_residential.get_outer_wall_area(90), 0) == 312\n\t\tassert round(test_residential.get_outer_wall_area(270), 0) == 312\n\t\tassert round(test_residential.get_window_area(0), 0) == 125\n\t\tassert round(test_residential.get_window_area(180), 0) == 125\n\t\tassert round(test_residential.get_window_area(90), 0) == 125\n\t\tassert round(test_residential.get_window_area(270), 0) == 125\n\n\t\tprj.set_default()\n\t\ttest_residential = SingleFamilyDwelling(\n\t\t\tparent=prj,\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=3,\n\t\t\theight_of_floors=3,\n\t\t\tnet_leased_area=2500,\n\t\t\tresidential_layout=1,\n\t\t\tneighbour_buildings=1,\n\t\t\tattic=1,\n\t\t\tdormer=1,\n\t\t\tcellar=1,\n\t\t\tconstruction_type=\"light\",\n\t\t)\n\n\t\ttest_residential.generate_archetype()\n\n\t\t# facade specific parameters\n\n\t\tassert round(test_residential.get_outer_wall_area(-2), 0) == 1108\n\t\tassert round(test_residential.get_outer_wall_area(-1), 0) == 1108\n\t\tassert round(test_residential.get_outer_wall_area(0), 0) == 393\n\t\tassert round(test_residential.get_outer_wall_area(180), 0) == 393\n\t\tassert round(test_residential.get_outer_wall_area(90), 0) == 393\n\t\tassert round(test_residential.get_outer_wall_area(270), 0) == 393\n\t\tassert round(test_residential.get_window_area(0), 0) == 125\n\t\tassert round(test_residential.get_window_area(180), 0) == 125\n\t\tassert round(test_residential.get_window_area(90), 0) == 125\n\t\tassert round(test_residential.get_window_area(270), 0) == 125\n\n\t\tprj.set_default()\n\t\ttest_residential = SingleFamilyDwelling(\n\t\t\tparent=prj,\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=3,\n\t\t\theight_of_floors=3,\n\t\t\tnet_leased_area=2500,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=2,\n\t\t\tattic=2,\n\t\t\tdormer=0,\n\t\t\tcellar=2,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\n\t\ttest_residential.generate_archetype()\n\n\t\t# facade specific parameters\n\n\t\tassert round(test_residential.get_outer_wall_area(-2), 0) == 858\n\t\tassert round(test_residential.get_outer_wall_area(-1), 0) == 484\n\t\tassert round(test_residential.get_outer_wall_area(0), 0) == 267\n\t\tassert round(test_residential.get_outer_wall_area(180), 0) == 267\n\t\tassert round(test_residential.get_outer_wall_area(90), 0) == 267\n\t\tassert round(test_residential.get_outer_wall_area(270), 0) == 267\n\t\tassert round(test_residential.get_window_area(0), 0) == 125\n\t\tassert round(test_residential.get_window_area(180), 0) == 125\n\t\tassert round(test_residential.get_window_area(90), 0) == 125\n\t\tassert round(test_residential.get_window_area(270), 0) == 125\n\n\t\tprj.set_default()\n\t\ttest_residential = SingleFamilyDwelling(\n\t\t\tparent=prj,\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=3,\n\t\t\theight_of_floors=3,\n\t\t\tnet_leased_area=2500,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=2,\n\t\t\tattic=3,\n\t\t\tdormer=0,\n\t\t\tcellar=3,\n\t\t\tconstruction_type=\"light\",\n\t\t)\n\n\t\ttest_residential.generate_archetype()\n\n\t\t# facade specific parameters\n\n\t\tassert round(test_residential.get_outer_wall_area(-2), 0) == 700\n\t\tassert round(test_residential.get_outer_wall_area(-1), 0) == 789\n\t\tassert round(test_residential.get_outer_wall_area(0), 0) == 251\n\t\tassert round(test_residential.get_outer_wall_area(180), 0) == 251\n\t\tassert round(test_residential.get_outer_wall_area(90), 0) == 251\n\t\tassert round(test_residential.get_outer_wall_area(270), 0) == 251\n\t\tassert round(test_residential.get_window_area(0), 0) == 125\n\t\tassert round(test_residential.get_window_area(180), 0) == 125\n\t\tassert round(test_residential.get_window_area(90), 0) == 125\n\t\tassert round(test_residential.get_window_area(270), 0) == 125\n\n\t# # methods in Project, these tests only test if the API function works,\n\t# # not if it produces reliable results.\n\n\tdef test_load_save_project(self):\n\t\t\"\"\"test of load_project and save_project\"\"\"\n\n\t\tprj.load_project(\n\t\t\tutilities.get_full_path((\"examples/examplefiles\" \"/unitTest.json\"))\n\t\t)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[0]\n\t\tassert round(therm_zone.outer_walls[0].area, 2) == 137.23\n\t\ttz_area = sum([tz.area for tz in prj.buildings[-1].thermal_zones])\n\t\tassert prj.buildings[-1].net_leased_area == tz_area\n\t\tprj.save_project(file_name=\"unitTest\", path=None)\n\t\tprj.save_project(file_name=None, path=utilities.get_default_path())\n\t\tprj.set_default()\n\n\tdef test_load_save_project_new(self):\n\t\t\"\"\"test of load_project and save_project\"\"\"\n\t\tprj.set_default(load_data=True)\n\t\tprj.load_project(os.path.join(utilities.get_default_path(), \"unitTest.json\"))\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[0]\n\t\tassert therm_zone.area == 994.0\n\t\ttz_area = sum([tz.area for tz in prj.buildings[-1].thermal_zones])\n\t\tfor tz in prj.buildings[-1].thermal_zones:\n\t\t\tprint(tz.name, tz.area)\n\t\tprint(prj.buildings[-1].name, prj.buildings[-1].net_leased_area)\n\t\tassert prj.buildings[-1].net_leased_area == tz_area\n\t\tassert prj.buildings[-1].net_leased_area == 1988.0\n\t\tassert prj.buildings[-1].name == \"TestBuilding\"\n\t\tprj.name = \"Project\"\n\t\tprj.save_project(file_name=\"unitTest_new.json\", path=None)\n\n\tdef test_calc_all_buildings(self):\n\t\t\"\"\"test of calc_all_buildings, no calculation verification\"\"\"\n\n\t\thelptest.building_test2(prj)\n\t\thelptest.building_test2(prj)\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings(raise_errors=True)\n\n\tdef test_retrofit_all_buildings(self):\n\t\t\"\"\"test of retrofit_all_buildings, no calculation verification\"\"\"\n\t\tprj.add_residential(\n\t\t\tmethod=\"iwu\",\n\t\t\tusage=\"single_family_dwelling\",\n\t\t\tname=\"ResidentialBuilding\",\n\t\t\tyear_of_construction=1858,\n\t\t\tnumber_of_floors=2,\n\t\t\theight_of_floors=3.2,\n\t\t\tnet_leased_area=219,\n\t\t)\n\t\tprj.add_residential(\n\t\t\tmethod=\"tabula_de\",\n\t\t\tusage=\"single_family_house\",\n\t\t\tname=\"ResidentialBuilding\",\n\t\t\tyear_of_construction=1858,\n\t\t\tnumber_of_floors=2,\n\t\t\theight_of_floors=3.2,\n\t\t\tnet_leased_area=219,\n\t\t)\n\t\tprj.retrofit_all_buildings(year_of_retrofit=2015, type_of_retrofit=\"retrofit\")\n\n\tdef test_export_aixlib(self):\n\t\t\"\"\"test of export_aixlib, no calculation verification\"\"\"\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib(building_model=\"Test\", zone_model=\"Test\", corG=\"Test\")\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.buildings.append(prj.buildings[-1])\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib(path=utilities.get_default_path())\n\n\tdef test_export_ibpsa(self):\n\t\t\"\"\"test of export_ibpsa, no calculation verification\"\"\"\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa(library=\"AixLib\")\n\t\tprj.export_ibpsa(library=\"Buildings\")\n\t\tprj.export_ibpsa(library=\"BuildingSystems\")\n\t\tprj.export_ibpsa(library=\"IDEAS\")\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa(library=\"AixLib\")\n\t\tprj.export_ibpsa(library=\"Buildings\")\n\t\tprj.export_ibpsa(library=\"BuildingSystems\")\n\t\tprj.export_ibpsa(library=\"IDEAS\")\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa(library=\"AixLib\")\n\t\tprj.export_ibpsa(library=\"Buildings\")\n\t\tprj.export_ibpsa(library=\"BuildingSystems\")\n\t\tprj.export_ibpsa(library=\"IDEAS\")\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa(library=\"AixLib\")\n\t\tprj.export_ibpsa(library=\"Buildings\")\n\t\tprj.export_ibpsa(library=\"BuildingSystems\")\n\t\tprj.export_ibpsa(library=\"IDEAS\")\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa(library=\"AixLib\")\n\t\tprj.export_ibpsa(library=\"Buildings\")\n\t\tprj.export_ibpsa(library=\"BuildingSystems\")\n\t\tprj.export_ibpsa(library=\"IDEAS\")\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa(library=\"AixLib\")\n\t\tprj.export_ibpsa(library=\"Buildings\")\n\t\tprj.export_ibpsa(library=\"BuildingSystems\")\n\t\tprj.export_ibpsa(library=\"IDEAS\")\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa(library=\"AixLib\")\n\t\tprj.export_ibpsa(library=\"Buildings\")\n\t\tprj.export_ibpsa(library=\"BuildingSystems\")\n\t\tprj.export_ibpsa(library=\"IDEAS\")\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa(library=\"AixLib\")\n\t\tprj.export_ibpsa(library=\"Buildings\")\n\t\tprj.export_ibpsa(library=\"BuildingSystems\")\n\t\tprj.export_ibpsa(library=\"IDEAS\")\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa(internal_id=prj.buildings[-1].internal_id)\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa(path=utilities.get_default_path())\n\t\tprj.set_default()\n\n\tdef test_instantiate_data_class(self):\n\t\t\"\"\"test of instantiate_data_class\"\"\"\n\n\t\tprj.instantiate_data_class()\n\n\tdef test_type_bldg_office(self):\n\t\t\"\"\"test of type_bldg_office, no calculation verification\n\t\t\"\"\"\n\t\tprj.set_default(load_data=True)\n\n\t\tprj.add_non_residential(\n\t\t\tmethod=\"bmvbs\",\n\t\t\tusage=\"office\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\t\tprj.add_non_residential(\n\t\t\tmethod=\"bmvbs\",\n\t\t\tusage=\"office\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tinternal_gains_mode=2,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\t\tprj.add_non_residential(\n\t\t\tmethod=\"bmvbs\",\n\t\t\tusage=\"office\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tinternal_gains_mode=3,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\n\tdef test_type_bldg_institute(self):\n\t\t\"\"\"test of type_bldg_institute, no calculation verification\"\"\"\n\n\t\tprj.add_non_residential(\n\t\t\tmethod=\"bmvbs\",\n\t\t\tusage=\"institute\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=True,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\t\tprj.add_non_residential(\n\t\t\tmethod=\"bmvbs\",\n\t\t\tusage=\"institute\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tinternal_gains_mode=2,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\t\tprj.add_non_residential(\n\t\t\tmethod=\"bmvbs\",\n\t\t\tusage=\"institute\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tinternal_gains_mode=3,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\n\tdef test_type_bldg_institute4(self):\n\t\t\"\"\"test of type_bldg_institute4, no calculation verification\"\"\"\n\n\t\tprj.add_non_residential(\n\t\t\tmethod=\"bmvbs\",\n\t\t\tusage=\"institute4\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=True,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\n\tdef test_type_bldg_institute8(self):\n\t\t\"\"\"test of type_bldg_institute8, no calculation verification\"\"\"\n\n\t\tprj.add_non_residential(\n\t\t\tmethod=\"bmvbs\",\n\t\t\tusage=\"institute8\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=True,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\n\tdef test_type_bldg_residential(self):\n\t\t\"\"\"test of type_bldg_residential, no calculation verification\"\"\"\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"iwu\",\n\t\t\tusage=\"single_family_dwelling\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\n\tdef test_est_bldgs(self):\n\t\t\"\"\"test of type_bldg_est, no calculation verification\"\"\"\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"urbanrenet\",\n\t\t\tusage=\"est1a\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"urbanrenet\",\n\t\t\tusage=\"est1b\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"urbanrenet\",\n\t\t\tusage=\"est2\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"urbanrenet\",\n\t\t\tusage=\"est3\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"urbanrenet\",\n\t\t\tusage=\"est4a\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"urbanrenet\",\n\t\t\tusage=\"est4b\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"urbanrenet\",\n\t\t\tusage=\"est5\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"urbanrenet\",\n\t\t\tusage=\"est6\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"urbanrenet\",\n\t\t\tusage=\"est7\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"urbanrenet\",\n\t\t\tusage=\"est8a\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\n\t\tprj.add_residential(\n\t\t\tmethod=\"urbanrenet\",\n\t\t\tusage=\"est8b\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=False,\n\t\t\tresidential_layout=0,\n\t\t\tneighbour_buildings=0,\n\t\t\tattic=0,\n\t\t\tcellar=0,\n\t\t\tdormer=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\n\t# methods in Building\n\n\tdef test_get_inner_wall_area(self):\n\t\t\"\"\"test of get_inner_wall_area\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\tsum_area = prj.buildings[-1].get_inner_wall_area()\n\t\tassert round(sum_area, 1) == 34.0\n\n\tdef test_set_outer_wall_area(self):\n\t\t\"\"\"test of set_outer_wall_area\"\"\"\n\t\tprint(prj.buildings[-1].thermal_zones[-1].outer_walls[1].area)\n\t\tprj.buildings[-1].set_outer_wall_area(2.0, 0.0)\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\tprint(therm_zone.outer_walls[1].area)\n\t\tassert round(therm_zone.outer_walls[0].area, 3) == 2.0\n\t\tassert round(therm_zone.outer_walls[1].area, 3) == 14.0\n\n\tdef test_get_outer_wall_area(self):\n\t\t\"\"\"test of get_outer_wall_area\"\"\"\n\t\tprj.buildings[-1].get_outer_wall_area(0.0)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\tassert round(therm_zone.outer_walls[0].area, 3) == 2.0\n\t\tassert round(therm_zone.outer_walls[1].area, 3) == 14.0\n\n\tdef test_set_window_area(self):\n\t\t\"\"\"test of set_window_area\"\"\"\n\t\tprj.buildings[-1].set_window_area(1.0, 90.0)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\tassert round(therm_zone.windows[0].area, 3) == 1.0\n\n\tdef test_get_window_area(self):\n\t\t\"\"\"test of get_window_area\"\"\"\n\t\tprj.buildings[-1].get_window_area(90.0)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\tassert round(therm_zone.windows[0].area, 3) == 1.0\n\n\tdef test_fill_outer_wall_area_dict(self):\n\t\t\"\"\"test of fill_outer_wall_area_dict\"\"\"\n\n\t\tprj.buildings[-1].fill_outer_area_dict()\n\t\toutwall_dict_round = {\n\t\t\tkey: round(value, 2) for key, value in prj.buildings[-1].outer_area.items()\n\t\t}\n\t\tassert outwall_dict_round == {\n\t\t\t-2.0: 140,\n\t\t\t-1.0: 140,\n\t\t\t0.0: 2.0,\n\t\t\t90.0: 14.0,\n\t\t\t180.0: 10.0,\n\t\t\t270.0: 14.0,\n\t\t}\n\n\tdef test_fill_window_area_dict(self):\n\t\t\"\"\"test of fill_window_area_dict\"\"\"\n\t\tprj.buildings[-1].fill_window_area_dict()\n\t\tassert prj.buildings[-1].window_area == {90.0: 1.0, 180.0: 8.0, 270.0: 5.0}\n\n\tdef test_calc_building_parameter(self):\n\t\t\"\"\"test of calc_building_parameter\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\n\t\tprj.buildings[-1].calc_building_parameter(\n\t\t\tnumber_of_elements=2, merge_windows=True, used_library=\"AixLib\"\n\t\t)\n\n\t\tassert round(prj.buildings[-1].volume, 1) == 490.0\n\t\tassert round(prj.buildings[-1].sum_heat_load, 4) == 5023.0256\n\n\t# methods in therm_zone\n\n\tdef test_calc_zone_parameters(self):\n\t\t\"\"\"test of calc zone parameter, no calculation verification\"\"\"\n\n\t\tprj.buildings[-1].thermal_zones[-1].calc_zone_parameters(\n\t\t\tnumber_of_elements=2, merge_windows=False\n\t\t)\n\t\tprj.buildings[-1].thermal_zones[-1].calc_zone_parameters(\n\t\t\tnumber_of_elements=2, merge_windows=True\n\t\t)\n\n\tdef test_heat_load(self):\n\t\t\"\"\"test of heating_load\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\tprj.buildings[-1].thermal_zones[-1].use_conditions.infiltration_rate = 0.5\n\t\tprj.buildings[-1].thermal_zones[-1].calc_zone_parameters(\n\t\t\tnumber_of_elements=2, merge_windows=True\n\t\t)\n\t\tprj.buildings[-1].thermal_zones[-1].model_attr.calc_attributes()\n\t\tassert (\n\t\t\tround(prj.buildings[-1].thermal_zones[-1].model_attr.heat_load, 4)\n\t\t\t== 6659.6256\n\t\t)\n\n\tdef test_sum_building_elements_one(self):\n\t\t\"\"\"test of combine_building_elements\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\n\t\tfrom teaser.logic.buildingobjects.calculation.one_element import OneElement\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\n\t\tcalc_attr = OneElement(therm_zone, merge_windows=False, t_bt=5)\n\n\t\thelplist = (\n\t\t\ttherm_zone.outer_walls\n\t\t\t+ therm_zone.rooftops\n\t\t\t+ therm_zone.ground_floors\n\t\t\t+ therm_zone.inner_walls\n\t\t\t+ therm_zone.ceilings\n\t\t\t+ therm_zone.floors\n\t\t\t+ therm_zone.windows\n\t\t)\n\n\t\tfor element in helplist:\n\t\t\telement.calc_equivalent_res()\n\t\t\telement.calc_ua_value()\n\n\t\tcalc_attr._sum_outer_wall_elements()\n\t\tcalc_attr._sum_window_elements()\n\n\t\t# outerwall\n\t\tassert round(calc_attr.ua_value_ow, 16) == 135.5818558809656\n\t\tassert round(calc_attr.area_ow, 1) == 328.0\n\t\tassert round(calc_attr.r_conv_inner_ow, 19) == 0.0016512549537648611\n\t\tassert round(calc_attr.r_rad_inner_ow, 18) == 0.000609756097560976\n\t\tassert round(calc_attr.r_comb_inner_ow, 20) == 0.00044531528322052017\n\t\tassert round(calc_attr.r_conv_outer_ow, 20) == 0.00026595744680851064\n\t\tassert round(calc_attr.r_rad_outer_ow, 18) == 0.001063829787234043\n\t\tassert round(calc_attr.r_comb_outer_ow, 20) == 0.0002127659574468085\n\t\tassert round(calc_attr.alpha_conv_inner_ow, 5) == 1.84634\n\t\tassert round(calc_attr.alpha_rad_inner_ow, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_inner_ow, 5) == 6.84634\n\t\tassert round(calc_attr.alpha_conv_outer_ow, 1) == 20.0\n\t\tassert round(calc_attr.alpha_rad_outer_ow, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_outer_ow, 1) == 25.0\n\n\t\t# window\n\t\tassert round(calc_attr.ua_value_win, 16) == 32.87895310796074\n\t\tassert round(calc_attr.area_win, 1) == 18.0\n\t\tassert round(calc_attr.r_conv_inner_win, 19) == 0.032679738562091505\n\t\tassert round(calc_attr.r_rad_inner_win, 4) == 0.0111\n\t\tassert round(calc_attr.r_comb_inner_win, 19) == 0.008291873963515755\n\t\tassert round(calc_attr.r_conv_outer_win, 5) == 0.00278\n\t\tassert round(calc_attr.r_rad_outer_win, 4) == 0.0111\n\t\tassert round(calc_attr.r_comb_outer_win, 4) == 0.0022\n\t\tassert round(calc_attr.alpha_conv_inner_win, 1) == 1.7\n\t\tassert round(calc_attr.alpha_comb_outer_win, 1) == 25.0\n\t\tassert round(calc_attr.alpha_conv_outer_win, 1) == 20.0\n\t\tassert round(calc_attr.weighted_g_value, 3) == 0.789\n\n\tdef test_calc_chain_matrix_one(self):\n\t\t\"\"\"test of calc_chain_matrix\"\"\"\n\n\t\tfrom teaser.logic.buildingobjects.calculation.one_element import OneElement\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\n\t\tcalc_attr = OneElement(therm_zone, merge_windows=False, t_bt=5)\n\n\t\thelplist = (\n\t\t\ttherm_zone.outer_walls\n\t\t\t+ therm_zone.rooftops\n\t\t\t+ therm_zone.ground_floors\n\t\t\t+ therm_zone.inner_walls\n\t\t\t+ therm_zone.ceilings\n\t\t\t+ therm_zone.floors\n\t\t\t+ therm_zone.windows\n\t\t)\n\n\t\tfor element in helplist:\n\t\t\telement.calc_equivalent_res()\n\t\t\telement.calc_ua_value()\n\n\t\tomega = 2 * math.pi / 86400 / 5\n\n\t\thelplist_outer_walls = (\n\t\t\ttherm_zone.outer_walls\n\t\t\t+ therm_zone.rooftops\n\t\t\t+ therm_zone.ground_floors\n\t\t\t+ therm_zone.windows\n\t\t)\n\n\t\tr1_ow, c1_ow = calc_attr._calc_parallel_connection(\n\t\t\telement_list=helplist_outer_walls, omega=omega\n\t\t)\n\t\tassert round(r1_ow, 14) == 0.00100751548411\n\t\tassert round(c1_ow, 5) == 3648580.59312\n\n\tdef test_sum_building_elements_two(self):\n\t\t\"\"\"test of combine_building_elements\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\n\t\tfrom teaser.logic.buildingobjects.calculation.two_element import TwoElement\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\n\t\tcalc_attr = TwoElement(therm_zone, merge_windows=False, t_bt=5)\n\n\t\thelplist = (\n\t\t\ttherm_zone.outer_walls\n\t\t\t+ therm_zone.rooftops\n\t\t\t+ therm_zone.ground_floors\n\t\t\t+ therm_zone.inner_walls\n\t\t\t+ therm_zone.ceilings\n\t\t\t+ therm_zone.floors\n\t\t\t+ therm_zone.windows\n\t\t)\n\n\t\tfor element in helplist:\n\t\t\telement.calc_equivalent_res()\n\t\t\telement.calc_ua_value()\n\n\t\tcalc_attr._sum_outer_wall_elements()\n\t\tcalc_attr._sum_inner_wall_elements()\n\t\tcalc_attr._sum_window_elements()\n\n\t\t# innerwall\n\n\t\tassert round(calc_attr.ua_value_iw, 16) == 14.286493860845841\n\t\tassert round(calc_attr.area_iw, 1) == 34.0\n\t\tassert round(calc_attr.r_conv_inner_iw, 18) == 0.010893246187363833\n\t\tassert round(calc_attr.r_rad_inner_iw, 19) == 0.0058823529411764705\n\t\tassert round(calc_attr.r_comb_inner_iw, 19) == 0.003819709702062643\n\t\tassert round(calc_attr.alpha_conv_inner_iw, 1) == 2.7\n\t\tassert round(calc_attr.alpha_rad_inner_iw, 1) == 5.0\n\t\tassert round(calc_attr.alpha_comb_inner_iw, 1) == 7.7\n\n\t\t# outerwall\n\t\tassert round(calc_attr.ua_value_ow, 16) == 135.5818558809656\n\t\tassert round(calc_attr.area_ow, 1) == 328.0\n\t\tassert round(calc_attr.r_conv_inner_ow, 19) == 0.0016512549537648611\n\t\tassert round(calc_attr.r_rad_inner_ow, 18) == 0.000609756097560976\n\t\tassert round(calc_attr.r_comb_inner_ow, 20) == 0.00044531528322052017\n\t\tassert round(calc_attr.r_conv_outer_ow, 20) == 0.00026595744680851064\n\t\tassert round(calc_attr.r_rad_outer_ow, 18) == 0.001063829787234043\n\t\tassert round(calc_attr.r_comb_outer_ow, 20) == 0.0002127659574468085\n\t\tassert round(calc_attr.alpha_conv_inner_ow, 5) == 1.84634\n\t\tassert round(calc_attr.alpha_rad_inner_ow, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_inner_ow, 5) == 6.84634\n\t\tassert round(calc_attr.alpha_conv_outer_ow, 1) == 20.0\n\t\tassert round(calc_attr.alpha_rad_outer_ow, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_outer_ow, 1) == 25.0\n\n\t\t# window\n\t\tassert round(calc_attr.ua_value_win, 16) == 32.87895310796074\n\t\tassert round(calc_attr.area_win, 1) == 18.0\n\t\tassert round(calc_attr.r_conv_inner_win, 19) == 0.032679738562091505\n\t\tassert round(calc_attr.r_rad_inner_win, 4) == 0.0111\n\t\tassert round(calc_attr.r_comb_inner_win, 19) == 0.008291873963515755\n\t\tassert round(calc_attr.r_conv_outer_win, 5) == 0.00278\n\t\tassert round(calc_attr.r_rad_outer_win, 4) == 0.0111\n\t\tassert round(calc_attr.r_comb_outer_win, 4) == 0.0022\n\t\tassert round(calc_attr.alpha_conv_inner_win, 1) == 1.7\n\t\tassert round(calc_attr.alpha_comb_outer_win, 1) == 25.0\n\t\tassert round(calc_attr.alpha_conv_outer_win, 1) == 20.0\n\t\tassert round(calc_attr.weighted_g_value, 3) == 0.789\n\n\tdef test_calc_chain_matrix_two(self):\n\t\t\"\"\"test of calc_chain_matrix\"\"\"\n\t\tfrom teaser.logic.buildingobjects.calculation.two_element import TwoElement\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\n\t\tcalc_attr = TwoElement(therm_zone, merge_windows=False, t_bt=5)\n\n\t\thelplist = (\n\t\t\ttherm_zone.outer_walls\n\t\t\t+ therm_zone.rooftops\n\t\t\t+ therm_zone.ground_floors\n\t\t\t+ therm_zone.inner_walls\n\t\t\t+ therm_zone.ceilings\n\t\t\t+ therm_zone.floors\n\t\t\t+ therm_zone.windows\n\t\t)\n\n\t\tfor element in helplist:\n\t\t\telement.calc_equivalent_res()\n\t\t\telement.calc_ua_value()\n\n\t\tomega = 2 * math.pi / 86400 / 5\n\n\t\tcalc_attr = TwoElement(therm_zone, merge_windows=True, t_bt=5)\n\n\t\thelplist_outer_walls = (\n\t\t\ttherm_zone.outer_walls\n\t\t\t+ therm_zone.rooftops\n\t\t\t+ therm_zone.ground_floors\n\t\t\t+ therm_zone.windows\n\t\t)\n\n\t\tr1_ow, c1_ow = calc_attr._calc_parallel_connection(\n\t\t\telement_list=helplist_outer_walls, omega=omega\n\t\t)\n\t\tassert round(r1_ow, 14) == 0.00100751548411\n\t\tassert round(c1_ow, 5) == 3648580.59312\n\n\t\thelplist_inner_walls = (\n\t\t\ttherm_zone.inner_walls + therm_zone.ceilings + therm_zone.floors\n\t\t)\n\n\t\tr1_iw, c1_iw = calc_attr._calc_parallel_connection(\n\t\t\telement_list=helplist_inner_walls, omega=omega\n\t\t)\n\t\tassert round(r1_iw, 13) == 0.0097195611408\n\t\tassert round(c1_iw, 6) == 319983.518743\n\n\tdef test_sum_building_elements_three(self):\n\t\t\"\"\"test of combine_building_elements\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\n\t\tfrom teaser.logic.buildingobjects.calculation.three_element import ThreeElement\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\n\t\tcalc_attr = ThreeElement(therm_zone, merge_windows=False, t_bt=5)\n\n\t\thelplist = (\n\t\t\ttherm_zone.outer_walls\n\t\t\t+ therm_zone.rooftops\n\t\t\t+ therm_zone.ground_floors\n\t\t\t+ therm_zone.inner_walls\n\t\t\t+ therm_zone.ceilings\n\t\t\t+ therm_zone.floors\n\t\t\t+ therm_zone.windows\n\t\t)\n\n\t\tfor element in helplist:\n\t\t\telement.calc_equivalent_res()\n\t\t\telement.calc_ua_value()\n\n\t\tcalc_attr._sum_outer_wall_elements()\n\t\tcalc_attr._sum_ground_floor_elements()\n\t\tcalc_attr._sum_inner_wall_elements()\n\t\tcalc_attr._sum_window_elements()\n\n\t\t# innerwall\n\n\t\tassert round(calc_attr.ua_value_iw, 16) == 14.286493860845841\n\t\tassert round(calc_attr.area_iw, 1) == 34.0\n\t\tassert round(calc_attr.r_conv_inner_iw, 18) == 0.010893246187363833\n\t\tassert round(calc_attr.r_rad_inner_iw, 19) == 0.0058823529411764705\n\t\tassert round(calc_attr.r_comb_inner_iw, 19) == 0.003819709702062643\n\t\tassert round(calc_attr.alpha_conv_inner_iw, 1) == 2.7\n\t\tassert round(calc_attr.alpha_rad_inner_iw, 1) == 5.0\n\t\tassert round(calc_attr.alpha_comb_inner_iw, 1) == 7.7\n\n\t\t# outerwall\n\t\tassert round(calc_attr.ua_value_ow, 16) == 77.23037843150993\n\t\tassert round(calc_attr.area_ow, 1) == 188.0\n\t\tassert round(calc_attr.r_conv_inner_ow, 19) == 0.0027203482045701846\n\t\tassert round(calc_attr.r_rad_inner_ow, 18) == 0.001063829787234043\n\t\tassert round(calc_attr.r_comb_inner_ow, 20) == 0.0007647598654022638\n\t\tassert round(calc_attr.r_conv_outer_ow, 20) == 0.00026595744680851064\n\t\tassert round(calc_attr.r_rad_outer_ow, 18) == 0.001063829787234043\n\t\tassert round(calc_attr.r_comb_outer_ow, 20) == 0.0002127659574468085\n\t\tassert round(calc_attr.alpha_conv_inner_ow, 5) == 1.95532\n\t\tassert round(calc_attr.alpha_rad_inner_ow, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_inner_ow, 5) == 6.95532\n\t\tassert round(calc_attr.alpha_conv_outer_ow, 1) == 20.0\n\t\tassert round(calc_attr.alpha_rad_outer_ow, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_outer_ow, 1) == 25.0\n\n\t\t# groundfloor\n\t\tassert round(calc_attr.ua_value_gf, 16) == 58.351477449455686\n\t\tassert round(calc_attr.area_gf, 1) == 140.0\n\t\tassert round(calc_attr.r_conv_inner_gf, 19) == 0.004201680672268907\n\t\tassert round(calc_attr.r_rad_inner_gf, 18) == 0.001428571428571429\n\t\tassert round(calc_attr.r_comb_inner_gf, 20) == 0.0010660980810234541\n\t\tassert round(calc_attr.alpha_conv_inner_gf, 5) == 1.7\n\t\tassert round(calc_attr.alpha_rad_inner_gf, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_inner_gf, 5) == 6.7\n\n\t\t# window\n\t\tassert round(calc_attr.ua_value_win, 16) == 32.87895310796074\n\t\tassert round(calc_attr.area_win, 1) == 18.0\n\t\tassert round(calc_attr.r_conv_inner_win, 19) == 0.032679738562091505\n\t\tassert round(calc_attr.r_rad_inner_win, 4) == 0.0111\n\t\tassert round(calc_attr.r_comb_inner_win, 19) == 0.008291873963515755\n\t\tassert round(calc_attr.r_conv_outer_win, 5) == 0.00278\n\t\tassert round(calc_attr.r_rad_outer_win, 4) == 0.0111\n\t\tassert round(calc_attr.r_comb_outer_win, 4) == 0.0022\n\t\tassert round(calc_attr.alpha_conv_inner_win, 1) == 1.7\n\t\tassert round(calc_attr.alpha_comb_outer_win, 1) == 25.0\n\t\tassert round(calc_attr.alpha_conv_outer_win, 1) == 20.0\n\t\tassert round(calc_attr.weighted_g_value, 3) == 0.789\n\n\tdef test_calc_chain_matrix_three(self):\n\t\t\"\"\"test of calc_chain_matrix\"\"\"\n\t\tfrom teaser.logic.buildingobjects.calculation.three_element import ThreeElement\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\n\t\tcalc_attr = ThreeElement(therm_zone, merge_windows=False, t_bt=5)\n\n\t\thelplist = (\n\t\t\ttherm_zone.outer_walls\n\t\t\t+ therm_zone.rooftops\n\t\t\t+ therm_zone.ground_floors\n\t\t\t+ therm_zone.inner_walls\n\t\t\t+ therm_zone.ceilings\n\t\t\t+ therm_zone.floors\n\t\t\t+ therm_zone.windows\n\t\t)\n\n\t\tfor element in helplist:\n\t\t\telement.calc_equivalent_res()\n\t\t\telement.calc_ua_value()\n\n\t\tomega = 2 * math.pi / 86400 / 5\n\n\t\thelplist_outer_walls = (\n\t\t\ttherm_zone.outer_walls + therm_zone.rooftops + therm_zone.windows\n\t\t)\n\n\t\tr1_ow, c1_ow = calc_attr._calc_parallel_connection(\n\t\t\telement_list=helplist_outer_walls, omega=omega\n\t\t)\n\t\tassert round(r1_ow, 14) == 0.00175779297228\n\t\tassert round(c1_ow, 5) == 2091259.60825\n\n\t\thelplist_inner_walls = (\n\t\t\ttherm_zone.inner_walls + therm_zone.ceilings + therm_zone.floors\n\t\t)\n\n\t\tr1_iw, c1_iw = calc_attr._calc_parallel_connection(\n\t\t\telement_list=helplist_inner_walls, omega=omega\n\t\t)\n\t\tassert round(r1_iw, 13) == 0.0097195611408\n\t\tassert round(c1_iw, 6) == 319983.518743\n\n\tdef test_sum_building_elements_four(self):\n\t\t\"\"\"test of combine_building_elements\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\n\t\tfrom teaser.logic.buildingobjects.calculation.four_element import FourElement\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\n\t\tcalc_attr = FourElement(therm_zone, merge_windows=True, t_bt=5)\n\n\t\thelplist = (\n\t\t\ttherm_zone.outer_walls\n\t\t\t+ therm_zone.rooftops\n\t\t\t+ therm_zone.ground_floors\n\t\t\t+ therm_zone.inner_walls\n\t\t\t+ therm_zone.ceilings\n\t\t\t+ therm_zone.floors\n\t\t\t+ therm_zone.windows\n\t\t)\n\n\t\tfor element in helplist:\n\t\t\telement.calc_equivalent_res()\n\t\t\telement.calc_ua_value()\n\n\t\tcalc_attr._sum_outer_wall_elements()\n\t\tcalc_attr._sum_ground_floor_elements()\n\t\tcalc_attr._sum_rooftop_elements()\n\t\tcalc_attr._sum_inner_wall_elements()\n\t\tcalc_attr._sum_window_elements()\n\n\t\t# innerwall\n\n\t\tassert round(calc_attr.ua_value_iw, 16) == 14.286493860845841\n\t\tassert round(calc_attr.area_iw, 1) == 34.0\n\t\tassert round(calc_attr.r_conv_inner_iw, 18) == 0.010893246187363833\n\t\tassert round(calc_attr.r_rad_inner_iw, 19) == 0.0058823529411764705\n\t\tassert round(calc_attr.r_comb_inner_iw, 19) == 0.003819709702062643\n\t\tassert round(calc_attr.alpha_conv_inner_iw, 1) == 2.7\n\t\tassert round(calc_attr.alpha_rad_inner_iw, 1) == 5.0\n\t\tassert round(calc_attr.alpha_comb_inner_iw, 1) == 7.7\n\n\t\t# outerwall\n\t\tassert round(calc_attr.ua_value_ow, 16) == 19.83577523748189\n\t\tassert round(calc_attr.area_ow, 1) == 48.0\n\t\tassert round(calc_attr.r_conv_inner_ow, 19) == 0.007716049382716048\n\t\tassert round(calc_attr.r_rad_inner_ow, 18) == 0.004166666666666667\n\t\tassert round(calc_attr.r_comb_inner_ow, 20) == 0.0027056277056277055\n\t\tassert round(calc_attr.r_conv_outer_ow, 20) == 0.0010416666666666667\n\t\tassert round(calc_attr.r_rad_outer_ow, 18) == 0.004166666666666667\n\t\tassert round(calc_attr.r_comb_outer_ow, 20) == 0.0008333333333333334\n\t\tassert round(calc_attr.alpha_conv_inner_ow, 5) == 2.7\n\t\tassert round(calc_attr.alpha_rad_inner_ow, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_inner_ow, 5) == 7.7\n\t\tassert round(calc_attr.alpha_conv_outer_ow, 1) == 20.0\n\t\tassert round(calc_attr.alpha_rad_outer_ow, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_outer_ow, 1) == 25.0\n\n\t\t# groundfloor\n\t\tassert round(calc_attr.ua_value_gf, 16) == 58.351477449455686\n\t\tassert round(calc_attr.area_gf, 1) == 140.0\n\t\tassert round(calc_attr.r_conv_inner_gf, 19) == 0.004201680672268907\n\t\tassert round(calc_attr.r_rad_inner_gf, 18) == 0.001428571428571429\n\t\tassert round(calc_attr.r_comb_inner_gf, 20) == 0.0010660980810234541\n\t\tassert round(calc_attr.alpha_conv_inner_gf, 5) == 1.7\n\t\tassert round(calc_attr.alpha_rad_inner_gf, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_inner_gf, 5) == 6.7\n\n\t\t# outerwall\n\t\tassert round(calc_attr.ua_value_rt, 16) == 57.394603194028036\n\t\tassert round(calc_attr.area_rt, 1) == 140.0\n\t\tassert round(calc_attr.r_conv_inner_rt, 19) == 0.004201680672268907\n\t\tassert round(calc_attr.r_rad_inner_rt, 18) == 0.001428571428571429\n\t\tassert round(calc_attr.r_comb_inner_rt, 20) == 0.0010660980810234541\n\t\tassert round(calc_attr.r_conv_outer_rt, 20) == 0.00035714285714285714\n\t\tassert round(calc_attr.r_rad_outer_rt, 18) == 0.001428571428571429\n\t\tassert round(calc_attr.r_comb_outer_rt, 20) == 0.00028571428571428574\n\t\tassert round(calc_attr.alpha_conv_inner_rt, 5) == 1.7\n\t\tassert round(calc_attr.alpha_rad_inner_rt, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_inner_rt, 5) == 6.7\n\t\tassert round(calc_attr.alpha_conv_outer_rt, 1) == 20.0\n\t\tassert round(calc_attr.alpha_rad_outer_rt, 5) == 5.0\n\t\tassert round(calc_attr.alpha_comb_outer_rt, 1) == 25.0\n\n\t\t# window\n\t\tassert round(calc_attr.ua_value_win, 16) == 32.87895310796074\n\t\tassert round(calc_attr.area_win, 1) == 18.0\n\t\tassert round(calc_attr.r_conv_inner_win, 19) == 0.032679738562091505\n\t\tassert round(calc_attr.r_rad_inner_win, 4) == 0.0111\n\t\tassert round(calc_attr.r_comb_inner_win, 19) == 0.008291873963515755\n\t\tassert round(calc_attr.r_conv_outer_win, 5) == 0.00278\n\t\tassert round(calc_attr.r_rad_outer_win, 4) == 0.0111\n\t\tassert round(calc_attr.r_comb_outer_win, 4) == 0.0022\n\t\tassert round(calc_attr.alpha_conv_inner_win, 1) == 1.7\n\t\tassert round(calc_attr.alpha_comb_outer_win, 1) == 25.0\n\t\tassert round(calc_attr.alpha_conv_outer_win, 1) == 20.0\n\t\tassert round(calc_attr.weighted_g_value, 3) == 0.789\n\n\tdef test_calc_chain_matrix_four(self):\n\t\t\"\"\"test of calc_chain_matrix\"\"\"\n\t\tfrom teaser.logic.buildingobjects.calculation.four_element import FourElement\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\n\t\tcalc_attr = FourElement(therm_zone, merge_windows=False, t_bt=5)\n\n\t\thelplist = (\n\t\t\ttherm_zone.outer_walls\n\t\t\t+ therm_zone.rooftops\n\t\t\t+ therm_zone.ground_floors\n\t\t\t+ therm_zone.inner_walls\n\t\t\t+ therm_zone.ceilings\n\t\t\t+ therm_zone.floors\n\t\t\t+ therm_zone.windows\n\t\t)\n\n\t\tfor element in helplist:\n\t\t\telement.calc_equivalent_res()\n\t\t\telement.calc_ua_value()\n\n\t\tomega = 2 * math.pi / 86400 / 5\n\n\t\thelplist_outer_walls = therm_zone.outer_walls + therm_zone.windows\n\n\t\tr1_ow, c1_ow = calc_attr._calc_parallel_connection(\n\t\t\telement_list=helplist_outer_walls, omega=omega\n\t\t)\n\t\tassert round(r1_ow, 14) == 0.00688468914141\n\t\tassert round(c1_ow, 5) == 533938.62338\n\n\t\thelplist_inner_walls = (\n\t\t\ttherm_zone.inner_walls + therm_zone.ceilings + therm_zone.floors\n\t\t)\n\n\t\tr1_iw, c1_iw = calc_attr._calc_parallel_connection(\n\t\t\telement_list=helplist_inner_walls, omega=omega\n\t\t)\n\t\tassert round(r1_iw, 13) == 0.0097195611408\n\t\tassert round(c1_iw, 6) == 319983.518743\n\n\tdef test_calc_weightfactor_one(self):\n\t\t\"\"\"test of calc_weightfactor\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\tprj.buildings[-1].calc_building_parameter(\n\t\t\tnumber_of_elements=1, merge_windows=True, used_library=\"IBPSA\"\n\t\t)\n\n\t\tcalc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n\t\tweightfactors_test_list = [\n\t\t\t0,\n\t\t\t0.024530650180761254,\n\t\t\t0.03434291025306576,\n\t\t\t0.024530650180761254,\n\t\t\t0.03434291025306576,\n\t\t\t0.3407000330729792,\n\t\t]\n\n\t\tcalc_attr.weightfactor_ow.sort()\n\t\tweightfactors_test_list.sort()\n\n\t\tassert calc_attr.weightfactor_ow == weightfactors_test_list\n\n\t\tweightfactors_test_list = [\n\t\t\t0.08674342795625017,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.054214642472656345,\n\t\t\t0.054214642472656345,\n\t\t]\n\t\tcalc_attr.weightfactor_win.sort()\n\t\tweightfactors_test_list.sort()\n\n\t\tassert calc_attr.weightfactor_win == weightfactors_test_list\n\t\tassert calc_attr.weightfactor_ground == 0.34638013315780397\n\n\t\tprj.buildings[-1].thermal_zones[-1].weightfactor_ow = []\n\t\tprj.buildings[-1].thermal_zones[-1].weightfactor_win = []\n\n\t\tprj.buildings[-1].calc_building_parameter(\n\t\t\tnumber_of_elements=1, merge_windows=False, used_library=\"AixLib\"\n\t\t)\n\t\tcalc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n\t\tweightfactors_test_list = [\n\t\t\t0.03047939672771178,\n\t\t\t0.423320678280269,\n\t\t\t0.03047939672771178,\n\t\t\t0.0,\n\t\t\t0.04267115541879649,\n\t\t\t0.04267115541879649,\n\t\t]\n\t\tcalc_attr.weightfactor_ow.sort()\n\t\tweightfactors_test_list.sort()\n\n\t\tassert calc_attr.weightfactor_ow == weightfactors_test_list\n\n\t\tweightfactors_test_list = [\n\t\t\t0.44444444444444453,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.2777777777777778,\n\t\t\t0.2777777777777778,\n\t\t]\n\n\t\tcalc_attr.weightfactor_win.sort()\n\t\tweightfactors_test_list.sort()\n\t\tassert calc_attr.weightfactor_win.sort() == weightfactors_test_list.sort()\n\t\tassert calc_attr.weightfactor_ground == 0.4303782174267145\n\n\tdef test_calc_weightfactor_two(self):\n\t\t\"\"\"test of calc_weightfactor\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\tprj.buildings[-1].calc_building_parameter(\n\t\t\tnumber_of_elements=2, merge_windows=True, used_library=\"IBPSA\"\n\t\t)\n\n\t\tcalc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n\t\tweightfactors_test_list = [\n\t\t\t0.0,\n\t\t\t0.024530650180761254,\n\t\t\t0.03434291025306576,\n\t\t\t0.024530650180761254,\n\t\t\t0.03434291025306576,\n\t\t\t0.3407000330729792,\n\t\t]\n\t\tcalc_attr.weightfactor_ow.sort()\n\t\tweightfactors_test_list.sort()\n\n\t\tassert calc_attr.weightfactor_ow == weightfactors_test_list\n\t\tweightfactors_test_list = [\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.054214642472656345,\n\t\t\t0.08674342795625017,\n\t\t\t0.054214642472656345,\n\t\t\t0.0,\n\t\t]\n\t\tcalc_attr.weightfactor_win.sort()\n\t\tweightfactors_test_list.sort()\n\t\tassert calc_attr.weightfactor_win == weightfactors_test_list\n\t\tassert calc_attr.weightfactor_ground == 0.34638013315780397\n\n\t\tprj.buildings[-1].thermal_zones[-1].weightfactor_ow = []\n\t\tprj.buildings[-1].thermal_zones[-1].weightfactor_win = []\n\n\t\tprj.buildings[-1].calc_building_parameter(\n\t\t\tnumber_of_elements=2, merge_windows=False, used_library=\"AixLib\"\n\t\t)\n\t\tcalc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n\t\tweightfactors_test_list = [\n\t\t\t0.0,\n\t\t\t0.03047939672771178,\n\t\t\t0.04267115541879649,\n\t\t\t0.03047939672771178,\n\t\t\t0.04267115541879649,\n\t\t\t0.423320678280269,\n\t\t]\n\t\tcalc_attr.weightfactor_ow.sort()\n\t\tweightfactors_test_list.sort()\n\t\tassert calc_attr.weightfactor_ow == weightfactors_test_list\n\n\t\tweightfactors_test_list = [\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.27777777777777778,\n\t\t\t0.44444444444444453,\n\t\t\t0.27777777777777778,\n\t\t\t0.0,\n\t\t]\n\n\t\tcalc_attr.weightfactor_win.sort()\n\t\tweightfactors_test_list.sort()\n\t\tassert calc_attr.weightfactor_win == weightfactors_test_list\n\t\tassert calc_attr.weightfactor_ground == 0.4303782174267145\n\n\tdef test_calc_weightfactor_three(self):\n\t\t\"\"\"test of calc_weightfactor\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\tprj.buildings[-1].calc_building_parameter(\n\t\t\tnumber_of_elements=3, merge_windows=True, used_library=\"IBPSA\"\n\t\t)\n\n\t\tcalc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\t\tweightfactors_test_list = [\n\t\t\t0.03753045374718346,\n\t\t\t0.5212510365068732,\n\t\t\t0.05254263524605685,\n\t\t\t0.03753045374718346,\n\t\t\t0.05254263524605685,\n\t\t]\n\t\tcalc_attr.weightfactor_ow.sort()\n\t\tweightfactors_test_list.sort()\n\n\t\tassert calc_attr.weightfactor_ow == weightfactors_test_list\n\t\tweightfactors_test_list = [\n\t\t\t0.13271234911406493,\n\t\t\t0.0,\n\t\t\t0.08294521819629057,\n\t\t\t0.0,\n\t\t\t0.08294521819629057,\n\t\t]\n\t\tcalc_attr.weightfactor_win.sort()\n\t\tweightfactors_test_list.sort()\n\t\tassert calc_attr.weightfactor_win == weightfactors_test_list\n\t\tassert calc_attr.weightfactor_ground == 0\n\n\t\tprj.buildings[-1].thermal_zones[-1].weightfactor_ow = []\n\t\tprj.buildings[-1].thermal_zones[-1].weightfactor_win = []\n\n\t\tprj.buildings[-1].calc_building_parameter(\n\t\t\tnumber_of_elements=3, merge_windows=False, used_library=\"AixLib\"\n\t\t)\n\t\tcalc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n\t\tweightfactors_test_list = [\n\t\t\t0.05350813058801943,\n\t\t\t0.7431609731775066,\n\t\t\t0.07491138282322722,\n\t\t\t0.05350813058801943,\n\t\t\t0.07491138282322722,\n\t\t]\n\n\t\tcalc_attr.weightfactor_ow.sort()\n\t\tweightfactors_test_list.sort()\n\n\t\tassert calc_attr.weightfactor_ow == weightfactors_test_list\n\n\t\tweightfactors_test_list = [\n\t\t\t0.44444444444444453,\n\t\t\t0.0,\n\t\t\t0.2777777777777778,\n\t\t\t0.0,\n\t\t\t0.2777777777777778,\n\t\t]\n\t\tcalc_attr.weightfactor_win.sort()\n\t\tweightfactors_test_list.sort()\n\t\tassert calc_attr.weightfactor_win == weightfactors_test_list\n\t\tassert calc_attr.weightfactor_ground == 0\n\n\tdef test_calc_weightfactor_four(self):\n\t\t\"\"\"test of calc_weightfactor\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\tprj.buildings[-1].calc_building_parameter(\n\t\t\tnumber_of_elements=4, merge_windows=True, used_library=\"IBPSA\"\n\t\t)\n\n\t\tcalc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n\t\tweightfactors_test_list = [\n\t\t\t0.07839276240589141,\n\t\t\t0.10974986736824797,\n\t\t\t0.07839276240589141,\n\t\t\t0.10974986736824797,\n\t\t]\n\n\t\tcalc_attr.weightfactor_ow.sort()\n\t\tweightfactors_test_list.sort()\n\n\t\tassert calc_attr.weightfactor_ow == weightfactors_test_list\n\t\tweightfactors_test_list = [\n\t\t\t0.27720655131187616,\n\t\t\t0.17325409456992255,\n\t\t\t0.0,\n\t\t\t0.17325409456992255,\n\t\t]\n\t\tcalc_attr.weightfactor_win.sort()\n\t\tweightfactors_test_list.sort()\n\t\tassert calc_attr.weightfactor_win == weightfactors_test_list\n\t\tassert calc_attr.weightfactor_ground == 0\n\t\tassert calc_attr.weightfactor_rt == [1]\n\n\t\tprj.buildings[-1].thermal_zones[-1].weightfactor_ow = []\n\t\tprj.buildings[-1].thermal_zones[-1].weightfactor_win = []\n\n\t\tprj.buildings[-1].calc_building_parameter(\n\t\t\tnumber_of_elements=4, merge_windows=False, used_library=\"AixLib\"\n\t\t)\n\t\tcalc_attr = prj.buildings[-1].thermal_zones[-1].model_attr\n\n\t\tweightfactors_test_list = [\n\t\t\t0.20833333333333331,\n\t\t\t0.29166666666666663,\n\t\t\t0.20833333333333331,\n\t\t\t0.29166666666666663,\n\t\t]\n\t\tcalc_attr.weightfactor_ow.sort()\n\t\tweightfactors_test_list.sort()\n\t\tassert calc_attr.weightfactor_ow == weightfactors_test_list\n\n\t\tweightfactors_test_list = [\n\t\t\t0.44444444444444453,\n\t\t\t0.2777777777777778,\n\t\t\t0.0,\n\t\t\t0.2777777777777778,\n\t\t]\n\n\t\tcalc_attr.weightfactor_win.sort()\n\t\tweightfactors_test_list.sort()\n\t\tassert calc_attr.weightfactor_win == weightfactors_test_list\n\t\tassert calc_attr.weightfactor_ground == 0\n\t\tassert calc_attr.weightfactor_rt == [1]\n\n\tdef test_calc_one_element(self):\n\t\t\"\"\"test of calc_two_element\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.calc_zone_parameters(number_of_elements=1, merge_windows=True)\n\n\t\tzone_attr = therm_zone.model_attr\n\t\tassert round(zone_attr.area_ow, 1) == 328.0\n\t\tassert round(zone_attr.ua_value_ow, 16) == 135.5818558809656\n\t\tassert round(zone_attr.r_conv_inner_ow, 16) == 0.0016512549537649\n\t\tassert round(zone_attr.r_rad_inner_ow, 16) == 0.000609756097561\n\n\t\tassert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 5) == 1.84634\n\t\tassert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n\t\tassert round(zone_attr.r1_ow, 15) == 0.000772773294534\n\t\tassert round(zone_attr.c1_ow, 5) == 3648580.59312\n\t\tassert round(zone_attr.r_rest_ow, 14) == 0.00461875570532\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.calc_zone_parameters(number_of_elements=1, merge_windows=False)\n\n\t\tzone_attr = therm_zone.model_attr\n\t\tassert round(zone_attr.area_ow, 1) == 328.0\n\t\tassert round(zone_attr.ua_value_ow, 16) == 135.5818558809656\n\t\tassert round(zone_attr.r_conv_inner_ow, 16) == 0.0016512549537649\n\t\tassert round(zone_attr.r_rad_inner_ow, 16) == 0.000609756097561\n\n\t\tassert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 5) == 1.84634\n\t\tassert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n\t\tassert round(zone_attr.r1_win, 13) == 0.0199004975124\n\t\tassert round(zone_attr.r1_ow, 15) == 0.001007515484109\n\t\tassert round(zone_attr.c1_ow, 5) == 3648580.59312\n\t\tassert round(zone_attr.r_rest_ow, 14) == 0.00585224061345\n\n\tdef test_calc_two_element(self):\n\t\t\"\"\"test of calc_two_element\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.calc_zone_parameters(number_of_elements=2, merge_windows=True)\n\n\t\tzone_attr = therm_zone.model_attr\n\t\tassert round(zone_attr.area_ow, 1) == 328.0\n\t\tassert round(zone_attr.ua_value_ow, 16) == 135.5818558809656\n\t\tassert round(zone_attr.r_conv_inner_ow, 16) == 0.0016512549537649\n\t\tassert round(zone_attr.r_rad_inner_ow, 16) == 0.000609756097561\n\t\tassert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 5) == 1.84634\n\t\tassert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n\t\tassert round(zone_attr.r1_ow, 15) == 0.000772773294534\n\t\tassert round(zone_attr.c1_ow, 5) == 3648580.59312\n\t\tassert round(zone_attr.r1_iw, 15) == 0.009719561140816\n\t\tassert round(zone_attr.c1_iw, 5) == 319983.51874\n\n\t\tassert round(zone_attr.r_rest_ow, 14) == 0.00461875570532\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.calc_zone_parameters(number_of_elements=2, merge_windows=False)\n\n\t\tzone_attr = therm_zone.model_attr\n\t\tassert round(zone_attr.area_ow, 1) == 328.0\n\t\tassert round(zone_attr.ua_value_ow, 16) == 135.5818558809656\n\t\tassert round(zone_attr.r_conv_inner_ow, 16) == 0.0016512549537649\n\t\tassert round(zone_attr.r_rad_inner_ow, 16) == 0.000609756097561\n\t\tassert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 5) == 1.84634\n\t\tassert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n\t\tassert round(zone_attr.r1_win, 13) == 0.0199004975124\n\t\tassert round(zone_attr.r1_ow, 15) == 0.001007515484109\n\t\tassert round(zone_attr.c1_ow, 5) == 3648580.59312\n\t\tassert round(zone_attr.r1_iw, 15) == 0.009719561140816\n\t\tassert round(zone_attr.r_rest_ow, 14) == 0.00585224061345\n\n\tdef test_calc_three_element(self):\n\t\t\"\"\"test of calc_two_element\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.calc_zone_parameters(number_of_elements=3, merge_windows=True)\n\n\t\tzone_attr = therm_zone.model_attr\n\t\tassert round(zone_attr.area_ow, 1) == 188.0\n\t\tassert round(zone_attr.ua_value_ow, 16) == 77.23037843150993\n\t\tassert round(zone_attr.r_conv_inner_ow, 16) == 0.0027203482045702\n\t\tassert round(zone_attr.r_rad_inner_ow, 16) == 0.001063829787234\n\t\tassert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 5) == 1.95532\n\t\tassert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n\t\tassert round(zone_attr.r1_ow, 14) == 0.00114890338306\n\t\tassert round(zone_attr.c1_ow, 5) == 2091259.60825\n\t\tassert round(zone_attr.r1_iw, 15) == 0.009719561140816\n\t\tassert round(zone_attr.c1_iw, 5) == 319983.51874\n\t\tassert round(zone_attr.r_rest_ow, 11) == 0.00702003101\n\t\tassert round(zone_attr.area_gf, 1) == 140.0\n\t\tassert round(zone_attr.ua_value_gf, 16) == 58.351477449455686\n\t\tassert round(zone_attr.r_conv_inner_gf, 16) == 0.0042016806722689\n\t\tassert round(zone_attr.r_rad_inner_gf, 16) == 0.0014285714285714\n\t\tassert round(zone_attr.alpha_conv_inner_gf, 5) == 1.7\n\t\tassert round(zone_attr.alpha_rad_inner_gf, 1) == 5.0\n\t\tassert round(zone_attr.r1_gf, 14) == 0.00236046484848\n\t\tassert round(zone_attr.c1_gf, 5) == 1557320.98487\n\t\tassert round(zone_attr.r_rest_gf, 13) == 0.0137109637229\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.calc_zone_parameters(number_of_elements=3, merge_windows=False)\n\n\t\tzone_attr = therm_zone.model_attr\n\t\tassert round(zone_attr.area_ow, 1) == 188.0\n\t\tassert round(zone_attr.ua_value_ow, 16) == 77.23037843150993\n\t\tassert round(zone_attr.r_conv_inner_ow, 16) == 0.0027203482045702\n\t\tassert round(zone_attr.r_rad_inner_ow, 16) == 0.001063829787234\n\t\tassert round(zone_attr.r_conv_outer_ow, 9) == 0.000265957\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 5) == 1.95532\n\t\tassert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n\t\tassert round(zone_attr.r1_win, 13) == 0.0199004975124\n\t\tassert round(zone_attr.r1_ow, 13) == 0.0017577929723\n\t\tassert round(zone_attr.c1_ow, 5) == 2091259.60825\n\t\tassert round(zone_attr.r1_iw, 15) == 0.009719561140816\n\t\tassert round(zone_attr.c1_iw, 5) == 319983.51874\n\t\tassert round(zone_attr.r_rest_ow, 13) == 0.0102102921341\n\t\tassert round(zone_attr.area_gf, 1) == 140.0\n\t\tassert round(zone_attr.ua_value_gf, 16) == 58.351477449455686\n\t\tassert round(zone_attr.r_conv_inner_gf, 16) == 0.0042016806722689\n\t\tassert round(zone_attr.r_rad_inner_gf, 16) == 0.0014285714285714\n\t\tassert round(zone_attr.alpha_conv_inner_gf, 5) == 1.7\n\t\tassert round(zone_attr.alpha_rad_inner_gf, 1) == 5.0\n\t\tassert round(zone_attr.r1_gf, 14) == 0.00236046484848\n\t\tassert round(zone_attr.c1_gf, 5) == 1557320.98487\n\t\tassert round(zone_attr.r_rest_gf, 13) == 0.0137109637229\n\n\tdef test_calc_four_element(self):\n\t\t\"\"\"test of calc_two_element\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.calc_zone_parameters(number_of_elements=4, merge_windows=True)\n\n\t\tzone_attr = therm_zone.model_attr\n\t\tassert round(zone_attr.area_ow, 1) == 48.0\n\t\tassert round(zone_attr.ua_value_ow, 16) == 19.83577523748189\n\t\tassert round(zone_attr.r_conv_inner_ow, 16) == 0.007716049382716\n\t\tassert round(zone_attr.r_rad_inner_ow, 16) == 0.0041666666666667\n\t\tassert round(zone_attr.r_conv_outer_ow, 9) == 0.001041667\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 5) == 2.7\n\t\tassert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n\t\tassert round(zone_attr.r1_ow, 14) == 0.00223838915931\n\t\tassert round(zone_attr.c1_ow, 5) == 533938.62338\n\t\tassert round(zone_attr.r1_iw, 14) == 0.00971956114082\n\t\tassert round(zone_attr.c1_iw, 5) == 319983.51874\n\t\tassert round(zone_attr.r_rest_ow, 13) == 0.0138583242416\n\t\tassert round(zone_attr.area_gf, 1) == 140.0\n\t\tassert round(zone_attr.ua_value_gf, 16) == 58.351477449455686\n\t\tassert round(zone_attr.r_conv_inner_gf, 16) == 0.0042016806722689\n\t\tassert round(zone_attr.r_rad_inner_gf, 16) == 0.0014285714285714\n\t\tassert round(zone_attr.alpha_conv_inner_gf, 5) == 1.7\n\t\tassert round(zone_attr.alpha_rad_inner_gf, 1) == 5.0\n\t\tassert round(zone_attr.r1_gf, 14) == 0.00236046484848\n\t\tassert round(zone_attr.c1_gf, 5) == 1557320.98487\n\t\tassert round(zone_attr.r_rest_gf, 13) == 0.0137109637229\n\n\t\tassert round(zone_attr.area_rt, 1) == 140.0\n\t\tassert round(zone_attr.ua_value_rt, 16) == 57.394603194028036\n\t\tassert round(zone_attr.r_conv_inner_rt, 16) == 0.0042016806722689\n\t\tassert round(zone_attr.r_rad_inner_rt, 16) == 0.0014285714285714\n\t\tassert round(zone_attr.r_conv_outer_rt, 9) == 0.000357143\n\t\tassert round(zone_attr.alpha_conv_inner_rt, 5) == 1.7\n\t\tassert round(zone_attr.alpha_rad_inner_rt, 1) == 5.0\n\t\tassert round(zone_attr.r1_rt, 14) == 0.00236046484848\n\t\tassert round(zone_attr.c1_rt, 5) == 1557320.98487\n\t\tassert round(zone_attr.r_rest_rt, 13) == 0.0137109637229\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.calc_zone_parameters(number_of_elements=4, merge_windows=False)\n\n\t\tzone_attr = therm_zone.model_attr\n\t\tassert round(zone_attr.area_ow, 1) == 48.0\n\t\tassert round(zone_attr.ua_value_ow, 16) == 19.83577523748189\n\t\tassert round(zone_attr.r_conv_inner_ow, 16) == 0.007716049382716\n\t\tassert round(zone_attr.r_rad_inner_ow, 16) == 0.0041666666666667\n\t\tassert round(zone_attr.r_conv_outer_ow, 9) == 0.001041667\n\t\tassert round(zone_attr.alpha_conv_inner_ow, 5) == 2.7\n\t\tassert round(zone_attr.alpha_rad_inner_ow, 1) == 5.0\n\t\tassert round(zone_attr.r1_win, 13) == 0.0199004975124\n\t\tassert round(zone_attr.r1_ow, 14) == 0.00688468914141\n\t\tassert round(zone_attr.c1_ow, 5) == 533938.62338\n\t\tassert round(zone_attr.r1_iw, 14) == 0.00971956114082\n\t\tassert round(zone_attr.c1_iw, 5) == 319983.51874\n\t\tassert round(zone_attr.r_rest_ow, 13) == 0.0399903108586\n\n\t\tassert round(zone_attr.area_gf, 1) == 140.0\n\t\tassert round(zone_attr.ua_value_gf, 16) == 58.351477449455686\n\t\tassert round(zone_attr.r_conv_inner_gf, 16) == 0.0042016806722689\n\t\tassert round(zone_attr.r_rad_inner_gf, 16) == 0.0014285714285714\n\t\tassert round(zone_attr.alpha_conv_inner_gf, 5) == 1.7\n\t\tassert round(zone_attr.alpha_rad_inner_gf, 1) == 5.0\n\t\tassert round(zone_attr.r1_gf, 14) == 0.00236046484848\n\t\tassert round(zone_attr.c1_gf, 5) == 1557320.98487\n\t\tassert round(zone_attr.r_rest_gf, 13) == 0.0137109637229\n\n\t\tassert round(zone_attr.area_rt, 1) == 140.0\n\t\tassert round(zone_attr.ua_value_rt, 16) == 57.394603194028036\n\t\tassert round(zone_attr.r_conv_inner_rt, 16) == 0.0042016806722689\n\t\tassert round(zone_attr.r_rad_inner_rt, 16) == 0.0014285714285714\n\t\tassert round(zone_attr.r_conv_outer_rt, 9) == 0.000357143\n\t\tassert round(zone_attr.alpha_conv_inner_rt, 5) == 1.7\n\t\tassert round(zone_attr.alpha_rad_inner_rt, 1) == 5.0\n\t\tassert round(zone_attr.r1_rt, 14) == 0.00236046484848\n\t\tassert round(zone_attr.c1_rt, 5) == 1557320.98487\n\t\tassert round(zone_attr.r_rest_rt, 13) == 0.0137109637229\n\n\tdef test_volume_zone(self):\n\t\t\"\"\"test of volume_zone\"\"\"\n\n\t\tprj.buildings[-1].thermal_zones[-1].set_volume_zone()\n\t\tassert prj.buildings[-1].thermal_zones[-1].volume == 490.0\n\n\tdef test_set_inner_wall_area(self):\n\t\t\"\"\"test of set_inner_wall_area\"\"\"\n\n\t\tprj.buildings[-1].thermal_zones[-1].set_inner_wall_area()\n\t\tfor wall in prj.buildings[-1].thermal_zones[-1].inner_walls:\n\t\t\tassert round(wall.area, 16) == 11.951219512195122\n\t\t# methods in BuildingElement\n\n\tdef test_ua_value(self):\n\t\t\"\"\"test of ua_value\"\"\"\n\t\tprj.set_default(load_data=True)\n\t\thelptest.building_test2(prj)\n\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.outer_walls[0].calc_ua_value()\n\n\t\tassert round(therm_zone.outer_walls[0].ua_value, 15) == 4.132453174475393\n\n\tdef test_gather_element_properties(self):\n\t\t\"\"\"test of gather_element_properties\"\"\"\n\t\touterWalls = prj.buildings[-1].thermal_zones[-1].outer_walls[0]\n\t\tnumber_of_layer, density, thermal_conduc, heat_capac, thickness = (\n\t\t\touterWalls.gather_element_properties()\n\t\t)\n\t\tassert number_of_layer == 2\n\t\tassert (density == [5.0, 2.0]).all()\n\t\tassert (thermal_conduc == [4.0, 2.0]).all()\n\t\tassert (heat_capac == [0.48, 0.84]).all()\n\t\tassert (thickness == [5.0, 2.0]).all()\n\n\tdef test_load_type_element(self):\n\t\t\"\"\"test of load_type_element, no parameter checking\"\"\"\n\n\t\t# test load function\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.outer_walls[0].load_type_element(1988, \"heavy\", prj.data)\n\t\ttherm_zone.inner_walls[0].load_type_element(1988, \"light\", prj.data)\n\t\ttherm_zone.windows[0].load_type_element(\n\t\t\t1988, \"Kunststofffenster, Isolierverglasung\", prj.data\n\t\t)\n\n\tdef test_save_type_element(self):\n\t\t\"\"\"test of save_type_element, no parameter checking\"\"\"\n\t\timport os\n\n\t\t# test load function\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\tpath = os.path.join(utilities.get_default_path(), \"unitTestTB.json\")\n\t\tprj.data.path_tb = path\n\t\tprj.data.load_tb_binding()\n\t\ttherm_zone.outer_walls[0].save_type_element(data_class=prj.data)\n\t\ttherm_zone.inner_walls[0].save_type_element(data_class=prj.data)\n\t\ttherm_zone.windows[0].save_type_element(data_class=prj.data)\n\n\tdef test_delete_type_element(self):\n\t\t\"\"\"test of save_type_element, no parameter checking\"\"\"\n\t\timport os\n\n\t\t# test load function\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\tpath = os.path.join(utilities.get_default_path(), \"unitTestTB.json\")\n\t\tprj.data.path_tb = path\n\t\tprj.data.load_tb_binding()\n\t\ttherm_zone.outer_walls[0].delete_type_element(data_class=prj.data)\n\t\ttherm_zone.inner_walls[0].delete_type_element(data_class=prj.data)\n\t\ttherm_zone.windows[0].delete_type_element(data_class=prj.data)\n\n\t# methods in Wall\n\n\tdef test_calc_equivalent_res_wall(self):\n\t\t\"\"\"test of calc_equivalent_res, wall\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\n\t\ttherm_zone.outer_walls[0].calc_equivalent_res()\n\n\t\t# parameters for outwall\n\n\t\tassert round(therm_zone.outer_walls[0].c1, 6) == 111237.213205\n\t\tassert round(therm_zone.outer_walls[0].c2, 7) == 59455.3856787\n\t\tassert round(therm_zone.outer_walls[0].r1, 13) == 0.0330465078788\n\t\tassert round(therm_zone.outer_walls[0].r2, 13) == 0.0549256129353\n\t\tassert round(therm_zone.outer_walls[0].r3, 12) == 0.137027879186\n\t\tassert round(therm_zone.outer_walls[0].c1_korr, 6) == 111237.213205\n\n\tdef test_insulate_wall(self):\n\t\t\"\"\"test of insulate_wall\"\"\"\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.outer_walls[0].insulate_wall(\"EPS_040_15\", 0.04)\n\t\tassert round(therm_zone.outer_walls[0].ua_value, 6) == 2.924088\n\n\tdef test_retrofit_wall(self):\n\t\t\"\"\"test of retrofit_wall\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.outer_walls[0].retrofit_wall(2016, \"EPS_040_15\")\n\t\tassert round(therm_zone.outer_walls[0].ua_value, 6) == 2.4\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.outer_walls[0].retrofit_wall(2010, \"EPS_040_15\")\n\t\tassert round(therm_zone.outer_walls[0].ua_value, 6) == 2.4\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.outer_walls[0].retrofit_wall(2005, \"EPS_040_15\")\n\t\tassert round(therm_zone.outer_walls[0].ua_value, 2) == 4.13\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.outer_walls[0].retrofit_wall(1998, \"EPS_040_15\")\n\t\tassert round(therm_zone.outer_walls[0].ua_value, 2) == 4.13\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.outer_walls[0].retrofit_wall(1990, \"EPS_040_15\")\n\t\tassert round(therm_zone.outer_walls[0].ua_value, 2) == 4.13\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.outer_walls[0].retrofit_wall(1980, \"EPS_040_15\")\n\t\tassert round(therm_zone.outer_walls[0].ua_value, 2) == 4.13\n\n\tdef test_calc_equivalent_res_win(self):\n\t\t\"\"\"test of calc_equivalent_res, win\"\"\"\n\t\tprj.set_default()\n\t\thelptest.building_test2(prj)\n\t\ttherm_zone = prj.buildings[-1].thermal_zones[-1]\n\t\ttherm_zone.windows[0].calc_equivalent_res()\n\n\t\tassert round(therm_zone.windows[0].r1, 3) == 0.072\n\n\tdef test_load_save_material(self):\n\t\t\"\"\"test of load_material_template and save_material_template,\n\t\tno parameter checking\"\"\"\n\n\t\tfrom teaser.logic.buildingobjects.buildingphysics.material import Material\n\n\t\tpath = os.path.join(utilities.get_default_path(), \"MatUT.json\")\n\n\t\tmat = Material(parent=None)\n\t\tmat.load_material_template(mat_name=\"Tiledroof\", data_class=prj.data)\n\n\t\tfrom teaser.data.dataclass import DataClass\n\n\t\tdat = DataClass()\n\t\tdat.path_mat = path\n\t\tdat.load_mat_binding()\n\n\t\tmat.save_material_template(data_class=dat)\n\n\tdef test_properties_project(self):\n\t\t\"\"\"Tests properties of project class\"\"\"\n\t\tprj.number_of_elements_calc\n\t\tprj.merge_windows_calc\n\t\tprj.used_library_calc\n\t\tprj.name = 123\n\t\tassert prj.name == \"P123\"\n\n\tdef test_warnings_prj(self):\n\t\t\"\"\"Tests misc parts in project.py\"\"\"\n\n\t\tfrom teaser.logic.buildingobjects.building import Building\n\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone\n\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions\n\n\t\t# warnings for not calculated buildings\n\t\tbld = Building(parent=prj)\n\t\ttz = ThermalZone(parent=bld)\n\t\ttz.use_conditions = UseConditions(parent=tz)\n\t\tprj.calc_all_buildings()\n\t\tprj.set_default(load_data=True)\n\t\t# warning if iwu and number_of_apartments is used\n\t\tprj.add_residential(\n\t\t\tmethod=\"iwu\",\n\t\t\tusage=\"single_family_dwelling\",\n\t\t\tname=\"test\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=1,\n\t\t\theight_of_floors=7,\n\t\t\tnet_leased_area=1988,\n\t\t\tnumber_of_apartments=1,\n\t\t)\n\t\t# not all buildings if internal id is passed over\n\t\tprj.add_residential(\n\t\t\tmethod=\"iwu\",\n\t\t\tusage=\"single_family_dwelling\",\n\t\t\tname=\"test1\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=15,\n\t\t\theight_of_floors=6,\n\t\t\tnet_leased_area=1988,\n\t\t)\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib(internal_id=prj.buildings[-1].internal_id)\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa(internal_id=prj.buildings[-1].internal_id)\n\n\t\tprj.set_default(load_data=\"Test\")\n\n\tdef test_export_aixlib_only_iw(self):\n\t\t\"\"\"\n\t\tTests AixLib output for a building with inner walls only\n\t\t\"\"\"\n\n\t\tfrom teaser.logic.buildingobjects.building import Building\n\n\t\tprj.set_default(load_data=True)\n\n\t\tbldg = Building(parent=prj)\n\t\tbldg.name = \"SuperExampleBuilding\"\n\t\tbldg.street_name = \"AwesomeAvenue42\"\n\t\tbldg.city = \"46325FantasticTown\"\n\t\tbldg.year_of_construction = 2015\n\t\tbldg.number_of_floors = 1\n\t\tbldg.height_of_floors = 3.5\n\n\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone\n\n\t\ttz = ThermalZone(parent=bldg)\n\t\ttz.name = \"LivingRoom\"\n\t\ttz.area = 140.0\n\t\ttz.volume = tz.area * bldg.number_of_floors * bldg.height_of_floors\n\t\ttz.infiltration_rate = 0.5\n\n\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions\n\n\t\ttz.use_conditions = UseConditions(parent=tz)\n\t\ttz.use_conditions.load_use_conditions(\"Living\", prj.data)\n\n\t\tfrom teaser.logic.buildingobjects.buildingphysics.innerwall import InnerWall\n\n\t\tin_wall_dict = {\n\t\t\t\"InnerWall1\": [10.0],\n\t\t\t\"InnerWall2\": [14.0],\n\t\t\t\"InnerWall3\": [10.0],\n\t\t}\n\n\t\tfor key, value in in_wall_dict.items():\n\n\t\t\tin_wall = InnerWall(parent=tz)\n\t\t\tin_wall.name = key\n\t\t\tin_wall.load_type_element(\n\t\t\t\tyear=bldg.year_of_construction, construction=\"heavy\"\n\t\t\t)\n\t\t\tin_wall.area = value[0]\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\tdef test_export_only_ow(self):\n\t\t\"\"\"\n\t\tTests AixLib output for a building with outer walls only\n\t\t\"\"\"\n\n\t\tfrom teaser.logic.buildingobjects.building import Building\n\n\t\tbldg = Building(parent=prj)\n\t\tbldg.name = \"SuperExampleBuilding\"\n\t\tbldg.street_name = \"AwesomeAvenue42\"\n\t\tbldg.city = \"46325FantasticTown\"\n\t\tbldg.year_of_construction = 2015\n\t\tbldg.number_of_floors = 1\n\t\tbldg.height_of_floors = 3.5\n\n\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone\n\n\t\ttz = ThermalZone(parent=bldg)\n\t\ttz.name = \"LivingRoom\"\n\t\ttz.area = 140.0\n\t\ttz.volume = tz.area * bldg.number_of_floors * bldg.height_of_floors\n\t\ttz.infiltration_rate = 0.5\n\n\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions\n\n\t\ttz.use_conditions = UseConditions(parent=tz)\n\t\ttz.use_conditions.load_use_conditions(\"Living\", prj.data)\n\n\t\tfrom teaser.logic.buildingobjects.buildingphysics.outerwall import OuterWall\n\n\t\tout_wall_dict = {\n\t\t\t\"OuterWall_north\": [10.0, 90.0, 0.0],\n\t\t\t\"OuterWall_east\": [14.0, 90.0, 90.0],\n\t\t\t\"OuterWall_south\": [10.0, 90.0, 180.0],\n\t\t\t\"OuterWall_west\": [14.0, 90.0, 270.0],\n\t\t}\n\n\t\tfor key, value in out_wall_dict.items():\n\t\t\tout_wall = OuterWall(parent=tz)\n\t\t\tout_wall.name = key\n\n\t\t\tout_wall.load_type_element(\n\t\t\t\tyear=bldg.year_of_construction, construction=\"heavy\"\n\t\t\t)\n\n\t\t\tout_wall.area = value[0]\n\t\t\tout_wall.tilt = value[1]\n\t\t\tout_wall.orientation = value[2]\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\tdef test_export_only_win(self):\n\t\t\"\"\"\n\t\tTests AixLib output for a building with windows only\n\t\t\"\"\"\n\n\t\tfrom teaser.logic.buildingobjects.building import Building\n\n\t\tbldg = Building(parent=prj)\n\t\tbldg.name = \"SuperExampleBuilding\"\n\t\tbldg.street_name = \"AwesomeAvenue42\"\n\t\tbldg.city = \"46325FantasticTown\"\n\t\tbldg.year_of_construction = 2015\n\t\tbldg.number_of_floors = 1\n\t\tbldg.height_of_floors = 3.5\n\n\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone\n\n\t\ttz = ThermalZone(parent=bldg)\n\t\ttz.name = \"LivingRoom\"\n\t\ttz.area = 140.0\n\t\ttz.volume = tz.area * bldg.number_of_floors * bldg.height_of_floors\n\t\ttz.infiltration_rate = 0.5\n\n\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions\n\n\t\ttz.use_conditions = UseConditions(parent=tz)\n\t\ttz.use_conditions.load_use_conditions(\"Living\", prj.data)\n\n\t\tfrom teaser.logic.buildingobjects.buildingphysics.window import Window\n\t\tfrom teaser.logic.buildingobjects.buildingphysics.layer import Layer\n\t\tfrom teaser.logic.buildingobjects.buildingphysics.material import Material\n\n\t\twin_dict = {\n\t\t\t\"Window_east\": [5.0, 90.0, 90.0],\n\t\t\t\"Window_south\": [8.0, 90.0, 180.0],\n\t\t\t\"Window_west\": [5.0, 90.0, 270.0],\n\t\t}\n\n\t\tfor key, value in win_dict.items():\n\n\t\t\twin = Window(parent=tz)\n\t\t\twin.name = key\n\t\t\twin.area = value[0]\n\t\t\twin.tilt = value[1]\n\t\t\twin.orientation = value[2]\n\n\t\t\twin.inner_convection = 1.7\n\t\t\twin.inner_radiation = 5.0\n\t\t\twin.outer_convection = 20.0\n\t\t\twin.outer_radiation = 5.0\n\t\t\twin.g_value = 0.789\n\t\t\twin.a_conv = 0.03\n\t\t\twin.shading_g_total = 0.0\n\t\t\twin.shading_max_irr = 180.0\n\n\t\t\twin_layer = Layer(parent=win)\n\t\t\twin_layer.id = 1\n\t\t\twin_layer.thickness = 0.024\n\n\t\t\twin_material = Material(win_layer)\n\t\t\twin_material.name = \"GlasWindow\"\n\t\t\twin_material.thermal_conduc = 0.067\n\t\t\twin_material.transmittance = 0.9\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = True\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\tdef test_export_only_rt(self):\n\t\t\"\"\"\n\t\tTests AixLib output for a building with rooftops only\n\t\t\"\"\"\n\n\t\tfrom teaser.logic.buildingobjects.building import Building\n\n\t\tbldg = Building(parent=prj)\n\t\tbldg.name = \"SuperExampleBuilding\"\n\t\tbldg.street_name = \"AwesomeAvenue42\"\n\t\tbldg.city = \"46325FantasticTown\"\n\t\tbldg.year_of_construction = 2015\n\t\tbldg.number_of_floors = 1\n\t\tbldg.height_of_floors = 3.5\n\n\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone\n\n\t\ttz = ThermalZone(parent=bldg)\n\t\ttz.name = \"LivingRoom\"\n\t\ttz.area = 140.0\n\t\ttz.volume = tz.area * bldg.number_of_floors * bldg.height_of_floors\n\t\ttz.infiltration_rate = 0.5\n\n\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions\n\n\t\ttz.use_conditions = UseConditions(parent=tz)\n\t\ttz.use_conditions.load_use_conditions(\"Living\", prj.data)\n\n\t\tfrom teaser.logic.buildingobjects.buildingphysics.rooftop import Rooftop\n\n\t\troof_south = Rooftop(parent=tz)\n\t\troof_south.name = \"Roof_South\"\n\t\troof_south.area = 75.0\n\t\troof_south.orientation = 180.0\n\t\troof_south.tilt = 55.0\n\t\troof_south.inner_convection = 1.7\n\t\troof_south.outer_convection = 20.0\n\t\troof_south.inner_radiation = 5.0\n\t\troof_south.outer_radiation = 5.0\n\n\t\troof_north = Rooftop(parent=tz)\n\t\troof_north.name = \"Roof_North\"\n\t\troof_north.area = 75.0\n\t\troof_north.orientation = 0.0\n\t\troof_north.tilt = 55.0\n\t\troof_north.inner_convection = 1.7\n\t\troof_north.outer_convection = 20.0\n\t\troof_north.inner_radiation = 5.0\n\t\troof_north.outer_radiation = 5.0\n\n\t\tfrom teaser.logic.buildingobjects.buildingphysics.layer import Layer\n\n\t\tlayer_s1 = Layer(parent=roof_south, id=0)\n\t\tlayer_s1.thickness = 0.3\n\n\t\tfrom teaser.logic.buildingobjects.buildingphysics.material import Material\n\n\t\tmaterial_s1 = Material(layer_s1)\n\t\tmaterial_s1.name = \"Insulation\"\n\t\tmaterial_s1.density = 120.0\n\t\tmaterial_s1.heat_capac = 0.04\n\t\tmaterial_s1.thermal_conduc = 1.0\n\n\t\tlayer_s2 = Layer(parent=roof_south, id=1)\n\t\tlayer_s2.thickness = 0.15\n\n\t\tmaterial_s2 = Material(layer_s2)\n\t\tmaterial_s2.name = \"Tile\"\n\t\tmaterial_s2.density = 1400.0\n\t\tmaterial_s2.heat_capac = 0.6\n\t\tmaterial_s2.thermal_conduc = 2.5\n\n\t\tlayer_n1 = Layer(parent=roof_north, id=0)\n\t\tlayer_n1.thickness = 0.3\n\n\t\tmaterial_n1 = Material(layer_n1)\n\t\tmaterial_n1.name = \"Insulation\"\n\t\tmaterial_n1.density = 120.0\n\t\tmaterial_n1.heat_capac = 0.04\n\t\tmaterial_n1.thermal_conduc = 1.0\n\n\t\tlayer_n2 = Layer(parent=roof_north, id=1)\n\t\tlayer_n2.thickness = 0.15\n\n\t\tmaterial_n2 = Material(layer_n2)\n\t\tmaterial_n2.name = \"Tile\"\n\t\tmaterial_n2.density = 1400.0\n\t\tmaterial_n2.heat_capac = 0.6\n\t\tmaterial_n2.thermal_conduc = 2.5\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\tdef test_export_only_gf(self):\n\t\t\"\"\"\n\t\tTests AixLib output for a building with ground floors only\n\t\t\"\"\"\n\n\t\tfrom teaser.logic.buildingobjects.building import Building\n\n\t\tbldg = Building(parent=prj)\n\t\tbldg.name = \"SuperExampleBuilding\"\n\t\tbldg.street_name = \"AwesomeAvenue42\"\n\t\tbldg.city = \"46325FantasticTown\"\n\t\tbldg.year_of_construction = 2015\n\t\tbldg.number_of_floors = 1\n\t\tbldg.height_of_floors = 3.5\n\n\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone\n\n\t\ttz = ThermalZone(parent=bldg)\n\t\ttz.name = \"LivingRoom\"\n\t\ttz.area = 140.0\n\t\ttz.volume = tz.area * bldg.number_of_floors * bldg.height_of_floors\n\t\ttz.infiltration_rate = 0.5\n\n\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions\n\n\t\ttz.use_conditions = UseConditions(parent=tz)\n\t\ttz.use_conditions.load_use_conditions(\"Living\", prj.data)\n\n\t\tfrom teaser.logic.buildingobjects.buildingphysics.groundfloor import GroundFloor\n\n\t\tground_floor_dict = {\"GroundFloor\": [100.0, 0.0, -2]}\n\n\t\tfor key, value in ground_floor_dict.items():\n\n\t\t\tground = GroundFloor(parent=tz)\n\t\t\tground.name = key\n\t\t\tground.load_type_element(\n\t\t\t\tyear=bldg.year_of_construction, construction=\"heavy\"\n\t\t\t)\n\t\t\tground.area = value[0]\n\t\t\tground.tilt = value[1]\n\t\t\tground.orientation = value[2]\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"AixLib\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n\n\t\tprj.number_of_elements_calc = 1\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 2\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 3\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\t\tprj.number_of_elements_calc = 4\n\t\tprj.merge_windows_calc = False\n\t\tprj.used_library_calc = \"IBPSA\"\n\t\tprj.calc_all_buildings()\n\t\tprj.export_ibpsa()\n\n\tdef test_ashrae_140_600(self):\n\n\t\tfrom teaser.examples.verification.verification_ASHRAE_140_600 import (\n\t\t\tmain as exmain,\n\t\t)\n\n\t\texmain(number_of_elements=1)\n\t\texmain(number_of_elements=2)\n\t\texmain(number_of_elements=3)\n\t\texmain(number_of_elements=4)\n\n\tdef test_ashrae_140_620(self):\n\n\t\tfrom teaser.examples.verification.verification_ASHRAE_140_620 import (\n\t\t\tmain as exmain,\n\t\t)\n\n\t\texmain(number_of_elements=1)\n\t\texmain(number_of_elements=2)\n\t\texmain(number_of_elements=3)\n\t\texmain(number_of_elements=4)\n\n\tdef test_ashrae_140_900(self):\n\n\t\tfrom teaser.examples.verification.verification_ASHRAE_140_900 import (\n\t\t\tmain as exmain,\n\t\t)\n\n\t\texmain(number_of_elements=1)\n\t\texmain(number_of_elements=2)\n\t\texmain(number_of_elements=3)\n\t\texmain(number_of_elements=4)\n\n\tdef test_ashrae_140_920(self):\n\n\t\tfrom teaser.examples.verification.verification_ASHRAE_140_920 import (\n\t\t\tmain as exmain,\n\t\t)\n\n\t\texmain(number_of_elements=1)\n\t\texmain(number_of_elements=2)\n\t\texmain(number_of_elements=3)\n\t\texmain(number_of_elements=4)\n\n\t# def test_type_bldg_residential_profiles(self):\n\t#\t \"\"\"\n\t#\t Verification of the type building generation of an office building.\n\t#\t Values are compared with TEASER3 values.\n\t#\t \"\"\"\n\t#\t from teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling \\\n\t#\t\t import SingleFamilyDwelling\n\t#\n\t#\t prj.set_default()\n\t#\t test_residential = SingleFamilyDwelling(parent=prj,\n\t#\t\t\t\t\t\t\t\t\t\t\t name=\"TestBuilding\",\n\t#\t\t\t\t\t\t\t\t\t\t\t year_of_construction=1988,\n\t#\t\t\t\t\t\t\t\t\t\t\t number_of_floors=3,\n\t#\t\t\t\t\t\t\t\t\t\t\t height_of_floors=3,\n\t#\t\t\t\t\t\t\t\t\t\t\t net_leased_area=2500)\n\t#\n\t#\t test_residential.generate_archetype()\n\t#\n\t#\t prj.calc_all_buildings()\n\t#\n\t#\t path_to_export = prj.export_aixlib(\n\t#\t\t internal_id=None,\n\t#\t\t path=None)\n\t#\n\t#\t from scipy.io import loadmat\n\t#\t file = loadmat(os.path.join(\n\t#\t\t path_to_export,\n\t#\t\t \"TestBuilding\",\n\t#\t\t \"InternalGains_TestBuilding.mat\"))\n\t#\n\t#\t use_cond = test_residential.thermal_zones[0].use_conditions\n\t#\n\t#\t assert (file['Internals'].transpose()[1][1:] ==\n\t#\t\t\t use_cond.profile_persons).all()\n\t#\n\t#\t assert (file['Internals'].transpose()[2][1:] ==\n\t#\t\t\t use_cond.profile_machines).all()\n\t#\n\t#\t assert (file['Internals'].transpose()[3][1:] ==\n\t#\t\t\t use_cond.profile_lighting).all()\n\n\tdef test_ahu_profiles(self):\n\t\t\"\"\"Test setting AHU profiles of different lengths\n\n\t\tRelated to issue 553 at https://github.com/RWTH-EBC/TEASER/issues/553\n\t\t\"\"\"\n\n\t\tprj_test = Project(load_data=True)\n\t\tprj_test.name = \"TestAHUProfiles\"\n\n\t\tprj_test.add_non_residential(\n\t\t\tmethod=\"bmvbs\",\n\t\t\tusage=\"office\",\n\t\t\tname=\"OfficeBuilding\",\n\t\t\tyear_of_construction=2015,\n\t\t\tnumber_of_floors=4,\n\t\t\theight_of_floors=3.5,\n\t\t\tnet_leased_area=1000.0,\n\t\t)\n\n\t\tprj_test.used_library_calc = \"AixLib\"\n\t\tprj_test.number_of_elements_calc = 2\n\n\t\tv_flow_workday = [\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t1.0,\n\t\t\t1.0,\n\t\t\t1.0,\n\t\t\t1.0,\n\t\t\t1.0,\n\t\t\t1.0,\n\t\t\t1.0,\n\t\t\t1.0,\n\t\t\t1.0,\n\t\t\t1.0,\n\t\t\t1.0,\n\t\t\t1.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t\t0.0,\n\t\t]\n\n\t\tv_flow_week = []\n\t\tfor day in range(7):\n\t\t\tfor val in v_flow_workday:\n\t\t\t\tif day < 5:\n\t\t\t\t\tratio = val\n\t\t\t\telse:\n\t\t\t\t\tif val == 1:\n\t\t\t\t\t\tratio = 0.2\n\t\t\t\t\telse:\n\t\t\t\t\t\tratio = 0.0\n\t\t\t\tv_flow_week.append(ratio)\n\n\t\tprj_test.buildings[-1].central_ahu.profile_v_flow = v_flow_week\n\n\t\tassert prj_test.buildings[-1].central_ahu.profile_v_flow == v_flow_week\n\n\tdef test_export_bldg_threshold(self):\n\n\t\tprj.set_default(load_data=True)\n\n\t\tprj.add_non_residential(\n\t\t\tmethod=\"bmvbs\",\n\t\t\tusage=\"institute\",\n\t\t\tname=\"TestBuilding\",\n\t\t\tyear_of_construction=1988,\n\t\t\tnumber_of_floors=7,\n\t\t\theight_of_floors=1,\n\t\t\tnet_leased_area=1988,\n\t\t\twith_ahu=True,\n\t\t\toffice_layout=0,\n\t\t\twindow_layout=0,\n\t\t\tconstruction_type=\"heavy\",\n\t\t)\n\t\tprj.buildings[-1].thermal_zones[0].use_conditions.with_ahu = True\n\t\tprj.buildings[-1].thermal_zones[0].use_conditions.with_ideal_thresholds = True\n\t\tprj.buildings[-1].thermal_zones[1].use_conditions.with_ahu = False\n\t\tprj.buildings[-1].thermal_zones[1].use_conditions.with_ideal_thresholds = False\n\t\tprj.buildings[-1].thermal_zones[-1].use_conditions.with_ahu = True\n\t\tprj.buildings[-1].thermal_zones[-1].use_conditions.with_ideal_thresholds = True\n\t\tprj.calc_all_buildings()\n\t\tprj.export_aixlib()\n", "description": "Unit Tests for TEASER", "category": "math", "imports": ["from teaser.logic import utilities", "from teaser.project import Project", "import math", "import os", "import helptest", "import warnings as warnings", "\t\timport teaser.examples.verification.verification_VDI_6007_room1 as room1", "\t\timport teaser.examples.verification.verification_VDI_6007_room3 as room3", "\t\timport teaser.examples.verification.verification_VDI_6007_room8 as room8", "\t\tfrom teaser.logic.archetypebuildings.bmvbs.office import Office", "\t\tfrom teaser.logic.archetypebuildings.bmvbs.custom.institute4 import Institute4", "\t\tfrom teaser.logic.archetypebuildings.bmvbs.custom.institute8 import Institute8", "\t\tfrom teaser.logic.archetypebuildings.bmvbs.custom.institute import Institute", "\t\tfrom teaser.logic.archetypebuildings.bmvbs.singlefamilydwelling import (", "\t\tfrom teaser.logic.buildingobjects.calculation.one_element import OneElement", "\t\tfrom teaser.logic.buildingobjects.calculation.one_element import OneElement", "\t\tfrom teaser.logic.buildingobjects.calculation.two_element import TwoElement", "\t\tfrom teaser.logic.buildingobjects.calculation.two_element import TwoElement", "\t\tfrom teaser.logic.buildingobjects.calculation.three_element import ThreeElement", "\t\tfrom teaser.logic.buildingobjects.calculation.three_element import ThreeElement", "\t\tfrom teaser.logic.buildingobjects.calculation.four_element import FourElement", "\t\tfrom teaser.logic.buildingobjects.calculation.four_element import FourElement", "\t\timport os", "\t\timport os", "\t\tfrom teaser.logic.buildingobjects.buildingphysics.material import Material", "\t\tfrom teaser.data.dataclass import DataClass", "\t\tfrom teaser.logic.buildingobjects.building import Building", "\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone", "\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions", "\t\tfrom teaser.logic.buildingobjects.building import Building", "\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone", "\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions", "\t\tfrom teaser.logic.buildingobjects.buildingphysics.innerwall import InnerWall", "\t\tfrom teaser.logic.buildingobjects.building import Building", "\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone", "\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions", "\t\tfrom teaser.logic.buildingobjects.buildingphysics.outerwall import OuterWall", "\t\tfrom teaser.logic.buildingobjects.building import Building", "\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone", "\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions", "\t\tfrom teaser.logic.buildingobjects.buildingphysics.window import Window", "\t\tfrom teaser.logic.buildingobjects.buildingphysics.layer import Layer", "\t\tfrom teaser.logic.buildingobjects.buildingphysics.material import Material", "\t\tfrom teaser.logic.buildingobjects.building import Building", "\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone", "\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions", "\t\tfrom teaser.logic.buildingobjects.buildingphysics.rooftop import Rooftop", "\t\tfrom teaser.logic.buildingobjects.buildingphysics.layer import Layer", "\t\tfrom teaser.logic.buildingobjects.buildingphysics.material import Material", "\t\tfrom teaser.logic.buildingobjects.building import Building", "\t\tfrom teaser.logic.buildingobjects.thermalzone import ThermalZone", "\t\tfrom teaser.logic.buildingobjects.useconditions import UseConditions", "\t\tfrom teaser.logic.buildingobjects.buildingphysics.groundfloor import GroundFloor", "\t\tfrom teaser.examples.verification.verification_ASHRAE_140_600 import (", "\t\tfrom teaser.examples.verification.verification_ASHRAE_140_620 import (", "\t\tfrom teaser.examples.verification.verification_ASHRAE_140_900 import (", "\t\tfrom teaser.examples.verification.verification_ASHRAE_140_920 import (", "\t#\t\t import SingleFamilyDwelling", "\t#\t from scipy.io import loadmat"]}], [{"term": "class", "name": "TestTax", "data": "class TestTax(unittest.TestCase):\n\n\tdef test_calc_tax_negative_age_should_raise_error(self):\n\t\tself.assertRaises(ValueError, calc_tax, 60000, 0.20, -10)\n\n\tdef test_calc_tax_negative_tax_rate_should_raise_error(self):\n\t\tself.assertRaises(ValueError, calc_tax, 60000, -0.20, 10)\n\n\tdef test_calc_tax_negative_amount_should_raise_error(self):\n\t\tself.assertRaises(ValueError, calc_tax, -60000, 0.20, 10)\n\n\tdef test_calc_tax_incorrect_age_type(self):\n\t\tself.assertRaises(TypeError, calc_tax, 60000, 0.20, '10')\n\n\tdef test_calc_tax_incorrect_amount_type(self):\n\t\tself.assertRaises(TypeError, calc_tax, '60000', 0.20, 10)\n\n\tdef test_calc_tax_incorrect_tax_rate_type(self):\n\t\tself.assertRaises(TypeError, calc_tax, 60000, '0.20', 10)\n\n\tdef test_calc_tax(self):\n\t\tself.assertEqual(calc_tax(60000, 0.20, 10), 5000)\n\t\tself.assertAlmostEqual(calc_tax(60000, 0.20, 10), 5000)\n\n\tdef test_calc_tax_eighteen_age_and_below(self):\n\t\tself.assertEqual(calc_tax(60000, 0.2, 18), 5000)\n\t\tself.assertEqual(calc_tax(25000, 0.2, 18), 5000)\n\t\tself.assertLessEqual(calc_tax(20000, 0.2, 18), 5000)\n\n\tdef test_calc_tax_sixty_five_age_above(self):\n\t\tself.assertEqual(calc_tax(60000, 0.20, 66), 8000)\n\t\tself.assertEqual(calc_tax(60000, 0.20, 65), 12000)\n\t\tself.assertLessEqual(calc_tax(35000, 0.20, 65), 12000)\n\n\tdef test_calc_tax_between_18_and_65_age(self):\n\t\tself.assertEqual(calc_tax(60000, 0.2, 30), 12000)\n\t\tself.assertGreaterEqual(calc_tax(60000, 0.2, 30), 5000)\n", "description": null, "category": "math", "imports": ["import unittest", "from tax import calc_tax"]}], [{"term": "class", "name": "TestWriteCalcPr", "data": "class TestWriteCalcPr(unittest.TestCase):\n\t\"\"\"\n\tTest the Workbook _write_calc_pr() method.\n\n\t\"\"\"\n\n\tdef setUp(self):\n\t\tself.fh = StringIO()\n\t\tself.workbook = Workbook()\n\t\tself.workbook._set_filehandle(self.fh)\n\n\tdef test_write_calc_pr(self):\n\t\t\"\"\"Test the _write_calc_pr() method.\"\"\"\n\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef test_calc_mode_auto_except_tables(self):\n\t\t\"\"\"\n\t\tTest the _write_calc_pr() method with the calculation mode set\n\t\tto auto_except_tables.\n\n\t\t\"\"\"\n\n\t\tself.workbook.set_calc_mode(\"auto_except_tables\")\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef test_calc_mode_manual(self):\n\t\t\"\"\"\n\t\tTest the _write_calc_pr() method with the calculation mode set to\n\t\tmanual.\n\n\t\t\"\"\"\n\n\t\tself.workbook.set_calc_mode(\"manual\")\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef test_write_calc_pr(self):\n\t\t\"\"\"Test the _write_calc_pr() method with non-default calc id.\"\"\"\n\n\t\tself.workbook.set_calc_mode(\"auto\", 12345)\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef tearDown(self):\n\t\tself.workbook.fileclosed = 1\n", "description": "\n\tTest the Workbook _write_calc_pr() method.\n\n\t", "category": "math", "imports": ["import unittest", "from ...compatibility import StringIO", "from ...workbook import Workbook"]}], [{"term": "def", "name": "entrada", "data": "def entrada(rec):\r\n\tglobal calc,lbVisor,temp,op,lbVisor2\r\n\tif len(calc) > 1 and calc[1].isdigit():\r\n\t\tcalc = calc.lstrip('0')\r\n\t\tlbVisor.config(text=calc)\r\n\t#ENTRADA VIA BOTAO\r\n\ttry:\r\n\t\tif rec.widget==bt0:\r\n\t\t\tcalc+=\"0\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==bt1:\r\n\t\t\tcalc+=\"1\"\r\n\t\t\tlbVisor.config(text=calc)\t\t\r\n\t\telif rec.widget==bt2:\r\n\t\t\tcalc+=\"2\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==bt3:\r\n\t\t\tcalc+=\"3\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==bt4:\r\n\t\t\tcalc+=\"4\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==bt5:\r\n\t\t\tcalc+=\"5\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==bt6:\r\n\t\t\tcalc+=\"6\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==bt7:\r\n\t\t\tcalc+=\"7\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==bt8:\r\n\t\t\tcalc+=\"8\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==bt9:\r\n\t\t\tcalc+=\"9\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==btPonto:\r\n\t\t\tcalc+=\".\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==btPercert:\r\n\t\t\ti=0\r\n\t\t\tpos=0\r\n\t\t\twhile i < len(calc):\r\n\t\t\t\tl = calc[i]\r\n\t\t\t\tif (l==\"+\" or (l==\"-\") or (l==\"*\") or (l==\"/\")):\r\n\t\t\t\t\tpos = i\r\n\t\t\t\ti+=1\r\n\t\t\top=calc[pos]\r\n\t\t\ti=0\r\n\t\t\tnCalc=\"\"\r\n\t\t\twhile i < pos:\r\n\t\t\t\tl = calc[i]\r\n\t\t\t\tnCalc+=l\r\n\t\t\t\ti+=1\r\n\t\t\ti=0\r\n\t\t\tpos=pos+1\r\n\t\t\trest=\"\"\r\n\t\t\twhile pos < len(calc):\r\n\t\t\t\tl = calc[pos]\r\n\t\t\t\trest+=l\r\n\t\t\t\tpos+=1\r\n\t\t\tres = eval(nCalc)  \r\n\t\t\tif op == \"+\":\r\n\t\t\t\t\trs=float(res)/100*float(rest)\r\n\t\t\t\t\tcalc=float(res)+rs\r\n\t\t\telif op == \"-\":\r\n\t\t\t\t\trs=float(res)/100*float(rest)\r\n\t\t\t\t\tcalc=float(res)-rs\r\n\t\t\telif op == \"*\":\r\n\t\t\t\t\trs=float(res)/100*float(rest)\r\n\t\t\t\t\tcalc=rs\r\n\t\t\telif op == \"/\":\r\n\t\t\t\t\trs=float(res)/100*float(rest)\r\n\t\t\t\t\tcalc=float(res)/rs\r\n\t\t\tcalc=str(calc)\r\n\t\t\tlbVisor2.config(text=calc)\r\n\t\telif rec.widget==btSoma:\r\n\t\t\tcalc+=\"+\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==btSubi:\r\n\t\t\tcalc+=\"-\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==btMult:\r\n\t\t\tcalc+=\"*\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==btDiv:\r\n\t\t\tcalc+=\"/\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==btRaiz:\r\n\t\t\ttry:\r\n\t\t\t\tres = eval(calc)  \r\n\t\t\t\traiz = math.sqrt(res)\r\n\t\t\t\tcalc = str(raiz)\r\n\t\t\t\tlbVisor2.config(text=calc)\r\n\t\t\texcept:\r\n\t\t\t\tlbVisor2.config(text=\"erro!\")\r\n\t\telif rec.widget==btPoten:\r\n\t\t\tres = eval(calc) \r\n\t\t\tif temp == \"\":\r\n\t\t\t\ttemp=res\r\n\t\t\t\ttemp=str(temp)\r\n\t\t\t\tcalc=\"\"\r\n\t\t\t\tlbVisor.config(text=calc)\r\n\t\t\t\tlbVisor2.config(text=temp+\"^\")\r\n\t\t\telse:\r\n\t\t\t\tn1=float(temp)\r\n\t\t\t\tn2=float(res)\r\n\t\t\t\tcalc=(n1 ** n2)\r\n\t\t\t\ttemp=\"\"\r\n\t\t\t\tcalc= str(calc)\r\n\t\t\t\tlbVisor.config(text=str(res))\r\n\t\t\t\tlbVisor2.config(text=calc)\r\n\t\t\t\tteste=(2.1 ** 5.1)\r\n\t\t\t\tprint(teste)\r\n\t\telif rec.widget==btFseno:\r\n\t\t\ttry:\r\n\t\t\t\tres = eval(calc)\r\n\t\t\t\tcalc= str(res)\r\n\t\t\t\tlbVisor.config(text= calc)\t\t\r\n\t\t\t\tres=float(res)\r\n\t\t\t\trd = math.radians(res)\r\n\t\t\t\tseno= math.sin(rd)\r\n\t\t\t\tcalc= str(seno)\r\n\t\t\t\tlbVisor2.config(text= calc)  \r\n\t\t\texcept:\r\n\t\t\t\tlbVisor2.config(text=\"erro!\")\r\n\t\telif rec.widget==btFcose:\r\n\t\t\ttry:\r\n\t\t\t\tres = eval(calc)\r\n\t\t\t\tcalc= str(res)\r\n\t\t\t\tlbVisor.config(text= calc)\t\t\r\n\t\t\t\tres=float(res)\r\n\t\t\t\trd = math.radians(res)\r\n\t\t\t\tcose= math.cos(rd)\r\n\t\t\t\tcalc= str(cose)\r\n\t\t\t\tlbVisor2.config(text= calc)  \r\n\t\t\texcept:\r\n\t\t\t\tlbVisor2.config(text=\"erro!\")\r\n\t\telif rec.widget==btFtang:\r\n\t\t\ttry:\r\n\t\t\t\tres = eval(calc)\r\n\t\t\t\tcalc= str(res)\r\n\t\t\t\tlbVisor.config(text= calc)\t\t\r\n\t\t\t\tres=float(res)\r\n\t\t\t\trd = math.radians(res)\r\n\t\t\t\ttam= math.tan(rd)\r\n\t\t\t\tcalc= str(tam)\r\n\t\t\t\tlbVisor2.config(text= calc)  \r\n\t\t\texcept:\r\n\t\t\t\tlbVisor2.config(text=\"erro!\")\r\n\t\telif rec.widget==btLimpa:\r\n\t\t\tcalc = \"\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\t\tlbVisor2.config(text=calc)\r\n\t\telif rec.widget==btApaga:\r\n\t\t\tcalc = calc[:-1]\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec.widget==btIgual:\r\n\t\t\ttry:\r\n\t\t\t\tres = eval(calc)  \r\n\t\t\t\tcalc= str(res)\r\n\t\t\t\tlbVisor2.config(text= calc)\t   \r\n\t\t\texcept:\r\n\t\t\t\tlbVisor2.config(text=\"erro!\")\r\n\t#ENTRA VIA TELCADO \r\n\texcept:\r\n\t\tif rec==\"0\":\r\n\t\t\tcalc+=\"0\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"1\":\r\n\t\t\tcalc+=\"1\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"2\":\r\n\t\t\tcalc+=\"2\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"3\":\r\n\t\t\tcalc+=\"3\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"4\":\r\n\t\t\tcalc+=\"4\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"5\":\r\n\t\t\tcalc+=\"5\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"6\":\r\n\t\t\tcalc+=\"6\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"7\":\r\n\t\t\tcalc+=\"7\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"8\":\r\n\t\t\tcalc+=\"8\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"9\":\r\n\t\t\tcalc+=\"9\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\".\":\r\n\t\t\tcalc+=\".\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"shift+5\":\r\n\t\t\ti=0\r\n\t\t\tpos=0\r\n\t\t\twhile i < len(calc):\r\n\t\t\t\tl = calc[i]\r\n\t\t\t\tif (l==\"+\" or (l==\"-\") or (l==\"*\") or (l==\"/\")):\r\n\t\t\t\t\tpos = i\r\n\t\t\t\ti+=1\r\n\t\t\top=calc[pos]\r\n\t\t\ti=0\r\n\t\t\tnCalc=\"\"\r\n\t\t\twhile i < pos:\r\n\t\t\t\tl = calc[i]\r\n\t\t\t\tnCalc+=l\r\n\t\t\t\ti+=1\r\n\t\t\ti=0\r\n\t\t\tpos=pos+1\r\n\t\t\trest=\"\"\r\n\t\t\twhile pos < len(calc):\r\n\t\t\t\tl = calc[pos]\r\n\t\t\t\trest+=l\r\n\t\t\t\tpos+=1\r\n\t\t\tres = eval(nCalc)  \r\n\t\t\tif op == \"+\":\r\n\t\t\t\t\trs=float(res)/100*float(rest)\r\n\t\t\t\t\tcalc=float(res)+rs\r\n\t\t\telif op == \"-\":\r\n\t\t\t\t\trs=float(res)/100*float(rest)\r\n\t\t\t\t\tcalc=float(res)-rs\r\n\t\t\telif op == \"*\":\r\n\t\t\t\t\trs=float(res)/100*float(rest)\r\n\t\t\t\t\tcalc=rs\r\n\t\t\telif op == \"/\":\r\n\t\t\t\t\trs=float(res)/100*float(rest)\r\n\t\t\t\t\tcalc=float(res)/rs\r\n\t\t\tcalc=str(calc)\r\n\t\t\tlbVisor2.config(text=calc)\r\n\t\telif rec==\"+\":\r\n\t\t\tcalc+=\"+\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"-\":\r\n\t\t\tcalc+=\"-\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"*\":\r\n\t\t\tcalc+=\"*\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"/\":\r\n\t\t\tcalc+=\"/\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"esc\":\r\n\t\t\tcalc= \"\"\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\t\tlbVisor2.config(text=calc)\r\n\t\telif rec==\"backspace\":\r\n\t\t\tcalc = calc[:-1]\r\n\t\t\tlbVisor.config(text=calc)\r\n\t\telif rec==\"enter\":\r\n\t\t\ttry:\r\n\t\t\t\tres = eval(calc)  \r\n\t\t\t\tcalc= str(res)\r\n\t\t\t\tlbVisor2.config(text= calc)\t   \r\n\t\t\texcept:\r\n\t\t\t\tlbVisor2.config(text=\"erro!\")\r\n\r\n", "description": null, "category": "math", "imports": ["from tkinter import *\r", "import keyboard\r", "import string\r", "from threading import *\r", "import math\r"]}, {"term": "def", "name": "listen", "data": "def listen(tecla):\r\n\twhile True:\r\n\t\tkeyboard.wait(tecla)\r\n\t\tentrada(tecla)\r\n\t\tprint(\"- Tecla pressionada: \",tecla)\r\n", "description": null, "category": "math", "imports": ["from tkinter import *\r", "import keyboard\r", "import string\r", "from threading import *\r", "import math\r"]}], [], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "test_calc_score1", "data": "def test_calc_score1():\n\tassert scoring.calc_score(\"2:1,1,2,2\") == \"2,6\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score2", "data": "def test_calc_score2():\n\tassert scoring.calc_score(\"3:1,4,6,4,7,0\") == \"5,22,29\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score3", "data": "def test_calc_score3():\n\tassert scoring.calc_score(\"3:0,0,9,1,0,0\") == \"0,10,10\"\n\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score4", "data": "def test_calc_score4():\n\tassert scoring.calc_score(\"3:1,2,6,4,5,2\") == \"3,18,25\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score5", "data": "def test_calc_score5():\n\tassert scoring.calc_score(\"2:1,2,6,4,5\") == \"3,18\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score6", "data": "def test_calc_score6():\n\tassert scoring.calc_score(\"1:2,8,5\") == \"15\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score7", "data": "def test_calc_score7():\n\tassert scoring.calc_score(\"3:0,0,9,1,0,0\") == \"0,10,10\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score8", "data": "def test_calc_score8():\n\tassert scoring.calc_score(\"4:1,5,5,5,4,6,8,1\") == \"6,20,38,47\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score9", "data": "def test_calc_score9():\n\tassert scoring.calc_score(\"3:1,5,5,5,4,6,8\") == \"6,20,38\"\n\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score10", "data": "def test_calc_score10():\n\tassert scoring.calc_score(\"3:1,4,10,2,5\") == \"5,22,29\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score11", "data": "def test_calc_score11():\n\tassert scoring.calc_score(\"1:10,1,3\") == \"14\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score12", "data": "def test_calc_score12():\n\tassert scoring.calc_score(\"3:3,4,10,1,2\") == \"7,20,23\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score13", "data": "def test_calc_score13():\n\tassert scoring.calc_score(\"2:3,4,10,1,2\") == \"7,20\"\n\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score14", "data": "def test_calc_score14():\n\tassert scoring.calc_score(\"4:1,4,10,10,3,6\") == \"5,28,47,56\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score15", "data": "def test_calc_score15():\n\tassert scoring.calc_score(\"3:10,10,10,3,6\") == \"30,53,72\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score16", "data": "def test_calc_score16():\n\tassert scoring.calc_score(\"4:1,5,10,10,1,7\") == \"6,27,45,53\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score17", "data": "def test_calc_score17():\n\tassert scoring.calc_score(\"3:1,5,10,10,1,7\") == \"6,27,45\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score18", "data": "def test_calc_score18():\n\tassert scoring.calc_score(\"3:1,4,10,7,3,8\") == \"5,25,43\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score19", "data": "def test_calc_score19():\n\tassert scoring.calc_score(\"2:7,3,10,1,4\") == \"20,35\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score20", "data": "def test_calc_score20():\n\tassert scoring.calc_score(\"4:2,7,10,4,6,4,5\") == \"9,29,43,52\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score21", "data": "def test_calc_score21():\n\tassert scoring.calc_score(\"4:2,7,4,6,10,4,5\") == \"9,29,48,57\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score22", "data": "def test_calc_score22():\n\tassert scoring.calc_score(\"3:2,7,4,6,10,4,5\") == \"9,29,48\"\n\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score23", "data": "def test_calc_score23():\n\tassert scoring.calc_score(\"10:1,4,4,5,6,4,5,5,10,0,1,7,3,6,4,10,2,8,6\") == \"5,14,29,49,60,61,77,97,117,133\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score24", "data": "def test_calc_score24():\n\tassert scoring.calc_score(\"10:1,4,4,5,6,4,5,5,10,0,1,7,3,6,4,10,2,8,6\") == \"5,14,29,49,60,61,77,97,117,133\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score25", "data": "def test_calc_score25():\n\tassert scoring.calc_score(\"10:0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\") == \"0,0,0,0,0,0,0,0,0,0\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score26", "data": "def test_calc_score26():\n\tassert scoring.calc_score(\"10:10,10,10,10,10,10,10,10,10,10,10,10\") == \"30,60,90,120,150,180,210,240,270,300\"\n", "description": null, "category": "math", "imports": ["import scoring"]}, {"term": "def", "name": "test_calc_score27", "data": "def test_calc_score27():\n\tassert scoring.calc_score(\"10:7,2,1,9,6,4,5,5,10,3,7,7,3,6,4,10,2,8,6\") == \"9,25,40,60,80,97,113,133,153,169\"\n\n", "description": null, "category": "math", "imports": ["import scoring"]}], [{"term": "def", "name": "test_h2dft_old", "data": "def test_h2dft_old(name):\n\tfactory = ObsoleteFactoryWrapper(name)\n\trun(factory)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "test_h2dft", "data": "def test_h2dft(factory):\n\trun(factory)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "run", "data": "def run(factory):\n\tname = factory.name\n\tpar = required.get(name, {})\n\tcalc = factory.calc(label=name, xc='LDA', **par)\n\th2 = molecule('H2', calculator=calc)\n\th2.center(vacuum=2.0)\n\te2 = h2.get_potential_energy()\n\tcalc.set(xc='PBE')\n\te2pbe = h2.get_potential_energy()\n\th1 = h2.copy()\n\tdel h1[1]\n\th1.set_initial_magnetic_moments([1])\n\th1.calc = calc\n\te1pbe = h1.get_potential_energy()\n\tcalc.set(xc='LDA')\n\te1 = h1.get_potential_energy()\n\ttry:\n\t\tm1 = h1.get_magnetic_moment()\n\texcept NotImplementedError:\n\t\tpass\n\telse:\n\t\tprint(m1)\n\tprint(2 * e1 - e2)\n\tprint(2 * e1pbe - e2pbe)\n\tprint(e1, e2, e1pbe, e2pbe)\n\tcalc = factory.calc(restart=name)\n\tprint(calc.parameters, calc.results, calc.atoms)\n\tassert not calc.calculation_required(h1, ['energy'])\n\th1 = calc.get_atoms()\n\tprint(h1.get_potential_energy())\n\tlabel = 'dir/' + name + '-h1'\n\tcalc = factory.calc(label=label, atoms=h1, xc='LDA', **par)\n\tprint(h1.get_potential_energy())\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import molecule", "from ase.test.factories import ObsoleteFactoryWrapper"]}], [{"term": "class", "name": "classSpline:", "data": "class Spline:\n\t\"\"\"\n\tCubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.b, self.c, self.d, self.w = [], [], [], []\n\n\t\tself.x = x\n\t\tself.y = y\n\n\t\tself.nx = len(x)  # dimension of x\n\t\th = np.diff(x)\n\n\t\t# calc coefficient c\n\t\tself.a = [iy for iy in y]\n\n\t\t# calc coefficient c\n\t\tA = self.__calc_A(h)\n\t\tB = self.__calc_B(h)\n\t\tself.c = np.linalg.solve(A, B)\n\t\t#  print(self.c1)\n\n\t\t# calc spline coefficient b and d\n\t\tfor i in range(self.nx - 1):\n\t\t\tself.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n\t\t\ttb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n\t\t\t\t(self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n\t\t\tself.b.append(tb)\n\n\tdef calc(self, t):\n\t\t\"\"\"\n\t\tCalc position\n\n\t\tif t is outside of the input x, return None\n\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.a[i] + self.b[i] * dx + \\\n\t\t\tself.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n\t\treturn result\n\n\tdef calcd(self, t):\n\t\t\"\"\"\n\t\tCalc first derivative\n\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n\t\treturn result\n\n\tdef calcdd(self, t):\n\t\t\"\"\"\n\t\tCalc second derivative\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n\t\treturn result\n\n\tdef __search_index(self, x):\n\t\t\"\"\"\n\t\tsearch data segment index\n\t\t\"\"\"\n\t\treturn bisect.bisect(self.x, x) - 1\n\n\tdef __calc_A(self, h):\n\t\t\"\"\"\n\t\tcalc matrix A for spline coefficient c\n\t\t\"\"\"\n\t\tA = np.zeros((self.nx, self.nx))\n\t\tA[0, 0] = 1.0\n\t\tfor i in range(self.nx - 1):\n\t\t\tif i != (self.nx - 2):\n\t\t\t\tA[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n\t\t\tA[i + 1, i] = h[i]\n\t\t\tA[i, i + 1] = h[i]\n\n\t\tA[0, 1] = 0.0\n\t\tA[self.nx - 1, self.nx - 2] = 0.0\n\t\tA[self.nx - 1, self.nx - 1] = 1.0\n\t\t#  print(A)\n\t\treturn A\n\n\tdef __calc_B(self, h):\n\t\t\"\"\"\n\t\tcalc matrix B for spline coefficient c\n\t\t\"\"\"\n\t\tB = np.zeros(self.nx)\n\t\tfor i in range(self.nx - 2):\n\t\t\tB[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n\t\t\t\th[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n\t\treturn B\n\n", "description": "\n\tCubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "class", "name": "classSpline2D:", "data": "class Spline2D:\n\t\"\"\"\n\t2D Cubic Spline class\n\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.s = self.__calc_s(x, y)\n\t\tself.sx = Spline(self.s, x)\n\t\tself.sy = Spline(self.s, y)\n\n\tdef __calc_s(self, x, y):\n\t\tdx = np.diff(x)\n\t\tdy = np.diff(y)\n\t\tself.ds = np.hypot(dx, dy)\n\t\ts = [0]\n\t\ts.extend(np.cumsum(self.ds))\n\t\treturn s\n\n\tdef calc_position(self, s):\n\t\t\"\"\"\n\t\tcalc position\n\t\t\"\"\"\n\t\tx = self.sx.calc(s)\n\t\ty = self.sy.calc(s)\n\n\t\treturn x, y\n\n\tdef calc_curvature(self, s):\n\t\t\"\"\"\n\t\tcalc curvature\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tddx = self.sx.calcdd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tddy = self.sy.calcdd(s)\n\t\tk = (ddy * dx - ddx * dy) / ((dx ** 2 + dy ** 2)**(3 / 2))\n\t\treturn k\n\n\tdef calc_yaw(self, s):\n\t\t\"\"\"\n\t\tcalc yaw\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tyaw = math.atan2(dy, dx)\n\t\treturn yaw\n\n", "description": "\n\t2D Cubic Spline class\n\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "calc_spline_course", "data": "def calc_spline_course(x, y, ds=0.1):\n\tsp = Spline2D(x, y)\n\ts = list(np.arange(0, sp.s[-1], ds))\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\treturn rx, ry, ryaw, rk, s\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():  # pragma: no cover\n\tprint(\"Spline 2D test\")\n\timport matplotlib.pyplot as plt\n\tx = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n\ty = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n\tds = 0.1  # [m] distance of each interpolated points\n\n\tsp = Spline2D(x, y)\n\ts = np.arange(0, sp.s[-1], ds)\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\tplt.subplots(1)\n\tplt.plot(x, y, \"xb\", label=\"input\")\n\tplt.plot(rx, ry, \"-r\", label=\"spline\")\n\tplt.grid(True)\n\tplt.axis(\"equal\")\n\tplt.xlabel(\"x[m]\")\n\tplt.ylabel(\"y[m]\")\n\tplt.legend()\n\n\tplt.subplots(1)\n\tplt.plot(s, [np.rad2deg(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"yaw angle[deg]\")\n\n\tplt.subplots(1)\n\tplt.plot(s, rk, \"-r\", label=\"curvature\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"curvature [1/m]\")\n\n\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "lemmatized_words", "data": "def lemmatized_words(doc):\r\n\treturn (wnl.lemmatize(w) for w in analyzer(doc))\r\n", "description": null, "category": "math", "imports": ["from sklearn.feature_extraction.text import CountVectorizer\r", "import pandas as pd\r", "from nltk.stem import WordNetLemmatizer\r", "import numpy as np\r", "from sklearn.neighbors import KNeighborsRegressor\r", "from sklearn.metrics import mean_squared_log_error\r", "from matplotlib import pyplot as plt\r"]}, {"term": "def", "name": "traintest", "data": "def traintest(test1, test2):\r\n\ttestdata = title_tags[test1: test2]\r\n\t#\t print testdata.head()\r\n\tdrop = pd.Series(range(test1, test2))\r\n\t#\t print drop\r\n\ttraindata = title_tags.drop(title_tags.index[[drop]])\r\n\t#\t traindata = title_tags[:]\r\n\t#\t traindata = traindata.drop(traindata.index[[test1,test2]])\r\n\t#\t print traindata.head()\r\n\ttrain_xformed = vectorizer.fit_transform(traindata.questions_title)\r\n\t# print train_xformed.shape\r\n\ttest_xformed = vectorizer.transform(testdata.questions_title)\r\n\t# print test_xformed.shape\r\n\ttime = traindata.time\r\n\ttime = time.astype('float64')\r\n\treturn (train_xformed, test_xformed, time)\r\n\r\n", "description": null, "category": "math", "imports": ["from sklearn.feature_extraction.text import CountVectorizer\r", "import pandas as pd\r", "from nltk.stem import WordNetLemmatizer\r", "import numpy as np\r", "from sklearn.neighbors import KNeighborsRegressor\r", "from sklearn.metrics import mean_squared_log_error\r", "from matplotlib import pyplot as plt\r"]}, {"term": "def", "name": "predictor", "data": "def predictor(ind1, ind2):\r\n\tans = []\r\n\tsplit = traintest(ind1, ind2)\r\n\tregressor = KNeighborsRegressor(n_neighbors=3, weights='distance')\r\n\tregressor = regressor.fit(split[0], split[2])\r\n\titerations = int((ind2 - ind1) / 200)\r\n\ti1 = 0\r\n\tneigh = [0] * 200\r\n\tdist = [0] * 200\r\n\tfor x in range(iterations):\r\n\t\ttest = split[1]\r\n\t\ty = regressor.predict(test[i1:(i1 + 200)])\r\n\t\tans.extend(y)\r\n\t\ti1 = i1 + 200\r\n\treturn ans\r\n\r\n", "description": null, "category": "math", "imports": ["from sklearn.feature_extraction.text import CountVectorizer\r", "import pandas as pd\r", "from nltk.stem import WordNetLemmatizer\r", "import numpy as np\r", "from sklearn.neighbors import KNeighborsRegressor\r", "from sklearn.metrics import mean_squared_log_error\r", "from matplotlib import pyplot as plt\r"]}, {"term": "def", "name": "calc_accuracy", "data": "def calc_accuracy(arr, ind1, ind2):\r\n\ttc = 0\r\n\ttimetest = title_tags[ind1:ind2].time.astype('float64')\r\n\tfor x, y in np.nditer([arr, timetest]):\r\n\t\tif abs(x - y) <= 36000:\r\n\t\t\ttc = tc + 1\r\n\treturn tc\r\n\r\n", "description": null, "category": "math", "imports": ["from sklearn.feature_extraction.text import CountVectorizer\r", "import pandas as pd\r", "from nltk.stem import WordNetLemmatizer\r", "import numpy as np\r", "from sklearn.neighbors import KNeighborsRegressor\r", "from sklearn.metrics import mean_squared_log_error\r", "from matplotlib import pyplot as plt\r"]}, {"term": "def", "name": "calc_meanlog", "data": "def calc_meanlog(arr, ind1, ind2):\r\n\ttimetest = title_tags[ind1:ind2].time.astype('float64')\r\n\tl1 = []\r\n\tl2 = []\r\n\r\n\tfor x in range(1000):\r\n\t\tl1.append(arr[x] / 3600)\r\n\r\n\tfor x in range(1000):\r\n\t\tl2.append(timetest[ind1 + x] / 3600)\r\n\r\n\treturn mean_squared_log_error(l2, l1)\r\n\r\n", "description": null, "category": "math", "imports": ["from sklearn.feature_extraction.text import CountVectorizer\r", "import pandas as pd\r", "from nltk.stem import WordNetLemmatizer\r", "import numpy as np\r", "from sklearn.neighbors import KNeighborsRegressor\r", "from sklearn.metrics import mean_squared_log_error\r", "from matplotlib import pyplot as plt\r"]}], [{"term": "def", "name": "calc", "data": "def calc(a1, operator, a2):  # A basic function for calculating with\n\tglobal n_calc\n\tn_calc += 1\n\tif operator == ' + ':\n\t\treturn a1 + a2\n\tif operator == ' - ':\n\t\treturn a1 - a2\n\tif operator == ' / ':\n\t\tif a2 == 0:\n\t\t\treturn 10000000\n\t\telse:\n\t\t\treturn a1 / float(a2)\n\tif operator == ' * ':\n\t\treturn a1 * a2\n\n", "description": null, "category": "math", "imports": ["from random import *", "from itertools import permutations, product", "from time import time"]}, {"term": "def", "name": "counter", "data": "def counter(string, char):\n\tcount = 0\n\tfor c in string:\n\t\tif c == char:\n\t\t\tcount += 1\n\treturn count\n\n", "description": null, "category": "math", "imports": ["from random import *", "from itertools import permutations, product", "from time import time"]}, {"term": "def", "name": "add_solution", "data": "def add_solution(result):\n\tresult = remove_brackets(result)\n\tif len(solutions) < limit and result not in solutions:\n\t\tsolutions.append(result)\n\t\tif len(solutions) == limit:\n\t\t\tprint_solutions()\n\n", "description": null, "category": "math", "imports": ["from random import *", "from itertools import permutations, product", "from time import time"]}, {"term": "def", "name": "compare_operators", "data": "def compare_operators(first, second, pos):\n\tif first == '+':\n\t\tif second == '+':\n\t\t\treturn True\n\t\telif second == '-':\n\t\t\tif pos:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\t\telif second == '*':\n\t\t\treturn False\n\t\telif second == '/':\n\t\t\treturn False\n\telif first == '-':\n\t\tif second == '+':\n\t\t\treturn True\n\t\telif second == '-':\n\t\t\tif pos:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\t\telif second == '*':\n\t\t\treturn False\n\t\telif second == '/':\n\t\t\treturn False\n\telif first == '*':\n\t\tif second == '+':\n\t\t\treturn True\n\t\telif second == '-':\n\t\t\treturn True\n\t\telif second == '*':\n\t\t\treturn True\n\t\telif second == '/':\n\t\t\tif pos:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\telif first == '/':\n\t\tif second == '+':\n\t\t\treturn True\n\t\telif second == '-':\n\t\t\treturn True\n\t\telif second == '*':\n\t\t\treturn True\n\t\telif second == '/':\n\t\t\tif pos:\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\n", "description": null, "category": "math", "imports": ["from random import *", "from itertools import permutations, product", "from time import time"]}, {"term": "def", "name": "remove_brackets", "data": "def remove_brackets(string):\n\tno_close_brackets = counter(string, ')')\n\topen_brackets = []\n\tfirsts_to_skip = []\n\tbrackets_to_remove = []\n\tfirst_op = '+'\n\tfor i in range(len(string)):\n\t\tif string[i] == '(':\n\t\t\topen_brackets.append(i)\n\t\telif string[i] == ')':\n\t\t\tfor x in range(open_brackets[-1], i):\n\t\t\t\tif x not in firsts_to_skip and string[x] in ['+', '-', '/', '*']:\n\t\t\t\t\tfirst_op = string[x]\n\t\t\t\t\tfirsts_to_skip.append(x)\n\t\t\t\t\tbreak\n\t\t\tif len(firsts_to_skip) == no_close_brackets:\n\t\t\t\tfor x in range(len(string)):\n\t\t\t\t\tif x not in firsts_to_skip and string[x] in ['+', '-', '/', '*']:\n\t\t\t\t\t\tif x > i:\n\t\t\t\t\t\t\tpos = 1\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tpos = 0\n\t\t\t\t\t\tif compare_operators(first_op, string[x], pos):\n\t\t\t\t\t\t\tbrackets_to_remove.append(open_brackets[-1])\n\t\t\t\t\t\t\tbrackets_to_remove.append(i)\n\n\t\t\tif len(open_brackets) == 1 or open_brackets[-1] - 1 == open_brackets[-2]:\n\t\t\t\tpos = 1  # AFTER\n\t\t\t\tfor x in range(i, len(string)):\n\t\t\t\t\tif string[x] in ['+', '-', '/', '*']:\n\t\t\t\t\t\tif compare_operators(first_op, string[x], pos):\n\t\t\t\t\t\t\tbrackets_to_remove.append(open_brackets[-1])\n\t\t\t\t\t\t\tbrackets_to_remove.append(i)\n\t\t\t\t\t\tbreak\n\t\t\telse:  # BEFORE\n\t\t\t\tpos = 0\n\t\t\t\tfor x in range(open_brackets[-2], open_brackets[-1]):\n\t\t\t\t\tif string[x] in ['+', '-', '/', '*'] and x not in firsts_to_skip:\n\t\t\t\t\t\tif compare_operators(first_op, string[x], pos):\n\t\t\t\t\t\t\tbrackets_to_remove.append(open_brackets[-1])\n\t\t\t\t\t\t\tbrackets_to_remove.append(i)\n\t\t\topen_brackets = open_brackets[:-1]\n\tnew_string = list('' for i in range(len(string)))\n\tfor i in range(len(string)):\n\t\tif i not in brackets_to_remove:\n\t\t\tnew_string[i] = string[i]\n\treturn ''.join(new_string)\n\n", "description": null, "category": "math", "imports": ["from random import *", "from itertools import permutations, product", "from time import time"]}, {"term": "def", "name": "solve", "data": "def solve():\n\tglobal n_comp\n\tif target in number:\n\t\tadd_solution(str(target) + ' = ' + str(target))\n\t\t\n\tfor num_perm in set(permutations(number, 2)):\n\t\tfor o1 in op:\n\t\t\tresult = calc(num_perm[0], o1, num_perm[1])\n\t\t\tn_comp += 1\n\t\t\tif result == target:\n\t\t\t\tsolution_str = ''.join(str(num_perm[0]) + o1 + str(num_perm[1]) + ' = ' + str(result))  \n\t\t\t\tadd_solution(solution_str)\n\n\tfor num_perm in set(permutations(number, 3)):\n\t\tfor op_perm in (p for p in product(op, repeat=2)):\n\t\t\tresult = calc(num_perm[0], op_perm[0], calc(num_perm[1], op_perm[1], num_perm[2]))\n\t\t\t# a + (b + c)\n\t\t\tn_comp += 1\n\t\t\tif result == target:\n\t\t\t\tsolution_str = str(num_perm[0]) + op_perm[0] + '(' +\\\n\t\t\t\t\t\t\t   str(num_perm[1]) + op_perm[1] + str(num_perm[2]) + ')' + ' = ' + str(result)\n\t\t\t\tadd_solution(solution_str)\n\n\t\t\tresult = calc(calc(num_perm[0], op_perm[0], num_perm[1]), op_perm[1], num_perm[2])\n\t\t\t# (a + b) + c\n\t\t\tn_comp += 1\n\t\t\tif result == target:\n\t\t\t\tsolution_str = '(' + str(num_perm[0]) + op_perm[0] + \\\n\t\t\t\t\t\t\t   str(num_perm[1]) + ')' + op_perm[1] + str(num_perm[2]) + ' = ' + str(result)\n\t\t\t\tadd_solution(solution_str)\n\n\tfor num_perm in set(permutations(number, 4)):\n\t\tfor op_perm in (p for p in product(op, repeat=3)):\n\t\t\t\n\t\t\tresult = calc(num_perm[0], op_perm[0], calc(num_perm[1], op_perm[1],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcalc(num_perm[2], op_perm[2], num_perm[3])))\n\t\t\t# a + (b + (c + d))\n\t\t\tn_comp += 1\n\t\t\tif result == target:\n\t\t\t\tsolution_str = str(num_perm[0]) + op_perm[0] + '(' + str(num_perm[1]) + op_perm[1] + '(' +\\\n\t\t\t\t\t\t\t   str(num_perm[2]) + op_perm[2] + str(num_perm[3]) + ')) = ' + str(result)\n\t\t\t\tadd_solution(solution_str)\n\n\t\t\tresult = calc(calc(num_perm[0], op_perm[0], num_perm[1]), op_perm[1],\n\t\t\t\t\t\t  calc(num_perm[2], op_perm[2], num_perm[3]))\n\t\t\t# (a + b) + (c + d)\n\t\t\tn_comp += 1\n\t\t\tif result == target:\n\t\t\t\tsolution_str = '(' + str(num_perm[0]) + op_perm[0] + str(num_perm[1]) + ')' + op_perm[1] + '(' + \\\n\t\t\t\t\t\t\t   str(num_perm[2]) + op_perm[2] + str(num_perm[3]) + ') = ' + str(result)\n\t\t\t\tadd_solution(solution_str)\n\n\t\t\tresult = calc(num_perm[0], op_perm[0],\n\t\t\t\t\t\t  calc(calc(num_perm[1], op_perm[1], num_perm[2]), op_perm[2], num_perm[3]))\n\t\t\t# a + ((b + c) + d)\n\t\t\tn_comp += 1\n\t\t\tif result == target:\n\t\t\t\tsolution_str = str(num_perm[0]) + op_perm[0] + '((' + str(num_perm[1]) + op_perm[1] + \\\n\t\t\t\t\t\t\t   str(num_perm[2]) + ')' + op_perm[2] + str(num_perm[3]) + ') = ' + str(result)\n\t\t\t\tadd_solution(solution_str)\n\tfor num_perm in set(permutations(number, 5)):\n\t\tfor op_perm in (p for p in product(op, repeat=4)):\n\t\t\tn_comp += 1\n\t\t\tresult = calc(num_perm[0], op_perm[0],\n\t\t\t\t\t\t  calc(num_perm[1], op_perm[1],\n\t\t\t\t\t\t\t   calc(num_perm[2], op_perm[2],\n\t\t\t\t\t\t\t\t\tcalc(num_perm[3], op_perm[3], num_perm[4]))))\n\t\t\t# a + (b + (c + (d + e)))\n\t\t\tif result == target:\n\t\t\t\tsolution_str = str(num_perm[0]) + op_perm[0] + '(' + str(num_perm[1]) + op_perm[1] + \\\n\t\t\t\t\t\t\t   '(' + str(num_perm[2]) + op_perm[2] + '(' + str(num_perm[3]) + op_perm[3]\\\n\t\t\t\t\t\t\t   + str(num_perm[4]) + '))) = ' + str(result)\n\t\t\t\tadd_solution(solution_str)\n\t\t\tn_comp += 1\n\t\t\tresult = calc(calc(calc(num_perm[0], op_perm[0], num_perm[1]), op_perm[1],\n\t\t\t\t\t\t\t   calc(num_perm[2], op_perm[2], num_perm[3])), op_perm[3], num_perm[4])\n\t\t\t# ((a + b) + (c + d)) + e\n\t\t\tif result == target:\n\t\t\t\tsolution_str = '((' + str(num_perm[0]) + op_perm[0] + str(num_perm[1]) + ')' + op_perm[1] + \\\n\t\t\t\t\t\t\t   '(' + str(num_perm[2]) + op_perm[2] + str(num_perm[3]) + '))' + op_perm[3] \\\n\t\t\t\t\t\t\t   + str(num_perm[4]) + ' = ' + str(result)\n\t\t\t\tadd_solution(solution_str)\n\t\t\tn_comp += 1\n\t\t\tresult = calc(calc(num_perm[0], op_perm[0], num_perm[1]), op_perm[1],\n\t\t\t\t\t\t  calc(num_perm[2], op_perm[2], calc(num_perm[3], op_perm[3], num_perm[4])))\n\t\t\t# (a + b) + (c + (d + e))\n\t\t\tif result == target:\n\t\t\t\tsolution_str = '(' + str(num_perm[0]) + op_perm[0] + str(num_perm[1]) + ')' + op_perm[1] + \\\n\t\t\t\t\t\t\t   '(' + str(num_perm[2]) + op_perm[2] + '(' + str(num_perm[3]) + op_perm[3] \\\n\t\t\t\t\t\t\t   + str(num_perm[4]) + ')) = ' + str(result)\n\t\t\t\tadd_solution(solution_str)\n\n\tfor num_perm in set(permutations(number, 6)):\n\t\tfor op_perm in (p for p in product(op, repeat=5)):\n\t\t\tn_comp += 1\n\t\t\tresult = calc(num_perm[0], op_perm[0],\n\t\t\t\t\t\t  calc(num_perm[1], op_perm[1],\n\t\t\t\t\t\t\t   calc(num_perm[2], op_perm[2],\n\t\t\t\t\t\t\t\t\tcalc(num_perm[3], op_perm[3], calc(num_perm[4], op_perm[4], num_perm[5])))))\n\t\t\t# a + (b + (c + (d + (e + f))))\n\t\t\tif result == target:\n\t\t\t\tsolution_str = str(num_perm[0]) + op_perm[0] + '(' + str(num_perm[1]) + op_perm[1] + \\\n\t\t\t\t\t\t\t   '(' + str(num_perm[2]) + op_perm[2] + '(' + str(num_perm[3]) + op_perm[3] \\\n\t\t\t\t\t\t\t   + '(' + str(num_perm[4]) + op_perm[4] + str(num_perm[5]) + ')))) = ' + str(result)\n\t\t\t\tadd_solution(solution_str)\n\t\t\tn_comp += 1\n\t\t\tresult = calc(calc(calc(num_perm[0], op_perm[0], num_perm[1]), op_perm[1],\n\t\t\t\t\t\t\t   calc(num_perm[2], op_perm[2], num_perm[3])), op_perm[3],\n\t\t\t\t\t\t  calc(num_perm[4], op_perm[4], num_perm[5]))\n\t\t\t# ((a + b) + (c + d)) + (e + f)\n\t\t\tif result == target:\n\t\t\t\tsolution_str = '((' + str(num_perm[0]) + op_perm[0] + str(num_perm[1]) + ')' + op_perm[1] + \\\n\t\t\t\t\t\t\t   '(' + str(num_perm[2]) + op_perm[2] + str(num_perm[3]) + '))' + op_perm[3] \\\n\t\t\t\t\t\t\t   + '(' + str(num_perm[4]) + op_perm[4] + str(num_perm[5]) + ') = ' + str(result)\n\t\t\t\tadd_solution(solution_str)\n\t\t\tn_comp += 1\n\t\t\tresult = calc(calc(num_perm[0], op_perm[0],\n\t\t\t\t\t\t\t   calc(calc(num_perm[1], op_perm[1], num_perm[2]), op_perm[2],\n\t\t\t\t\t\t\t   calc(num_perm[3], op_perm[3], num_perm[4]))), op_perm[4], num_perm[5])\n\t\t\t# (a + ((b + c) + (d + e))) + f\n\t\t\tif result == target:\n\t\t\t\tsolution_str = '(' + str(num_perm[0]) + op_perm[0] + '((' + str(num_perm[1]) + op_perm[1] +\\\n\t\t\t\t\t\t\t   str(num_perm[2]) + ')' + op_perm[2] + '(' + str(num_perm[3]) + op_perm[3] \\\n\t\t\t\t\t\t\t   + str(num_perm[4]) + ')))' + op_perm[4] + str(num_perm[5]) + ' = ' + str(result)\n\t\t\t\tadd_solution(solution_str)\n\tprint_solutions()\n\n", "description": null, "category": "math", "imports": ["from random import *", "from itertools import permutations, product", "from time import time"]}, {"term": "def", "name": "print_solutions", "data": "def print_solutions():\n\ttime_d = time() - now\n\tif len(solutions) > 0:  # checks if it found anything\n\t\tfor te in solutions:  # prints it\n\t\t\tprint(te)\n\tprint(\"Done.\")\n\tprint(str(len(solutions)) + \" results were found.\")  # tells the user how many result were found\n\tprint('Time = ', time_d)\n\tprint('Calculations performed', n_calc)\n\tprint('Comparisons: ', n_comp)\n\texit(0)\n\n", "description": null, "category": "math", "imports": ["from random import *", "from itertools import permutations, product", "from time import time"]}], [{"term": "def", "name": "calc", "data": "def calc():\n\treturn Calculator(CompassExtension.namespace).evaluate_expression\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_blank", "data": "def test_blank(calc):\n\tassert calc('blank(false)')\n\tassert calc('blank(\"\")')\n\tassert calc('blank(\" \")')\n\t# TODO this is a syntax error; see #166\n\t#assert calc('blank(())')\n\n\tassert not calc('blank(null)')  # yes, really\n\tassert not calc('blank(1)')\n\tassert not calc('blank((1, 2))')\n\tassert not calc('blank(0)')\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_compact", "data": "def test_compact(calc):\n\tassert calc('compact(1 2 3 false 4 5 null 6 7)') == calc('1 2 3 4 5 6 7')\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_reject", "data": "def test_reject(calc):\n\tassert calc('reject(a b c d, a, c)') == calc('b d')\n\tassert calc('reject(a b c d, e)') == calc('a b c d')\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_first_value_of", "data": "def test_first_value_of(calc):\n\tassert calc('first-value-of(a b c d)') == calc('a')\n\tassert calc('first-value-of(\"a b c d\")') == calc('\"a\"')\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_enumerate", "data": "def test_enumerate(calc):\n\tassert calc('enumerate(foo, 4, 7)') == calc('foo-4, foo-5, foo-6, foo-7')\n\tassert calc('enumerate(\"bar\", 8, 10)') == calc('bar-8, bar-9, bar-10')\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_headings", "data": "def test_headings(calc):\n\tassert calc('headings()') == calc('h1, h2, h3, h4, h5, h6')\n\tassert calc('headings(all)') == calc('h1, h2, h3, h4, h5, h6')\n\tassert calc('headings(2)') == calc('h1, h2')\n\tassert calc('headings(2, 5)') == calc('h2, h3, h4, h5')\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_nest", "data": "def test_nest(calc):\n\t# Using .render() here because the structure is complicated and only the\n\t# output matters\n\tassert calc('nest(selector1, selector2, selector3)').render() == 'selector1 selector2 selector3'\n\tassert calc('nest(\"a b\", \"c d\")').render() == 'a b c d'\n\tassert calc('nest((a, b), (c, d))').render() == 'a c, a d, b c, b d'\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_opposite_position", "data": "def test_opposite_position(calc):\n\tassert calc('opposite-position(left)') == calc('right')\n\tassert calc('opposite-position(top)') == calc('bottom')\n\tassert calc('opposite-position(center)') == calc('center')\n\tassert calc('opposite-position(top left)') == calc('bottom right')\n\tassert calc('opposite-position(center right)') == calc('center left')\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_pi", "data": "def test_pi(calc):\n\tassert calc('pi()') == calc('3.141592653589793')\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_e", "data": "def test_e(calc):\n\tassert calc('e()') == calc('2.718281828459045')\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_sqrt", "data": "def test_sqrt(calc):\n\tassert calc('sqrt(9)') == calc('3')\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_log", "data": "def test_log(calc):\n\tassert calc('log(9, 3)') == calc('2')\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_pow", "data": "def test_pow(calc):\n\tassert calc('pow(3, 2)') == calc('9')\n\tassert calc('pow(10px, 2) / 1px') == calc('100px')\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_font_url", "data": "def test_font_url(calc):\n\t# nb: config.FONTS_URL is None and defaults to this\n\tfonts_url = config.STATIC_URL\n\tassert calc('font-url(\"/some_path.woff\")').render() == 'url({0}some_path.woff)'.format(fonts_url)\n\tassert calc('font-url(\"/some_path.woff\") format(\"woff\")').render() == 'url({0}some_path.woff) format(\"woff\")'.format(fonts_url)\n\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_font_files", "data": "def test_font_files(calc):\n\t\"\"\"\n\t@author: funvit\n\t@note: adapted from  compass / test / units / sass_extensions_test.rb\n\t\"\"\"\n\t# nb: config.FONTS_URL is None and defaults to this\n\tfonts_url = config.STATIC_URL\n\tassert '' == calc('font-files()').render()\n\tassert 'url({0}font/name.woff) format(\"woff\"), url({0}fonts/name.ttf) format(\"truetype\"), url({0}fonts/name.svg#fontpath) format(\"svg\")'.format(fonts_url) == calc('font-files(\"/font/name.woff\", woff, \"/fonts/name.ttf\", truetype, \"/fonts/name.svg#fontpath\", svg)').render()\n\n\tassert 'url({0}font/with/right_ext.woff) format(\"woff\")'.format(fonts_url) == calc('font_files(\"/font/with/right_ext.woff\")').render()\n\tassert 'url({0}font/with/wrong_ext.woff) format(\"svg\")'.format(fonts_url) == calc('font_files(\"/font/with/wrong_ext.woff\", \"svg\")').render()\n\tassert 'url({0}font/with/no_ext) format(\"opentype\")'.format(fonts_url) == calc('font_files(\"/font/with/no_ext\", \"otf\")').render()\n\tassert 'url({0}font/with/weird.ext) format(\"truetype\")'.format(fonts_url) == calc('font_files(\"/font/with/weird.ext\", \"truetype\")').render()\n\n\tassert 'url({0}font/with/right_ext.woff) format(\"woff\"), url({0}font/with/right_ext_also.otf) format(\"opentype\")'.format(fonts_url) == calc('font_files(\"/font/with/right_ext.woff\", \"/font/with/right_ext_also.otf\")').render()\n\tassert 'url({0}font/with/wrong_ext.woff) format(\"truetype\"), url({0}font/with/right_ext.otf) format(\"opentype\")'.format(fonts_url) == calc('font_files(\"/font/with/wrong_ext.woff\", \"ttf\", \"/font/with/right_ext.otf\")').render()\n\n", "description": "\n\t@author: funvit\n\t@note: adapted from  compass / test / units / sass_extensions_test.rb\n\t", "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}, {"term": "def", "name": "test_inline_font_files", "data": "def test_inline_font_files(calc, monkeypatch):\n\t\"\"\"\n\t@author: funvit\n\t@note: adapted from  compass / test / units / sass_extensions_test.rb\n\t\"\"\"\n\tmonkeypatch.setattr(config, 'FONTS_ROOT', os.path.join(config.PROJECT_ROOT, 'tests/files/fonts'))\n\n\twith open(os.path.join(config.PROJECT_ROOT, 'tests/files/fonts/bgrove.base64.txt'), 'r') as f:\n\t\tfont_base64 = ''.join((f.readlines()))\n\n\tassert 'url(data:font/truetype;base64,%s) format(\"truetype\")' % font_base64 == calc('inline_font_files(\"/bgrove.ttf\", truetype)').render()\n\n", "description": "\n\t@author: funvit\n\t@note: adapted from  compass / test / units / sass_extensions_test.rb\n\t", "category": "math", "imports": ["from __future__ import absolute_import", "from __future__ import unicode_literals", "import os", "from scss import config", "from scss.calculator import Calculator", "from scss.extension.compass import CompassExtension", "import pytest"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "store_last_page", "data": "def store_last_page(func):\n\t# python decorator for keeping route method function identity properties\n\t@functools.wraps(func)\n\tdef set_last_page(*args, **kwargs):\n\t\t# set session list with first page always the index\n\t\tif not session.get('global_page_history'):\n\t\t\tsession['global_page_history'] = ['index']\n\t\telse:\n\t\t\t# get name of route that was navigated to\n\t\t\tpage = func.__name__\n\t\t\t# don't record if refreshed or same page navigated to\n\t\t\tif page != session.get('global_page_history')[-1]:\n\t\t\t\tsession.get('global_page_history').append(page) # save page name\n\t\t\t\t# flash(f\"history list: {session.get('global_page_history')}\")\n\t\t# remove first item if list is longer than 10 paths (limit stack size to 10)\n\t\tif  len(session.get('global_page_history')) > 10:\n\t\t\tsession.get('global_page_history').pop(0)\n\n\t\t# call route function and return returned variables\n\t\treturn func(*args, **kwargs)\n\n\t# return wrapped function\n\treturn set_last_page\n\n\n\n", "description": null, "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}, {"term": "def", "name": "index", "data": "def index():\n\treturn render_template('index.html', index = True)\n\n\n", "description": null, "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}, {"term": "def", "name": "about", "data": "def about():\n\treturn render_template('about.html', about = True)\n\n", "description": null, "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}, {"term": "def", "name": "contact", "data": "def contact():\n\tform = ContactForm()\n\tif form.validate_on_submit():\n\t\tsubject = form.subject.data\n\t\tmsg = Message(form.subject.data, sender='team@encompapp.com', recipients=['team@encompapp.com'])\n\t\tmsg.body = \"\"\"\n\t\tFrom: %s <%s>\n\t\t%s\n\t\t\"\"\" % (form.name.data, form.email.data, form.message.data)\n\t\tmail.send(msg)\n\t\tflash(\n\t\t\t\"Thank you for contacting us. We will reach out to you as soon as possible.\",\n\t\t\t\"success\",\n\t\t)\n\n\t\treturn redirect(url_for('index'))\n\t# else:\n\t#\t flash(\"All fields required\")\n\treturn render_template('contact.html', contact = True, form = form)\n\n", "description": "\n\t\tFrom: %s <%s>\n\t\t%s\n\t\t", "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}, {"term": "def", "name": "landing", "data": "def landing():\n\tif not session.get('username'):\n\t\treturn redirect(url_for('index'))\n\tmy_projects = getUserProjects(session.get('user_id'))\n\n\tif selected_project_id := request.form.get('selected_project_id'):\n\t\tsession['current_project_id'] = selected_project_id\n\t\tselected_project = Project.objects(_id=selected_project_id).first()\n\t\tsession['current_p_name'] = selected_project.project_name\n\t\tsession['current_p_description'] = selected_project.description\n\n\tif session.get('current_project_id'):\n\t\tselect_comment = False\n\t\tproject_calcs = getProjCalcs(session.get('current_project_id'))\n\telse:\n\t\tselect_comment = True\n\t\tproject_calcs = False\n\n\t\t###### Import Calculation  #####\n\tif request.method == 'POST':\n\t\tif file := request.files.get('upload_calc'):\n\t\t\tif file.filename == '':\n\t\t\t\tflash(\"No file has been selected\")\n\t\t\telif session.get('current_project_id'):\n\t\t\t\tfilename = secure_filename(file.filename)\n\t\t\t\tupload_content = file.read()\n\t\t\t\tcalc_import_dict = json.loads(upload_content)\n\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])\n\t\t\t\tnew_calc_from_import.save()\n\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")\n\t\t\t\treturn redirect(url_for('landing'))\n\n\tif selected_calc_id := request.form.get('selected_calc_id'):\n\t\tsession['current_calc_id'] = selected_calc_id\n\t\tselected_calculation = CalcInput.objects(_id=selected_calc_id).first()\n\t\tsession['current_c_name'] = selected_calculation.calc_name\n\t\tsession['current_c_description'] = selected_calculation.description\n\t\treturn redirect(url_for('design_dashboard'))\n\n\t############------------ADD PROJECT FORM-----------##############\n\tpform = ProjectForm()\n\tif pform.validate_on_submit():\n\t\tproject_name = pform.project_name.data\n\t\tdescription = pform.description.data\n\n\t\tproject = Project( project_name=project_name, description=description, user_id=session.get('user_id')) # user_id=ObjectId(),\n\t\tproject.save()\n\n\t\tflash(f\"You have saved {project_name}\", \"success\")\n\t\treturn redirect(url_for('landing'))\n\n\t############------------CHANGE PROJECT NAME FORM-----------##############\n\tpnameform = ChangeProjectForm()\n\tif pnameform.validate_on_submit():\n\t\tnew_project_name = pnameform.new_project_name.data\n\t\tnew_description = pnameform.new_description.data\n\n\t\tproject = Project.objects( _id = session['current_project_id'] ).first()\n\t\tproject.project_name = new_project_name\n\t\tproject.description = new_description\n\t\tproject.save()\n\n\t\tflash(f\"You have updated {new_project_name}\", \"success\")\n\t\treturn redirect(url_for('landing'))\n\n\t############------------ADD calc FORM-----------##############\n\tcform = CalcForm()\n\tif cform.validate_on_submit():\n\t\tcalc_name = cform.calc_name.data\n\t\tdescription = cform.description.data\n\t\tcalc_type_name = cform.calc_type.data\n\t\tcalc_type = CalcType.objects(type_name=calc_type_name).first()\n\n\t\tcalc_type_id = calc_type._id\n\t\tproject_id = session.get('current_project_id')\n\n\t\tcalc = CalcInput( calc_name=calc_name, description=description, calc_type_id=calc_type_id, project_id=project_id) # user_id=ObjectId(),\n\t\tcalc.save()\n\n\t\tflash(f\"You have saved {calc_name}\", \"success\")\n\t\treturn redirect(url_for('landing'))\n\n\tif delete_project_trigger := request.form.get('delete_current_project'):\n\t\tdeleteProject(session.get('current_project_id'))\n\t\tdeleted_project_name = session.get('current_p_name')\n\t\tsession.pop('current_project_id')\n\t\tsession.pop('current_p_name')\n\t\tsession.pop('current_p_description')\n\t\tif session.get('current_calc_id'):\n\t\t\tsession.pop('current_calc_id')\n\t\t\tsession.pop('current_c_name')\n\t\t\tsession.pop('current_c_description')\n\t\tflash(f\"You have deleted {deleted_project_name}\", \"success\")\n\t\treturn redirect(url_for('landing'))\n\n\treturn render_template('landing.html', my_projects=my_projects, project_calcs=project_calcs, select_comment=select_comment, pform = pform, cform=cform, pnameform = pnameform,current_p_description =session.get('current_p_description'), current_p_name = session.get('current_p_name'),  project=True)\n\n", "description": null, "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}, {"term": "def", "name": "login", "data": "def login():\n\tif session.get('username'):\n\t\tflash(f\"You are already logged in, {session.get('username')}\")\n\t\treturn redirect(url_for('landing'))\n\tform = LoginForm()\n\tformR = RegisterForm()\n\n\tif request.method == 'POST':\n\t\tform_submit_dict = request.form\n\t\tlogin_attempt\t = 'login_submit' in form_submit_dict\n\t\tregister_attempt  = 'register_submit' in form_submit_dict\n\t\tif login_attempt:\n\t\t\tif form.validate_on_submit():\n\t\t\t\temail\t   = form.email.data  # request.form.get(\"email\")\n\t\t\t\tpassword\t= form.password.data\n\n\t\t\t\tuser = User.objects(email=email).first()  # gets first occurance not as array, could also do User.objects(email=email)[0]\n\t\t\t\tif user and user.get_password(password):\n\t\t\t\t\tflash(f\"Welcome {user.first_name}, you are successfully logged in!\", \"success\")\n\t\t\t\t\tsession['user_id'] = str(user._id)\n\t\t\t\t\tsession['username'] = user.first_name\n\t\t\t\t\tsession['current_project_id'] = \"\"\n\t\t\t\t\treturn redirect(url_for('landing'))\n\t\t\t\telif user:\n\t\t\t\t\tflash(\"Password is incorrect.\", \"danger\")\n\t\t\t\telse:\n\t\t\t\t\tflash(\"Sorry, email not found.\", \"danger\")\n\t\telif register_attempt:\n\t\t\tif formR.validate_on_submit():\n\t\t\t\temailR = formR.emailR.data\n\t\t\t\tpasswordR = formR.passwordR.data\n\t\t\t\tfirst_nameR = formR.first_name.data\n\t\t\t\tlast_nameR = formR.last_name.data\n\n\t\t\t\tuser = User( email=emailR, first_name=first_nameR, last_name=last_nameR) # user_id=ObjectId(),\n\t\t\t\tuser.set_password(passwordR)\n\t\t\t\tuser.save()\n\n\t\t\t\tflash(\"You are successfully registered\", \"success\")\n\t\t\t\treturn redirect(url_for('login'))\n\n\treturn render_template(\"login.html\", login=True, form=form, formR=formR)\n\n\n", "description": null, "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}, {"term": "def", "name": "logout", "data": "def logout():\n\tcurrent_user_id = session.get('user_id')\n\t# dir_path = f\"C:/Users/ayoung/encomp/application/static/jsonfiles/{current_user_id}\"\n\tdir_path = f\"/home/ubuntu/encomp/application/static/jsonfiles/{current_user_id}\"\n\tif os.path.exists(dir_path):\n\t\ttry:\n\t\t\tshutil.rmtree(dir_path)\n\t\texcept OSError as e:\n\t\t\tflash(f\"Error: {dir_path} : {e.strerror}\")\n\t[session.pop(key) for key in list(session.keys())]\n\tflash(\"You have been logged out.\", \"success\")\n\treturn redirect(url_for('index'))\n\n\n", "description": null, "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}, {"term": "def", "name": "design_dashboard", "data": "def design_dashboard():\n\n\tif not session.get('current_calc_id'):\n\t\treturn redirect(url_for('index'))\n\n\t############------------GET CURRENT CALCULATION INFO AND DB OBJECTS-----------##############\n\tcurrent_calc = CalcInput.objects( _id = session['current_calc_id'] ).first()\n\tcurrent_calc_type = CalcType.objects( _id = current_calc.calc_type_id ).first()\n\tcalc_file_name = current_calc_type.file_name\n\tif not current_calc:\n\t\treturn render_template(\"design.html\", calculation_name= \"No calc found for id:\",calculation_description=session['current_calc_id'])\n\n\t############------------GET CALCULATION INPUT OBJECTS BY RUNNING CALC -----------##############\n\tcalculation_path = f'application.calcscripts.{calc_file_name}.create_calculation'\n\tcalc_items_and_strings, calc_errors = compile_calculation(compile_calc_path=calculation_path)\n\tcalc_items = calc_items_and_strings['all_items']\n\tsetup_items = calc_items['setup']\n\tcalc_inputs = []\n\tfor item in setup_items:\n\t\tif item.__class__.__name__ == 'DeclareVariable':\n\t\t\tcalc_inputs.append(item)\n\n\n\t############------------POPULATE CHANGE CALC NAME FORM DATA -----------##############\n\tcalcnameform = ChangeCalcForm()\n\tleft_header=current_calc.left_header\n\tcenter_header=current_calc.center_header\n\tright_header=current_calc.right_header\n\t# if request.method == 'GET':\n\tcalcnameform.new_description.data = current_calc.description\n\tcalcnameform.new_left_header.data = left_header\n\tcalcnameform.new_center_header.data = center_header\n\tcalcnameform.new_right_header.data = right_header\n\n\n\t############------------CHANGE CALCULATION NAME FORM-----------##############\n\tdef change_calculation_name(posted_dict):\n\t\tif calcnameform.validate_on_submit():\n\t\t\tnew_calc_name = posted_dict.get('new_calc_name')\n\t\t\tnew_description = posted_dict.get('new_description')\n\t\t\tnew_left_header = posted_dict.get('new_left_header')\n\t\t\tnew_center_header = posted_dict.get('new_center_header')\n\t\t\tnew_right_header = posted_dict.get('new_right_header')\n\n\t\t\tcurrent_calc.calc_name = new_calc_name\n\t\t\tcurrent_calc.description = new_description\n\t\t\tcurrent_calc.left_header = new_left_header\n\t\t\tcurrent_calc.center_header = new_center_header\n\t\t\tcurrent_calc.right_header = new_right_header\n\t\t\tcurrent_calc.save()\n\n\t\t\tflash(f\"You have updated {new_calc_name}\", \"success\")\n\t\t\treturn redirect(url_for('design_dashboard'))\n\t\telse:\n\t\t\tflash(\"Error in text submitted\")\n\t\t\treturn None\n\n\t############------------DELETE CALCULATION FORM-----------##############\n\tdef delete_current_calculation():\n\t\tremoveCalculationFromDB(session['current_calc_id'])\n\t\tdeleted_calc_name = session.get('current_c_name')\n\t\tsession.pop('current_calc_id')\n\t\tsession.pop('current_c_name')\n\t\tsession.pop('current_c_description')\n\t\tflash(f\"You have deleted {deleted_calc_name}\", \"success\")\n\t\treturn redirect(url_for('landing'))\n\n\n\t############------------WHEN FORM IS SUBMITTED-----------##############\n\tif request.method == 'POST':\n\t\tform_submit_dict = request.form\n\t\t# flash(f\"posted:  {form_submit_dict}\")\n\t\t# submitted_form = form_submit_dict.get('submit')\n\t\t# flash(f\"submitted form: {submitted_form}\")\n\t\tupdate_results\t = 'update_results_submitted' in form_submit_dict\n\t\tshow_report\t\t= 'show_calc_report' in form_submit_dict\n\t\tprint_report\t   = 'print_calc_report' in form_submit_dict\n\t\tchange_calc_name   = 'change_calc_name' in form_submit_dict\n\t\tdelete_calc\t\t= 'delete_current_calc' in form_submit_dict\n\t\texport_calc\t\t= 'export_calc' in form_submit_dict\n\t\tgo_back\t\t\t= 'go_back' in form_submit_dict\n\n\t\tif update_results:\n\t\t\tcurrent_calc.calc_input_dict = form_submit_dict\n\t\t\tcurrent_calc.save()\n\t\telif show_report:\n\t\t\treturn redirect(url_for('calcreport', print_report=\"view\"))\n\t\telif print_report:\n\t\t\treturn redirect(url_for('calcreport', print_report=\"print\"))\n\t\telif change_calc_name:\n\t\t\treturn change_calculation_name(form_submit_dict)\n\t\telif delete_calc:\n\t\t\treturn delete_current_calculation()\n\t\telif export_calc:\n\t\t\treturn export_calculation()\n\t\telif go_back:\n\t\t\t# get rid of current page from history list, then go to previous page\n\t\t\tsession.get('global_page_history').pop()\n\t\t\treturn redirect(url_for(session.get('global_page_history').pop()))\n\n\n\t############------------RENDER INPUT AND OUTPUT VALUES-----------##############\n\t# update input variables\n\tcalc_saved_input = current_calc.calc_input_dict\n\tif isinstance(calc_saved_input, dict):\n\t\tfor item in calc_inputs:\n\t\t\tvar_name = item.name\n\t\t\tsaved_input = calc_saved_input.get(var_name)\n\t\t\tif saved_input:\n\t\t\t\titem._set_value(saved_input)\n\n\t\t\telse:\n\t\t\t\tcalc_saved_input[var_name] = item.value\n\t\tcurrent_calc.calc_input_dict = calc_saved_input\n\t\tcurrent_calc.save()\n\n\telse:\n\t\tcurrent_calc.calc_input_dict = {'a': 3, 'b': 4}\n\t\tcurrent_calc.save()\n\n\t#  get calculation output objects\n\tcalc_items_and_strings, calc_errors = compile_calculation(compile_calc_path=calculation_path, compile_update_vals=True, compile_updated_items=calc_inputs)\n\tif calc_errors:\n\t\tflash(calc_errors)\n\tcalc_items = calc_items_and_strings['all_items']\n\tresult_items = calc_items['calc']\n\tcalc_results = []\n\tfor item in result_items:\n\t\tif item.__class__.__name__ == 'CalcVariable' or item.__class__.__name__ == 'CheckVariable':\n\t\t\tif item.result_check:\n\t\t\t\tcalc_results.append(item)\n\n\t# SAVE HTML STRINGS FOR CALC REPORT\n\tstringsdict = calc_items_and_strings['html_strings']\n\tsession['stringsdict'] = stringsdict\n\n\treturn render_template(\"design.html\", calculation_name= current_calc.calc_name,calculation_description=current_calc.description, calc_inputs=calc_inputs, calc_results=calc_results, calcnameform=calcnameform,  design=True)\n\n\n", "description": null, "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}, {"term": "def", "name": "calcreport", "data": "def calcreport(print_report):\n\tcurrent_calc = CalcInput.objects( _id = session['current_calc_id'] ).first()\n\tcurrent_calc_type = CalcType.objects( _id = current_calc.calc_type_id ).first()\n\tcalc_name = current_calc_type.type_name\n\n\tleft_header = current_calc.left_header\n\tcenter_header = current_calc.center_header\n\tright_header = current_calc.right_header\n\n\tstringsdict = session.get('stringsdict')\n\n\n\theadstrings = stringsdict['head']\n\tassumstrings = stringsdict['assum']\n\tassum_length = len(assumstrings)\n\tsetupstrings = stringsdict['setup']\n\tcalcstrings = stringsdict['calc']\n\n\treturn render_template(\"calculations/view_calc_report.html\", print_report=print_report, calc_title = calc_name, headstrings = headstrings, assumstrings = assumstrings, assum_length=assum_length, setupstrings=setupstrings, calcstrings=calcstrings, left_header=left_header, center_header=center_header, right_header=right_header )\n\n\n", "description": null, "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}, {"term": "def", "name": "export_calculation", "data": "def export_calculation():\n\tif not session.get('user_id') or not session.get('current_calc_id'):\n\t\treturn redirect(url_for('index'))\n\tcurrent_user_id = session.get('user_id')\n\tif current_calc := CalcInput.objects(\n\t\t_id=session['current_calc_id']\n\t).first():\n\t\tcalc_file_name =  current_calc.calc_name.replace(\" \", \"_\")\n\t\tcalc_export_dict = {'calc_name': current_calc.calc_name, 'description': current_calc.description, 'calc_type_id': str(current_calc.calc_type_id), 'calc_input_dict': current_calc.calc_input_dict, 'left_header': current_calc.left_header, 'center_header': current_calc.center_header, 'right_header': current_calc.right_header}\n\t\t# file_path = f\"C:/Users/ayoung/encomp/application/static/jsonfiles/{current_user_id}/{calc_file_name}.json\"\n\t\tfile_path = f\"/home/ubuntu/encomp/application/static/jsonfiles/{current_user_id}/{calc_file_name}.json\"\n\t\t# dir_path = f\"C:/Users/ayoung/encomp/application/static/jsonfiles/{current_user_id}\"\n\t\tdir_path = f\"/home/ubuntu/encomp/application/static/jsonfiles/{current_user_id}\"\n\t\tif not os.path.exists(dir_path):\n\t\t\tos.makedirs(dir_path)\n\t\twith open(file_path,\"w\") as file:\n\t\t\tjson.dump(calc_export_dict,file)\n\t\treturn send_file(file_path, as_attachment=True, attachment_filename=f\"{calc_file_name}_export.json\")\n\telse:\n\t\tflash(\"Current calculation not found.\", \"danger\")\n", "description": null, "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}, {"term": "def", "name": "test_api", "data": "def test_api():\n\tif input_json := request.json:\n\t\ta = input_json.get(\"a\", 0)\n\t\tb = input_json.get(\"b\", 0)\n\t\treturn {'sum':a+b, \"product\":a*b}\n\treturn \"No input given\"\n", "description": null, "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}, {"term": "def", "name": "concrete_beam_api", "data": "def concrete_beam_api():\n\tif not (input_json := request.json):\n\t\treturn \"No input given\"\n\tcalc_file_name = 'ConcreteBeam'\n\n\t############------------GET CALCULATION INPUT OBJECTS BY RUNNING CALC -----------##############\n\tcalculation_path = f'application.calcscripts.{calc_file_name}.create_calculation'\n\tcalc_items_and_strings, calc_errors = compile_calculation(compile_calc_path=calculation_path)\n\t# if calc_errors:\n\t#\t print(calc_errors)\n\tcalc_items = calc_items_and_strings['all_items']\n\tsetup_items = calc_items['setup']\n\tcalc_inputs = [\n\t\titem\n\t\tfor item in setup_items\n\t\tif item.__class__.__name__ in ['DeclareVariable', 'DeclareTable']\n\t]\n\n\t\t############------------UPDATE INPUTS, RUN CALC, AND GET OUTPUT VALUES-----------##############\n\t\t# update input variables\n\tif isinstance(input_json, dict):\n\n\t\tfor item in calc_inputs:\n\t\t\tvar_name = item.name\n\t\t\tif input_val := input_json.get(var_name):\n\t\t\t\titem._set_value(input_val)\n\t\t\telse:\n\t\t\t\tinput_json[var_name] = item.value\n\n\t#  get calculation output objects\n\tcalc_items_and_strings, calc_errors = compile_calculation(compile_calc_path=calculation_path, compile_update_vals=True, compile_updated_items=calc_inputs)\n\t# if calc_errors:\n\t#\t print(calc_errors)\n\tcalc_items = calc_items_and_strings['all_items']\n\tresult_items = calc_items['calc']\n\t\t# SAVE HTML STRINGS FOR CALC REPORT\n\t\t# stringsdict = calc_items_and_strings['html_strings']\n\t\t# session['stringsdict'] = stringsdict\n\n\treturn {\n\t\titem.name: item.result()\n\t\tfor item in result_items\n\t\tif item.__class__.__name__ in ['CalcVariable', 'CalcTable']\n\t\tand item.result_check\n\t}\n", "description": null, "category": "math", "imports": ["from application import application, db, mail", "from flask import render_template, request, json, jsonify, Response, redirect, flash, url_for, session, send_file", "from flask_mail import Message, Mail", "from werkzeug.utils import secure_filename", "from application.models import User, Project, CalcInput, CalcType", "from application.forms import LoginForm, RegisterForm, ProjectForm, CalcForm, CalcTypeForm, ChangeProjectForm, ChangeCalcForm, ContactForm", "from application.mongo_query import getUserProjects, getProjCalcs, removeCalculationFromDB, deleteProject", "from application.calcscripts.process.compilecalc import compile_calculation", "import shutil", "import os", "import functools", "\t\t\t\tcalc_import_dict = json.loads(upload_content)", "\t\t\t\tnew_calc_from_import = CalcInput(calc_name = calc_import_dict['calc_name'], description = calc_import_dict['description'],calc_type_id= calc_import_dict['calc_type_id'], project_id = session.get('current_project_id'), calc_input_dict=calc_import_dict['calc_input_dict'], left_header=calc_import_dict['left_header'], center_header=calc_import_dict['center_header'],right_header=calc_import_dict['right_header'])", "\t\t\t\tnew_calc_from_import.save()", "\t\t\t\tflash(f\"You have uploaded {filename} successfully as: {calc_import_dict['calc_name']}\", \"success\")"]}], [{"term": "def", "name": "postorder", "data": "def postorder(T):\n\tif T:\n\t\tpostorder(cl[T])\n\t\tpostorder(cr[T])\n\t\tcalc.append(num_list[T])\n", "description": null, "category": "math", "imports": ["import sys"]}], [{"term": "class", "name": "classDescriptiveStats:", "data": "class DescriptiveStats:\n\n\tdef calc_count(self,x: List[float]) -> int:\n\t\t\"\"\"Returns the number of data points in a data set\"\"\"\n\t\treturn len(x)\n\n\tdef calc_minimum(self,x: List[float]) -> float:\n\t\t\"\"\"Returns the lowest data point in a data set\"\"\"\n\t\treturn min(x)\n\n\tdef calc_maximum(self,x: List[float]) -> float:\n\t\t\"\"\"Returns the highest data point in a data set\"\"\"\n\t\treturn max(x)\n\n\tdef calc_range(self,x: List[float]) -> float:\n\t\"\"\"Returns the difference between the lowest and highest values in a data set\"\"\"\n\t\treturn self.calc_maximum(x) - self.calc_minimum(x)\n\n\tdef calc_mean(self,x: List[float]) -> float:\n\t\"\"\"Returns the average value of a data set\"\"\"\n\t\treturn sum(x) / self.calc_count(x)\n\n\tdef calc_median(self,x: List[float]) -> float:\n\t   \"\"\"Returns the middle value of a data set\"\"\"\n\t\tif self.calc_count(x) % 2 == 1:\n\t\t\treturn sorted(x)[self.calc_count(x) // 2]\n\t\tif self.calc_count(x) % 2 == 0:\n\t\t\treturn ((sorted(x)[(self.calc_count(x) // 2) - 1]) + \\\n\t\t\t\t\t(sorted(x)[self.calc_count(x) // 2])) / 2\n\n\tdef calc_quantile(self,x: List[float], y: float) -> float:\n\t\"\"\"Returns a particular part of a data set\"\"\"\n\t\treturn sorted(x)[int(y * self.calc_count(x))]\n\n\tdef calc_interquantile_range(self,x: List[float]) -> float:\n\t\"\"\"Returns the difference in value between the upper quartile and lower quartile of a data set\"\"\"\n\t\treturn self.calc_quantile(x, 0.75) - self.calc_quantile(x, 0.25)\n\n\tdef calc_mode(self,x: List[float]) -> List[float]:\n\t\"\"\"Returns the number that is repeated most  in a data set\"\"\"\n\t\tfrequency_dict = {}\n\t\tfor i in x:\n\t\t\tif i not in frequency_dict:\n\t\t\t\tfrequency_dict[i] = 1\n\t\t\telse:\n\t\t\t\tfrequency_dict[i] += 1\n\t\tmodes = []\n\t\thighest_frequency = sorted(frequency_dict.values())[-1]\n\t\tfor key, value in frequency_dict.items():\n\t\t\tif value == highest_frequency:\n\t\t\t\tmodes.append(key)\n\t\treturn modes\n\n\tdef calc_variance(self,x: List[float]) -> float:\n\t\"\"\"Returns the variability from the mean of a data set\"\"\"\n\t\tassert self.calc_count(x) >= 2, \"Variance requires at least two elements\"\n\t\treturn sum([(i - (self.calc_mean(x)))**2 for i in x]) / self.calc_count(x)\n\n\tdef calc_bessel_variance(self,x: List[float]) -> float:\n\t   \"\"\"Returns the variability from the mean of a data set\"\"\"\n\t\tassert self.calc_count(x) >= 2, \"Variance requires at least two elements\"\n\t\treturn sum([(i - (self.calc_mean(x)))**2 for i in x]) / (self.calc_count(x) - 1)\n\n\tdef calc_standard_deviation(self,x: List[float]) -> float:\n\t\t\"\"\"Returns the dispersion of a dataset relative to its mean and is\n\t\tcalculated as the square root of the\n\t\tvariance\"\"\"\n\t\tassert self.calc_count(x) >= 2, \"Standard Deviation requires at least two \" \\\n\t\t\"elements\"\n\t\treturn (sum([(i - (self.calc_mean(x)))**2 for i in x]) / self.calc_count(x))**0.5\n\n\tdef calc_bessel_standard_deviation(self,x: List[float]) -> float:\n\t\t\"\"\"Bessel's correction is the use of n - 1 instead of n in the formula for the sample variance and sample standard deviation\"\"\"\n\t\tassert self.calc_count(x) >= 2, \"Standard Deviation requires at least two \" \\\n\t\t\"elements\"\n\t\treturn (sum([(i - (self.calc_mean(x)))**2 for i in x]) / \\\n\t\t\t\t(self.calc_count(x) - 1))**0.5\n\n\tdef calc_covariance(self,x: List[float], y: List[float]) -> float:\n\t\t\"\"\"Returns how much two random variables vary together.\"\"\"\n\t\tassert self.calc_count(x) == self.calc_count(y), \"x and y must contain the same \" \\\n\t\t\"number of elements\"\n\t\treturn sum([(i - (self.calc_mean(x))) * (j - (self.calc_mean(y))) for i, \\\n\t\t\t\t\tj in zip(x, y)]) / (self.calc_count(x) - 1)\n\n\tdef calc_correlation(self,x: List[float], y: List[float]) -> float:\n\t\t\"\"\"Returns the strength of the relationship between the relative movements of two variables\"\"\"\n\t\tif self.calc_bessel_standard_deviation(x) > 0 and \\\n\t\tself.calc_bessel_standard_deviation(y) > 0:\n\t\t\treturn self.calc_covariance(x, y) / self.calc_bessel_standard_deviation(x) / \\\n\t\t\tself.calc_bessel_standard_deviation(y)\n\t\telse:\n\t\t\treturn 0\n", "description": "Returns the number of data points in a data set", "category": "math", "imports": ["from typing import List"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "main_test_num", "data": "def main_test_num():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tarray.add_elements_from_file(r\"..\\array_elements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\HandOffElements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\switched_off.txt\")\r\n\r\n\tmed = medium.medium_from_file(r\"..\\medium.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\tcalc_field.set_nodes_num(341, 341, 1)\r\n\tcalc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n\tcalc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n\t# calc_field.set_nodes_num(1, 1, 131)\r\n\t# calc_field.set_grid_bottom(0.0e-03, 0.0e-03, 1.0e-03)\r\n\t# calc_field.set_grid_top(0.0e-03, 0.0e-03, 130.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# # calc_field = field.PressureFieldCartesian()\r\n\t# # calc_field.set_nodes_num(1, 121, 121)\r\n\t# # calc_field.set_grid_bottom(0.0e-03, -60.0e-03, 70.0e-03)\r\n\t# # calc_field.set_grid_top(0.0e-03, 60.0e-03, 190.0e-03)\r\n\t# # calc_field.prepare_grid()\r\n\r\n\t# array.set_focus_from_file(r\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\focus.txt\")\r\n\r\n\t# -------------------------CALCULATIONS-----------------------------------------\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\trayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\t# output.PrintCylAmpPhaseZ_Binary(calc_field, 1, 1)\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import analytic_calc\r", "import ribs\r", "import rayleigh\r", "\t# import cProfile\r"]}, {"term": "def", "name": "main", "data": "def main():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\array.txt\")\r\n\tarray.add_elements_from_file(r\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\array_elements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\HandOffElements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\switched_off.txt\")\r\n\r\n\tmed = medium.medium_from_file(r\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\medium.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\t# calc_field.set_nodes_num(341, 341, 1)\r\n\t# calc_field.set_grid_bottom(-85.0e-03, -85.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(85.0e-03, 85.0e-03, 45.0e-03)\r\n\tcalc_field.set_nodes_num(1, 1, 131)\r\n\tcalc_field.set_grid_bottom(0.0e-03, 0.0e-03, 1.0e-03)\r\n\tcalc_field.set_grid_top(0.0e-03, 0.0e-03, 130.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# # calc_field = field.PressureFieldCartesian()\r\n\t# # calc_field.set_nodes_num(1, 121, 121)\r\n\t# # calc_field.set_grid_bottom(0.0e-03, -60.0e-03, 70.0e-03)\r\n\t# # calc_field.set_grid_top(0.0e-03, 60.0e-03, 190.0e-03)\r\n\t# # calc_field.prepare_grid()\r\n\r\n\tarray.set_focus_from_file(r\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\focus.txt\")\r\n\r\n\t# -------------------------CALCULATIONS-----------------------------------------\r\n\tanalytic_calc.calc_field_analytically(calc_field, array, med)\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\t# output.PrintCylAmpPhaseZ_Binary(calc_field, 1, 1)\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import analytic_calc\r", "import ribs\r", "import rayleigh\r", "\t# import cProfile\r"]}, {"term": "def", "name": "main_one_el", "data": "def main_one_el():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\\\array.txt\")\r\n\tarray.add_element(\"0\", 0.0, 0.0)\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\t# array.add_elements_from_file(r\"array_elements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\HandOffElements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\switched_off.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\t# calc_field.set_nodes_num(341, 341, 1)\r\n\t# calc_field.set_grid_bottom(-85.0e-03, -85.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(85.0e-03, 85.0e-03, 45.0e-03)\r\n\tcalc_field.set_nodes_num(1, 1, 2601)\r\n\tcalc_field.set_grid_bottom(0.0e-03, 0.0e-03, 0.1e-03)\r\n\tcalc_field.set_grid_top(0.0e-03, 0.0e-03, 150.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# # calc_field = field.PressureFieldCartesian()\r\n\t# # calc_field.set_nodes_num(1, 121, 121)\r\n\t# # calc_field.set_grid_bottom(0.0e-03, -60.0e-03, 70.0e-03)\r\n\t# # calc_field.set_grid_top(0.0e-03, 60.0e-03, 190.0e-03)\r\n\t# # calc_field.prepare_grid()\r\n\r\n\t# array.set_focus_from_file(r\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\focus.txt\")\r\n\r\n\t# # -------------------------CALCULATIONS-----------------------------------------\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\tanalytic_calc.calc_exact_on_axis(calc_field, array, med)\r\n\r\n\toutput.save_field_on_disk(calc_field, \"field_Z\")\r\n\t# output.PrintCylAmpPhaseZ_Binary(calc_field, 1, 1)\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import analytic_calc\r", "import ribs\r", "import rayleigh\r", "\t# import cProfile\r"]}, {"term": "def", "name": "main_1d", "data": "def main_1d():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\\\array.txt\")\r\n\tarray.add_elements_from_file(r\"..\\\\array_elements.txt\")\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\t# array.add_elements_from_file(r\"array_elements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\HandOffElements.txt\")\r\n\t# array.switch_off_elements_from_file(ur\"d:\\Downloads Projects\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0434\u043b\u044f \u0441\u0442\u0430\u0442\u044c\u0438\\switched_off.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\t# calc_field.set_nodes_num(341, 341, 1)\r\n\t# calc_field.set_grid_bottom(-85.0e-03, -85.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(85.0e-03, 85.0e-03, 45.0e-03)\r\n\tcalc_field.set_nodes_num(1, 1, 1001)\r\n\tcalc_field.set_grid_bottom(0.0e-03, 0.0e-03, 100.0e-03)\r\n\tcalc_field.set_grid_top(0.0e-03, 0.0e-03, 150.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# # calc_field = field.PressureFieldCartesian()\r\n\t# # calc_field.set_nodes_num(1, 121, 121)\r\n\t# # calc_field.set_grid_bottom(0.0e-03, -60.0e-03, 70.0e-03)\r\n\t# # calc_field.set_grid_top(0.0e-03, 60.0e-03, 190.0e-03)\r\n\t# # calc_field.prepare_grid()\r\n\r\n\t# array.set_focus_from_file(r\"d:\\Educ\\\u0410\u041a\u0423\u0421\u0422\u0418\u041a\u0410\\.Current\\\u0420\u0430\u0441\u0447\u0435\u0442 \u0430\u043a \u043f\u043e\u043b\u044f \u0440\u0435\u0448\u0435\u0442\u043a\u0438\\CalcPy\\focus.txt\")\r\n\r\n\t# # -------------------------CALCULATIONS-----------------------------------------\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\trayleigh.calc_field_from_trans_opt(calc_field, array, med, 1000)\r\n\toutput.save_field_on_disk(calc_field, \"field_Z\")\r\n\t# output.PrintCylAmpPhaseZ_Binary(calc_field, 1, 1)\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import analytic_calc\r", "import ribs\r", "import rayleigh\r", "\t# import cProfile\r"]}, {"term": "def", "name": "main_y", "data": "def main_y():\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"array.txt\")\r\n\tarray.add_elements_from_file(r\"array_elements.txt\")\r\n\tmed = medium.medium_from_file(r\"water_medium.txt\")\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\tcalc_field.set_nodes_num(1, 401, 1)\r\n\tcalc_field.set_grid_bottom(0.0e-03, -100.0e-03, 45.0e-03)\r\n\tcalc_field.set_grid_top(0.0e-03, 100.0e-03, 45.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\tribs_phantom = {\r\n\t# \u0420\u0435\u0431\u0440\u0430 - \u043f\u043b\u043e\u0441\u043a\u0438\u0435 \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u043e\u043b\u043e\u0441\u043a\u0438 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u043e\u0439 \u0442\u043e\u043b\u0449\u0438\u043d\u044b\r\n\t\r\n\t# \u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u0438 \u0440\u0435\u0431\u0435\u0440 \u043e\u0442 \u0440\u0435\u0448\u0435\u0442\u043a\u0438\r\n\t'dist_to_ribs_plane': 45.0e-03,\r\n\r\n\t# \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0435\u0431\u0435\u0440\r\n\t'ribs_count': 5,\r\n\r\n\t# \u0428\u0438\u0440\u0438\u043d\u0430 \u0440\u0435\u0431\u0440\u0430\r\n\t'rib_width': 18.0e-03,\r\n\r\n\t# \u0428\u0438\u0440\u0438\u043d\u0430 \u0449\u0435\u043b\u0438 \u043c\u0435\u0436\u0434\u0443 \u0440\u0435\u0431\u0440\u0430\u043c\u0438\r\n\t'gap_width': 14.0e-03,\r\n\r\n\t# \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 Y \u043d\u0438\u0436\u043d\u0435\u0439 \u0433\u0440\u0430\u043d\u0438 \u043d\u0438\u0436\u043d\u0435\u0433\u043e \u0440\u0435\u0431\u0440\u0430\r\n\t'bottom_coord': 14.0e-03\r\n\t}\r\n\t\r\n\t# ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n\tarray.switch_off_elements_from_file(r\"switched_off.txt\")\r\n\tanalytic_calc.calc_field_analytically(calc_field, array, med)\r\n\toutput.save_field_on_disk(calc_field, \"field_2\")\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import analytic_calc\r", "import ribs\r", "import rayleigh\r", "\t# import cProfile\r"]}, {"term": "def", "name": "ribs_calc", "data": "def ribs_calc():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tarray.add_elements_from_file(r\"..\\array_elements.txt\")\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n\tribs_phantom = {\r\n\t# \u0420\u0435\u0431\u0440\u0430 - \u043f\u043b\u043e\u0441\u043a\u0438\u0435 \u0433\u043e\u0440\u0438\u0437\u043e\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u043f\u043e\u043b\u043e\u0441\u043a\u0438 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u043e\u0439 \u0442\u043e\u043b\u0449\u0438\u043d\u044b\r\n\t\r\n\t# \u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u043e\u0441\u043a\u043e\u0441\u0442\u0438 \u0440\u0435\u0431\u0435\u0440 \u043e\u0442 \u0440\u0435\u0448\u0435\u0442\u043a\u0438\r\n\t'dist_to_ribs_plane': 45.0e-03,\r\n\t# 'dist_to_ribs_plane': 65.0e-03,\r\n\r\n\t# \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0435\u0431\u0435\u0440\r\n\t'ribs_count': 5,\r\n\r\n\t# \u0428\u0438\u0440\u0438\u043d\u0430 \u0440\u0435\u0431\u0440\u0430\r\n\t'rib_width': 18.0e-03,\r\n\r\n\t# \u0428\u0438\u0440\u0438\u043d\u0430 \u0449\u0435\u043b\u0438 \u043c\u0435\u0436\u0434\u0443 \u0440\u0435\u0431\u0440\u0430\u043c\u0438\r\n\t'gap_width': 14.0e-03,\r\n\r\n\t# \u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 Y \u043d\u0438\u0436\u043d\u0435\u0439 \u0433\u0440\u0430\u043d\u0438 \u043d\u0438\u0436\u043d\u0435\u0433\u043e \u0440\u0435\u0431\u0440\u0430\r\n\t'bottom_coord': 14.0e-03\r\n\t}\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\tcalc_field.set_nodes_num(201, 201, 1)\r\n\tcalc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n\tcalc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n\t# calc_field.set_nodes_num(341, 341, 1)\r\n\t# calc_field.set_grid_bottom(-85.0e-03, -85.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(85.0e-03, 85.0e-03, 45.0e-03)\r\n\t# calc_field.set_nodes_num(1000, 1000, 1)\r\n\t# calc_field.set_grid_bottom(-100.0e-03, -100.0e-03, 45.0e-03)\r\n\t# calc_field.set_grid_top(100.0e-03, 100.0e-03, 45.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\t# ribs.create_switched_off_elements_file(ribs_phantom, array, \"switched_off.txt\")\r\n\t# array.switch_off_elements_from_file(r\"switched_off.txt\")\r\n\t\r\n\t# analytic_calc.calc_field_analytically(calc_field, array, med)\r\n\t# rayleigh.calc_field_from_trans_opt(calc_field, array, med, 300)\r\n\t\r\n\trayleigh.calc_field_from_trans_opt_ideal_trans(calc_field, array, med, 2000, ribs_phantom)\r\n\t# rayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\r\n\t\r\n\t# calc_field = output.restore_field_from_disk(\"field_plane\")\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\tribs.CalcPowerOnRibs(calc_field, ribs_phantom)\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import analytic_calc\r", "import ribs\r", "import rayleigh\r", "\t# import cProfile\r"]}, {"term": "def", "name": "main_num_test", "data": "def main_num_test():\r\n\tnew_work_dir_with_time_stamp()\r\n\tprepare_logging()\r\n\r\n\tarray = transducer.transducer_from_file(r\"..\\array.txt\")\r\n\tmed = medium.medium_from_file(r\"..\\water_medium.txt\")\r\n\r\n\tcalc_field = field.PressureFieldCartesian()\r\n\t# calc_field.set_nodes_num(501, 1, 1)\r\n\t# calc_field.set_grid_bottom(-30.0e-03, 0.0e-03, 130.0e-03)\r\n\t# calc_field.set_grid_top(30.0e-03, 0.0e-03, 130.0e-03)\r\n\tcalc_field.set_nodes_num(1, 1, 1623)\r\n\tcalc_field.set_grid_bottom(0.0e-03, 0.0e-03, 30.0e-03)\r\n\tcalc_field.set_grid_top(0.0e-03, 0.0e-03, 232.0e-03)\r\n\tcalc_field.prepare_grid()\r\n\r\n\trayleigh.calc_field_from_trans_opt_full(calc_field, array, med, 300)\r\n\t# rayleigh.reference_anal_calc_in_focal_plane(calc_field, array, med)\r\n\t# rayleigh.reference_anal_calc_on_axis(calc_field, array, med)\r\n\toutput.save_field_on_disk(calc_field, \"field_plane\")\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import analytic_calc\r", "import ribs\r", "import rayleigh\r", "\t# import cProfile\r"]}, {"term": "def", "name": "prepare_logging", "data": "def prepare_logging():\r\n\tlogging.basicConfig(\r\n\t\tfilename='log.txt',\r\n\t\tfilemode='w',\r\n\t\tformat='%(asctime)s %(message)s',\r\n\t\tdatefmt='%Y/%m/%d %H:%M:%S',\r\n\t\tlevel=logging.INFO\r\n\t\t)\r\n\tconsole = logging.StreamHandler(stream=sys.stdout)\r\n\tconsole.setLevel(logging.INFO)\r\n\tconsole.setFormatter(logging.Formatter('%(message)s'))\r\n\tlogging.getLogger('').addHandler(console)\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import analytic_calc\r", "import ribs\r", "import rayleigh\r", "\t# import cProfile\r"]}, {"term": "def", "name": "new_work_dir_with_time_stamp", "data": "def new_work_dir_with_time_stamp():\r\n\tpath = os.getcwd()\r\n\tpath += \"\\\\\"+ time.strftime(\"%Y-%m-%d_%H-%M-%S\", time.localtime())\r\n\tos.mkdir(path)\r\n\tos.chdir(path)\r\n\r\n", "description": null, "category": "math", "imports": ["import transducer\r", "import field\r", "import medium\r", "import output\r", "import logging\r", "import sys\r", "import os\r", "import time\r", "import analytic_calc\r", "import ribs\r", "import rayleigh\r", "\t# import cProfile\r"]}], [], [{"term": "def", "name": "insert_number_in_calc_result", "data": "def insert_number_in_calc_result(button_number):\n\tlbl_calc_result['text'] = button_number\n", "description": null, "category": "math", "imports": ["import tkinter as tk"]}], [{"term": "class", "name": "TestCalc", "data": "class TestCalc(unittest.TestCase):\n\n\tdef test_add(self):\n\t\tself.assertEqual(calc.add(10, 5), 15)\n\t\tself.assertEqual(calc.add(-1, 1), 0)\n\t\tself.assertEqual(calc.add(-1, -1), -2)\n\n\tdef test_subtract(self):\n\t\tself.assertEqual(calc.subtract(10, 5), 5)\n\t\tself.assertEqual(calc.subtract(-1, 1), -2)\n\t\tself.assertEqual(calc.subtract(-1, -1), 0)\n\n\tdef test_multiply(self):\n\t\tself.assertEqual(calc.multiply(10, 5), 50)\n\t\tself.assertEqual(calc.multiply(-1, 1), -1)\n\t\tself.assertEqual(calc.multiply(-1, -1), 1)\n\n\tdef test_divide(self):\n\t\tself.assertEqual(calc.divide(10, 5), 2)\n\t\tself.assertEqual(calc.divide(-1, 1), -1)\n\t\tself.assertEqual(calc.divide(-1, -1), 1)\n\t\tself.assertEqual(calc.divide(5, 2), 2.5)\n\n\t\twith self.assertRaises(ValueError):\n\t\t\tcalc.divide(10, 0)\n\n", "description": null, "category": "math", "imports": ["import unittest", "import calc"]}], [{"term": "def", "name": "check_kpoints_line", "data": "def check_kpoints_line(n, contents):\n\t\"\"\"Assert the contents of a line\"\"\"\n\twith open('KPOINTS', 'r') as f:\n\t\tlines = f.readlines()\n\t\tassert lines[n] == contents\n", "description": "Assert the contents of a line", "category": "math", "imports": ["import os", "import filecmp", "from ase.calculators.vasp import Vasp", "from ase.build import bulk"]}], [{"term": "def", "name": "C", "data": "def C(n, k):\n\treturn math.factorial(n)/(math.factorial(n-k)*math.factorial(k))\n\n", "description": null, "category": "math", "imports": ["import math", "import PyGnuplot as gp"]}, {"term": "class", "name": "classSolver:", "data": "class Solver:\n\n\tdef __init__(self, a, b, n):\n\t\tassert a > 0 and a < 1 and b > 0 and b < 1 and n >= 1\n\t\tself.a = a\n\t\tself.b = b\n\t\tself.inA = 1 - a\n\t\tself.inB = 1 - b\n\t\tself.n = n\n\t\tself.count = 0\n\t\tself.q = [None for i in range(n+1)]\n\t\tself.q[n] = 1\n\n\tdef reload(self, a, b, n):\n\t\tassert a > 0 and a < 1 and b > 0 and b < 1 and n >= 1\n\t\tself.a = a\n\t\tself.b = b\n\t\tself.inA = 1 - a\n\t\tself.inB = 1 - b\n\t\tself.n = n\n\t\tself.q = [None for i in range(n+1)]\n\t\tself.q[n] = 1\n\t# -------------------------1st----------------------------\n\tdef calc_pij(self, i, j):\n\t\tif j == 0:\n\t\t\treturn self.inA*self.b**i\n\t\telif j == i+1 and i < self.n:\n\t\t\treturn self.a*self.inB**i\n\t\telif i == self.n and j == self.n:\n\t\t\treturn self.inB**self.n + self.a*C(self.n, 1)*self.inB**(self.n-1)*self.b\n\t\telse:\n\t\t\treturn self.inA*C(i, j)*(self.inB**j)*self.b**(i-j) + self.a * C(i, j-1) * (self.inB**(j-1))*self.b**(i-j+1)\n\n\tdef calc_Pij(self, i, j):\n\t\tres = 0\n\t\tassert i >= 1 and i <= self.n and j >= 0 and j <= i-1\n\t\tfor k in range(0, j+1):\n\t\t\tres += self.calc_pij(i, k)\n\t\treturn res\n\n\tdef calc_qi(self, i):\n\t\tif self.q[i]:\n\t\t\treturn self.q[i]\n\t\telse:\n\t\t\ttmp = 0\n\t\t\tfor j in range(self.n, i, -1):\n\t\t\t\ttmp += self.calc_qi(j)*self.calc_Pij(j, i)\n\t\t\tself.q[i] = tmp/self.calc_pij(i, i+1)\n\t\t\treturn self.q[i]\n\n\tdef calc_pi(self, i):\n\t\tassert i >= 0 and i <= self.n\n\t\tif i == self.n:\n\t\t\ttmp = 0\n\t\t\tfor k in range(0, self.n):\n\t\t\t\ttmp += self.calc_qi(k)\n\t\t\treturn 1/(1+tmp)\n\t\telse:\n\t\t\treturn self.calc_pi(self.n) * self.calc_qi(i)\n\n\tdef calc_pxji(self, j, i):\n\t\treturn C(j, i) * self.inB**i * self.b**(j-i)\n\n\tdef calc_pxi(self, i):\n\t\tsum = 0\n\t\tfor j in range(i, self.n+1):\n\t\t\tsum += self.calc_pi(j)*self.calc_pxji(j, i)\n\t\treturn sum\n\n\t# -------------------------2nd----------------------------\n\n\tdef calc_special_pi(self):\n\t\treturn self.calc_pxi(self.n)\n\n\tdef calc_N(self):\n\t\tres = 0\n\t\tfor i in range(self.n+1):\n\t\t\tres += i * self.calc_pi(i)\n\t\treturn res\n\n\tdef calc_Nx(self):\n\t\tres = 0\n\t\tfor i in range(self.n+1):\n\t\t\tres += i * self.calc_pxi(i)\n\t\treturn res\n\n\tdef calc_VarN(self):\n\t\tres = 0\n\t\tfor i in range(self.n+1):\n\t\t\tres += (i - self.calc_N())**2*self.calc_pi(i)\n\t\treturn res\n\n\tdef calc_VarNx(self):\n\t\tres = 0\n\t\tfor i in range(self.n+1):\n\t\t\tres += (i - self.calc_Nx())**2*self.calc_pxi(i)\n\t\treturn res\n\n", "description": null, "category": "math", "imports": ["import math", "import PyGnuplot as gp"]}, {"term": "class", "name": "Graphics", "data": "class Graphics():\n\n\tdef _draw(self,\n\t\t\t points, # ([x1,y1],filename,functionname), ...\n\t\t\t xl='\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f a',\n\t\t\t yl='\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438',\n\t\t\t title='\u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a',\n\t\t\t yrange='[0:5]',\n\t\t\t xrange='[-1:1]',\n\t\t\t out_file='file.pdf'):\n\t\tgp.c('set xlabel \"' + xl + '\"')\n\t\tgp.c('set ylabel \"' + yl + '\"')\n\t\tgp.c('set title \"' + title + '\"')\n\t\tgp.c('set yrange ' + yrange)\n\t\tgp.c('set xrange ' + xrange)\n\t\tplotstr = 'plot '\n\t\tfor q in points:\n\t\t\tgp.s([q[0][0], q[0][1]], filename=q[1])\n\t\t\tplotstr += '\"' + q[1] + '\" u 1:2 w l title \"' + q[2] + '\", '\n\t\tplotstr = plotstr.strip(', ')\n\t\tgp.c(plotstr)\n\t\t# print(plotstr)\n\t\t# gp.pdf(\"out.pdf\")\n\n\tdef draw_N_Nx(self, a, b, n, da=0.001):\n\t\ts = Solver(a, b, n)\n\t\tx1 = []\n\t\ty1 = []\n\t\tx2 = []\n\t\ty2 = []\n\t\twhile a < 1-da:\n\t\t\tx1.append(a)\n\t\t\tx2.append(a)\n\t\t\ty1.append(s.calc_N())\n\t\t\ty2.append(s.calc_Nx())\n\t\t\ta += da\n\t\t\ts.reload(a, b, n)\n\t\tpoints = []\n\t\tpoints.append(((x1, y1), 'tmp.dat', 'N(a)'))\n\t\tpoints.append(((x2, y2), 'tmp2.dat', 'N*(a)'))\n\t\tself._draw(points=points,\n\t\t\t\t   title=\"\u0413\u0440\u0430\u0444\u0438\u043a \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 N(a) \u0438 N*(a)\",\n\t\t\t\t   )\n\n\tdef draw_VarN_VarNx(self, a, b, n, da=0.001):\n\t\ts = Solver(a, b, n)\n\t\tx1 = []\n\t\ty1 = []\n\t\tx2 = []\n\t\ty2 = []\n\t\twhile a < 1-da:\n\t\t\tprint(a)\n\t\t\tx1.append(a)\n\t\t\tx2.append(a)\n\t\t\ty1.append(s.calc_VarN())\n\t\t\ty2.append(s.calc_VarNx())\n\t\t\ta += da\n\t\t\ts.reload(a, b, n)\n\t\tpoints = []\n\t\tpoints.append(((x1, y1), 'tmp.dat', 'VarN(a)'))\n\t\tpoints.append(((x2, y2), 'tmp2.dat', 'VarN*(a)'))\n\t\tself._draw(points=points,\n\t\t\t\t   title=\"\u0413\u0440\u0430\u0444\u0438\u043a \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 VarN(a) \u0438 VarN*(a)\",\n\t\t\t\t   )\n\n\tdef draw_special_pi(self, a, b, n, da=0.001):\n\t\ts = Solver(a, b, n)\n\t\tx1 = []\n\t\ty1 = []\n\t\twhile a < 1-da:\n\t\t\tprint(a)\n\t\t\tx1.append(a)\n\t\t\ty1.append(s.calc_special_pi())\n\t\t\ta += da\n\t\t\ts.reload(a, b, n)\n\t\tpoints = []\n\t\tpoints.append(((x1, y1), 'tmp.dat', 'p*n(a)'))\n\t\tself._draw(points=points,\n\t\t\t\t   title=\"\u0413\u0440\u0430\u0444\u0438\u043a \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 VarN(a) \u0438 VarN*(a)\",\n\t\t\t\t   )\n", "description": null, "category": "math", "imports": ["import math", "import PyGnuplot as gp"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [], [{"term": "class", "name": "TestCalc", "data": "class TestCalc(unittest.TestCase):\n\n\tdef test_add(self):\n\t\tself.assertEqual(calc.add(10, 5), 15)\n\t\tself.assertEqual(calc.add(-1, 1), 0)\n\t\tself.assertEqual(calc.add(-1, -1), -2)\n\n\tdef test_subtract(self):\n\t\tself.assertEqual(calc.subtract(10, 5), 5)\n\t\tself.assertEqual(calc.subtract(-1, 1), -2)\n\t\tself.assertEqual(calc.subtract(-1, -1), 0)\n\n\tdef test_multiply(self):\n\t\tself.assertEqual(calc.multiply(10, 5), 50)\n\t\tself.assertEqual(calc.multiply(-1, 1), -1)\n\t\tself.assertEqual(calc.multiply(-1, -1), 1)\n\n\tdef test_divide(self):\n\t\tself.assertEqual(calc.divide(10, 5), 2)\n\t\tself.assertEqual(calc.divide(-1, 1), -1)\n\t\tself.assertEqual(calc.divide(-1, -1), 1)\n\t\tself.assertEqual(calc.divide(5, 2), 2.5)\n\n\t\twith self.assertRaises(ValueError):\n\t\t\tcalc.divide(10, 0)\n\n", "description": null, "category": "math", "imports": ["import unittest", "import calc"]}], [], [{"term": "def", "name": "simple_work_calc", "data": "def simple_work_calc(n, a, b):\n\t# TODO\n\tif n == 1:\n\t\treturn 1\n\telif n == 0:\n\t\treturn 0\n\telse: \n\t\treturn a*simple_work_calc(n//b, a, b) + n\n", "description": null, "category": "math", "imports": ["### the only imports needed are here", "from cmath import e", "import tabulate", "import time", "import math"]}, {"term": "def", "name": "test_simple_work", "data": "def test_simple_work():\n\tassert simple_work_calc(10, 2, 2) == 36 #TODO\n\tassert simple_work_calc(20, 3, 2) == 230 #TODO\n\tassert simple_work_calc(30, 4, 2) == 650 #TODO\n\t# Additional three cases:\n\tassert simple_work_calc(1, 2, 2) == 1\n\tassert simple_work_calc(40, 2, 3) == 90\n\tassert simple_work_calc(50, 4, 3) == 258\n\n", "description": null, "category": "math", "imports": ["### the only imports needed are here", "from cmath import e", "import tabulate", "import time", "import math"]}, {"term": "def", "name": "work_calc", "data": "def work_calc(n, a, b, f):\n\t# TODO\n\tif n == 1:\n\t\treturn 1\n\telif n == 0:\n\t\treturn 0\n\telse:\n\t\treturn a*work_calc(n//b, a, b, f) + f(n)\n", "description": null, "category": "math", "imports": ["### the only imports needed are here", "from cmath import e", "import tabulate", "import time", "import math"]}, {"term": "def", "name": "span_calc", "data": "def span_calc(n, a, b, f):\n\t# TODO\n\tif n== 1:\n\t\treturn 1\n\telif n == 0:\n\t\treturn 0\n\telse:\n\t\treturn span_calc((n//b), a, b, f) + f(n)\n\t\n", "description": null, "category": "math", "imports": ["### the only imports needed are here", "from cmath import e", "import tabulate", "import time", "import math"]}, {"term": "def", "name": "test_work", "data": "def test_work():\n\tassert work_calc(10, 2, 2,lambda n: 1) == 15 #TODO\n\tassert work_calc(20, 1, 2, lambda n: n*n) == 530 #TODO\n\tassert work_calc(30, 3, 2, lambda n: n) == 300 #TODO\n\t# Additional three cases:\n\tassert work_calc(40, 4, 2, lambda n: n+1) == 2477\n\tassert work_calc(50, 2, 4, lambda n: n) == 86\n\tassert work_calc(60, 3, 3, lambda n: n*n) == 5232\n", "description": null, "category": "math", "imports": ["### the only imports needed are here", "from cmath import e", "import tabulate", "import time", "import math"]}, {"term": "def", "name": "compare_work", "data": "def compare_work(work_fn1, work_fn2, work_fn3, sizes=[10, 20, 50, 100, 1000, 5000, 10000]):\n\t\"\"\"\n\tCompare the values of different recurrences for \n\tgiven input sizes.\n\n\tReturns:\n\tA list of tuples of the form\n\t(n, work_fn1(n), work_fn2(n), ...)\n\t\n\t\"\"\"\n\tresult = []\n\tfor n in sizes:\n\t\t# compute W(n) using current a, b, f\n\t\tresult.append((\n\t\t\tn,\n\t\t\twork_fn1(n),\n\t\t\twork_fn2(n),\n\t\t\twork_fn3(n)\n\t\t\t))\n\treturn result\n", "description": "\n\tCompare the values of different recurrences for \n\tgiven input sizes.\n\n\tReturns:\n\tA list of tuples of the form\n\t(n, work_fn1(n), work_fn2(n), ...)\n\t\n\t", "category": "math", "imports": ["### the only imports needed are here", "from cmath import e", "import tabulate", "import time", "import math"]}, {"term": "def", "name": "print_results", "data": "def print_results(results):\n\t\"\"\" done \"\"\"\n\tprint(tabulate.tabulate(results,\n\t\t\t\t\t\t\theaders=['n', 'W_1', 'W_2', 'W_3'],\n\t\t\t\t\t\t\tfloatfmt=\".3f\",\n\t\t\t\t\t\t\ttablefmt=\"github\"))\n", "description": " done ", "category": "math", "imports": ["### the only imports needed are here", "from cmath import e", "import tabulate", "import time", "import math"]}, {"term": "def", "name": "test_compare_work", "data": "def test_compare_work():\n\t# curry work_calc to create multiple work\n\t# functions taht can be passed to compare_work\n\t\n\t# create work_fn1\n\t# create work_fn2\n\twork_fn1 = lambda n:work_calc(n, 8, 2, lambda n: n**4) # let c be 4 which > log_b(a)\n\twork_fn2 = lambda n:work_calc(n, 8, 2, lambda n: n**2) # let c be 2 which < log_b(a)\n\twork_fn3 = lambda n:work_calc(n, 8, 2, lambda n: n**3) # let c be 3 which = log_b(a)\n\tres = print_results(compare_work(work_fn1, work_fn2, work_fn3))\n\tprint(res)\n", "description": null, "category": "math", "imports": ["### the only imports needed are here", "from cmath import e", "import tabulate", "import time", "import math"]}, {"term": "def", "name": "test_compare_span", "data": "def test_compare_span():\n\twork_fn1 = lambda n:span_calc(n, 8, 2, lambda n: 1) # f(n) = 1\n\twork_fn2 = lambda n:span_calc(n, 8, 2, lambda n: math.log(n,e)) # f(n) = logn\n\twork_fn3 = lambda n:span_calc(n, 8, 2, lambda n: n) # f(n) = n\n\tres = print_results(compare_work(work_fn1, work_fn2, work_fn3))\n\tprint(res)\n\t# TODO\n", "description": null, "category": "math", "imports": ["### the only imports needed are here", "from cmath import e", "import tabulate", "import time", "import math"]}], [{"term": "def", "name": "test_push", "data": "def test_push():\n\tcalc = RpnCalculator()\n\n\tcalc.push(0)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}, {"term": "def", "name": "test_push_multiple", "data": "def test_push_multiple(i, j, k, expected):\n\tcalc = RpnCalculator()\n\n\tcalc.push(i, j, k)\n\n\tv = calc.result()\n\n\tassert_that(v).is_equal_to(expected)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}, {"term": "def", "name": "test_push_no_values", "data": "def test_push_no_values():\n\tcalc = RpnCalculator()\n\n\tcalc.push()\n\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}, {"term": "def", "name": "test_pop", "data": "def test_pop(i, expected):\n\tcalc = RpnCalculator()\n\tcalc.push(i)\n\n\tv = calc.pop()\n\n\tassert_that(v).is_equal_to(expected)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}, {"term": "def", "name": "test_result", "data": "def test_result(i, j, expected):\n\tcalc = RpnCalculator()\n\tcalc.push(i, j)\n\n\tv = calc.result()\n\n\tassert_that(v).is_equal_to(expected)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}, {"term": "def", "name": "test_stack", "data": "def test_stack(i, j, expected):\n\tcalc = RpnCalculator()\n\tcalc.push(i, j)\n\n\tstack = calc.stack()\n\n\tassert_that(stack).is_equal_to(expected)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}, {"term": "def", "name": "test_clear", "data": "def test_clear():\n\tcalc = RpnCalculator()\n\tcalc.push(1, 2)\n\n\tassert_that(calc.stack()).is_not_empty()\n\n\tcalc.clear()\n\n\tassert_that(calc.stack()).is_empty()\n\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}, {"term": "def", "name": "test_add", "data": "def test_add(i, j, expected):\n\tcalc = RpnCalculator()\n\tcalc.push(i, j)\n\n\tcalc.add()\n\n\tv = calc.result()\n\tassert_that(v).is_equal_to(expected)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}, {"term": "def", "name": "test_sub", "data": "def test_sub(i, j, expected):\n\tcalc = RpnCalculator()\n\tcalc.push(i, j)\n\n\tcalc.sub()\n\n\tv = calc.result()\n\tassert_that(v).is_equal_to(expected)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}, {"term": "def", "name": "test_mul", "data": "def test_mul(i, j, expected):\n\tcalc = RpnCalculator()\n\tcalc.push(i, j)\n\n\tcalc.mul()\n\n\tv = calc.result()\n\tassert_that(v).is_equal_to(expected)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}, {"term": "def", "name": "test_div", "data": "def test_div(i, j, expected):\n\tcalc = RpnCalculator()\n\tcalc.push(i, j)\n\n\tcalc.div()\n\n\tv = calc.result()\n\tassert_that(v).is_equal_to(expected)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}, {"term": "def", "name": "test_sqrt", "data": "def test_sqrt(i, expected):\n\tcalc = RpnCalculator()\n\tcalc.push(i)\n\n\tcalc.sqrt()\n\n\tv = calc.result()\n\tassert_that(v).is_equal_to(expected)\n", "description": null, "category": "math", "imports": ["import pytest", "from assertpy import assert_that", "from rpn_calculator import RpnCalculator"]}], [{"term": "def", "name": "test_plugin_output_decimal_instantiate", "data": "def test_plugin_output_decimal_instantiate():\n\tOutputDecimal()\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_hook", "data": "def test_plugin_output_decimal_hook():\n\tcalc = TestCalculator()\n\tplugin = OutputDecimal()\n\tcalc.register_plugin_and_enable(plugin)\n\tassert plugin in calc.plugins\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_context_updated", "data": "def test_plugin_output_decimal_context_updated():\n\tcalc = TestCalculator()\n\tcalc.register_plugin_and_enable(OutputDecimal())\n\tassert calc.chksym(\"output_decimal\")\n\tassert callable(calc.getsym(\"output_decimal\"))\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_available", "data": "def test_plugin_output_decimal_available():\n\tcalc = TestCalculator()\n\tcalc.register_plugin_and_enable(OutputDecimal())\n\tassert callable(calc.command(\"output_decimal\"))\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_check_real", "data": "def test_plugin_output_decimal_check_real():\n\tplugin = OutputDecimal()\n\n\tfor x in generate_test_values(50, False, real=True, complex=False):\n\t\tassert plugin.check_number(str(x))\n\tfor x in generate_test_values(50, True, real=True, complex=False):\n\t\tassert plugin.check_number(str(x.evalf()))\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_check_complex", "data": "def test_plugin_output_decimal_check_complex():\n\tplugin = OutputDecimal()\n\n\tfor x in generate_test_values(10, False, real=False, complex=True):\n\t\tassert plugin.check_number(str(x))\n\tfor x in generate_test_values(10, True, real=False, complex=True):\n\t\tassert plugin.check_number(str(x.evalf()))\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_check_invalid", "data": "def test_plugin_output_decimal_check_invalid():\n\tplugin = OutputDecimal()\n\tfor t in generate_test_values(5, False, real=True, complex=False) + generate_test_values(5, False, real=False, complex=True):\n\t\tassert plugin.check_number(random_str()) is None\n\t\tassert plugin.check_number(f\"{t}*x\") is None\n\t\tassert plugin.check_number(f\"{t/1000}*x\") is None\n\t\tassert plugin.check_number(f\"{random_str()}({t})\") is None\n\t\tassert plugin.check_number(f\"[{t},{t}]\") is None\n\t\tassert plugin.check_number(f\"[{random_str()},{random_str()}]\") is None\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_output_real", "data": "def test_plugin_output_decimal_output_real(capfd):\n\tcalc = TestCalculator()\n\tplugin = OutputDecimal()\n\tcalc.register_plugin_and_enable(plugin)\n\n\tfor x in generate_test_values(5, False, real=True, complex=False):\n\t\tcalc.command(str(x))\n\tassert capfd.readouterr().out.count(\"Decimal\") == 0\n\n\tfor x in generate_test_values(5, True, real=True, complex=False):\n\t\tcalc.command(f\"sympify('{str(x)}')\")\n\t\toutput = capfd.readouterr().out\n\t\tif isinstance(x, sympy.core.numbers.Integer | sympy.core.numbers.Float):\n\t\t\tassert \"Decimal\" not in output\n\t\telse:\n\t\t\tassert \"Decimal\" in output\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_output_complex", "data": "def test_plugin_output_decimal_output_complex(capfd):\n\treturn\n\tcalc = TestCalculator()\n\tplugin = OutputDecimal()\n\tcalc.register_plugin_and_enable(plugin)\n\n\tfor x in generate_test_values(5, False, real=False, complex=True):\n\t\tcalc.command(str(x))\n\tassert capfd.readouterr().out.count(\"Decimal\") == 0\n\n\tfor x in generate_test_values(5, True, real=False, complex=True, include_edge_cases=False):\n\t\tcalc.command(f\"sympify('{str(x)}')\")\n\t\toutput = capfd.readouterr().out\n\t\tif isinstance(sympy.re(x), sympy.core.numbers.Integer | sympy.core.numbers.Float) and isinstance(sympy.im(x), sympy.core.numbers.Integer | sympy.core.numbers.Float):\n\t\t\tassert \"Decimal\" not in output\n\t\telse:\n\t\t\tassert \"Decimal\" in output\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_output_expressions", "data": "def test_plugin_output_decimal_output_expressions(capfd):\n\treturn\n\tcalc = TestCalculator()\n\tplugin = OutputDecimal()\n\tcalc.register_plugin_and_enable(plugin)\n\tfor x in generate_test_values(1, False, real=True, complex=True):\n\t\tcalc.command(f\"{str(x)} + {str(x)}\")\n\t\tcalc.command(f\"{str(x)} * {str(x)}**2\")\n\t\tcalc.command(f\"abs({str(x)}) - 2 * abs({str(x)})\")\n\tassert \"Decimal\" not in capfd.readouterr().out\n\tfor x in generate_test_values(1, True, real=True, complex=True, include_edge_cases=False):\n\t\tcalc.command(f\"sympify('{str(x)}') + sympify('{str(x)}')\")\n\t\tcalc.command(f\"sympify('{str(x)}') - 2 * sympify('{str(x)}')\")\n\t\toutput = capfd.readouterr().out\n\t\tif isinstance(sympy.re(x), sympy.core.numbers.Integer | sympy.core.numbers.Float) and isinstance(sympy.im(x), sympy.core.numbers.Integer | sympy.core.numbers.Float):\n\t\t\tassert \"Decimal\" not in output\n\t\telse:\n\t\t\tassert output.count(\"Decimal\") == 2\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_output_invalid", "data": "def test_plugin_output_decimal_output_invalid():\n\tplugin = OutputDecimal()\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_output_duplicates", "data": "def test_plugin_output_decimal_output_duplicates(capfd):\n\treturn\n\tcalc = TestCalculator()\n\tplugin = OutputDecimal()\n\tcalc.register_plugin_and_enable(plugin)\n\n\tfor x in generate_test_values(5, False, real=False, complex=True):\n\t\tcalc.command(str(x))\n\tassert capfd.readouterr().out.count(\"Decimal\") == 0\n\n\tfor x in generate_test_values(3, True, real=False, complex=True, include_edge_cases=True):\n\t\tcalc.command(f\"sympify('{str(x)}')\")\n\t\toutput = capfd.readouterr().out\n\t\tif isinstance(sympy.re(x), sympy.core.numbers.Integer | sympy.core.numbers.Float) and isinstance(sympy.im(x), sympy.core.numbers.Integer | sympy.core.numbers.Float):\n\t\t\tassert \"Decimal\" not in output\n\t\telse:\n\t\t\tassert \"Decimal\" in output\n\t\tcalc.command(f\"sympify('{str(x)}')\")\n\t\tassert capfd.readouterr().out.count(\"Decimal\") == 0\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_output_real_list_matrix", "data": "def test_plugin_output_decimal_output_real_list_matrix(capfd):\n\tcalc = TestCalculator()\n\tplugin = OutputDecimal()\n\tcalc.register_plugin_and_enable(plugin)\n\n\tfor n in range(0, 6):\n\t\tx = []\n\t\tm = None\n\t\tfor i in range(n):\n\t\t\ttv = generate_test_values(5, False, real=True, complex=False)\n\t\t\tm = min(m, len(tv)) if m is not None else len(tv)\n\t\t\tx.append(tv)\n\n\t\tif m:\n\t\t\tfor i in range(m):\n\t\t\t\tta = []\n\t\t\t\ttb = []\n\t\t\t\tfor j in range(n):\n\t\t\t\t\tta.append(str(x[j][i]))\n\t\t\t\t\ttb.append(f\"sympify({x[j][i]})\")\n\t\t\t\tcalc.command(f\"[{','.join(ta)}]\")\n\t\t\t\tcalc.command(\"0\")\n\t\t\t\tcalc.command(f\"[{','.join(tb)}]\")\n\t\t\t\tcalc.command(\"0\")\n\t\t\tassert capfd.readouterr().out.count(\"Decimal\") == 0\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_output_complex_list_matrix", "data": "def test_plugin_output_decimal_output_complex_list_matrix():\n\tplugin = OutputDecimal()\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_output_invalid_list_matrix", "data": "def test_plugin_output_decimal_output_invalid_list_matrix():\n\tplugin = OutputDecimal()\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_example", "data": "def test_plugin_output_decimal_example(capfd):\n\tcalc = TestCalculator()\n\tplugin = OutputDecimal()\n\tcalc.register_plugin_and_enable(plugin)\n\tcalc.command(\"3+3.2j\")\n\tassert \"Decimal\" in capfd.readouterr().out\n\tcalc.command(\"sympify('123/321',rational=True)\")\n\tassert \"Decimal\" in capfd.readouterr().out\n\tcalc.command(\"x=sympify('123/321',rational=True)\")\n\tassert \"Decimal\" in capfd.readouterr().out\n\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}, {"term": "def", "name": "test_plugin_output_decimal_enable_switch", "data": "def test_plugin_output_decimal_enable_switch(capfd):\n\tcalc = TestCalculator()\n\tplugin = OutputDecimal()\n\tcalc.register_plugin(plugin)\n\tassert plugin.setting_name\n\tcalc.settings[plugin.setting_name] = False\n\n\tfor x in generate_test_values(2, False, real=True, complex=True):\n\t\tcalc.command(str(x))\n\tfor x in generate_test_values(2, True, real=True, complex=True):\n\t\tcalc.command(f\"sympify('{str(x)}')\")\n\tassert capfd.readouterr().out.count(\"Decimal\") == 0\n", "description": null, "category": "math", "imports": ["import sympy", "from symcalc.plugins.output.decimal import OutputDecimal", "from tests import TestCalculator, generate_test_values, random_str"]}], [{"term": "def", "name": "systems_minimum", "data": "def systems_minimum():\n\t\"\"\"two atoms at potential minimum\"\"\"\n\n\tatoms = Atoms('H2', positions=[[0, 0, 0], [0, 0, 2 ** (1.0 / 6.0)]])\n\tcalc = LennardJones(rc=1.0e5)\n\tatoms.calc = calc\n\tyield atoms\n\n\tcalc = LennardJones(rc=1.0e5, smooth=True)\n\tatoms.calc = calc\n\tyield atoms\n\n", "description": "two atoms at potential minimum", "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_minimum_energy", "data": "def test_minimum_energy():\n\t# testing at the minimum to see if anything is on fire\n\t# See https://en.wikipedia.org/wiki/Lennard-Jones_potential\n\t# Minimum is at r=2^(1/6)*sigma, and it's -1.\n\n\tfor atoms in systems_minimum():\n\t\tassert atoms.get_potential_energy() == reference_potential_energy\n\t\tassert atoms.get_potential_energies().sum() == reference_potential_energy\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_minimum_forces", "data": "def test_minimum_forces():\n\t# forces should be zero\n\tfor atoms in systems_minimum():\n\t\tnp.testing.assert_allclose(atoms.get_forces(), 0, atol=1e-14)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_system_changes", "data": "def test_system_changes():\n\t# https://gitlab.com/ase/ase/-/merge_requests/1817\n\n\tfor atoms in systems_minimum():\n\t\tatoms.calc.calculate(atoms, system_changes=['positions'])\n\t\tassert atoms.get_potential_energy() == reference_potential_energy\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_finite_difference", "data": "def test_finite_difference():\n\t# ensure that we got the modified forces right\n\th = 1e-10\n\tr = 8.0\n\tcalc = LennardJones(smooth=True, ro=6, rc=10, sigma=3)\n\tatoms = Atoms('H2', positions=[[0, 0, 0], [r, 0, 0]])\n\tatoms2 = Atoms('H2', positions=[[0, 0, 0], [r + h, 0, 0]])\n\tatoms.calc = calc\n\tatoms2.calc = calc\n\n\tfd_force = (atoms2.get_potential_energy() - atoms.get_potential_energy()) / h\n\tforce = atoms.get_forces()[0, 0]\n\n\tnp.testing.assert_allclose(fd_force, force)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "systems_bulk", "data": "def systems_bulk():\n\tatoms = bulk(\"Ar\", cubic=True)\n\tatoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n\tcalc = LennardJones(rc=10)\n\tatoms.calc = calc\n\n\tyield atoms\n\n\tatoms = bulk(\"Ar\", cubic=True)\n\tatoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n\t# somewhat hand-picked parameters, but ok for comparison\n\tcalc = LennardJones(rc=12, ro=10, smooth=True)\n\tatoms.calc = calc\n\n\tyield atoms\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_bulk_energies", "data": "def test_bulk_energies():\n\t# check energies\n\n\tfor atoms in systems_bulk():\n\t\tassert np.allclose(\n\t\t\tatoms.get_potential_energy(), atoms.get_potential_energies().sum()\n\t\t)\n\t\t# energies should be equal in this high-symmetry structure\n\t\tassert atoms.get_potential_energies().std() == pytest.approx(0.0)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_bulk_forces", "data": "def test_bulk_forces():\n\tfor atoms in systems_bulk():\n\t\t# displace atom for 0.03 \\AA\n\t\tatoms.positions[0, 0] += 0.03\n\n\t\t# check forces sum to zero\n\t\tassert np.allclose(atoms.get_forces().sum(axis=0), 0)\n\n\t\t# check reference force\n\t\tassert atoms.get_forces()[0, 0] == reference_force\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}, {"term": "def", "name": "test_bulk_stress", "data": "def test_bulk_stress():\n\t# check stress computation for sanity and reference\n\t# reference value computed for \"non-smooth\" LJ, so\n\t# we only test that\n\tatoms = bulk(\"Ar\", cubic=True)\n\tatoms.set_cell(atoms.cell * stretch, scale_atoms=True)\n\n\tcalc = LennardJones(rc=10)\n\tatoms.calc = calc\n\n\tstress = atoms.get_stress()\n\tstresses = atoms.get_stresses()\n\n\tassert np.allclose(stress, stresses.sum(axis=0))\n\n\t# check reference pressure\n\tpressure = sum(stress[:3]) / 3\n\n\tassert pressure == reference_pressure\n", "description": null, "category": "math", "imports": ["import numpy as np", "import pytest", "from ase import Atoms", "from ase.build import bulk", "from ase.calculators.lj import LennardJones"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "test_version", "data": "def test_version():\n\ttxt = \"\"\"\n\t Program PWSCF v.6.4.1 starts on  5Aug2021 at 11: 2:26\n\n\t This program is part of the open-source Quantum ESPRESSO suite\n\t\"\"\"\n\tassert EspressoProfile.parse_version(txt) == '6.4.1'\n\n", "description": "\n\t Program PWSCF v.6.4.1 starts on  5Aug2021 at 11: 2:26\n\n\t This program is part of the open-source Quantum ESPRESSO suite\n\t", "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}, {"term": "def", "name": "verify", "data": "def verify(calc):\n\tassert calc.get_fermi_level() is not None\n\tassert calc.get_ibz_k_points() is not None\n\tassert calc.get_eigenvalues(spin=0, kpt=0) is not None\n\tassert calc.get_number_of_spins() is not None\n\tassert calc.get_k_point_weights() is not None\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}, {"term": "def", "name": "test_main", "data": "def test_main(espresso_factory):\n\tatoms = bulk('Si')\n\tatoms.calc = espresso_factory.calc()\n\tatoms.get_potential_energy()\n\tverify(atoms.calc)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}, {"term": "def", "name": "test_smearing", "data": "def test_smearing(espresso_factory):\n\tatoms = bulk('Cu')\n\tinput_data = {'system': {'occupations': 'smearing',\n\t\t\t\t\t\t\t 'smearing': 'fermi-dirac',\n\t\t\t\t\t\t\t 'degauss': 0.02}}\n\tatoms.calc = espresso_factory.calc(input_data=input_data)\n\tatoms.get_potential_energy()\n\tverify(atoms.calc)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}, {"term": "def", "name": "test_warn_label", "data": "def test_warn_label():\n\twith pytest.warns(FutureWarning):\n\t\tEspresso(label='hello')\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}, {"term": "def", "name": "test_error_command", "data": "def test_error_command():\n\twith pytest.raises(RuntimeError):\n\t\tEspresso(command='hello')\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.calculators.espresso import EspressoProfile, Espresso"]}], [{"term": "class", "name": "EvaluatorTest", "data": "class EvaluatorTest(unittest.TestCase):\n\t\"\"\"\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t\"\"\"\n\n\tdef test_number_input(self):\n\t\t\"\"\"\n\t\tTest different kinds of float inputs\n\n\t\tSee also\n\t\t  test_trailing_period (slightly different)\n\t\t  test_exponential_answer\n\t\t  test_si_suffix\n\t\t\"\"\"\n\t\teasy_eval = lambda x: calc.evaluator({}, {}, x)\n\n\t\tself.assertEqual(easy_eval(\"13\"), 13)\n\t\tself.assertEqual(easy_eval(\"3.14\"), 3.14)\n\t\tself.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n\t\tself.assertEqual(easy_eval(\"-13\"), -13)\n\t\tself.assertEqual(easy_eval(\"-3.14\"), -3.14)\n\t\tself.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n\tdef test_period(self):\n\t\t\"\"\"\n\t\tThe string '.' should not evaluate to anything.\n\t\t\"\"\"\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '.')\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '1+.')\n\n\tdef test_trailing_period(self):\n\t\t\"\"\"\n\t\tTest that things like '4.' will be 4 and not throw an error\n\t\t\"\"\"\n\t\tself.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n\tdef test_exponential_answer(self):\n\t\t\"\"\"\n\t\tTest for correct interpretation of scientific notation\n\t\t\"\"\"\n\t\tanswer = 50\n\t\tcorrect_responses = [\n\t\t\t\"50\", \"50.0\", \"5e1\", \"5e+1\",\n\t\t\t\"50e0\", \"50.0e0\", \"500e-1\"\n\t\t]\n\t\tincorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n\t\tfor input_str in correct_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\t\tfor input_str in incorrect_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to not equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertNotEqual(answer, result, msg=fail_msg)\n\n\tdef test_si_suffix(self):\n\t\t\"\"\"\n\t\tTest calc.py's unique functionality of interpreting si 'suffixes'.\n\n\t\tFor instance 'k' stand for 'kilo-' so '1k' should be 1,000\n\t\t\"\"\"\n\t\ttest_mapping = [\n\t\t\t('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n\t\t\t('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n\t\t\t('5.4m', 0.0054), ('8.7u', 0.0000087),\n\t\t\t('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n\t\t]\n\n\t\tfor (expr, answer) in test_mapping:\n\t\t\ttolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n\t\t\tfail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n\t\t\tfail_msg = fail_msg.format(expr[-1], expr, answer)\n\t\t\tself.assertAlmostEqual(\n\t\t\t\tcalc.evaluator({}, {}, expr), answer,\n\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t)\n\n\tdef test_operator_sanity(self):\n\t\t\"\"\"\n\t\tTest for simple things like '5+2' and '5/2'\n\t\t\"\"\"\n\t\tvar1 = 5.0\n\t\tvar2 = 2.0\n\t\toperators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n\t\tfor (operator, answer) in operators:\n\t\t\tinput_str = \"{0} {1} {2}\".format(var1, operator, var2)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n\t\t\t\toperator, input_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\tdef test_raises_zero_division_err(self):\n\t\t\"\"\"\n\t\tEnsure division by zero gives an error\n\t\t\"\"\"\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0.0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({'x': 0.0}, {}, '1/x')\n\n\tdef test_parallel_resistors(self):\n\t\t\"\"\"\n\t\tTest the parallel resistor operator ||\n\n\t\tThe formula is given by\n\t\t\ta || b || c ...\n\t\t\t= 1 / (1/a + 1/b + 1/c + ...)\n\t\tIt is the resistance of a parallel circuit of resistors with resistance\n\t\ta, b, c, etc&. See if this evaulates correctly.\n\t\t\"\"\"\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n\t\tself.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n\tdef test_parallel_resistors_with_zero(self):\n\t\t\"\"\"\n\t\tCheck the behavior of the || operator with 0\n\t\t\"\"\"\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n\tdef assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n\t\t\"\"\"\n\t\tHelper function to test many values at once\n\n\t\tTest the accuracy of evaluator's use of the function given by fname\n\t\tSpecifically, the equality of `fname(ins[i])` against outs[i].\n\t\tThis is used later to test a whole bunch of f(x) = y at a time\n\t\t\"\"\"\n\n\t\tfor (arg, val) in zip(ins, outs):\n\t\t\tinput_str = \"{0}({1})\".format(fname, arg)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n\t\t\t\tfname, input_str, val\n\t\t\t)\n\t\t\tself.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n\tdef test_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the trig functions provided in calc.py\n\n\t\twhich are: sin, cos, tan, arccos, arcsin, arctan\n\t\t\"\"\"\n\n\t\tangles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n\t\tcos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n\t\ttan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n\t\t# Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n\t\tself.assert_function_values('sin', angles, sin_values)\n\t\tself.assert_function_values('cos', angles, cos_values)\n\t\tself.assert_function_values('tan', angles, tan_values)\n\n\t\t# Include those where the real part is between -pi/2 and pi/2\n\t\tarcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n\t\tarcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n\t\tself.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n\t\t# Rather than a complex number, numpy.arcsin gives nan\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n\t\t# Include those where the real part is between 0 and pi\n\t\tarccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n\t\tarccos_angles = [0, 0.524, 0.628, 1 + 1j]\n\t\tself.assert_function_values('arccos', arccos_inputs, arccos_angles)\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n\t\t# Has the same range as arcsin\n\t\tarctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n\t\tarctan_angles = arcsin_angles\n\t\tself.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n\tdef test_reciprocal_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the reciprocal trig functions provided in calc.py\n\n\t\twhich are: sec, csc, cot, arcsec, arccsc, arccot\n\t\t\"\"\"\n\t\tangles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n\t\tcsc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n\t\tcot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n\t\tself.assert_function_values('sec', angles, sec_values)\n\t\tself.assert_function_values('csc', angles, csc_values)\n\t\tself.assert_function_values('cot', angles, cot_values)\n\n\t\tarcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n\t\tarcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n\t\tself.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n\t\tarccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n\t\tarccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n\t\tself.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n\t\t# Has the same range as arccsc\n\t\tarccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n\t\tarccot_angles = arccsc_angles\n\t\tself.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n\tdef test_hyperbolic_functions(self):\n\t\t\"\"\"\n\t\tTest the hyperbolic functions\n\n\t\twhich are: sinh, cosh, tanh, sech, csch, coth\n\t\t\"\"\"\n\t\tinputs = ['0', '0.5', '1', '2', '1+j']\n\t\tneg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n\t\tnegate = lambda x: [-k for k in x]\n\n\t\t# sinh is odd\n\t\tsinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n\t\tself.assert_function_values('sinh', inputs, sinh_vals)\n\t\tself.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n\t\t# cosh is even - do not negate\n\t\tcosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n\t\tself.assert_function_values('cosh', inputs, cosh_vals)\n\t\tself.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n\t\t# tanh is odd\n\t\ttanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n\t\tself.assert_function_values('tanh', inputs, tanh_vals)\n\t\tself.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n\t\t# sech is even - do not negate\n\t\tsech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n\t\tself.assert_function_values('sech', inputs, sech_vals)\n\t\tself.assert_function_values('sech', neg_inputs, sech_vals)\n\n\t\t# the following functions do not have 0 in their domain\n\t\tinputs = inputs[1:]\n\t\tneg_inputs = neg_inputs[1:]\n\n\t\t# csch is odd\n\t\tcsch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n\t\tself.assert_function_values('csch', inputs, csch_vals)\n\t\tself.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n\t\t# coth is odd\n\t\tcoth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n\t\tself.assert_function_values('coth', inputs, coth_vals)\n\t\tself.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n\tdef test_hyperbolic_inverses(self):\n\t\t\"\"\"\n\t\tTest the inverse hyperbolic functions\n\n\t\twhich are of the form arc[X]h\n\t\t\"\"\"\n\t\tresults = [0, 0.5, 1, 2, 1 + 1j]\n\n\t\tsinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n\t\tself.assert_function_values('arcsinh', sinh_vals, results)\n\n\t\tcosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n\t\tself.assert_function_values('arccosh', cosh_vals, results)\n\n\t\ttanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n\t\tself.assert_function_values('arctanh', tanh_vals, results)\n\n\t\tsech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n\t\tself.assert_function_values('arcsech', sech_vals, results)\n\n\t\tresults = results[1:]\n\t\tcsch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n\t\tself.assert_function_values('arccsch', csch_vals, results)\n\n\t\tcoth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n\t\tself.assert_function_values('arccoth', coth_vals, results)\n\n\tdef test_other_functions(self):\n\t\t\"\"\"\n\t\tTest the non-trig functions provided in calc.py\n\n\t\tSpecifically:\n\t\t  sqrt, log10, log2, ln, abs,\n\t\t  fact, factorial\n\t\t\"\"\"\n\n\t\t# Test sqrt\n\t\tself.assert_function_values(\n\t\t\t'sqrt',\n\t\t\t[0, 1, 2, 1024],  # -1\n\t\t\t[0, 1, 1.414, 32]  # 1j\n\t\t)\n\t\t# sqrt(-1) is NAN not j (!!).\n\n\t\t# Test logs\n\t\tself.assert_function_values(\n\t\t\t'log10',\n\t\t\t[0.1, 1, 3.162, 1000000, '1+j'],\n\t\t\t[-1, 0, 0.5, 6, 0.151 + 0.341j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'log2',\n\t\t\t[0.5, 1, 1.414, 1024, '1+j'],\n\t\t\t[-1, 0, 0.5, 10, 0.5 + 1.133j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'ln',\n\t\t\t[0.368, 1, 1.649, 2.718, 42, '1+j'],\n\t\t\t[-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n\t\t)\n\n\t\t# Test abs\n\t\tself.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n\t\t# Test factorial\n\t\tfact_inputs = [0, 1, 3, 7]\n\t\tfact_values = [1, 1, 6, 5040]\n\t\tself.assert_function_values('fact', fact_inputs, fact_values)\n\t\tself.assert_function_values('factorial', fact_inputs, fact_values)\n\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n\tdef test_constants(self):\n\t\t\"\"\"\n\t\tTest the default constants provided in calc.py\n\n\t\twhich are: j (complex number), e, pi, k, c, T, q\n\t\t\"\"\"\n\n\t\t# Of the form ('expr', python value, tolerance (or None for exact))\n\t\tdefault_variables = [\n\t\t\t('i', 1j, None),\n\t\t\t('j', 1j, None),\n\t\t\t('e', 2.7183, 1e-4),\n\t\t\t('pi', 3.1416, 1e-4),\n\t\t\t('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n\t\t\t('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n\t\t\t('T', 298.15, 0.01),  # 0 deg C = T Kelvin\n\t\t\t('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n\t\t]\n\t\tfor (variable, value, tolerance) in default_variables:\n\t\t\tfail_msg = \"Failed on constant '{0}', not within bounds\".format(\n\t\t\t\tvariable\n\t\t\t)\n\t\t\tresult = calc.evaluator({}, {}, variable)\n\t\t\tif tolerance is None:\n\t\t\t\tself.assertEqual(value, result, msg=fail_msg)\n\t\t\telse:\n\t\t\t\tself.assertAlmostEqual(\n\t\t\t\t\tvalue, result,\n\t\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t\t)\n\n\tdef test_complex_expression(self):\n\t\t\"\"\"\n\t\tCalculate combinations of operators and default functions\n\t\t\"\"\"\n\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n\t\t\t10.180,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n\t\t\t1.6,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"10||sin(7+5)\"),\n\t\t\t-0.567, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"sin(e)\"),\n\t\t\t0.41, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"k*T/q\"),\n\t\t\t0.025, delta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"e^(j*pi)\"),\n\t\t\t-1, delta=1e-5\n\t\t)\n\n\tdef test_explicit_sci_notation(self):\n\t\t\"\"\"\n\t\tExpressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^-3\"),\n\t\t\t-0.0016\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n\t\t\t-0.0016\n\t\t)\n\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^3\"),\n\t\t\t-1600\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(3)\"),\n\t\t\t-1600\n\t\t)\n\n\tdef test_simple_vars(self):\n\t\t\"\"\"\n\t\tSubstitution of variables into simple equations\n\t\t\"\"\"\n\t\tvariables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n\t\t# Should not change value of constant\n\t\t# even with different numbers of variables...\n\t\tself.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n\t\t# Easy evaluation\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n\t\t# Test a simple equation\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, '3*x-y'),\n\t\t\t21.25, delta=0.01  # = 3 * 9.72 - 7.91\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, 'x*y'),\n\t\t\t76.89, delta=0.01\n\t\t)\n\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(\n\t\t\t\t{'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n\t\t\t\t{}, \"5\"\n\t\t\t),\n\t\t\t5\n\t\t)\n\n\tdef test_variable_case_sensitivity(self):\n\t\t\"\"\"\n\t\tTest the case sensitivity flag and corresponding behavior\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n\t\t\t8.0\n\t\t)\n\n\t\tvariables = {'t': 1.0}\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(variables, {}, \"t\", case_sensitive=True),\n\t\t\t1.0\n\t\t)\n\t\t# Recall 'T' is a default constant, with value 298.15\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, \"T\", case_sensitive=True),\n\t\t\t298, delta=0.2\n\t\t)\n\n\tdef test_simple_funcs(self):\n\t\t\"\"\"\n\t\tSubsitution of custom functions\n\t\t\"\"\"\n\t\tvariables = {'x': 4.712}\n\t\tfunctions = {'id': lambda x: x}\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n\t\tfunctions.update({'f': numpy.sin})\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, functions, 'f(x)'),\n\t\t\t-1, delta=1e-3\n\t\t)\n\n\tdef test_function_case_insensitive(self):\n\t\t\"\"\"\n\t\tTest case insensitive evaluation\n\n\t\tNormal functions with some capitals should be fine\n\t\t\"\"\"\n\t\tself.assertAlmostEqual(\n\t\t\t-0.28,\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n\t\t\tdelta=1e-3\n\t\t)\n\n\tdef test_function_case_sensitive(self):\n\t\t\"\"\"\n\t\tTest case sensitive evaluation\n\n\t\tIncorrectly capitilized should fail\n\t\tAlso, it should pick the correct version of a function.\n\t\t\"\"\"\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n\t\t# With case sensitive turned on, it should pick the right function\n\t\tfunctions = {'f': lambda x: x, 'F': lambda x: x + 1}\n\t\tself.assertEqual(\n\t\t\t6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n\t\t)\n\t\tself.assertEqual(\n\t\t\t7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n\t\t)\n\n\tdef test_undefined_vars(self):\n\t\t\"\"\"\n\t\tCheck to see if the evaluator catches undefined variables\n\t\t\"\"\"\n\t\tvariables = {'R1': 2.0, 'R3': 4.0}\n\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n\t\t\tcalc.evaluator({}, {}, \"5+7*QWSEKO\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n\t\t\tcalc.evaluator({'r1': 5}, {}, \"r1+r2\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n\t\t\tcalc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "description": "\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t", "category": "math", "imports": ["import unittest", "import numpy", "import calc", "from pyparsing import ParseException"]}], [{"term": "def", "name": "band_map", "data": "def band_map(i, ras_multi, band_idx_multi, calc_arg, out_file):\n\ttem_file = os.path.join(os.path.dirname(out_file),\n\t\t\t\t\t\t\t'_temp_' + os.path.splitext(\n\t\t\t\t\t\t\tos.path.basename(out_file))[0] +\n\t\t\t\t\t\t\t'_' + str(i) + '.tif')\n\n\tif os.path.exists(tem_file):\n\t\treturn tem_file\n\n\tras_args = {chr(i + 65): ras\n\t\t\t\tfor i, ras in enumerate(ras_multi)}\n\tband_args = {chr(i + 65) + '_band': int(band_idx)\n\t\t\t\t for i, band_idx in enumerate(band_idx_multi)}\n\tinput_args = {**ras_args, **band_args}\n\n\tCalc(calc_arg, tem_file, creation_options=CREATION,\n\t\t quiet=True, **input_args)\n\n\treturn tem_file\n\n", "description": null, "category": "math", "imports": ["import os", "import numpy as np", "from geospace.gdal_calc import Calc", "from geospace._const import CREATION", "from geospace.raster import mosaic", "from geospace.utils import ds_name, context_file", "from multiprocessing import Pool, cpu_count", "from collections.abc import Iterable"]}, {"term": "def", "name": "check_iter", "data": "def check_iter(ds_multi, calc_args, band_idxs):\n\titer_ds_multi = isinstance(\n\t\tds_multi, Iterable) and not isinstance(ds_multi, str)\n\titer_calc_args = isinstance(\n\t\tcalc_args, Iterable) and not isinstance(calc_args, str)\n\tif band_idxs is not None:\n\t\tif iter_ds_multi:\n\t\t\titer_band_idxs = isinstance(band_idxs[0], Iterable)\n\t\telse:\n\t\t\titer_band_idxs = isinstance(band_idxs, Iterable)\n\telse:\n\t\titer_band_idxs = False\n\n\treturn iter_ds_multi, iter_calc_args, iter_band_idxs\n\n", "description": null, "category": "math", "imports": ["import os", "import numpy as np", "from geospace.gdal_calc import Calc", "from geospace._const import CREATION", "from geospace.raster import mosaic", "from geospace.utils import ds_name, context_file", "from multiprocessing import Pool, cpu_count", "from collections.abc import Iterable"]}, {"term": "def", "name": "broadcast_args", "data": "def broadcast_args(ds_multi, calc_args, band_idxs):\n\titer_ds_multi, iter_calc_args, iter_band_idxs = check_iter(\n\t\tds_multi, calc_args, band_idxs)\n\n\tif iter_ds_multi:\n\t\tds = ds_multi[0]\n\telse:\n\t\tds = ds_multi\n\n\tds, ras = ds_name(ds)\n\tif band_idxs is not None:\n\t\tif iter_band_idxs and iter_calc_args:\n\t\t\tif len(band_idxs) != len(calc_args):\n\t\t\t\traise Exception(\n\t\t\t\t\t'length of band list not equal to that of calc args')\n\t\telif iter_band_idxs:\n\t\t\tcalc_args = [calc_args] * len(band_idxs)\n\t\telif iter_calc_args:\n\t\t\tband_idxs = [band_idxs] * len(calc_args)\n\t\telse:\n\t\t\tcalc_args = [calc_args]\n\t\t\tband_idxs = [band_idxs]\n\telse:\n\t\tn_band = ds.RasterCount\n\t\tif iter_calc_args:\n\t\t\tif len(calc_args) != n_band:\n\t\t\t\traise Exception(\n\t\t\t\t\t'calc args length not equal to band counts')\n\t\telse:\n\t\t\tcalc_args = [calc_args] * n_band\n\n\t\tif iter_ds_multi:\n\t\t\tband_idxs = np.repeat(\n\t\t\t\tnp.arange(1, n_band + 1, dtype=int), len(ds_multi)).reshape(-1, len(ds_multi))\n\t\telse:\n\t\t\tband_idxs = np.arange(1, n_band + 1, dtype=int)\n\n\tif not iter_ds_multi:\n\t\tds_multi = [ras]\n\t\tband_idxs = np.array(band_idxs).reshape(len(band_idxs), 1)\n\n\treturn ds_multi, calc_args, band_idxs\n\n", "description": null, "category": "math", "imports": ["import os", "import numpy as np", "from geospace.gdal_calc import Calc", "from geospace._const import CREATION", "from geospace.raster import mosaic", "from geospace.utils import ds_name, context_file", "from multiprocessing import Pool, cpu_count", "from collections.abc import Iterable"]}, {"term": "def", "name": "map_calc", "data": "def map_calc(ds_multi, calc_args, out_path, band_idxs=None, multiprocess=True):\n\titer_ds_multi = isinstance(\n\t\tds_multi, Iterable) and not isinstance(ds_multi, str)\n\n\tif iter_ds_multi:\n\t\tds = ds_multi[0]\n\telse:\n\t\tds = ds_multi\n\n\tds, ras = ds_name(ds)\n\tout_file = context_file(ras, out_path)\n\n\tif os.path.exists(out_file):\n\t\treturn out_file\n\n\tds_multi, calc_args, band_idxs = broadcast_args(\n\t\tds_multi, calc_args, band_idxs)\n\n\tn = len(calc_args)\n\targs = zip(np.arange(1, n + 1, dtype=int),\n\t\t\t   [ds_multi] * n, band_idxs,\n\t\t\t   calc_args, [out_file] * n)\n\n\tif multiprocess:\n\t\twith Pool(min(cpu_count() - 1, n)) as p:\n\t\t\ttem_files = p.starmap(band_map, args)\n\telse:\n\t\ttem_files = []\n\t\tfor arg in args:\n\t\t\ttem_files.append(band_map(*arg))\n\n\tif len(tem_files) == 1:\n\t\tos.rename(tem_files[0], out_file)\n\telse:\n\t\tmosaic(tem_files, out_file, separate=True)\n\t\t[os.remove(f) for f in tem_files]\n\n\treturn out_file\n", "description": null, "category": "math", "imports": ["import os", "import numpy as np", "from geospace.gdal_calc import Calc", "from geospace._const import CREATION", "from geospace.raster import mosaic", "from geospace.utils import ds_name, context_file", "from multiprocessing import Pool, cpu_count", "from collections.abc import Iterable"]}], [{"term": "def", "name": "main", "data": "def main():\n\tprime_list_path=\"/home/mint/Desktop/\"\n\tprime_list_filename=\"primes_upto_100000.csv\"\n\tprimefile=prime_list_path + prime_list_filename\n\tprint(\"primefile currently is: \"+str(primefile))\n\n\t#define prime list\n\t#print('Importing primes from csv file')\n\tprimes = csvfile_store_primes(primefile)\n\t#print('First ten primes are: '+str(primes[0:10]))\n\n\t#print(sys.version_info)\n\n\t#initialise g_values, p_values, and h_values\n\t\n\t#g_values = range(2,3)\n\tg_values = range(2,50)\n\tp_values = primes[0:201]\n\t#p_values = primes[0:1001]\n\t#h_values = range(2,201)\n\n\ttotal_g_values=len(g_values)\n\tprint(\"total_g_values: \"+str(total_g_values))\n\n\ttotal_p_values=len(p_values)\n\tprint(\"total_p_values: \"+str(total_p_values))\n\n\t#total_h_values=len(h_values)\n\t#print(\"total_h_values: \"+str(total_h_values)\n\n\tTotal_values = total_g_values * total_p_values \n\tprint(\"Total_values: \"+str(Total_values))\n\t#Grand_total_values = total_p_values * total_g_values * total_h_values\n\t#print(\"Grand_total_values: \"+str(Grand_total_values)\n\n\t#define counts for different types of results\n\tcount_nosolns=0\n\tcount_x_equals_0=0\n\tcount_normal_soln=0\n\tcount_needlargerprimelist=0\n\tcount_q_e_found=0\n\tcount_q_e_not_found=0\t\n\tcount_notprime=0\n\tcount_calc_xi_no_solns=0\n\tcount_order_not_prime=0\n\tcount_order_prime=0\n\tcount_xi_not_found=0\n\tcount_calc_xi_status_false=0\n\t\n\t#define lists for different types of results\n\tanswers_to_be_checked=[]\n\t#order_false_list=[]\n\tn_prime=[]\n\tq_e_nf_order_p_list=[]\n\n\t#dlp is:  g**x congruent to h mod p, where g, h and p are known, p prime.\n\n\tprint(\"======================================\")\n\n\tprint('Looping through values for g, p, & h..')\n\n\tprevious_calc_g_p=[]\n\tprevious_calc_orders=[]\n\tfor g in g_values:\n\t\tprint(\"---------------\")\n\t\tprint(\"g is:\",str(g))\t\t\n\t\torder = 0\t\t\n\t\t#h_values_no_solution = False\n\t\tfor p in p_values:\n\t\t\tg_p=str(g)+\"_\"+str(p)\n\t\t\t#print(\"g_p is:\",g_p)\n\t\t\t#print(\"p is:\",str(p))\n\t\t\t#print(\"====================================\"\t\n\t\t\t#print(\"p is: \"+str(p)\t\n\t\t\tif g % p == 0:\n\t\t\t\tcount_nosolns = count_nosolns + len(range(1,p+1))\n\t\t\t\t#print(str(g)+\" mod \"+str(p)+\" is 0!\")\n\t\t\t\t#input(\"Waiting for user..\")\n\n\t\t\telif g > p:\t\t\t\n\t\t\t\tg_old = g\t\t\t\t\n\t\t\t\tg_new = g % p\n\t\t\t\t#print(\"g:\",g_old,\"> p:\",p,\"- revised g_new is:\",g_new)\n\t\t\t\t#input(\"Waiting for user..\")\n\n\t\t\t\t# 2 < order <= p - 1\n\t\t\t\t#no_prim_roots = p - 1 #for F_p this is euler_phi(p) = p-1 since p is prime.\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tif g_new == 1:\n\t\t\t\t\t#print(\"g_new is 1!\")\n\t\t\t\t\tcount_nosolns = count_nosolns + len(range(1,p+1))\n\t\t\t\t\t#input(\"Waiting for user..\")\n\t\t\t\telse:\n\t\t\t\t\t#print(\"g_new_p is:\",str(g_new)+\"_\"+str(p),\", g: \", g_old,\"> p:\",p,\"- revised g_new:\",g_new)\t\t\t\n\t\t\t\t\tg_new_p = str(g_new)+\"_\"+str(p)\n\t\t\t\t\tif g_new_p not in previous_calc_g_p:\n\t\t\t\t\t\t#if g_new !=2:\t\t\t\t\t\t\n\t\t\t\t\t\t#print(g_p,\" not in previous_calc_g_p\")\n\t\t\t\t\t\t#print(\"previous_calc_g_p:\",previous_calc_g_p)\n\t\t\t\t\t\t#input(\"Waiting for user..\")\t\t\t\t\t\t\n\t\t\t\t\t\t\n\n\t\t\t\t\t\tresult = Calc_prop_234(g_new,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false)\n\n\t\t\t\t\t\t#return count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\t\t\t\t\t\t#x_final=result[0]\n\t\t\t\t\t\tcount_nosolns=result[0]\n\t\t\t\t\t\tcount_calc_xi_no_solns=result[1]\n\t\t\t\t\t\tcount_normal_soln=result[2]\n\t\t\t\t\t\t#x_moduli_final=result[4]\n\t\t\t\t\t\tanswers_to_be_checked=result[3]\n\t\t\t\t\t\tcount_x_equals_0=result[4]\n\t\t\t\t\t\tcount_needlargerprimelist=result[5]\n\t\t\t\t\t\tcount_notprime=result[6]\n\t\t\t\t\t\tq_e_nf_order_p_list=result[7]\n\t\t\t\t\t\tcount_xi_not_found=result[8]\n\t\t\t\t\t\tcount_calc_xi_status_false=result[9]\n\t\t\t\t\t\tprevious_calc_orders=result[10]\n\n\t\t\t\t\telse:\n\t\t\t\t\t\t#print(g_p,\" is in previous_calc_g_p!\")\n\t\t\t\t\t\t\n\t\t\t\t\t\t#pos_g_new_p = previous_calc_g_p.index(g_new_p)\n\t\t\t\t\t\t#order=previous_calc_orders[pos_g_new_p][1]\n\t\t\t\t\t\torder=previous_calc_orders[previous_calc_g_p.index(g_new_p)][1]\n\t\t\t\t\t\t#print(\"Index of g_new_p:\",g_new_p,\" in previous_calc_g_p:\",previous_calc_g_p.index(g_new_p))\n\t\t\t\t\t\t#print(\"g_p:\",g_p,\"- Order for g_new_p:\",g_new_p,\" in previous_calc_orders:\",order)\n\t\t\t\t\t\t#input(\"Waiting for user..\")\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t#for order_prev_calc in previous_calc_orders:\n\t\t\t\t\t\t#\tif order_prev_calc[0]== g_new_p:\n\t\t\t\t\t\t#\t\torder=order_prev_calc[1]\n\t\t\t\t\t\t#\t\tprint(g_new_p,\" is in previous_calc_g_p! - order:\",order)\n\t\t\t\t\t\t#\t\t#input(\"Waiting for user..\")\n\t\t\t\t\t\t#\t\tbreak\n\n\t\t\t\t\t\t#print(\"previous_calc_orders:\",previous_calc_orders)\n\t\t\t\t\t\t#print(\"previous_calc_orders for\",g_p,previous_calc_orders.index(str(g_new)+\"_\"+str(p)))\n\t\t\t\t\t\t#input(\"Waiting for user..\")\n\n\t\t\telif g_p in previous_calc_g_p:\n\t\t\t\t\n\t\t\t\tprint(g_p,\" is in previous_calc_g_p!\")\n\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\telif g_p not in previous_calc_g_p:\n\t\t\t\t#if g !=2:\t\t\t\t\t\t\n\t\t\t\t\t#print(str(g)+\"_\"+str(p)+\" not in previous_calc_g_p\")\n\n\t\t\t\t#input(\"Waiting for user..\")\n\t\t\t\tresult = Calc_prop_234(g,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false)\n\n\t\t\t\t#x_final=result[0]\n\t\t\t\tcount_nosolns=result[0]\n\t\t\t\tcount_calc_xi_no_solns=result[1]\n\t\t\t\tcount_normal_soln=result[2]\n\t\t\t\t#x_moduli_final=result[4]\n\t\t\t\tanswers_to_be_checked=result[3]\n\t\t\t\tcount_x_equals_0=result[4]\n\t\t\t\tcount_needlargerprimelist=result[5]\n\t\t\t\tcount_notprime=result[6]\n\t\t\t\tq_e_nf_order_p_list=result[7]\n\t\t\t\tcount_xi_not_found=result[8]\n\t\t\t\tcount_calc_xi_status_false=result[9]\n\t\t\t\tprevious_calc_orders=result[10]\n\n\t\t\t\n\n\n\t#print(\"Grand_total_considered: \"+str(Grand_total_values)+\", total_g_values: \"+str(total_g_values)+\", total_p_values: \"+str(total_p_values)+\", total_h_values: \"+str(total_h_values)+\", number_no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false))\n\n\tprint(\"total_g_values: \"+str(total_g_values)+\", total_p_values: \"+str(total_p_values)+\", number_no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false))\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "Calc_prop_234", "data": "def Calc_prop_234(g,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false):\n\n\t#print(\"Running Calc_prop_234(\",g,\",\",p,\")\")\n\t\n\t#print(\"previous_calc_g_p:\",previous_calc_g_p)\n\t#input(\"Waiting for user..\")\n\tif str(g)+\"_\"+str(p) in previous_calc_g_p:\n\t\t#Order for g & p has already been calculated previously\n\t\tprint(\"Order for g:\",g,\",p:\",p,\"has already been calculated previously\")\n\t\tinput(\"Waiting for user..\")\n\t\torder=\"\"\n\n\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\n\telif str(g)+\"_\"+str(p) not in previous_calc_g_p:\n\t\tg_p_to_append=str(g)+\"_\"+str(p)\n\t\t#g_p_to_append.append(str(g)+\"_\"+str(p))\n\t\tprevious_calc_g_p.append(g_p_to_append)\n\n\t\tif g == 1:\n\t\t\t#order = Not found!\n\t\t\tprint(\"order not found - g = 1\")\n\t\t\tcount_nosolns = count_nosolns + 1\n\t\t\tcount_order_not_prime = count_order_not_prime + 1\n\t\t\tcount_q_e_not_found = count_q_e_not_found + 1\n\t\t\torder=\"Not found\"\n\n\t\t\tg_p_order_to_append=[]\n\t\t\tg_p_order_to_append.append(g_p_to_append)\n\t\t\tg_p_order_to_append.append(str(order))\n\t\t\tprevious_calc_orders.append(g_p_order_to_append)\n\n\t\telse:\n\t\t\t#print(\"previous_calc_orders:\",previous_calc_orders)\n\t\t\t#input(\"waiting for user..\")\n\t\t\tif g_p_to_append in previous_calc_orders:\n\t\t\t\tprint(\"g_p_to_append:\",g_p_to_append,\" is in previous_calc_orders\")\n\t\t\t\tprint(previous_calc_orders.index(g_p_order_to_append))\n\t\t\t\tinput(\"waiting for user..\")\n\n\t\t\telse:\n\t\t\t\t#Calculate order\n\t\t\t\t#print(\"g_p_to_append:\",g_p_to_append,\" is NOT in previous_calc_orders\")\n\t\t\t\t#input(\"waiting for user..\")\t\t\t\t\t\n\t\t\t\torder_result = calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p)\n\n\t\t\t\t#return count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\n\t\t\t\tcount_nosolns = order_result[0]\n\t\t\t\tcount_order_not_prime = order_result[1]\n\t\t\t\tcount_q_e_found = order_result[2]\n\t\t\t\tcount_q_e_not_found = order_result[3]\n\t\t\t\tq_e_nf_order_p_list = order_result[4]\n\t\t\t\tq = order_result[5]\n\t\t\t\te = order_result[6]\n\t\t\t\torder_status = order_result[7]\n\t\t\t\tn_prime = order_result[8]\n\t\t\t\tcount_order_prime = order_result[9]\n\t\t\t\tprint(\"g:\",g,\"p:\",p,\"count_order_prime:\",count_order_prime)\n\t\t\t\torder = order_result[10]\n\t\t\t\tprint(\"g:\",g,\"p:\",p,\"order:\",order)\n\t\t\t\tlhs = order_result[11]\n\t\t\t\tconcat_order_p=str(order)+\"_\"+str(p)\n\n\t\t\t\tg_p_order_to_append=[]\n\t\t\t\tg_p_order_to_append.append(str(g)+\"_\"+str(p))\n\t\t\t\tg_p_order_to_append.append(order)\n\t\t\t\tprevious_calc_orders.append(g_p_order_to_append)\n\t\t\t\t\n\t\t\t\tif str(order)+\"_\"+str(p) in q_e_nf_order_p_list:\n\t\t\t\t\t#print(str(order)+\"_\"+str(p),\"is in q_e_nf_order_p_list\")\n\t\t\t\t\t#elif concat_g_p in order_false_list:\n\t\t\t\t\tcount_nosolns = count_nosolns + len(range(1, p+1))\n\t\t\t\t\t#count_nosolns = count_nosolns + len(h_values)\n\t\t\t\t\t#print(\"Previously calculated - \"+str(concat_order_p)+\" is NOT in form q**e !\"\n\t\t\t\t\tx_final = \"No solns!\"\t\t\t\n\t\t\t\t\t#print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)+\", no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false)\n\t\t\t\telse:\n\t\t\t\t\th_soln_alreadyfound = False\n\t\t\t\t\tfor h in range(1, p+1):\n\t\t\t\t\t#for h in h_values:\t\t\t\t\t\t\t\t\n\t\t\t\t\t#concat_g_h = str(g)+\"_\"+str(h)\n\t\t\t\t\t\t#print(\"-----------------------------------\"\n\t\t\t\t\t\t#print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)\n\t\t\t\t\t\tif h >= p:\n\t\t\t\t\t\t\t#print(\"Setting h_soln_alreadyfound to true..\"\n\t\t\t\t\t\t\th_soln_alreadyfound = True\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\telif g == h:\n\t\t\t\t\t\t\tx_final = 1\n\t\t\t\t\t\t\tx_moduli_final = p - 1\n\t\t\t\t\t\t\tx_to_print = str(x_final)+\" mod \"+str(x_moduli_final)\n\t\n\t\t\t\t\t\t\t#Check answers\n\t\t\t\t\t\t\tif pow(g, x_final, p) != h:\n\t\t\t\t\t\t\t\tprint(\"CHECK x_final! g_new: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli: \"+str(x_moduli))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\telif pow(g, x_final + x_moduli_final, p) != h:\n\t\t\t\t\t\t\t\tprint(\"CHECK x_moduli_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli_final: \"+str(x_moduli_final))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t\t#print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t#print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)+\", no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false)\t\t\t\t\t\t\t\n\t\n\t\t\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif order_status == True:\n\t\t\t\t\t\t\t\t#print(\"q is: \"+str(q)+\", e is: \"+str(e) \n\t\t\t\t\t\t\t\t#dlp is:  g**x congruent to h mod p, where g, h and p are known, p prime.\t\n\t\t\t\t\t\t\t\t#print('Running dlp()..')\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t#print(\"-----------------------------------\"\n\t\t\t\t\t\t\t\t#print(\"count_nosolns before dlp(): \"+str(count_nosolns)\n\n\t\t\t\t\t\t\t\tresult = dlp(g, p, h, count_nosolns, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, q_e_nf_order_p_list, primes, q, e, n_prime, count_xi_not_found, count_calc_xi_status_false, lhs)\n\n\t\t\t\t\t\t\t\t#print(\"return back to h_values loop..\"\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\tx_final = result[0]\n\t\t\t\t\t\t\t\tcount_nosolns = result[1]\n\t\t\t\t\t\t\t\tcount_calc_xi_no_solns = result[2]\n\t\t\t\t\t\t\t\tcount_normal_soln = result[3]\n\t\t\t\t\t\t\t\tx_moduli_final = result[4]\n\t\t\t\t\t\t\t\tanswers_to_be_checked.append(result[5])\n\t\t\t\t\t\t\t\tcount_x_equals_0 = result[6]\n\t\t\t\t\t\t\t\tcount_needlargerprimelist = result[7]\n\t\t\t\t\t\t\t\tcount_notprime = result[8]\n\t\t\t\t\t\t\t\tq_e_nf_order_p_list = result[9]\n\t\t\t\t\t\t\t\t#order_false_list = result[9]\n\t\t\t\t\t\t\t\tcount_xi_not_found = result[10]\n\t\t\t\t\t\t\t\tcount_calc_xi_status_false = result[11]\n\n\t\t\t\t\t\t\t\t#print(\"count_nosolns after dlp(): \"+str(count_nosolns)\n\t\t\t\t\t\t\t\t#print(\"x_final is: \"+str(x_final))\n\t\t\t\t\t\t\t\t#print(\"x_moduli_final is: \"+str(x_moduli_final)\n\t\t\t\t\t\t\t\tif x_final != \"No solns!\":\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t#print(\"x_final != No solns!\"\n\t\t\t\t\t\t\t\t\tx_to_print = str(x_final)+\" mod \"+str(x_moduli_final)\n\t\t\t\t\t\t\t\t\t#input(\"Waiting for user..\")\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t#Check answers\n\t\t\t\t\t\t\t\t\tif pow(g, x_final, p) != h:\n\t\t\t\t\t\t\t\t\t\tprint(\"CHECK x_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli: \"+str(x_moduli))\n\t\t\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t\t\telif pow(g, x_final + x_moduli_final, p) != h:\n\t\t\t\t\t\t\t\t\t\tprint(\"CHECK x_moduli_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli_final: \"+str(x_moduli_final))\n\t\t\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t\t#print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)\n\n\t\t\t\t\t\t\telif order_status != False:\n\t\t\t\t\t\t\t\tprint(\"***ERROR!!!*** order_status is: \"+str(order_status))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t#error=True\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\telse:\t\t\t\t\n\t\tprint(\"Order for g:\",g,\",p:\",p,\"does not match criteria - not in previous_calc_g_p!\")\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "ghp_checks", "data": "def ghp_checks(g,h,p,floor_sqrt_p, count_a_notprime):\t\n\t\n\t#print(\"Running ghp_checks()..\"\n\n\t#Assuming p is prime: \t\tBest case: O(sqrt(n)+5)\t\tWorst case: O(sqrt(n)+8)\n\t#Assuming p is not prime: \tO(sqrt(n)+5)\n\n\tstatus=1\n\t\n\t#Simple Checks for g & h:\n\tif (g==0 or h==0):\t\t\t\t#O(1)\n\t\tprint('One or more numbers entered for g, h and p are 0. Please choose numbers that are not 0.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\telif g==1:\t\t\t\t\t#O(1)\n\t\tprint('g = 1 has trivial solutions for the dlp. Please choose another number.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\telif g<0:\t\t\t\t\t#O(1)\n\t\tprint('Number for g is negative. Please enter another number.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\n\t#Check if g = p:\n\telif g == p:\n\t\tprint('g = p. x is any integer. Please enter other numbers for g and p.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#Check if h < p:\n\telif h >= p:\n\t\tprint('h is >= p. Please enter other numbers for h and p.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#Need to check if p is prime\n\t#print('Checking if p is prime ..')\n\ta = isprime(p)\t\t\t\t\t#O(sqrt(n))\t\n\t#True for Prime\n\t#False for not prime\t\n\tif a == False:\t\t\t\t\t#O(1)\t#Best case: O(5)\n\t\tprint('The number entered for p: '+str(p)+' is not prime. Please choose a number that is prime for p.')\t\t\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tcount_a_notprime = count_a_notprime + 1\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#return status, a, b, q\n\treturn status, a\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "isprime", "data": "def isprime(p):\t\t\t#this is O(sqrt(n))\n\t\n\t#print(\"Running isprime(\",p,\")\")\n\t\n\t# www.rookieslab.com/posts/fastest-way-to-check-if-a-number-is-prime-or-not\n\tif p==1:\n\t\treturn False\t\n\t\t\n\ti = 2\n\twhile i*i <= p:\n\t\t#print(\"p is: \"+str(p)+\", i is: \"+str(i)\t\t#\"g = 4\" #\"p is: No exponent found, i is: 2\"\n\t\tif p % i == 0:\n\t\t\treturn False\n\t\ti += 1\n\n\treturn True\t\t\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "dlp", "data": "def dlp(g, p, h, count_nosolns, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, q_e_nf_order_p_list, primes, q, e, n_prime, count_xi_not_found, count_calc_xi_status_false, lhs):\n\n\t#print(\"-------------------------------------------------\"\n\tprint(\"Running dlp(\"+str(g)+\", \"+str(p)+\", \"+str(h)+\"..)\")\n\n\tfloor_sqrt_p = int(math.floor(math.sqrt(p)))\t\t\t#O(3)\n\t#print('floor_sqrt_p is: '+str(floor_sqrt_p))\n\n\t#Run checks on g, h & p\t\n\t#result=ghp_checks(g,h,p,floor_sqrt_p)\n\t#count_notprime = 0\t\t\t\t\t\t#O(1)\n\t\n\tresult=ghp_checks(g, h, p, floor_sqrt_p, count_notprime) \t#Best case: O(sqrt(n)+5) \tWorst case: O(sqrt(n)+8)\n\t#return status, a\n\t#status=0 for problem and 1 for no problem\n\t#a=True for Prime, a=False for not prime\n\t\n\tstatus_ghp = result[0]\n\tstatus_isprime_a = result[1]\n\n\tif status_isprime_a == False:\t\t\t\t\t#O(1)\n\t\tcount_notprime = count_notprime + 1\t\t\t#O(1)\n\t\tprint(str(p),\" is not prime! Exiting..\")\t\n\t\tsys.exit()\t\t\t\t\t\t\t#O(1)\n\telif status_ghp == 0:\t\t\t\t\t\t#O(1)\n\t\tprint(\"At least one of checks for g, h or p failed! Exiting..\")\t\n\t\tsys.exit()\t\t\t\t\t\t\t#O(1)\n\telse:\n\t\t#store result of p and isprime(p) so later we do not need to run isprime(p) again\t\t\t\t\n\t\tn_prime.append(p)\n\t\t\n\t\t#print(\"n_prime is: \"+str(n_prime)\n\n\t\t#check if sqrt_p > largest element in primes\n\t\t#print('checking if square root of p > largest element in primes...')\n\t\tsqrt_p = math.sqrt(p)\t\t\t\t\t#O(1)\n\t\tlargest_prime = primes[-1]\t\t\t\t#O(???)\n\t\tif sqrt_p > largest_prime:\t\t\t\t#O(1)\t#Subtotal: O(4)\n\t\t\tprint('Square root of p - '+str(sqrt_p)+' is greater than largest prime in list - '+str(largest_prime)+'. Consider using a larger prime list. Exiting..')\n\t\t\tcount_needlargerprimelist = count_needlargerprimelist + 1\n\t\t\tsys.exit()\n\t\telse:\t\t\t\t\t\t\t#O(1)\n\t\t\t#initialise lists\t\n\t\t\tx=[]\t\t\n\t\t\tx_moduli=[]\n\t\t\t\t\t\n\t\t\t################################################\n\t\t\t# Prop_234 Algorithm\n\t\t\t\n\t\t\t#print(\"g: \"+str(g)+\", h: \"+str(h)+\", q: \"+str(q)+\", e: \"+str(e)+\", p: \"+str(p)\n\t\t\t#count_xi_not_found, count_calc_xi_status_false\n\t\t\tresult_prop_234 = prop_234(g, h, q, e, p, count_xi_not_found, count_calc_xi_status_false, lhs)\n\t\t\t#result_prop_234 = prop_234(g, h, q, e, p)\n\t\t\t\n\t\t\t#return x, M, calc_xi_status, xi_found, count_xi_not_found, count_calc_xi_status_false\n\t\t\n\t\t\tx_initial = result_prop_234[0]\n\t\t\tmoduli = result_prop_234[1]\n\t\t\tcalc_xi_status = result_prop_234[2]\t\t\t\t#O(1)\t\t\t\t\n\t\t\txi_found = result_prop_234[3]\t\t\t\t\t#O(1)\t\n\t\t\tcount_xi_not_found = result_prop_234[4]\n\t\t\tcount_calc_xi_status_false = result_prop_234[5]\n\n\t\t\t#print(\"calc_xi_status is: \"+str(calc_xi_status)\n\t\t\tif calc_xi_status == True and xi_found == True:\n\t\t\t\t#Calc_xi method found solutions\n\t\t\t\t#print(\"x_initial is: \"+str(x_initial))\n\t\t\t\tx.append(x_initial)\n\t\t\t\t#print(\"x is: \"+str(x[0]))\n\t\t\t\t#print str(x_initial)+\" appended to x\"\n\t\t\t\tif x_initial == 0:\t\t\n\t\t\t\t\t#print(\"x[0] = 0\")\n\t\t\t\t\tcount_x_equals_0 = count_x_equals_0 + 1 \n\t\t\t\t\tx_moduli.append(moduli)\n\t\t\t\t\tif moduli == 0:\n\t\t\t\t\t\tprint(\"x[0]=0 and x_moduli[0] is 0!\")\n\t\t\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tcount_normal_soln = count_normal_soln + 1\n\n\t\t\t\t\tif pow(g,x[0],p) != h:\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"CHECK ANSWER!!!\"\n\t\t\t\t\t\tprint(\"CHECK FAILED - g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x[0])+\", x_moduli: \"+str(x_moduli[0]))\n\t\t\t\t\t\tanswers_to_be_checked.append(\"g: \"+str(g)+\" h: \"+str(h)+\" p: \"+str(p)+\" x: \"+str(x[0]))\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\n\t\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\n\t\t\t\telse:\n\t\t\t\t\t#print(\"x[0] != 0\"\n\t\t\t\t\tx_moduli.append(moduli)\n\t\t\t\t\t#print str(result_prop_234[1])+\" appended to x_moduli\"\n\t\t\t\t\tif moduli == 0:\n\t\t\t\t\t\tprint(\"x[0] != 0 and moduli is 0!\")\n\t\t\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t\tcount_normal_soln = count_normal_soln + 1\n\t\t\t\t\tif pow(g,x[0],p) != h:\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"CHECK ANSWER!!!\"\n\t\t\t\t\t\tprint(\"CHECK FAILED - g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x[0])+\", x_moduli: \"+str(x_moduli[0]))\n\t\t\t\t\t\tanswers_to_be_checked.append(str(g)+\"_\"+str(h)+\"_\"+str(p)+\"_\"+str(x[0]))\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\n\t\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, x_moduli[0], answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\n\t\t\telif xi_found == False:\n\t\t\t\t#input(\"xi_found = False ! \")\n\t\t\t\t#Calc_xi method failed to find solutions - an xi was not found !\n\t\t\t\t#print(\"Calc_xi method failed to find solutions - an xi was not found ! \"\n\t\t\t\t#x.append(0)\n\t\t\t\tx.append(\"No solns!\")\n\t\t\t\tcount_calc_xi_no_solns = count_calc_xi_no_solns + 1\n\t\t\t\tcount_nosolns = count_nosolns + 1\t\t\t\t#O(1)\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\t\t\telif calc_xi_status == False:\n\t\t\t\t#input(\"calc_xi_status = False ! \")\n\t\t\t\t#Calc_xi method failed to find solutions - lhs=1 and rhs=1\t\n\t\t\t\t#print(\"Calc_xi method failed to find solutions - calc_xi_status is false ! \"\n\t\t\t\tx.append(\"No solns!\")\n\t\t\t\t#x.append(0)\n\t\t\t\tcount_calc_xi_no_solns = count_calc_xi_no_solns + 1\n\t\t\t\tcount_nosolns = count_nosolns + 1\t\t\t\t#O(1)\n\t\t\t\t#sys.exit()\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\t\t\telse:\n\t\t\t\tprint(\"calc_xi_status is: \"+str(calc_xi_status))\n\t\t\t\tprint(\"xi_found is: \"+str(calc_xi_status))\n\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t#sys.exit()\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "fcalc_order", "data": "#def calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, order_false_list, primes, n_prime, count_order_prime):\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "fcalc_order", "data": "#def calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime):\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "calc_order", "data": "def calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p):\n\n\tprint(\"Running calc_order(\"+str(g)+\", \"+str(p)+\", ..)\")\n\n\tprint(\"count_order_not_prime:\",count_order_not_prime)\n\tprint(\"count_order_prime:\",count_order_prime)\n\tinput(\"waiting for user..\")\n\t#print(\"previous_calc_g_p:\",previous_calc_g_p)\n\t#print(\"Need to calculate & check order for: \"+str(g)+\"_\"+str(p)\n\t#print(\"Need to calculate & check order for: \"+str(concat_g_p)\t\t\t\t\t\n\n\t#use exponent function to get order of g mod p\n\tresult = exponent_g_p(g, p)\t\t\t\t#Worst: O(n + 7)\t#Best: O(8)\n\t#return x, status\n\t#status is False for \"no exponent found\"\t\n\t#status is True for exponent found\n\tprint(\"Running calc_order(\"+str(g)+\", \"+str(p)+\", ..)\")\n\n\torder = result[0]\t\t\t\t\t#O(1)\n\tstatus = result[1]\t\t\t\t\t#O(1)\n\t#status = result[1]\t\t\t\t\t\n\n\tprint(\"order is:\",str(order))\n\t#input(\"Waiting for user..\")\n\n\t#sqrt_order=math.floor(math.sqrt(order))\n\n\t# Now want order = q**e, where q is prime\n\t# obtain q and e \n\tif status == False:\t\t\t\t\t#O(1)\n\t\tq=0\t\t\t\t\t\t\t#O(1)\n\t\te=0\t\t\t\t\t\t\t#O(1)\n\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\tq_e_nf_order_p_list.append(concat_order_p)\t\t#O(1)\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\tcount_nosolns = count_nosolns + 1\t\t\t#O(1)\n\t\torder_status = False\n\t\tlhs = 0\n\t\tprint(\"p:\",p,\"order not found!\")\n\t\tinput(\"Waiting for user..\")\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif order == 1:\t\t\t\t\t#O(1)\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tprint(\"q:\",q,\"e:\",e,\"g:\",g,\"p:\",p,)\n\t\t#input(\"Order is 1! Waiting for user..\")\n\t\t#print(\"order: \"+str(order)\n\t\t#order_false_list.append(str(g)+\"_\"+str(p))\n\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\tcount_nosolns = count_nosolns + 1\t\t\t#O(1)\n\t\t#x_final = \"No solns!\"\n\t\torder_status = False\n\t\t#counts_added = True\n\t\tq = 0\n\t\te = 0\n\t\tlhs = 0\n\t\tprint(\"p:\",p,\"order=1, count_order_not_prime:\",count_order_not_prime)\n\t\tinput(\"Waiting for user..\")\t\t\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif order in n_prime:\t\t\t\t\n\t\t#print(\"order: \"+str(order)+\" is prime\"\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tcount_order_prime = count_order_prime + 1\t\t#O(1)\n\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\torder_status = True\n\t\tlhs = pow(g,1,p)\n\t\t#counts_added = True\n\t\t#print(\"q: \"+str(q)+\", e: \"+str(e)\n\t\tprint(\"p:\",p,\"order:\",order,\"count_order_prime:\",count_order_prime)\n\t\tinput(\"Waiting for user..\")\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif isprime(order) == True:\t\t\t\t#O(sqrt(n))\n\t\t#True for prime\n\t\t#False for not prime\n\t\t#order is prime\n\t\t#print(\"order: \"+str(order)+\" is prime\"\n\t\tn_prime.append(order)\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tcount_order_prime = count_order_prime + 1\t\t#O(1)\n\t\torder_status=True\n\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\tlhs = pow(g,1,p)\n\t\t#counts_added = True\n\t\t#print(\"q: \"+str(q)+\", e: \"+str(e)\n\t\tprint(\"p:\",p,\"order:\",order,\"count_order_prime:\",count_order_prime)\n\t\tinput(\"Waiting for user..\")\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\n\telse:\n\t\t#print(\"order is: \"+str(order)+\" - not 1 nor prime!\"\n\t\t#input(\"Waiting for user..\")\n\t\t#order is not 1 nor prime\t\t\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\t\tprint(\"order:\",order,\", count_order_not_prime now:\",count_order_not_prime)\n\n\t\t#now check if order is of form q**e, where q is prime, e>=1. \n\t\t#Need to find q and e.\n\t\t\t\t\t\n\t\tresult = calc_q_e(primes, order, p)\t\t\t#Worst: O(n**2+7n+4)\t#Best: O(12)\n\t\t#return q, e, result\n\n\t\tq=result[0]\t\t\t\t\t\t#O(1)\n\t\te=result[1]\t\t\t\t\t\t#O(1)\n\t\torder_status=result[2]\t\t\t\t\t#O(1)\n\t\t#status=result[2]\t\t\t\t\t\n\t\t#counts_added = False\t\t\t\t\n\t\t#print(\"order_status is: \"+str(order_status)\n\n\t\tif order_status == False:\n\t\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\t\t#order_false_list.append(str(g)+\"_\"+str(p))\t\t#O(1)\n\t\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\t\tlhs = 0\n\t\t\t#counts_added = True\n\t\telif order_status == True:\n\t\t\tlhs = pow(g,pow(q,e-1),p)\n\t\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\telse:\n\t\t\tprint(\"order_status is: \"+str(order_status))\n\t\t\tlhs = 0\n\t\t\tinput(\"Waiting for user..\")\n\t\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "calc_q_e", "data": "def calc_q_e(primes, order, p):\n\tprint(\"Running calc_q_e()..\")\t\n\t#print(\"Running calc_q_e(primes, \"+str(k)+\", \"+str(p)+\")..\"\n\n\t#Worst: O(n**2+7n+4)\t#Best: O(12)\n\n\t#q needs to be prime, e >= 1 \n\t#p is prime\t\n\n\tresult=False\t\t\t#O(1)\n\tq=0\t\t\t\t#O(1)\n\te=0\t\t\t\t#O(1)\n\tn=1\t\t\t\t#O(1)\n\t#print(\"p is: \"+str(p)\n\t\n\t#***********\n\t#\"What should be used for calculating q & e - pow(prime,n) or pow(prime,n,p)??\")***********\n\n\tfor prime in primes:\t\t#O(n)\t#Worst: O(n**2+7n)\t#Best: O(8)\n\t\t#print(\"==================\"\n\t\tn = 1\t\t\t\t\t\n\t\t#print(\"n is: \"+str(n)+\", order is: \"+str(k) \t\t\n\t\t#print(\"prime is: \"+str(prime)+\", p is: \"+str(prime)\n\t\twhile result is False and prime < p and n <= order and pow(prime,n) <= order:\t#O(n)\t#Worst: O(n+7)\t#Best: O(7)\n\t\t\t#print(\"-----------------\"\n\t\t\t#print(\"n is: \"+str(n)+\", order is: \"+str(order) \n\t\t\t#print(\"prime is: \"+str(prime)+\", p is: \"+str(p)\n\t\t\t#print(\"prime ** n is: \"+str(prime**n)\n\t\t\tif pow(prime,n) == order:\t\t\t\t\t\t\t#O(2)\n\t\t\t\tq = prime\t\t\t\t\t\t#O(1)\n\t\t\t\te = n\t\t\t\t\t\t\t#O(1)\n\t\t\t\tresult = True\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"result is: \"+str(result)\t\t\t\t\n\t\t\t\tbreak\t\t\t\t\t\t\t#O(1)\n\t\t\telse:\n\t\t\t\tn = n + 1\t\t\t\t\t\t#O(1)\n\treturn q, e, result\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "exponent_g_p", "data": "def exponent_g_p(g, p):\n\tprint(\"Running exponent_g_p()..\")\n\n\t#Worst: O(n + 7)\t#Best: O(8)\n\n\tn=1\t\t\t\t\t\t#O(1)\n\tx=0\t\t\t\t\t\t#O(1)\n\tstatus=False\t\t\t\t\t#O(1)\n\twhile n < p:\t\t\t\t\t#O(n)\t#Worst: O(n + 7)\n\t\t#print(\"n is:\"+str(n)\n\t\tif pow(g,n,p) == 1:\t\t#O(2)\t#Worst: O(6)\n\t\t\tx = n\t\t\t\t#O(1)\n\t\t\tstatus=True\t\t\t#O(1)\n\t\t\tbreak\t\t\t\t#O(1)\n\t\telif pow(g,n,p) == -1:\t\t#O(2)\t#Worst: O(6)\n\t\t\tx = 2 * n\t\t\t#O(1)\n\t\t\tstatus=True\t\t\t#O(1)\n\t\t\tbreak\t\t\t\t#O(1)\n\t\tn = n + 1\t\t\t\t#O(1)\n\n\tif x==0:\t\t\t\t\t#O(1)\n\t\tx=\"No exponent found\"\t\t\t#O(1)\n\t\tstatus=False\t\t\t\t#O(1)\n\n\treturn x, status\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "a_exp_x_eq_r", "data": "def a_exp_x_eq_r(a,p,r):\n\t#print(\"Running a_exp_x_eq_r(\"+str(a)+\", \"+str(p)+\", \"+str(r)+\"..)\"\n\tx=1\n\tx_values=[]\n\tcount=0\n\tdiff=0\n\tfor x in range(0,2*p):\n\t\t#print(\"count is: \"+str(count)\t\t\n\t\tif pow(a,x,p) == r:\n\t\t\t#print(\"a**x % p is: \"+str(r)\n\t\t\tx_values.append(x)\n\t\t\t#print str(x)+\" appended to x_values\"\n\t\t\tcount=count+1\n\t\t\tif count==2:\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#print str(x)+\" appended to x_values\n\t\t\t\tdiff = x_values[1] - x_values[0]\t\t\t\t\n\t\t\t\t#print(\"diff is: \"+str(diff)\n\t\t\t\tbreak\n\t\t#x = x + 1\n\treturn diff\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "prop_234", "data": "def prop_234(g, h, qi, ei, p, count_xi_not_found, count_calc_xi_status_false, lhs):\n\t#print(\"-----------------------------------\"\n\t#print(\"Running prop_234(\"+str(g)+\", \"+str(h)+\", \"+str(qi)+\", \"+str(ei)+\", \"+str(p)+\"..) to solve for x...\"\n\t\n\t#g[var], h[var], qi[var], ei[var], p\n\t#let x = x_0 +x_1*(q)+x_2*(q**2)+...+x_{e-1}q^(e-1), with 0 <= x_i < q, and determine successively x_0, x_1, x_2, ...\n\n\t#print(\"qi is: \"+str(qi)\n\t#print(\"ei is: \"+str(ei)\n\n\t# constuct list of q_powers from 0 to e-1\n\tq_powers=[]\t\t\t\t\t\t#O(1)\n\n\t#when ei > 0: #worst: O(n+3)\t#best: O(3)\n\t#when ei = 0: O(3)\t\n\t#when ei not > 0 nor = 0: O(4)\n\n\t#first q_power will always be 1 (for k=0)\n\tif ei > 0:\t\t\t\t\t\t#O(1)\t#worst: O(n+3)\t#best: O(1)\n\t\tfor k in range(0,ei):\t\t\t\t\t#O(n)\n\t\t\tq_powers.append(pow(qi,k))\t\t\t#O(2)\n\t\t\t#q_powers.append(qi**k)\n\telif ei==0:\t\t\t\t\t\t#O(1)\t#worst: O(3)\n\t\tprint(\"ei = 0!\")\t\t\t\t\t\n\t\tsys.exit()\t\t\t\t\t#O(1)\n\n\telse:\t\t\t\t\t\t\t#O(1)\t#worst: O(4)\n\t\tprint(\"ei is: \",str(ei))\n\t\tsys.exit()\t\t\t\t\t#O(1)\n\n\t#print(\"q_powers are: \"+str(q_powers)\n\n\t#now want to calculate xi using function\t\n\tresult = calc_xi(q_powers, g, p, h, qi, ei, lhs)\n\t#return xi, calc_xi_status, xi_found\t\n\txi = result[0]\n\tcalc_xi_status = result[1]\n\txi_found = result[2]\n\n\t#Subtotal - Worst: O(n**2 + 7n + 3), Best: O(3) when calc_xi_status == False\n\tif calc_xi_status == False:\n\t\tcount_calc_xi_status_false = count_calc_xi_status_false + 1\n\t\t#print(\"Calc_xi_status is false! - g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", qi: \"+str(qi)+\", ei: \"+str(ei)\n\t\tx=0 \t\t\t\t\t\t#O(1)\n\t\tM=0\t\t\t\t\t\t#O(1)\n\t\t#input(\"Calc_xi method failed (lhs=rhs=1). Waiting for user..\")\n\telif xi_found == False:\t\t\t\t#O(1)\n\t\tcount_xi_not_found = count_xi_not_found + 1\n\t\t#print(\"An xi was not found! - g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", qi: \"+str(qi)+\", ei: \"+str(ei)\n\t\tx=0 \t\t\t\t\t\t#O(1)\n\t\tM=0\t\t\t\t\t\t#O(1)\n\t\t#input(\"Calc_xi method failed (lhs=rhs=1). Waiting for user..\")\n\telif calc_xi_status == True and xi_found == True:\t\t#O(1)\t#Subtotal - Worst: O(n**2 + 7n + 2), Best: O(n+5) when only 1 as q_power\n\t\t#print(\"xi are: \"+str(xi)\n\n\t\t#print(\"---------------------------\"\n\t\n\t\t#print(\"q_powers are: \"+str(q_powers)\t\n\t\tfor q_power in q_powers: \t\t\t#O(n)\t#Worst: O(n**2 + 7n)\t#Best: O(n+4) - when only 1 as q_power\n\t\t\t#print(\"q_power is: \"+str(q_power)\n\t\t\t#print(\"index of q_power is: \"+str(q_powers.index(q_power))\n\t\t\t#print(\"xi[(q_powers.index(q_power))] is: \"+str(xi[(q_powers.index(q_power))])\t\t\n\t\t\ta=xi[q_powers.index(q_power)] \t\t\t\t\t\t\t#O(n+1)\n\t\t\tif q_power==1: \t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Adding \"+str(xi[q_powers.index(q_power)])+\" to x\"\n\t\t\t\tx = a\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#x = xi[q_powers.index(q_power)]\n\t\t\t\n\t\t\telse:\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Adding \"+str(xi[(q_powers.index(q_power))])+\"*\"+str(q_power)+\" to x, and reducing mod \"+str(qi**ei)\n\t\t\t\tx = (x + a * q_power) % pow(qi,ei)\t\t\t\t\t#O(4)\n\t\t\t\t#x = (x + xi[q_powers.index(q_power)]*q_power) % (pow(qi,ei))\t\n\t\t\t\n\t\tM = pow(qi,ei)\t\t\t\t\t#O(1)\n\t\t#print(\"x is: \"+str(x)+\" mod \"+str(M))\t\t\n\telse:\n\t\tprint(\"calc_xi_status is: \"+str(calc_xi_status))\n\t\tprint(\"xi_found are: \"+str(xi_found))\n\t\tinput(\"Waiting for user..\")\n\n\treturn x, M, calc_xi_status, xi_found, count_xi_not_found, count_calc_xi_status_false\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "calc_xi", "data": "def calc_xi(q_powers, g, p, h, qi, ei, lhs):\n\t#print(\"---------------------------\"\t\t\t\n\t#print(\"Running calc_xi(\"+str(q_powers)+\", \"+str(g)+\", \"+str(h)+\", \"+str(qi)+\", \"+str(ei)+\", \"+str(p)+\") ..\"\t\t\t\t\n\n\t#initialise xi, cumul_q_powers, cumul_xi_q_powers\n\txi = len(q_powers) * [0]\t\t\t\t#O(len(q_powers))\n\tcumul_q_powers=[]\t\t\t\t\t#O(1)\n\tcumul_xi_q_powers=[]\t\t\t\t\t#O(1)\n\tcalc_xi_status=True\t\t\t\t\t#O(1)\n\n\t#Loop through each q_power until xi are calculated\n\tfor q_power in q_powers:\n\t\t#print(\"q_power is: \"+str(q_power)\t\t\n\t\tif calc_xi_status == True:\n\t\t\tif q_power==1:\t\t\t\t\t\t\t#total (incl top lev if) = \n\t\t\t\t#solving for x_0\t\t\n\t\t\t\t#print(\"---------------------------\")\t\t\t\n\t\t\t\txi_found = False\n\t\t\t\t#print(\"Solving for xi[0] ..\")\t\t\t\t\n\t\t\t\t#print(\"q_power is: \"+str(q_power))\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t#lhs= pow(g,pow(qi,ei-1),p)\t\t\t\t#O(2)\n\t\t\t\t#lhs= (g**qi**(ei-1)) % p\t\t\t\t\n\t\t\t\t#print(\"lhs is: \"+str(lhs)) \t\t# lhs=76\t\n\t\t\t\t\t\n\t\t\t\trhs= pow(h,pow(qi,ei-1),p)\t\t\t\t#O(2)\n\t\t\t\t#rhs= (h**qi**(ei-1)) % p\t\t\t\t\n\t\t\t\t#print(\"rhs is: \"+str(rhs)) \t\t# rhs=1\t\t\n\t\t\t\n\t\t\t\tif lhs ==1 and rhs ==1:\t\t\t\t\t#O(1)\t\t#subtotal: O(2)\t#section= O(2n+6)\t\t\t\t\n\t\t\t\t\t#This method seems to fail for this instance. Try p-1/q method?? brute force search instead??\t\t\t\t\n\t\t\t\t\tcalc_xi_status=False\t\t\t\t#O(1)\n\n\t\t\t\telse:\t\t\t\t\t\t\t#O(1)\t\t#Worst: O(4n+1)\t#best: O(6)\n\t\t\t\t\tfor t in range(0, qi):\t\t\t\t#O(n)\t\t#Worst: O(4n)\t#best: O(5)\n\t\t\t\t\t\tif pow(lhs,t,p) == rhs:\t\t\t#O(2)\t\t#Worst: O(4)\t#best: O(4)\n\t\t\t\t\t\t#if lhs**t % p ==rhs:\t\t\t\t\t\n\t\t\t\t\t\t\txi[0]=t  # xi[0]=\t\t#O(1)\n\t\t\t\t\t\t\txi_found = True\n\t\t\t\t\t\t\t#print(\"xi[0] is: \"+str(t)\t\n\t\t\t\t\t\t\tbreak\t\t\t\t\n\n\t\t\t\tif calc_xi_status == True:\t\t\t\t#O(1)\t\t#subtotal= O(3)\n\t\t\t\t\tcumul_xi_q_powers.append(xi[0])\t\t\t#O(1)\n\t\t\t\t\tcumul_q_powers.append(1)\t\t\t#O(1)\n\t\t\t\t\t#print(\"cumul_xi_q_powers after append: \"+str(cumul_xi_q_powers)\n\t\t\t\t\t#print(\"cumul_q_powers after append: \"+str(cumul_q_powers)\n\t\t\telse:\t\t\t\t\t\t\t\t#O(1)\t\t#total (incl top lev if) = \n\t\t\t\t#solving for x_n (n!=0)\n\t\t\t\t#print(\"---------------------------\")\t\t\t\n\t\t\t\txi_found = False\n\t\t\t\t#print(\"solving for x_n (n!=0)..\"\t\t\t\n\t\t\t\t#print(\"q_power is: \"+str(q_power))\t\t\t\n\t\t\t\txi_number = q_powers.index(q_power)\t\t\t#O(n)\n\t\t\t\t#print(\"Solving for xi[\"+str(xi_number)+\"] ..\")\n\t\t\t\t#print(\"cumul_xi_q_powers before append: \"+str(cumul_xi_q_powers)\n\t\t\t\t#print(\"cumul_q_powers before append: \"+str(cumul_q_powers)\n\t\t\t\n\t\t\t\t#print(\"g is: \"+str(g) # g=\n\t\t\t\t#print(\"h is: \"+str(h) # h=\n\t\t\t\ta = xi_number-1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"xi[\"+str(a)+\"] is: \"+str(xi[a])) # xi[0]=0\t\n\t\t\t\n\t\t\t\t#print(\"qi is: \"+str(qi))\t#qi = \n\t\t\t\t#print(\"ei is: \"+str(ei))\t#ei = \n\t\t\t\n\t\t\t\t#print(\"cumul_xi_q_powers is: \"+str(cumul_xi_q_powers)\t\n\t\t\t\t#print(\"cumul_q_powers is: \"+str(cumul_q_powers)\t\t\n\t\t\t\n\t\t\t\tz=0\n\t\t\t\tfor cumul_xi_q_power in cumul_xi_q_powers:\t\t#O(n+1)\n\t\t\t\t\tz = z + cumul_xi_q_power\n\t\t\t\t\n\t\t\t\t#print(\"sum_cumul_xi_q_power is now: \"+str(z)\t\t\n\n\t\t\t\tif xi[xi_number-1] >= 0:\n\t\t\t\t\t#need to work out what g**-[x_0+x_1*q_power+x_2*q_power**2 + ...], mod p is!!!\n\t\t\t\t\t#print(\"xi[\"+str(xi_number-1)+\"] >= 0\")\n\t\t\t\t\t#print(\"Calculating modular inverse of \"+str(g)+\"**\"+str(-z)+\", mod \"+str(p))\t\t\t\n\t\t\t\t\t#print(\"Calculating modular inverse of \"+str(g)+\"**\"+str(-xi[xi_number-1])+\", mod \"+str(p))\t\t\t\t\n\t\t\t\t\tb = calc_modinverse(g, z, p)\t\t\t\t\t\t\t\t\t#O(n+5)\n\t\t\t\t\t#b = calc_modinverse(g, xi[xi_number-1], p) #b = \n\t\t\t\t\t#print(\"inverse is: \"+str(b)) #b = \t\t\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t#(ei - xi_number - 1)\n\n\t\t\t\t\t#print(\"(h * b)**qi**(ei - xi_number - 1) % p is: \"+str((h * b)**qi**(ei - xi_number - 1) % p)\n\t\t\t\t\trhs = pow(h * b,pow(qi,ei - xi_number - 1),p)\n\t\t\t\t\t#rhs = (h * b)**qi**(ei - xi_number - 1) % p\t\t\t\t\t\t#O(2n+2)\t\t\t\n\n\t\t\t\t\t#print(\"rhs is: \"+str(rhs))\t\t\t\t\t\t\t\t\n\n\t\t\t\t\tif lhs == 1 and rhs == 1:\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(4)\n\t\t\t\t\t\tprint(\"lhs == 1 and rhs == 1\")\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t#print(\"xi[\"+str(xi_number-1)+\"] >= 0, lhs=1, rhs=1, g: \"+str(g)+\" p: \"+str(p)+\" h: \"+str(h))\t\t\t\n\t\t\t\t\t\tcalc_xi_status=False\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\tprint(\"Calc_xi method failed. h is \"+str(h)+\", p is \"+str(p)+\", qi is \"+str(qi)+\", ei is \"+str(ei)+\", xi_number is \"+str(xi_number))\t\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\t\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(n**2+5n+1)\n\t\t\t\t\t\tfor t in range(0, qi):\t\t\t\t\t\t\t\t\t#O(n)\n\t\t\t\t\t\t\t#print(\"t is now: \"+str(t)\t\t\t\t\t\n\t\t\t\t\t\t\t#print(str(lhs)+\"**\"+str(t)+\" % \"+str(p)+\" is: \"+str(lhs**t % p))\n\t\t\t\t\t\t\tif lhs**t % p == rhs:\t\t\t\t\t\t\t\t#O(n+2)\n\t\t\t\t\t\t\t\txi[xi_number]=t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\t\t\txi_found = True\n\t\t\t\t\t\t\t\t#print(\"xi[\"+str(xi_number)+\"] is: \"+str(t)\t\t\t\t\t\n\t\t\t\t\t\t\t\tbreak\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t\t\t\t\tif calc_xi_status == True:\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(n**2+5n+1)\n\t\t\t\t\t\tcumul_xi_q_powers.append(q_power * xi[xi_number])\t\t\t\t\t\t#O(3)\n\t\t\t\t\t\t#print(\"Appended \"+str(q_power * xi_number)+\" to cumul_xi_q_powers\")\n\t\t\t\t\t\tcumul_q_powers.append(q_power)\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"Appended \"+str(q_power)+\" to cumul_q_powers\")\n\t\t\t\t\t\t#print(\"xi[\"+str(xi_number)+\"] is: \"+str(xi[xi_number]))\n\t\t\t\t\t\t#print(\"xi are now:\"+str(xi)\n\t\t\t\t\t\t#print(\"cumul_xi_q_powers after append: \"+str(cumul_xi_q_powers)\n\t\t\t\t\t\t#print(\"cumul_q_powers after append: \"+str(cumul_q_powers)\n\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\tprint(\"xi[\"+str(xi_number-1)+\"] is negative !!! CHECK\")\t\t\t\t\t\t\t\n\t\t\t\t\t#input(\"Waiting for user..\")\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\n\t\t\t\t#print(\"lhs is: \"+str(lhs)\n\t\t\t\t#print(\"rhs is: \"+str(rhs)\n\n\t\t\t\t#print(\"rhs is: \"+str(rhs))\n\t\t\t\t#print(\"qi is: \"+str(qi)\n\treturn xi, calc_xi_status, xi_found\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "calc_modinverse", "data": "def calc_modinverse(g, power, p):\n\t#print(\"----------------\"\n\t#print(\"Running calc_modinverse()..\"\t\t\t\t\t#O(1)\n\t#print(\"g is: \"+str(g)\n\t#print(\"power is: \"+str(power)\n\t\n\tfloor_sqrt_p = math.floor(math.sqrt(p))\t\t\t\t\t#O(2)\n\n\t#this only works for p being prime!\t\n\tif isprime(p) == True:\t\t\t\t\t\t\t#O(1)\t#Subtotal O(2n+4)\n\t#if isprime(p,floor_sqrt_p) == 0:\t\n\t\tresult=g**(p-2)% p\t\t\t\t\t\t#O(n+2)\t#Subtotal O(2n+3)\n\t\t#print str(g)+\"**(-1) mod \"+str(p)+\" is: \"+str(result)\n\t\tc = result**power % p\t\t\t\t\t\t#O(n+1)\n\t\t#print(\"c is: \"+str(c)\t\n\t\t#print str(g)+\"**(-\"+str(power)+\") mod \"+str(p)+\" is: \"+str(c)\n\telse:\n\t\t#p is not prime!\n\t\t#print(\"p: \"+str(p)+\" is not prime!\"\n\t\tc = modinv(g, p)\t\t\t\t\t\t#O(n)\n\t\t#return x % m\n\t\t#print(\"inverse is: \"+str(c)\t\t\n\n\t\t#input(\"Waiting for user..\")\t\n\treturn c\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "calc_powers", "data": "def calc_powers(factors):\n\t#Worst: O(n+13)\t#Best: O(18)\n\n\t#print(\"Running calc_powers..\"\n\t#Now want to find max powers m for each factor in factors.\n\t#can do this by counting unique factors\t\t\t\n\tprime_factors=[]\t\t\t\t\t#O(1)\n\tpowers = []\t\t\t\t\t\t#O(1)\n\tfac_list = []\t\t\t\t\t\t#O(1)\n\tcount = 0\t\t\t\t\t\t#O(1)\n\tc_primefactors_powers = 0\t\t\t\t#O(1)\n\ts_before_calc_powers = time.clock()\t\t\t#O(1)\n\tfor factor in factors:\t\t\t\t\t#O(n)\t#Worst: O(n**2 + 2n)\t#Best: O(???)\n\t\t#print(\"------------------\"\t\n\t\t#print(\"factor is: \"+str(factor)\t\t\n\t\tif fac_list:\t\t\t\t\t\t#O(1)\t#Worst: O(n+2)\t#Best: O(4)\n\t\t\t#temp factor list for comparisons has values\n\t\t\tif factor in fac_list:\t\t\t\t\t#O(n)\t#Worst: O(n+1)\t#Best: O(6)\n\t\t\t\t#print str(factor)+\" is in fac_list\"\n\t\t\t\tcount += 1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#temp_factor, temp_count = factor, count\n\t\t\t\t#print temp_factor, temp_count\n\t\t\telse:\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#factor is not in fac_list\n\t\t\t\t#add factor to prime_factors\n\t\t\t\tprime_factors.append(factor)\t\t\t\t#O(1)\n\t\t\t\t#print(\"Added \"+str(factor)+\" to prime_factors\"\n\t\t\t\t#print(\"prime_factors is: \"+str(prime_factors)\n\t\t\t\t#add current count to powers for previous factor\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\tpowers.append(count)\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Added \"+str(count)+\" to powers for previous factor\"\n\t\t\t\t#count = 0\n\t\t\t\t#print str(factor)+\" is NOT in fac_list\"\n\t\t\t\t#append it\t\t\t\t\n\t\t\t\tfac_list.append(factor)\t\t\t\t\t#O(1)\n\t\t\t\t#count += 1\n\t\t\t\tcount = 1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#print(\"fac_list is: \"+str(fac_list)\n\t\t\t\t\n\t\telse:\t\t\t\t\t\t\t\t#O(1)\t#Subtotal: O(4)\n\t\t\t#temp factor list for comparisons is empty\n\t\t\t#store 1st factor\n\t\t\t#print(\"fac_list is empty\"\n\t\t\tfac_list.append(factor)\t\t\t\t\t\t#O(1)\n\t\t\t#print str(factor)+\" added to fac_list\"\n\t\t\tprime_factors.append(factor)\t\t\t\t\t#O(1)\n\t\t\t#print(\"Added \"+str(factor)+\" to prime_factors\"\n\t\t\t#print(\"prime_factors is: \"+str(prime_factors)\t\t\t\n\t\t\tcount += 1\t\t\t\t\t\t\t#O(1)\n\t\t\t#print(\"count is: \"+str(count)\t\n\n\t#add count to powers for the last factor and the last factor\n\tpowers.append(count)\n\t#print(\"Added \"+str(count)+\" to powers for previous factor\"\n\t\n\t#print(\"prime_factors are: \"+str(prime_factors)\n\t#print(\"powers are: \"+str(powers)\n\n\tc_calc_powers = time.clock() - s_before_calc_powers\n\n\treturn prime_factors, powers, c_calc_powers\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "csvfile_store_primes", "data": "def csvfile_store_primes(csv_filename_var):\t\t### Assumming O(n+len(z1)+1) ### \n\t\t\n\twith open(csv_filename_var,'r') as csvfile:\n\t\t# Strip quotes, eol chars etc, and convert strings to integers\n\t\t#Use generator to get number of primes to use in prime file..\n\t\tz1=(int(x) for row in csv.reader(csvfile) for x in row)\t\t\t#O(n) - Potentially y rows and x items in each row, \n\t\t\t\t\t\t\t\t\t\t\t# however only 1 row in csvfile being used. Hence x*y=x items to store\n\t\tprimes=list(z1)\t\t\t\t\t\t\t\t#O(len(z1))\n\t\tcsvfile.close()\t\t\t\t\t\t\t\t#O(1 ???)\n\treturn primes\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "factorise", "data": "def factorise(N):\t\t\n\t#based on code on https://stackoverflow.com/questions/16996217/prime-factorization-list/\n\t#Author states this is is O(sqrt(n))) and 2 to 3 times faster than trial division in practice\n\t#Wheel factorization, which uses a cyclic set of gaps between potential primes to greatly\n\t#reduce the number of trial divisions.\n\t#uses a 2,3,5-wheel\n\n\t#print(\"Running factorise(\"+str(N)+\")..\"\t\n\n\t#Create lists to hold prime factors of N and corresponding powers\n\tfactors = []\t\t\t\t\t#O(1)\n\n\t#print(\"Calculating prime factors and powers\"\n\ts_before_factorisations = time.clock()\t\t\n\t\t\n\tgaps=[1,2,2,4,2,4,2,4,6,2,6]\t\t\t#O(1)\n\tlength, cycle = 11,3\t\t\t\t#O(1)\n\tf, factors, next = 2, [], 0\t\t\t#O(1)\n\twhile f*f <= N:\t\t\t\t\t#O(n)\n\t\twhile N % f == 0:\t\t\t\t#O(n)\n\t\t\t#f is a factor. Add factor f to fs\n\t\t\tfactors.append(f)\t\t\t\t#O(1)\n\t\t\tN /= f\t\t\t\t\t\t#O(1)\n\t\tf += gaps[next]\t\t\t\t#O(1)\n\t\tnext += 1\t\t\t\t#O(1)\n\t\tif next == length:\t\t\t#O(1)\n\t\t\tnext = cycle\t\t\t\t#O(1)\n\tif N > 1: factors.append(N)\n\t\t\n\tc_factorisations = time.clock() - s_before_factorisations\t#O(1)\n\n\treturn factors, c_factorisations\t\t#O(1)\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "size_input_check", "data": "def size_input_check(input_number):\n\n\t#if size of number >= 2*10^8 then return message about memory & exit\n\tif input_number>2*(10**8):\n\t\tprint('Number to attempt to factorise is too large for this program. Try a number <= 2x10^8. Exiting to avoid memory issues..')\n\t\tsys.exit()\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "egcd", "data": "def egcd(a, b):\t\t\t\t\t\t\t#O(n)\n\t#print(\"Running egcd(\"+str(a)+\",\"+str(b)+\")\")\n\t#print(\"a is: \"+str(a)\n\t#print(\"b is: \"+str(b)\t\n\tif a == 0:\t\t\t\t\t\t#O(1)\t#Subtotal: O(2)\n\t\treturn (b, 0, a)\t\t\t\t#O(1)\n\tg, y, x = egcd(b % a, a)\t\t\t\t\n\t#print(\"egcd(\"+str(a)+\",\"+str(b)+\") is: \"+str(g)+\" \"+str(x - (b//a) * y)+\" \"+str(y))\n\treturn (g, x - (b//a) * y, y)\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "modinv", "data": "def modinv(a, m):\t\t\t\t\t\t#### O(n+5) ###\n\t#print(\"Running modinv(\"+str(a)+\",\"+str(m)+\")\")\t\t\n\t#print(\"a is: \"+str(a)\n\t#print(\"m is: \"+str(m)\t\n\t#egcd(a, m)\n\tg, x, y = egcd(a, m)\t\t\t\t\t#O(n)\n\tif g != 1:\t\t\t\t\t\t\t#O(1)\t#Subtotal: O(2)\n\t\traise Exception('No Modular Inverse') \t\t\t#O(1)\n\t#print(str(a)+\"**(-1) mod \"+str(m)+\" is: \"+str(x % m))\t\n\treturn x % m\t\t\t\t\t\t#O(1)\n\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}], [{"term": "def", "name": "test_calc_file_hash_md5", "data": "def test_calc_file_hash_md5():\n\tdigest = calc_file_hash(PATH, algorithm=\"md5\", split_chunk=False)\n\tassert digest == MD5HASH\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "from base.hash import calc_file_hash"]}, {"term": "def", "name": "test_calc_file_hash_sha224", "data": "def test_calc_file_hash_sha224():\n\tdigest = calc_file_hash(PATH, algorithm=\"sha224\", split_chunk=False)\n\tassert digest == SHA224HASH\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "from base.hash import calc_file_hash"]}, {"term": "def", "name": "test_calc_file_hash_sha256", "data": "def test_calc_file_hash_sha256():\n\tdigest = calc_file_hash(PATH, algorithm=\"sha256\", split_chunk=False)\n\tassert digest == SHA256HASH\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "from base.hash import calc_file_hash"]}, {"term": "def", "name": "test_calc_file_hash_sha384", "data": "def test_calc_file_hash_sha384():\n\tdigest = calc_file_hash(PATH, algorithm=\"sha384\", split_chunk=False)\n\tassert digest == SHA384HASH\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "from base.hash import calc_file_hash"]}, {"term": "def", "name": "test_calc_file_hash_sha512", "data": "def test_calc_file_hash_sha512():\n\tdigest = calc_file_hash(PATH, algorithm=\"sha512\", split_chunk=False)\n\tassert digest == SHA512HASH\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "from base.hash import calc_file_hash"]}, {"term": "def", "name": "test_calc_file_hash_sha1", "data": "def test_calc_file_hash_sha1():\n\tdigest = calc_file_hash(PATH, algorithm=\"sha1\", split_chunk=False)\n\tassert digest == SHA1HASH\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "from base.hash import calc_file_hash"]}, {"term": "def", "name": "test_split_chunk", "data": "def test_split_chunk():\n\tdigest = calc_file_hash(PATH, algorithm=\"sha256\", split_chunk=True)\n\tassert digest == SHA256HASH\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "from base.hash import calc_file_hash"]}], [{"term": "def", "name": "test_plugin_external_links_instantiate", "data": "def test_plugin_external_links_instantiate():\n\tAddExternalLinks()\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.external_links import AddExternalLinks", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_external_links_hook", "data": "def test_plugin_external_links_hook():\n\tcalc = TestCalculator()\n\tplugin = AddExternalLinks()\n\tcalc.register_plugin(plugin)\n\tassert plugin in calc.plugins\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.external_links import AddExternalLinks", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_external_links_context_updated", "data": "def test_plugin_external_links_context_updated():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(AddExternalLinks())\n\tassert calc.chksym(\"desmos\")\n\tassert calc.chksym(\"symbolab\")\n\tassert calc.chksym(\"wolframalpha\")\n\tassert calc.chksym(\"sympygamma\")\n\tassert callable(calc.getsym(\"desmos\"))\n\tassert callable(calc.getsym(\"symbolab\"))\n\tassert callable(calc.getsym(\"wolframalpha\"))\n\tassert callable(calc.getsym(\"sympygamma\"))\n\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.external_links import AddExternalLinks", "from tests import TestCalculator"]}, {"term": "def", "name": "test_plugin_external_links_available", "data": "def test_plugin_external_links_available():\n\tcalc = TestCalculator()\n\tcalc.register_plugin(AddExternalLinks())\n\tassert callable(calc.command(\"desmos\"))\n\tassert callable(calc.command(\"symbolab\"))\n\tassert callable(calc.command(\"wolframalpha\"))\n\tassert callable(calc.command(\"sympygamma\"))\n", "description": null, "category": "math", "imports": ["from symcalc.plugins.additions.external_links import AddExternalLinks", "from tests import TestCalculator"]}], [{"term": "def", "name": "parse", "data": "def parse(input):\n\tlines = [l.strip() for l in open(input)]\n\treturn lines\n\n", "description": null, "category": "math", "imports": ["import pprint as pp", "import heapq"]}, {"term": "def", "name": "disect", "data": "def disect(hex_val, num_bits, debug=False):\n\tif debug: print(f'{num_bits = } {hex_val = :b}')\n\n\tcalc = 0\n\n\tversion = hex_val >> (num_bits-3)\n\thex_val -= (version << (num_bits-3))\n\tnum_bits -= 3\n\tif debug: print(f'{version = }')\n\tif debug: print(f'{num_bits = } {hex_val = :b}')\n\t\n\ttypeID = hex_val >> (num_bits-3)\n\thex_val = hex_val - (typeID << (num_bits-3))\n\tnum_bits -= 3\n\tif debug: print(f'{typeID = }')\n\tif debug: print(f'{num_bits = } {hex_val = :b}')\n\n\tver_sum = version\t\n\tif typeID != 4:\n\t\tlenID = hex_val >> (num_bits-1)\n\t\thex_val = hex_val - (lenID << (num_bits-1))\n\t\tnum_bits -= 1\n\t\tif debug: print(f'{lenID = }')\n\t\tif debug: print(f'{num_bits = } {hex_val = :b}')\n\n\t\tcalc_n = []\n\t\tif lenID:\n\t\t\tsub_len = hex_val >> (num_bits-11)\n\t\t\thex_val = hex_val - (sub_len << (num_bits-11))\n\t\t\tnum_bits -= 11\n\t\t\tif debug: print(f'{sub_len = } {num_bits = } {hex_val = :b}')\n\n\t\t\twhile sub_len > 0:\n\t\t\t\tver_sum_n, num_bits_n, hex_val, calc_i = disect(hex_val, num_bits, debug)\n\t\t\t\tcalc_n.append(calc_i)\n\t\t\t\tsub_len -= 1\n\t\t\t\tver_sum += ver_sum_n\n\t\t\t\tnum_bits = num_bits_n\n\t\t\t\tif debug: print(f'{sub_len = } {ver_sum_n = } {num_bits_n = }')\n\t\telse:\n\t\t\ttot_len = hex_val >> (num_bits-15)\n\t\t\thex_val = hex_val - (tot_len << (num_bits-15))\n\t\t\tnum_bits -= 15\n\t\t\tif debug: print(f'{tot_len = } {num_bits = } {hex_val = :b}')\n\n\t\t\twhile tot_len > 0:\n\t\t\t\tver_sum_n, num_bits_n, hex_val, calc_i = disect(hex_val, num_bits, debug)\n\t\t\t\tcalc_n.append(calc_i)\n\t\t\t\ttot_len -= num_bits - num_bits_n\n\t\t\t\tver_sum += ver_sum_n\n\t\t\t\tnum_bits = num_bits_n\n\t\t\t\tif debug: print(f'{ver_sum_n = } {num_bits_n = }')\n\n\t\tif debug: print(f'before {typeID = } {calc = } {calc_n = }')\n\t\tif typeID == 0:\n\t\t\tcalc = sum(calc_n)\n\t\tif typeID == 1:\n\t\t\tcalc = 1\n\t\t\tfor c in calc_n:\n\t\t\t\tcalc *= c\n\t\tif typeID == 2:\n\t\t\tcalc = min(calc_n)\n\t\tif typeID == 3:\n\t\t\tcalc = max(calc_n)\n\t\tif typeID == 5:\n\t\t\tcalc = 1 if calc_n[0] > calc_n[1] else 0\n\t\tif typeID == 6:\n\t\t\tcalc = 1 if calc_n[0] < calc_n[1] else 0\n\t\tif typeID == 7:\n\t\t\tcalc = 1 if calc_n[0] == calc_n[1] else 0\n\t\tif debug: print(f'after  {typeID = } {calc = } {calc_n = }')\n\n\tif typeID == 4:\n\t\tnumber = 0\n\t\twhile (hex_val & 0x1 << (num_bits-1)) and num_bits >= 5:\n\t\t\tnum = hex_val >> (num_bits - 5)\n\t\t\tnumber <<= 4\n\t\t\tnumber += num & 0xF\n\t\t\thex_val -= num << (num_bits - 5)\n\t\t\tnum_bits -= 5\n\n\t\tnum = hex_val >> (num_bits - 5)\n\t\tnumber <<= 4\n\t\tnumber += num & 0xF\n\t\thex_val -= num << (num_bits - 5)\n\t\tnum_bits -= 5\n\t\tif debug: print(number)\n\t\tif debug: print(f'{num_bits = } {hex_val = :b}')\n\t\tcalc = number\n\n\treturn ver_sum, num_bits, hex_val, calc\n\n", "description": null, "category": "math", "imports": ["import pprint as pp", "import heapq"]}, {"term": "def", "name": "part1", "data": "def part1(input, debug=False):\n\thex_strs = parse(input)\n\tfor hex_str in hex_strs:\n\t\tprint(f'{hex_str = }')\n\t\thex_val = int(hex_str,16)\n\t\tnum_bits = len(hex_str)*4\n\n\t\tver_sum, num_bits, hex_val, calc = disect(hex_val, num_bits)\n\t\tprint(f'Part 1 {input}: {ver_sum = }')\n\t\tprint(f'Part 2 {input}: {calc = }')\n", "description": null, "category": "math", "imports": ["import pprint as pp", "import heapq"]}], [{"term": "def", "name": "fScientific_OP", "data": "\tdef Scientific_OP():\n\t\t\tui.second_power.setText('x\\u00B2')\n\t\t\tui.third_power.setText('x\\u00B3')\n\t\t\tui.nth_power.setText('x^n')\n\t\t\tui.inv_power.setText('x\\u207b\\xb9')\n\t\t\tui.tens_powers.setText('10^x')\n\t\t\tui.square_root.setText('\\u00B2\\u221A')\n\t\t\tui.third_root.setText('\\u00B3\\u221A')\n\t\t\tui.nth_root.setText('\\u221A')\n\t\t\tui.log_base10.setText('log\\u2081\\u2080')\n\t\t\tui.signs.setText('\\u00B1')\n\t\t\tui.abs_value.clicked.connect(lambda: button_click(\"abs(\"))\n\t\t\tui.modulo.clicked.connect(lambda: button_click('%'))\n\t\t\tui.int_div.clicked.connect(lambda: button_click('//'))\n\t\t\tui.factorial_button.clicked.connect(lambda: fact_func())\n\t\t\tui.eulers_num.clicked.connect(lambda: button_click(str(math.exp(1))))\n\t\t\tui.sine.clicked.connect(lambda: button_click(\"math.sin(\"))\n\t\t\tui.cosine.clicked.connect(lambda: button_click(\"math.cos(\"))\n\t\t\tui.tangent.clicked.connect(lambda: button_click(\"math.tan(\"))\n\t\t\tui.cotangent.clicked.connect(lambda: button_click(\"1/math.tan(\"))\n\t\t\tui.pi_num.clicked.connect(lambda: button_click(str(math.pi)))\n\t\t\tui.third_power.clicked.connect(lambda: button_click(\"**3\"))\n\t\t\tui.nth_power.clicked.connect(lambda: button_click(\"**\"))\n\t\t\tui.inv_power.clicked.connect(lambda: button_click(\"**(-1)\"))\n\t\t\tui.tens_powers.clicked.connect(lambda: button_click(\"10**\"))\n\t\t\tui.left_par.clicked.connect(lambda: button_click(\"(\"))\n\t\t\tui.right_par.clicked.connect(lambda: button_click(\")\"))\n\t\t\tui.signs.clicked.connect(lambda: sign_change())\n\t\t\tui.percentage.clicked.connect(lambda: percent())\n\t\t\tui.ex.clicked.connect(lambda: button_click(\"e(\"))\n\t\t\tui.square_root.clicked.connect(lambda: square_root())\n\t\t\tui.third_root.clicked.connect(lambda: third_root())\n\t\t\tui.nth_root.clicked.connect(lambda: button_click(\"**(1/\"))\n\t\t\tui.log_base10.clicked.connect(lambda: button_click(\"log(\"))\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "ftext_input", "data": "\tdef text_input():\n\t\th=text_input2\n\t\tfor ele in text_input2:\n\t\t\th +=ele\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "flabelRe", "data": "\tdef labelRe(value):\n\t\t\tt=\"\"\n\t\t\tfor ele in value:\n\t\t\t\tt += ele\n\t\t\tt = t.replace('math.sin(','sin(').replace('math.tan(','tan(').replace('math.cos(','cos(').replace('1/tan(','cot(')\n\t\t\tt = t.replace('/', '\u00f7')\n\t\t\tt = t.replace('3.141592653589793','\u03c0')\n\t\t\tt = t.replace(\"**2\",'\\u00B2').replace('**3','\\u00B3')\n\t\t\tt = t.replace(\"**\",'^')\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "fbutton_click", "data": "\tdef button_click(char):\n\t\tglobal calc_operator\n\t\tcalc_operator += str(char)\n\t\ttext_input2.clear()\n\t\ttext_input2.append(calc_operator)\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "fbutton_clear_all", "data": "\tdef button_clear_all():\n\t\tglobal calc_operator\n\t\tcalc_operator = \"\"\n\t\ttext_input2.clear()\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "fbutton_delete", "data": "\tdef button_delete():\n\t\tglobal calc_operator\n\t\ttext = calc_operator[:-1]\n\t\tcalc_operator = text\n\t\ttext_input2.clear()\n\t\ttext_input2.append(calc_operator)\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "ffactorial", "data": "\tdef factorial(n):\n\t\ttry:\n\t\t\tif n == 0 or n == 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn n * factorial(n - 1)\n\t\texcept:\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "ffact_func", "data": "\tdef fact_func():\n\t\ttry:\n\t\t\tglobal calc_operator\n\t\t\tresult = str(factorial(int(calc_operator)))\n\t\t\tcalc_operator = result\n\t\t\ttext_input2.clear()\n\t\t\ttext_input2.append(result)\n\t\t\tlabelRe(result)\n\t\texcept:\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "ftrig_sin", "data": "\tdef trig_sin():\n\t\ttry:\n\t\t\tglobal calc_operator\n\t\t\tresult = str(math.sin(math.radians(int(calc_operator))))\n\t\t\tcalc_operator = result\n\t\t\ttext_input2.clear()\n\t\t\ttext_input2.append(result)\n\t\t\tlabelRe(text_input2)\n\t\texcept:\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "ftrig_cos", "data": "\tdef trig_cos():\n\t\ttry:\n\t\t\tglobal calc_operator\n\t\t\tresult = str(math.cos(math.radians(int(calc_operator))))\n\t\t\tcalc_operator = result\n\t\t\ttext_input2.clear()\n\t\t\ttext_input2.append(result)\n\t\t\tlabelRe(text_input2)\n\t\texcept:\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "ftrig_tan", "data": "\tdef trig_tan():\n\t\ttry:\n\t\t\tglobal calc_operator\n\t\t\tresult = str(math.tan(math.radians(int(calc_operator))))\n\t\t\tcalc_operator = result\n\t\t\ttext_input2.clear()\n\t\t\ttext_input2.append(result)\n\t\t\tlabelRe(text_input2)\n\t\texcept:\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "ftrig_cot", "data": "\tdef trig_cot():\n\t\ttry:\n\t\t\tglobal calc_operator\n\t\t\tresult = str(1 / math.tan(math.radians(int(calc_operator))))\n\t\t\tcalc_operator = result\n\t\t\ttext_input2.clear()\n\t\t\ttext_input2.append(result)\n\t\t\tlabelRe(text_input2)\n\t\texcept:\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "fsquare_root", "data": "\tdef square_root():\n\t\ttry:\n\t\t\tglobal calc_operator\n\t\t\ttemp = str(eval(calc_operator + '**(1/2)'))\n\t\t\tcalc_operator = temp\n\t\t\ttext_input2.clear()\n\t\t\ttext_input2.append(temp)\n\t\t\tlabelRe(text_input2)\n\t\texcept:\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "fthird_root", "data": "\tdef third_root():\n\t\ttry:\n\t\t\tglobal calc_operator\n\t\t\ttemp = str(eval(calc_operator + '**(1/3)'))\n\t\t\tcalc_operator = temp\n\t\t\ttext_input2.clear()\n\t\t\ttext_input2.append(temp)\n\t\t\tlabelRe(text_input2)\n\t\texcept:\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "fsign_change", "data": "\tdef sign_change():\n\t\ttry:\n\t\t\tglobal calc_operator\n\t\t\tif calc_operator[0] == '-':\n\t\t\t\ttemp = calc_operator[1:]\n\t\t\telse:\n\t\t\t\ttemp = '-' + calc_operator\n\t\t\tcalc_operator = temp\n\t\t\ttext_input2.clear()\n\t\t\ttext_input2.append(temp)\n\t\t\tlabelRe(text_input2)\n\t\texcept:\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "fpercent", "data": "\tdef percent():\n\t\ttry:\n\t\t\tglobal calc_operator\n\t\t\ttemp = str(eval(calc_operator + '/100'))\n\t\t\tcalc_operator = temp\n\t\t\ttext_input2.clear()\n\t\t\ttext_input2.append(temp)\n\t\t\tlabelRe(text_input2)\n\t\texcept:\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}, {"term": "def", "name": "fbutton_equal", "data": "\tdef button_equal():\n\t\tif text_input2==[]:\n\t\t\ttext_input2.clear()\n\t\t\tlabelRe(text_input2)\n\t\telse:\n\t\t\tglobal calc_operator\n\t\t\ttry:\n\t\t\t\ttemp_op = str(eval(calc_operator))\n\t\t\t\ttext_input2.clear()\n\t\t\t\ttext_input2.append(temp_op)\n\t\t\t\tlabelRe(text_input2)\n\t\t\t\tcalc_operator = temp_op\n\t\t\texcept:\n", "description": null, "category": "math", "imports": ["import sys", "\tfrom PyQt5.QtWidgets import QApplication,QMainWindow", "\tfrom UI import Ui_layoutMAIN", "\tfrom tkinter import*", "\timport math"]}], [{"term": "class", "name": "classAStarPlanner:", "data": "class AStarPlanner:\n\n\tdef __init__(self, ox, oy, resolution, rr):\n\t\t\"\"\"\n\t\tInitialize grid map for a star planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t\"\"\"\n\n\t\tself.resolution = resolution\n\t\tself.rr = rr\n\t\tself.min_x, self.min_y = 0, 0\n\t\tself.max_x, self.max_y = 0, 0\n\t\tself.obstacle_map = None\n\t\tself.x_width, self.y_width = 0, 0\n\t\tself.motion = self.get_motion_model()\n\t\tself.calc_obstacle_map(ox, oy)\n\n\tclass Node:\n\t\tdef __init__(self, x, y, cost, parent_index):\n\t\t\tself.x = x  # index of grid\n\t\t\tself.y = y  # index of grid\n\t\t\tself.cost = cost\n\t\t\tself.parent_index = parent_index\n\n\t\tdef __str__(self):\n\t\t\treturn str(self.x) + \",\" + str(self.y) + \",\" + str(\n\t\t\t\tself.cost) + \",\" + str(self.parent_index)\n\n\tdef planning(self, sx, sy, gx, gy):\n\t\t\"\"\"\n\t\tA star path search\n\n\t\tinput:\n\t\t\ts_x: start x position [m]\n\t\t\ts_y: start y position [m]\n\t\t\tgx: goal x position [m]\n\t\t\tgy: goal y position [m]\n\n\t\toutput:\n\t\t\trx: x position list of the final path\n\t\t\try: y position list of the final path\n\t\t\"\"\"\n\n\t\tstart_node = self.Node(self.calc_xy_index(sx, self.min_x),\n\t\t\t\t\t\t\t   self.calc_xy_index(sy, self.min_y), 0.0, -1)\n\t\tgoal_node = self.Node(self.calc_xy_index(gx, self.min_x),\n\t\t\t\t\t\t\t  self.calc_xy_index(gy, self.min_y), 0.0, -1)\n\n\t\topen_set, closed_set = dict(), dict()\n\t\topen_set[self.calc_grid_index(start_node)] = start_node\n\n\t\twhile 1:\n\t\t\tif len(open_set) == 0:\n\t\t\t\tprint(\"Open set is empty..\")\n\t\t\t\tbreak\n\n\t\t\tc_id = min(\n\t\t\t\topen_set,\n\t\t\t\tkey=lambda o: open_set[o].cost + self.calc_heuristic(goal_node,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t open_set[\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t o]))\n\t\t\tcurrent = open_set[c_id]\n\n\t\t\t# show graph\n\t\t\tif show_animation:  # pragma: no cover\n\t\t\t\tplt.plot(self.calc_grid_position(current.x, self.min_x),\n\t\t\t\t\t\t self.calc_grid_position(current.y, self.min_y), \"xc\")\n\t\t\t\t# for stopping simulation with the esc key.\n\t\t\t\tplt.gcf().canvas.mpl_connect('key_release_event',\n\t\t\t\t\t\t\t\t\t\t\t lambda event: [exit(\n\t\t\t\t\t\t\t\t\t\t\t\t 0) if event.key == 'escape' else None])\n\t\t\t\tif len(closed_set.keys()) % 10 == 0:\n\t\t\t\t\tplt.pause(0.001)\n\n\t\t\tif current.x == goal_node.x and current.y == goal_node.y:\n\t\t\t\tprint(\"Find goal\")\n\t\t\t\tgoal_node.parent_index = current.parent_index\n\t\t\t\tgoal_node.cost = current.cost\n\t\t\t\tbreak\n\n\t\t\t# Remove the item from the open set\n\t\t\tdel open_set[c_id]\n\n\t\t\t# Add it to the closed set\n\t\t\tclosed_set[c_id] = current\n\n\t\t\t# expand_grid search grid based on motion model\n\t\t\tfor i, _ in enumerate(self.motion):\n\t\t\t\tnode = self.Node(current.x + self.motion[i][0],\n\t\t\t\t\t\t\t\t current.y + self.motion[i][1],\n\t\t\t\t\t\t\t\t current.cost + self.motion[i][2], c_id)\n\t\t\t\tn_id = self.calc_grid_index(node)\n\n\t\t\t\t# If the node is not safe, do nothing\n\t\t\t\tif not self.verify_node(node):\n\t\t\t\t\tcontinue\n\n\t\t\t\tif n_id in closed_set:\n\t\t\t\t\tcontinue\n\n\t\t\t\tif n_id not in open_set:\n\t\t\t\t\topen_set[n_id] = node  # discovered a new node\n\t\t\t\telse:\n\t\t\t\t\tif open_set[n_id].cost > node.cost:\n\t\t\t\t\t\t# This path is the best until now. record it\n\t\t\t\t\t\topen_set[n_id] = node\n\n\t\trx, ry = self.calc_final_path(goal_node, closed_set)\n\n\t\treturn rx, ry\n\n\tdef calc_final_path(self, goal_node, closed_set):\n\t\t# generate final course\n\t\trx, ry = [self.calc_grid_position(goal_node.x, self.min_x)], [\n\t\t\tself.calc_grid_position(goal_node.y, self.min_y)]\n\t\tparent_index = goal_node.parent_index\n\t\twhile parent_index != -1:\n\t\t\tn = closed_set[parent_index]\n\t\t\trx.append(self.calc_grid_position(n.x, self.min_x))\n\t\t\try.append(self.calc_grid_position(n.y, self.min_y))\n\t\t\tparent_index = n.parent_index\n\n\t\treturn rx, ry\n\n\t@staticmethod\n\tdef calc_heuristic(n1, n2):\n\t\tw = 1.0  # weight of heuristic\n\t\td = w * math.hypot(n1.x - n2.x, n1.y - n2.y)\n\t\treturn d\n\n\tdef calc_grid_position(self, index, min_position):\n\t\t\"\"\"\n\t\tcalc grid position\n\n\t\t:param index:\n\t\t:param min_position:\n\t\t:return:\n\t\t\"\"\"\n\t\tpos = index * self.resolution + min_position\n\t\treturn pos\n\n\tdef calc_xy_index(self, position, min_pos):\n\t\treturn round((position - min_pos) / self.resolution)\n\n\tdef calc_grid_index(self, node):\n\t\treturn (node.y - self.min_y) * self.x_width + (node.x - self.min_x)\n\n\tdef verify_node(self, node):\n\t\tpx = self.calc_grid_position(node.x, self.min_x)\n\t\tpy = self.calc_grid_position(node.y, self.min_y)\n\n\t\tif px < self.min_x:\n\t\t\treturn False\n\t\telif py < self.min_y:\n\t\t\treturn False\n\t\telif px >= self.max_x:\n\t\t\treturn False\n\t\telif py >= self.max_y:\n\t\t\treturn False\n\n\t\t# collision check\n\t\tif self.obstacle_map[node.x][node.y]:\n\t\t\treturn False\n\n\t\treturn True\n\n\tdef calc_obstacle_map(self, ox, oy):\n\n\t\tself.min_x = round(min(ox))\n\t\tself.min_y = round(min(oy))\n\t\tself.max_x = round(max(ox))\n\t\tself.max_y = round(max(oy))\n\t\tprint(\"min_x:\", self.min_x)\n\t\tprint(\"min_y:\", self.min_y)\n\t\tprint(\"max_x:\", self.max_x)\n\t\tprint(\"max_y:\", self.max_y)\n\n\t\tself.x_width = round((self.max_x - self.min_x) / self.resolution)\n\t\tself.y_width = round((self.max_y - self.min_y) / self.resolution)\n\t\tprint(\"x_width:\", self.x_width)\n\t\tprint(\"y_width:\", self.y_width)\n\n\t\t# obstacle map generation\n\t\tself.obstacle_map = [[False for _ in range(self.y_width)]\n\t\t\t\t\t\t\t for _ in range(self.x_width)]\n\t\tfor ix in range(self.x_width):\n\t\t\tx = self.calc_grid_position(ix, self.min_x)\n\t\t\tfor iy in range(self.y_width):\n\t\t\t\ty = self.calc_grid_position(iy, self.min_y)\n\t\t\t\tfor iox, ioy in zip(ox, oy):\n\t\t\t\t\td = math.hypot(iox - x, ioy - y)\n\t\t\t\t\tif d <= self.rr:\n\t\t\t\t\t\tself.obstacle_map[ix][iy] = True\n\t\t\t\t\t\tbreak\n\n\t@staticmethod\n\tdef get_motion_model():\n\t\t# dx, dy, cost\n\t\tmotion = [[1, 0, 1],\n\t\t\t\t  [0, 1, 1],\n\t\t\t\t  [-1, 0, 1],\n\t\t\t\t  [0, -1, 1],\n\t\t\t\t  [-1, -1, math.sqrt(2)],\n\t\t\t\t  [-1, 1, math.sqrt(2)],\n\t\t\t\t  [1, -1, math.sqrt(2)],\n\t\t\t\t  [1, 1, math.sqrt(2)]]\n\n\t\treturn motion\n\n", "description": "\n\t\tInitialize grid map for a star planning\n\n\t\tox: x position list of Obstacles [m]\n\t\toy: y position list of Obstacles [m]\n\t\tresolution: grid resolution [m]\n\t\trr: robot radius[m]\n\t\t", "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():\n\tprint(__file__ + \" start!!\")\n\n\t# start and goal position\n\tsx = 10.0  # [m]\n\tsy = 10.0  # [m]\n\tgx = 50.0  # [m]\n\tgy = 50.0  # [m]\n\tgrid_size = 2.0  # [m]\n\trobot_radius = 1.0  # [m]\n\n\t# set obstacle positions\n\tox, oy = [], []\n\tfor i in range(-10, 60):\n\t\tox.append(i)\n\t\toy.append(-10.0)\n\tfor i in range(-10, 60):\n\t\tox.append(60.0)\n\t\toy.append(i)\n\tfor i in range(-10, 61):\n\t\tox.append(i)\n\t\toy.append(60.0)\n\tfor i in range(-10, 61):\n\t\tox.append(-10.0)\n\t\toy.append(i)\n\tfor i in range(-10, 40):\n\t\tox.append(20.0)\n\t\toy.append(i)\n\tfor i in range(0, 40):\n\t\tox.append(40.0)\n\t\toy.append(60.0 - i)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(ox, oy, \".k\")\n\t\tplt.plot(sx, sy, \"og\")\n\t\tplt.plot(gx, gy, \"xb\")\n\t\tplt.grid(True)\n\t\tplt.axis(\"equal\")\n\n\ta_star = AStarPlanner(ox, oy, grid_size, robot_radius)\n\trx, ry = a_star.planning(sx, sy, gx, gy)\n\n\tif show_animation:  # pragma: no cover\n\t\tplt.plot(rx, ry, \"-r\")\n\t\tplt.pause(0.001)\n\t\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import matplotlib.pyplot as plt"]}], [{"term": "class", "name": "class_constBase:", "data": "class _constBase:\n\tclass ConstError(TypeError): pass\n\n\tdef __setattr__(self, name, value):\n\t\tif name in self.__dict__:\n\t\t\traise self.ConstError(\"Can't rebind const (%s)\" % name)\n\t\tself.__dict__[name] = value\n", "description": null, "category": "math", "imports": ["import os", "import json"]}, {"term": "class", "name": "classGlobalConst:", "data": "class GlobalConst:\n\tFILE_NAME_ORIGIN_DATA_HELPER_JSON = r\"..\\data\\invest\\OriginDataHelper.json\"\n\tFILE_NAME_ORIGIN_DATA_JSON = r\"..\\data\\invest\\OriginData.json\"\n\n\t@staticmethod\n\tdef currentDirFileName(fileName):\n\t\tcurrentDir = os.path.dirname(os.path.realpath(__file__))\n\t\treturn currentDir + '\\\\' + fileName\n\n\t# FCN, \u80a1\u7968, \u6307\u6570, \u516c\u52df\u57fa\u91d1, \u79c1\u52df\u57fa\u91d1, \u79c1\u52df\u80a1\u6743, \u503a\u5238, \u501f\u6b3e, \u56fa\u6536\u7c7b, \u5176\u5b83\n\tCALC_INVEST_TYPE_FCN = 1\n\tCALC_INVEST_TYPE_STOCK = 2\n\tCALC_INVEST_TYPE_INDEX = 3\n\tCALC_INVEST_TYPE_PUBLIC_FUND = 4\n\tCALC_INVEST_TYPE_PRIVATE_FUND = 5\n\tCALC_INVEST_TYPE_PRIVATE_EQUITY = 6\n\tCALC_INVEST_TYPE_BOND = 7\n\tCALC_INVEST_TYPE_LOAN = 8\n\tCALC_INVEST_TYPE_FIXED_INCOME = 9\n\tCALC_INVEST_TYPE_OTHER = 10\n\tCalcInvestType = {\n\t\tCALC_INVEST_TYPE_FCN : \"FCN\",\n\t\tCALC_INVEST_TYPE_STOCK : \"\u80a1\u7968\",\n\t\tCALC_INVEST_TYPE_INDEX : \"\u6307\u6570\",\n\t\tCALC_INVEST_TYPE_PUBLIC_FUND : \"\u516c\u52df\u57fa\u91d1\",\n\t\tCALC_INVEST_TYPE_PRIVATE_FUND : \"\u79c1\u52df\u57fa\u91d1\",\n\t\tCALC_INVEST_TYPE_PRIVATE_EQUITY : \"\u79c1\u52df\u80a1\u6743\",\n\t\tCALC_INVEST_TYPE_BOND : \"\u503a\u5238\",\n\t\tCALC_INVEST_TYPE_LOAN : \"\u501f\u6b3e\",\n\t\tCALC_INVEST_TYPE_FIXED_INCOME : \"\u56fa\u6536\u7c7b\",\n\t\tCALC_INVEST_TYPE_OTHER : \"\u5176\u5b83\",\n\t}\n", "description": null, "category": "math", "imports": ["import os", "import json"]}, {"term": "class", "name": "classGlobalTools:", "data": "class GlobalTools:\n\t@staticmethod\n\tdef convertExchangeRate():\n\t\t# =VLOOKUP(D2, M2: N5, 2, 0)\n\t\tfor i in range(2, 300):\n\t\t\tprint(\"=VLOOKUP(D{0}, M2: N5, 2, 0)\".format(i))\n", "description": null, "category": "math", "imports": ["import os", "import json"]}, {"term": "class", "name": "classJsonTools:", "data": "class JsonTools:\n\t@staticmethod\n\tdef dictGetDataByKey(dictData, key):\n\t\tif JsonTools.hasKey(dictData, key):\n\t\t\treturn dictData[key]\n\t\treturn None\n\n\t@staticmethod\n\tdef hasKey(dictData, key):\n\t\tfor k in dictData:\n\t\t\tif k == key:\n\t\t\t\treturn True\n\t\treturn False\n\n\t@staticmethod\n\tdef writeJson(filename, jsonData, mode = \"w\"):\n\t\tprint(\"Writing Json:\" + filename)\n\n\t\twith open(filename, mode,  encoding = 'utf-8') as file_obj:\n\t\t\tjson.dump(jsonData, file_obj, ensure_ascii=False)\n\t\tprint(\"Finish Writing!\")\n\n\t@staticmethod\n\tdef readAsJson(filename):\n\t\twith open(filename, 'r',  encoding = 'utf-8') as file_obj:\n\t\t\tjsonData = json.load(file_obj)\n\t\treturn jsonData\n", "description": null, "category": "math", "imports": ["import os", "import json"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "class", "name": "EvaluatorTest", "data": "class EvaluatorTest(unittest.TestCase):\n\t\"\"\"\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t\"\"\"\n\n\tdef test_number_input(self):\n\t\t\"\"\"\n\t\tTest different kinds of float inputs\n\n\t\tSee also\n\t\t  test_trailing_period (slightly different)\n\t\t  test_exponential_answer\n\t\t  test_si_suffix\n\t\t\"\"\"\n\t\teasy_eval = lambda x: calc.evaluator({}, {}, x)\n\n\t\tself.assertEqual(easy_eval(\"13\"), 13)\n\t\tself.assertEqual(easy_eval(\"3.14\"), 3.14)\n\t\tself.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n\t\tself.assertEqual(easy_eval(\"-13\"), -13)\n\t\tself.assertEqual(easy_eval(\"-3.14\"), -3.14)\n\t\tself.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n\tdef test_period(self):\n\t\t\"\"\"\n\t\tThe string '.' should not evaluate to anything.\n\t\t\"\"\"\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '.')\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '1+.')\n\n\tdef test_trailing_period(self):\n\t\t\"\"\"\n\t\tTest that things like '4.' will be 4 and not throw an error\n\t\t\"\"\"\n\t\tself.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n\tdef test_exponential_answer(self):\n\t\t\"\"\"\n\t\tTest for correct interpretation of scientific notation\n\t\t\"\"\"\n\t\tanswer = 50\n\t\tcorrect_responses = [\n\t\t\t\"50\", \"50.0\", \"5e1\", \"5e+1\",\n\t\t\t\"50e0\", \"50.0e0\", \"500e-1\"\n\t\t]\n\t\tincorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n\t\tfor input_str in correct_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\t\tfor input_str in incorrect_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to not equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertNotEqual(answer, result, msg=fail_msg)\n\n\tdef test_si_suffix(self):\n\t\t\"\"\"\n\t\tTest calc.py's unique functionality of interpreting si 'suffixes'.\n\n\t\tFor instance 'k' stand for 'kilo-' so '1k' should be 1,000\n\t\t\"\"\"\n\t\ttest_mapping = [\n\t\t\t('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n\t\t\t('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n\t\t\t('5.4m', 0.0054), ('8.7u', 0.0000087),\n\t\t\t('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n\t\t]\n\n\t\tfor (expr, answer) in test_mapping:\n\t\t\ttolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n\t\t\tfail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n\t\t\tfail_msg = fail_msg.format(expr[-1], expr, answer)\n\t\t\tself.assertAlmostEqual(\n\t\t\t\tcalc.evaluator({}, {}, expr), answer,\n\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t)\n\n\tdef test_operator_sanity(self):\n\t\t\"\"\"\n\t\tTest for simple things like '5+2' and '5/2'\n\t\t\"\"\"\n\t\tvar1 = 5.0\n\t\tvar2 = 2.0\n\t\toperators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n\t\tfor (operator, answer) in operators:\n\t\t\tinput_str = \"{0} {1} {2}\".format(var1, operator, var2)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n\t\t\t\toperator, input_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\tdef test_raises_zero_division_err(self):\n\t\t\"\"\"\n\t\tEnsure division by zero gives an error\n\t\t\"\"\"\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0.0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({'x': 0.0}, {}, '1/x')\n\n\tdef test_parallel_resistors(self):\n\t\t\"\"\"\n\t\tTest the parallel resistor operator ||\n\n\t\tThe formula is given by\n\t\t\ta || b || c ...\n\t\t\t= 1 / (1/a + 1/b + 1/c + ...)\n\t\tIt is the resistance of a parallel circuit of resistors with resistance\n\t\ta, b, c, etc&. See if this evaulates correctly.\n\t\t\"\"\"\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n\t\tself.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n\tdef test_parallel_resistors_with_zero(self):\n\t\t\"\"\"\n\t\tCheck the behavior of the || operator with 0\n\t\t\"\"\"\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n\tdef assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n\t\t\"\"\"\n\t\tHelper function to test many values at once\n\n\t\tTest the accuracy of evaluator's use of the function given by fname\n\t\tSpecifically, the equality of `fname(ins[i])` against outs[i].\n\t\tThis is used later to test a whole bunch of f(x) = y at a time\n\t\t\"\"\"\n\n\t\tfor (arg, val) in zip(ins, outs):\n\t\t\tinput_str = \"{0}({1})\".format(fname, arg)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n\t\t\t\tfname, input_str, val\n\t\t\t)\n\t\t\tself.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n\tdef test_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the trig functions provided in calc.py\n\n\t\twhich are: sin, cos, tan, arccos, arcsin, arctan\n\t\t\"\"\"\n\n\t\tangles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n\t\tcos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n\t\ttan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n\t\t# Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n\t\tself.assert_function_values('sin', angles, sin_values)\n\t\tself.assert_function_values('cos', angles, cos_values)\n\t\tself.assert_function_values('tan', angles, tan_values)\n\n\t\t# Include those where the real part is between -pi/2 and pi/2\n\t\tarcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n\t\tarcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n\t\tself.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n\t\t# Rather than a complex number, numpy.arcsin gives nan\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n\t\t# Include those where the real part is between 0 and pi\n\t\tarccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n\t\tarccos_angles = [0, 0.524, 0.628, 1 + 1j]\n\t\tself.assert_function_values('arccos', arccos_inputs, arccos_angles)\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n\t\t# Has the same range as arcsin\n\t\tarctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n\t\tarctan_angles = arcsin_angles\n\t\tself.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n\tdef test_reciprocal_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the reciprocal trig functions provided in calc.py\n\n\t\twhich are: sec, csc, cot, arcsec, arccsc, arccot\n\t\t\"\"\"\n\t\tangles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n\t\tcsc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n\t\tcot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n\t\tself.assert_function_values('sec', angles, sec_values)\n\t\tself.assert_function_values('csc', angles, csc_values)\n\t\tself.assert_function_values('cot', angles, cot_values)\n\n\t\tarcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n\t\tarcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n\t\tself.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n\t\tarccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n\t\tarccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n\t\tself.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n\t\t# Has the same range as arccsc\n\t\tarccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n\t\tarccot_angles = arccsc_angles\n\t\tself.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n\tdef test_hyperbolic_functions(self):\n\t\t\"\"\"\n\t\tTest the hyperbolic functions\n\n\t\twhich are: sinh, cosh, tanh, sech, csch, coth\n\t\t\"\"\"\n\t\tinputs = ['0', '0.5', '1', '2', '1+j']\n\t\tneg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n\t\tnegate = lambda x: [-k for k in x]\n\n\t\t# sinh is odd\n\t\tsinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n\t\tself.assert_function_values('sinh', inputs, sinh_vals)\n\t\tself.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n\t\t# cosh is even - do not negate\n\t\tcosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n\t\tself.assert_function_values('cosh', inputs, cosh_vals)\n\t\tself.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n\t\t# tanh is odd\n\t\ttanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n\t\tself.assert_function_values('tanh', inputs, tanh_vals)\n\t\tself.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n\t\t# sech is even - do not negate\n\t\tsech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n\t\tself.assert_function_values('sech', inputs, sech_vals)\n\t\tself.assert_function_values('sech', neg_inputs, sech_vals)\n\n\t\t# the following functions do not have 0 in their domain\n\t\tinputs = inputs[1:]\n\t\tneg_inputs = neg_inputs[1:]\n\n\t\t# csch is odd\n\t\tcsch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n\t\tself.assert_function_values('csch', inputs, csch_vals)\n\t\tself.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n\t\t# coth is odd\n\t\tcoth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n\t\tself.assert_function_values('coth', inputs, coth_vals)\n\t\tself.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n\tdef test_hyperbolic_inverses(self):\n\t\t\"\"\"\n\t\tTest the inverse hyperbolic functions\n\n\t\twhich are of the form arc[X]h\n\t\t\"\"\"\n\t\tresults = [0, 0.5, 1, 2, 1 + 1j]\n\n\t\tsinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n\t\tself.assert_function_values('arcsinh', sinh_vals, results)\n\n\t\tcosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n\t\tself.assert_function_values('arccosh', cosh_vals, results)\n\n\t\ttanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n\t\tself.assert_function_values('arctanh', tanh_vals, results)\n\n\t\tsech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n\t\tself.assert_function_values('arcsech', sech_vals, results)\n\n\t\tresults = results[1:]\n\t\tcsch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n\t\tself.assert_function_values('arccsch', csch_vals, results)\n\n\t\tcoth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n\t\tself.assert_function_values('arccoth', coth_vals, results)\n\n\tdef test_other_functions(self):\n\t\t\"\"\"\n\t\tTest the non-trig functions provided in calc.py\n\n\t\tSpecifically:\n\t\t  sqrt, log10, log2, ln, abs,\n\t\t  fact, factorial\n\t\t\"\"\"\n\n\t\t# Test sqrt\n\t\tself.assert_function_values(\n\t\t\t'sqrt',\n\t\t\t[0, 1, 2, 1024],  # -1\n\t\t\t[0, 1, 1.414, 32]  # 1j\n\t\t)\n\t\t# sqrt(-1) is NAN not j (!!).\n\n\t\t# Test logs\n\t\tself.assert_function_values(\n\t\t\t'log10',\n\t\t\t[0.1, 1, 3.162, 1000000, '1+j'],\n\t\t\t[-1, 0, 0.5, 6, 0.151 + 0.341j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'log2',\n\t\t\t[0.5, 1, 1.414, 1024, '1+j'],\n\t\t\t[-1, 0, 0.5, 10, 0.5 + 1.133j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'ln',\n\t\t\t[0.368, 1, 1.649, 2.718, 42, '1+j'],\n\t\t\t[-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n\t\t)\n\n\t\t# Test abs\n\t\tself.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n\t\t# Test factorial\n\t\tfact_inputs = [0, 1, 3, 7]\n\t\tfact_values = [1, 1, 6, 5040]\n\t\tself.assert_function_values('fact', fact_inputs, fact_values)\n\t\tself.assert_function_values('factorial', fact_inputs, fact_values)\n\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n\tdef test_constants(self):\n\t\t\"\"\"\n\t\tTest the default constants provided in calc.py\n\n\t\twhich are: j (complex number), e, pi, k, c, T, q\n\t\t\"\"\"\n\n\t\t# Of the form ('expr', python value, tolerance (or None for exact))\n\t\tdefault_variables = [\n\t\t\t('i', 1j, None),\n\t\t\t('j', 1j, None),\n\t\t\t('e', 2.7183, 1e-4),\n\t\t\t('pi', 3.1416, 1e-4),\n\t\t\t('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n\t\t\t('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n\t\t\t('T', 298.15, 0.01),  # Typical room temperature (Kelvin)\n\t\t\t('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n\t\t]\n\t\tfor (variable, value, tolerance) in default_variables:\n\t\t\tfail_msg = \"Failed on constant '{0}', not within bounds\".format(\n\t\t\t\tvariable\n\t\t\t)\n\t\t\tresult = calc.evaluator({}, {}, variable)\n\t\t\tif tolerance is None:\n\t\t\t\tself.assertEqual(value, result, msg=fail_msg)\n\t\t\telse:\n\t\t\t\tself.assertAlmostEqual(\n\t\t\t\t\tvalue, result,\n\t\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t\t)\n\n\tdef test_complex_expression(self):\n\t\t\"\"\"\n\t\tCalculate combinations of operators and default functions\n\t\t\"\"\"\n\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n\t\t\t10.180,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n\t\t\t1.6,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"10||sin(7+5)\"),\n\t\t\t-0.567, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"sin(e)\"),\n\t\t\t0.41, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"k*T/q\"),\n\t\t\t0.025, delta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"e^(j*pi)\"),\n\t\t\t-1, delta=1e-5\n\t\t)\n\n\tdef test_explicit_sci_notation(self):\n\t\t\"\"\"\n\t\tExpressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^-3\"),\n\t\t\t-0.0016\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n\t\t\t-0.0016\n\t\t)\n\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^3\"),\n\t\t\t-1600\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(3)\"),\n\t\t\t-1600\n\t\t)\n\n\tdef test_simple_vars(self):\n\t\t\"\"\"\n\t\tSubstitution of variables into simple equations\n\t\t\"\"\"\n\t\tvariables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n\t\t# Should not change value of constant\n\t\t# even with different numbers of variables...\n\t\tself.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n\t\t# Easy evaluation\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n\t\t# Test a simple equation\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, '3*x-y'),\n\t\t\t21.25, delta=0.01  # = 3 * 9.72 - 7.91\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, 'x*y'),\n\t\t\t76.89, delta=0.01\n\t\t)\n\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(\n\t\t\t\t{'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n\t\t\t\t{}, \"5\"\n\t\t\t),\n\t\t\t5\n\t\t)\n\n\tdef test_variable_case_sensitivity(self):\n\t\t\"\"\"\n\t\tTest the case sensitivity flag and corresponding behavior\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n\t\t\t8.0\n\t\t)\n\n\t\tvariables = {'t': 1.0}\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(variables, {}, \"t\", case_sensitive=True),\n\t\t\t1.0\n\t\t)\n\t\t# Recall 'T' is a default constant, with value 298.15\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, \"T\", case_sensitive=True),\n\t\t\t298, delta=0.2\n\t\t)\n\n\tdef test_simple_funcs(self):\n\t\t\"\"\"\n\t\tSubsitution of custom functions\n\t\t\"\"\"\n\t\tvariables = {'x': 4.712}\n\t\tfunctions = {'id': lambda x: x}\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n\t\tfunctions.update({'f': numpy.sin})\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, functions, 'f(x)'),\n\t\t\t-1, delta=1e-3\n\t\t)\n\n\tdef test_function_case_insensitive(self):\n\t\t\"\"\"\n\t\tTest case insensitive evaluation\n\n\t\tNormal functions with some capitals should be fine\n\t\t\"\"\"\n\t\tself.assertAlmostEqual(\n\t\t\t-0.28,\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n\t\t\tdelta=1e-3\n\t\t)\n\n\tdef test_function_case_sensitive(self):\n\t\t\"\"\"\n\t\tTest case sensitive evaluation\n\n\t\tIncorrectly capitilized should fail\n\t\tAlso, it should pick the correct version of a function.\n\t\t\"\"\"\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n\t\t# With case sensitive turned on, it should pick the right function\n\t\tfunctions = {'f': lambda x: x, 'F': lambda x: x + 1}\n\t\tself.assertEqual(\n\t\t\t6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n\t\t)\n\t\tself.assertEqual(\n\t\t\t7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n\t\t)\n\n\tdef test_undefined_vars(self):\n\t\t\"\"\"\n\t\tCheck to see if the evaluator catches undefined variables\n\t\t\"\"\"\n\t\tvariables = {'R1': 2.0, 'R3': 4.0}\n\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n\t\t\tcalc.evaluator({}, {}, \"5+7*QWSEKO\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n\t\t\tcalc.evaluator({'r1': 5}, {}, \"r1+r2\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n\t\t\tcalc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "description": "\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t", "category": "math", "imports": ["import unittest", "import numpy", "import calc", "from pyparsing import ParseException"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "classCalc:", "data": "class Calc:\n\n\tg = 0\n", "description": null, "category": "math", "imports": ["# The important thing is that the 31 digits show us the universal pattern of that row.", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i >= 322: # important because the for loop will go out of range without!"]}, {"term": "def", "name": "fcount_3_1", "data": "\tdef count_3_1():\n\t\tc_t = 0\n\t\tCalc.g = 0\n\t\tfor i in range(len(list)):\n\t\t\tCalc.g = Calc.g + 3\n\t\t\tCalc.g_counter()\n\t\t\ti = i + 1\n\t\t\tif i == 323: # important because the for loop will go out of range without!\n\t\t\t\tbreak\n\t\t\tif list[i][Calc.g] == \"#\":\n\t\t\t\tc_t += 1\n\t\treturn c_t\n", "description": null, "category": "math", "imports": ["# The important thing is that the 31 digits show us the universal pattern of that row.", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i >= 322: # important because the for loop will go out of range without!"]}, {"term": "def", "name": "fcount_1_1", "data": "\tdef count_1_1():\n\t\tc_t = 0\n\t\tCalc.g = 0\n\t\tfor i in range(len(list)):\n\t\t\tCalc.g = Calc.g + 1\n\t\t\tCalc.g_counter()\n\t\t\ti = i + 1\n\t\t\tif i == 323: # important because the for loop will go out of range without!\n\t\t\t\tbreak\n\t\t\tif list[i][Calc.g] == \"#\":\n\t\t\t\tc_t += 1\n\t\treturn c_t\n", "description": null, "category": "math", "imports": ["# The important thing is that the 31 digits show us the universal pattern of that row.", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i >= 322: # important because the for loop will go out of range without!"]}, {"term": "def", "name": "fcount_5_1", "data": "\tdef count_5_1():\n\t\tc_t = 0\n\t\tCalc.g = 0\n\t\tfor i in range(len(list)):\n\t\t\tCalc.g = Calc.g + 5\n\t\t\tCalc.g_counter()\n\t\t\ti = i + 1\n\t\t\tif i == 323: # important because the for loop will go out of range without!\n\t\t\t\tbreak\n\t\t\tif list[i][Calc.g] == \"#\":\n\t\t\t\tc_t += 1\n\t\treturn c_t\n", "description": null, "category": "math", "imports": ["# The important thing is that the 31 digits show us the universal pattern of that row.", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i >= 322: # important because the for loop will go out of range without!"]}, {"term": "def", "name": "fcount_7_1", "data": "\tdef count_7_1():\n\t\tc_t = 0\n\t\tCalc.g = 0\n\t\tfor i in range(len(list)):\n\t\t\tCalc.g = Calc.g + 7\n\t\t\tCalc.g_counter()\n\t\t\ti = i + 1\n\t\t\tif i == 323: # important because the for loop will go out of range without!\n\t\t\t\tbreak\n\t\t\tif list[i][Calc.g] == \"#\":\n\t\t\t\tc_t += 1\n\t\treturn c_t\n", "description": null, "category": "math", "imports": ["# The important thing is that the 31 digits show us the universal pattern of that row.", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i >= 322: # important because the for loop will go out of range without!"]}, {"term": "def", "name": "fcount_1_2", "data": "\tdef count_1_2():\n\t\tc_t = 0\n\t\tCalc.g = 0\n\t\tfor i in range(len(list)):\n\t\t\tCalc.g = Calc.g + 1\n\t\t\tCalc.g_counter()\n\t\t\ti = i + 2\n\t\t\tif i >= 322: # important because the for loop will go out of range without!\n\t\t\t\tbreak\n\t\t\tif list[i][Calc.g] == \"#\":\n\t\t\t\tc_t += 1\n\t\treturn c_t\n", "description": null, "category": "math", "imports": ["# The important thing is that the 31 digits show us the universal pattern of that row.", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i >= 322: # important because the for loop will go out of range without!"]}, {"term": "def", "name": "fmultiplier", "data": "\tdef multiplier():\n\t\tresult = Calc.count_1_1() * Calc.count_1_2() * Calc.count_3_1() * Calc.count_7_1() * Calc.count_5_1()\n\t\treturn result\n", "description": null, "category": "math", "imports": ["# The important thing is that the 31 digits show us the universal pattern of that row.", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i >= 322: # important because the for loop will go out of range without!"]}, {"term": "def", "name": "fg_counter", "data": "\tdef g_counter():\n\t\t\tif Calc.g == 31:\n\t\t\t\tCalc.g = 0\n\t\t\telif Calc.g == 32:\n\t\t\t\tCalc.g = 1\n\t\t\telif Calc.g == 33:\n\t\t\t\tCalc.g = 2\n\t\t\telif Calc.g == 34:\n\t\t\t\tCalc.g = 3\n\t\t\telif Calc.g == 35:\n\t\t\t\tCalc.g = 4\n\t\t\telif Calc.g == 36:\n\t\t\t\tCalc.g = 5\n\t\t\telif Calc.g == 37:\n\t\t\t\tCalc.g = 6\n\t\t\telif Calc.g == 38:\n\t\t\t\tCalc.g = 7\n\n", "description": null, "category": "math", "imports": ["# The important thing is that the 31 digits show us the universal pattern of that row.", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i == 323: # important because the for loop will go out of range without!", "\t\t\tif i >= 322: # important because the for loop will go out of range without!"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [], [{"term": "class", "name": "MyLayout", "data": "class MyLayout(Widget):\n\tmath_symbol_clicked = 0\n\n\tdef clear(self):\n\t\tself.ids.calc_input.text = '0'\n\n\tdef number_button(self, button):\n\n\t\tprior = self.ids.calc_input.text\n\n\t\tif \"Error!\" in prior:\n\t\t\tprior = ''\n\n\t\tif prior == '0':\n\t\t\tself.ids.calc_input.text = f'{button}'\n\t\telse:\n\t\t\tself.ids.calc_input.text = f'{prior}{button}'\n\n\t# For '<<' Button\n\tdef remove(self):\n\n\t\tprior = self.ids.calc_input.text\n\t\tif len(prior) == 1:\n\t\t\tself.ids.calc_input.text = '0'\n\t\telse:\n\t\t\tself.ids.calc_input.text = prior[:-1]\n\n\t# For '+/-' Button\n\tdef pos_neg(self):\n\n\t\tprior = self.ids.calc_input.text\n\t\tif prior == '0':\n\t\t\treturn\n\t\tif prior[0] == '-':\n\t\t\tself.ids.calc_input.text = f'{prior[1:]}'\n\t\telse:\n\t\t\tself.ids.calc_input.text = f'-{prior}'\n\n\t# For '.' Button\n\tdef dot(self):\n\n\t\tprior = self.ids.calc_input.text\n\t\tif '.' in prior and self.math_symbol_clicked == 0:\n\t\t\treturn\n\t\tself.ids.calc_input.text = f'{prior}.'\n\t\tself.math_symbol_clicked = 0\n\n\t# For '+', '-', 'x', '/' Symbols\n\tdef math_sign(self, sign):\n\n\t\tself.math_symbol_clicked = 1\n\t\tprior = self.ids.calc_input.text\n\n\t\tif \"Error!\" in prior:\n\t\t\tself.ids.calc_input.text = '0'\n\t\t\treturn\n\n\t\tself.ids.calc_input.text = f'{prior}{sign}'\n\n\t# For '=' Button\n\tdef equals(self):\n\n\t\tprior = self.ids.calc_input.text\n\t\ttry:\n\t\t\t# Evaluate the output\n\t\t\tanswer = eval(prior)\n\t\texcept Exception:\n\t\t\tanswer = \"Error!\"\n\n\t\tself.ids.calc_input.text = str(answer)\n\n", "description": null, "category": "math", "imports": ["# import kivy", "from kivy.app import App", "from kivy.uix.widget import Widget", "from kivy.lang import Builder", "from kivy.core.window import Window"]}, {"term": "class", "name": "CalculatorApp", "data": "class CalculatorApp(App):\n\n\tdef build(self):\n\t\treturn MyLayout()\n\n", "description": null, "category": "math", "imports": ["# import kivy", "from kivy.app import App", "from kivy.uix.widget import Widget", "from kivy.lang import Builder", "from kivy.core.window import Window"]}], [{"term": "def", "name": "__init__", "data": "  def __init__(self,\n\t  miller_obs,\n\t  miller_calc,\n\t  min_d_star_sq=0.0,\n\t  max_d_star_sq=2.0,\n\t  n_points=2000,\n\t  level=6.0):\n\tassert miller_obs.indices().all_eq(miller_calc.indices())\n\tif (miller_obs.is_xray_amplitude_array()):\n\t  miller_obs = miller_obs.f_as_f_sq()\n\tif (miller_calc.is_xray_amplitude_array()):\n\t  miller_calc = miller_calc.f_as_f_sq()\n\tself.obs  = miller_obs.deep_copy()\n\tself.calc = miller_calc.deep_copy()\n\tself.mind = min_d_star_sq\n\tself.maxd = max_d_star_sq\n\tself.m\t= n_points\n\tself.n\t= 2\n\tself.level = level\n\n\tnorma_obs  = absolute_scaling.kernel_normalisation(\n\t  miller_array=self.obs,\n\t  auto_kernel=True,\n\t  n_bins=45,\n\t  n_term=17)\n\tnorma_calc = absolute_scaling.kernel_normalisation(\n\t  miller_array=self.calc,\n\t  auto_kernel=True,\n\t  n_bins=45,\n\t  n_term=17)\n\n\tobs_d_star_sq  = norma_obs.d_star_sq_array\n\tcalc_d_star_sq = norma_calc.d_star_sq_array\n\tsel_calc_obs = norma_calc.bin_selection.select(norma_obs.bin_selection)\n\tsel_obs_calc = norma_obs.bin_selection.select(norma_calc.bin_selection)\n\tsel  = ((obs_d_star_sq > low_lim) & (obs_d_star_sq < high_lim) &\n\t\t\t(norma_obs.mean_I_array > 0))\n\tsel = sel.select(sel_calc_obs)\n\n\tself.obs_d_star_sq  = obs_d_star_sq.select( sel )\n\tself.calc_d_star_sq = calc_d_star_sq.select( sel_obs_calc ).select(sel)\n\tself.mean_obs\t   = norma_obs.mean_I_array.select(sel)\n\tself.mean_calc\t  = norma_calc.mean_I_array.select(\n\t\t\t\t\t\t\tsel_obs_calc).select(sel)\n\tself.var_obs\t\t= norma_obs.var_I_array.select(sel)\n\tself.var_calc\t   = norma_calc.var_I_array.select(\n\t  sel_obs_calc).select(sel)\n\n\t# make an interpolator object please\n\tself.interpol = scale_curves.curve_interpolator( self.mind, self.maxd,\n\t  self.m)\n\t# do the interpolation\n\ttmp_obs_d_star_sq  , self.mean_obs,self.obs_a  , self.obs_b  = \\\n\t  self.interpol.interpolate(self.obs_d_star_sq,self.mean_obs)\n\tself.obs_d_star_sq , self.var_obs,self.obs_a   , self.obs_b  = \\\n\t  self.interpol.interpolate(self.obs_d_star_sq, self.var_obs)\n\ttmp_calc_d_star_sq , self.mean_calc,self.calc_a, self.calc_b = \\\n\t  self.interpol.interpolate(self.calc_d_star_sq,self.mean_calc)\n\tself.calc_d_star_sq, self.var_calc,self.calc_a , self.calc_b = \\\n\t  self.interpol.interpolate(self.calc_d_star_sq,self.var_calc)\n\n\tself.mean_ratio_engine = chebyshev_polynome( mean_coefs.size(),\n\t  low_lim-1e-3, high_lim+1e-3,mean_coefs)\n\tself.std_ratio_engine = chebyshev_polynome( std_coefs.size(),\n\t  low_lim-1e-3, high_lim+1e-3,std_coefs)\n\n\tself.x = flex.double([0,0])\n\n\tself.low_lim_for_scaling = 1.0/(4.0*4.0) #0.0625\n\tselection = (self.calc_d_star_sq > self.low_lim_for_scaling)\n\tif (selection.count(True) == 0):\n\t  raise Sorry(\"No reflections within required resolution range after \"+\n\t\t\"filtering.\")\n\tself.weight_array = selection.as_double() / (2.0 * self.var_obs)\n\tassert (not self.weight_array.all_eq(0.0))\n\n\tself.mean   = flex.double( [1.0/(flex.sum(self.mean_calc) /\n\t\t\t\t\t\t\t\tflex.sum(self.mean_obs)), 0.0 ] )\n\tself.sigmas = flex.double( [0.5, 0.5] )\n\n\ts = 1.0/(flex.sum(self.weight_array*self.mean_calc)/\n\t\t\t flex.sum(self.weight_array*self.mean_obs))\n\tb = 0.0\n\tself.sart_simplex = [ flex.double([s,b]), flex.double([s+0.1,b+1.1]),\n\t\t\t\t\t\t  flex.double([s-0.1,b-1.1]) ]\n\tself.opti = simplex.simplex_opt( 2, self.sart_simplex, self)\n\n\tsol = self.opti.get_solution()\n\tself.scale   = abs(sol[0])\n\tself.b_value = sol[1]\n\n\tself.modify_weights()\n\tself.all_bad_z_scores = self.weight_array.all_eq(0.0)\n\tif (not self.all_bad_z_scores):\n\t  s = 1.0/(flex.sum(self.weight_array*self.mean_calc) /\n\t\t\t   flex.sum(self.weight_array*self.mean_obs))\n\t  b = 0.0\n\t  self.sart_simplex = [ flex.double([s,b]), flex.double([s+0.1,b+1.1]),\n\t\t\t\t\t\t\tflex.double([s-0.1,b-1.1]) ]\n\t  self.opti = simplex.simplex_opt( 2, self.sart_simplex, self)\n\t#self.mean_calc = self.mean_calc*self.scale*flex.exp(self.calc_d_star_sq*self.b_value)\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "from mmtbx.scaling import absolute_scaling", "import mmtbx.scaling", "from iotbx import data_plots", "from scitbx.array_family import flex", "from scitbx.math import scale_curves", "from scitbx import simplex", "from scitbx.math import chebyshev_polynome", "from libtbx.utils import Sorry", "from libtbx import table_utils", "import sys,math", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "summary", "data": "  def summary(self):\n\ti_scaled = flex.exp( self.calc_d_star_sq*self.b_value ) * \\\n\t\t\t\tself.mean_calc * self.scale\n\tsel = (self.mean_obs > 0).iselection()\n\tratio  = flex.log(i_scaled.select(sel) / self.mean_obs.select(sel))\n\tratio_ = flex.double(self.mean_obs.size(), 0)\n\tratio_.set_selected(sel, ratio)\n\tcurves = [\n\t  self.calc_d_star_sq,\n\t  -ratio_, # observed\n\t  self.curve( self.calc_d_star_sq ), # expected\n\t  self.get_z_scores(self.scale, self.b_value)\n\t]\n\treturn summary(\n\t  all_curves=curves,\n\t  level=self.level,\n\t  all_bad_z_scores=self.all_bad_z_scores)\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "from mmtbx.scaling import absolute_scaling", "import mmtbx.scaling", "from iotbx import data_plots", "from scitbx.array_family import flex", "from scitbx.math import scale_curves", "from scitbx import simplex", "from scitbx.math import chebyshev_polynome", "from libtbx.utils import Sorry", "from libtbx import table_utils", "import sys,math", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "modify_weights", "data": "  def modify_weights(self,level=5):\n\tz_scores = self.get_z_scores(self.scale, self.b_value)\n\tsel  = flex.double(list(flex.bool(z_scores 0) & (i_scaled > 0)) .iselection()\n\tratio  = self.mean_obs.select(sel) / i_scaled.select(sel)\n\tmean = self.curve( self.calc_d_star_sq ).select(sel)\n\tassert ratio.all_gt(0) # FIXME need to filter first!\n\tratio = flex.log(ratio)\n\tvar = self.std(self.calc_d_star_sq).select(sel)\n\td_star_sq = self.calc_d_star_sq.select(sel)\n\tassert var.all_ne(0)\n\tz = flex.abs(ratio-mean)/var\n\tz_ = flex.double(self.mean_obs.size(), -1)\n\tz_.set_selected(sel, z)\n\treturn z_\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "from mmtbx.scaling import absolute_scaling", "import mmtbx.scaling", "from iotbx import data_plots", "from scitbx.array_family import flex", "from scitbx.math import scale_curves", "from scitbx import simplex", "from scitbx.math import chebyshev_polynome", "from libtbx.utils import Sorry", "from libtbx import table_utils", "import sys,math", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "target", "data": "  def target(self,vector):\n\tv=1.0\n\tscale = abs(vector[0])\n\tb_value = vector[1]\n\tif b_value > 200.0:\n\t  b_value = 200.0\n\tif b_value < -200.0:\n\t  b_value = -200.0\n\ti_scaled = flex.exp( self.calc_d_star_sq*b_value )*self.mean_calc*scale\n\tratio  = i_scaled / self.mean_obs\n\tcurve = self.curve( self.calc_d_star_sq )\n\tresult = ratio - flex.exp(curve)\n\tif (flex.max(result) > math.sqrt(sys.float_info.max)):\n\t  raise OverflowError(\"Result array exceeds floating-point limit.\")\n\tresult = result*result\n\twmax = flex.max(self.weight_array)\n\tassert (wmax != 0)\n\tif (wmax > 1) and (flex.max(result) > sys.float_info.max / wmax):\n\t  raise OverflowError(\"Weighted result array will exceed floating-point \"+\n\t\t\"limit: %e\" % flex.max(result))\n\tresult = result*self.weight_array\n\tresult = flex.sum( result )\n\treturn result\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "from mmtbx.scaling import absolute_scaling", "import mmtbx.scaling", "from iotbx import data_plots", "from scitbx.array_family import flex", "from scitbx.math import scale_curves", "from scitbx import simplex", "from scitbx.math import chebyshev_polynome", "from libtbx.utils import Sorry", "from libtbx import table_utils", "import sys,math", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "curve", "data": "  def curve(self,d_star_sq):\n\tresult =  self.mean_ratio_engine.f( d_star_sq )\n\treturn result\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "from mmtbx.scaling import absolute_scaling", "import mmtbx.scaling", "from iotbx import data_plots", "from scitbx.array_family import flex", "from scitbx.math import scale_curves", "from scitbx import simplex", "from scitbx.math import chebyshev_polynome", "from libtbx.utils import Sorry", "from libtbx import table_utils", "import sys,math", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "std", "data": "  def std(self,d_star_sq):\n\tresult = self.std_ratio_engine.f( d_star_sq )\n\treturn result\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "from mmtbx.scaling import absolute_scaling", "import mmtbx.scaling", "from iotbx import data_plots", "from scitbx.array_family import flex", "from scitbx.math import scale_curves", "from scitbx import simplex", "from scitbx.math import chebyshev_polynome", "from libtbx.utils import Sorry", "from libtbx import table_utils", "import sys,math", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "show_summary", "data": "  def show_summary(self, out):\n\treturn self.summary().show(out=out)\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "from mmtbx.scaling import absolute_scaling", "import mmtbx.scaling", "from iotbx import data_plots", "from scitbx.array_family import flex", "from scitbx.math import scale_curves", "from scitbx import simplex", "from scitbx.math import chebyshev_polynome", "from libtbx.utils import Sorry", "from libtbx import table_utils", "import sys,math", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "__init__", "data": "  def __init__(self,\n\t  all_curves,\n\t  level=6.0,\n\t  all_bad_z_scores=False):\n\tself.table = data_plots.table_data(\n\t  title=\"Relative Wilson plot\",\n\t  column_labels=[\"Max. resolution\", \"log(I_exp/I_obs)\", \"Reference curve\",\n\t\t\"Z-score\"],\n\t  graph_names=[\"Relative Wilson plot\"],\n\t  graph_labels=[(\"High resolution\", \"\")],\n\t  graph_columns=[list(range(4))],\n\t  x_is_inverse_d_min=True,\n\t  data=[ list(array) for array in all_curves ])\n\tself.cutoff = level\n\tself.all_bad_z_scores = all_bad_z_scores\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "from mmtbx.scaling import absolute_scaling", "import mmtbx.scaling", "from iotbx import data_plots", "from scitbx.array_family import flex", "from scitbx.math import scale_curves", "from scitbx import simplex", "from scitbx.math import chebyshev_polynome", "from libtbx.utils import Sorry", "from libtbx import table_utils", "import sys,math", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "n_outliers", "data": "  def n_outliers(self):\n\tss,rr,ii,zz = self.data_as_flex_arrays()\n\tflagged = zz > self.cutoff\n\treturn flagged.count(True)\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "from mmtbx.scaling import absolute_scaling", "import mmtbx.scaling", "from iotbx import data_plots", "from scitbx.array_family import flex", "from scitbx.math import scale_curves", "from scitbx import simplex", "from scitbx.math import chebyshev_polynome", "from libtbx.utils import Sorry", "from libtbx import table_utils", "import sys,math", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "data_as_flex_arrays", "data": "  def data_as_flex_arrays(self):\n\treturn [ flex.double(column) for column in self.table.data ]\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "from mmtbx.scaling import absolute_scaling", "import mmtbx.scaling", "from iotbx import data_plots", "from scitbx.array_family import flex", "from scitbx.math import scale_curves", "from scitbx import simplex", "from scitbx.math import chebyshev_polynome", "from libtbx.utils import Sorry", "from libtbx import table_utils", "import sys,math", "from six.moves import zip", "from six.moves import range"]}, {"term": "def", "name": "_show_impl", "data": "  def _show_impl(self, out):\n\tss,rr,ii,zz = self.data_as_flex_arrays()\n\tflagged = zz > self.cutoff\n\tsel_ss = ss.select(flagged)\n\tsel_z = zz.select(flagged)\n\tsel_r = rr.select(flagged)\n\tsel_i = ii.select(flagged)\n\tout.show_sub_header(\"Relative Wilson plot\")\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "from mmtbx.scaling import absolute_scaling", "import mmtbx.scaling", "from iotbx import data_plots", "from scitbx.array_family import flex", "from scitbx.math import scale_curves", "from scitbx import simplex", "from scitbx.math import chebyshev_polynome", "from libtbx.utils import Sorry", "from libtbx import table_utils", "import sys,math", "from six.moves import zip", "from six.moves import range"]}], [{"term": "def", "name": "test_SAM", "data": "def test_SAM():\n\tv = np.arange(-2,2,.001)\n\tV=[]\n\tfor i in range(2):\n\t\tV = np.append(V,v)\n\tV = sorted(V)\n\t\n\t#\t\t n\t\tgammaW\t gammaC  deltaE eta\t   sigma c  vg T\n\targs = [1.50e+02,  1.375e-05, 0.0352, 0.75,   5.32e-01, 0,\t0, 0, 300]\n\t\n\tstart = time.time()\n\tvecCur = np.vectorize(tunnelmodel_singleLevel)\n\ty1 = vecCur(V, *args)\n\ttime1 = time.time()-start\n\t\n\tstart = time.time()\n\tfast = interp1D(tunnelmodel_singleLevel)\n\ty2 = fast(V, *args)\n\ttime2 = time.time()-start\n\t\n\tprint('Slow: %.2f\\t\\tFast: %.2f\\t\\tSpeed Increase: %.0f%%'%(time1,time2,time1/time2*100))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\tplt.figure()\n\tplt.scatter(V,y1, color = 'black')\n\tplt.plot(V,y2, color = 'red')\n", "description": null, "category": "math", "imports": ["from penguins.functions import tunnelmodel_singleLevel", "from penguins.functions import averageBridgePopulation", "from penguins.functions import MarcusETRates", "from penguins.functions import interp1D", "import numpy as np", "import matplotlib.pyplot as plt", "import time", "import pandas as pd"]}, {"term": "def", "name": "test_SET", "data": "def test_SET():\n\tv = np.arange(-.05,.05,.001)\n\tV=[]\n\tfor i in range(2):\n\t\tV = np.append(V,v)\n\tV = sorted(V)\n\t\n\t#\t\t n\t\tgammaW\t gammaC  deltaE eta\t   sigma c  vg T\n\targs = [1.50e+02,  1.375e-05, 0.0352, 0.03,   5.32e-01, 0,\t0, 0, 300]\n\t\n\tstart = time.time()\n\tvecCur = np.vectorize(tunnelmodel_singleLevel)\n\ty1 = vecCur(V, *args)\n\ttime1 = time.time()-start\n\t\n\tstart = time.time()\n\tfast = interp1D(tunnelmodel_singleLevel)\n\ty2 = fast(V, *args)\n\ttime2 = time.time()-start\n\t\n\t# print('Slow: %.2f\\t\\tFast: %.2f\\t\\tSpeed Increase: %.0f%%'%(time1,time2,time1/time2*100))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \n\tplt.figure()\n\tplt.scatter(V,y1, color = 'black')\n\tplt.plot(V,y2, color = 'red')\n", "description": null, "category": "math", "imports": ["from penguins.functions import tunnelmodel_singleLevel", "from penguins.functions import averageBridgePopulation", "from penguins.functions import MarcusETRates", "from penguins.functions import interp1D", "import numpy as np", "import matplotlib.pyplot as plt", "import time", "import pandas as pd"]}, {"term": "def", "name": "test_Hysteric", "data": "def test_Hysteric():\n\tdef HysteresisModel_Slow(vb, n, gammaL, gammaR, kappa, sigma, E_AB, E_AC, chi, eta,\n\t\t\t\t  gam, lam, P, u, c, vg, T):\n\n\t\tvolts = list(set(np.round(vb,2)))\n\t\n\t\t#%% Calculate all currents:\n\t\tcalcDB = pd.DataFrame()\n\t\tcalcDB['V'] = sorted(volts)\n\t\t\n\t\teqSTL = interp1D(tunnelmodel_singleLevel)\n\t\tcalcDB['I_np'] = eqSTL(calcDB['V'], n, gammaL*gammaR, gammaL+gammaR, E_AB,\n\t\t\t\t\t\t\t\teta, sigma, c, vg, T)\n\t\tcalcDB['I_p'] = eqSTL(calcDB['V'], n, gammaL*gammaR*kappa**2,\n\t\t\t\t\t\t\t  (gammaL+gammaR)*kappa, E_AB+chi, eta, sigma, c, vg,\n\t\t\t\t\t\t\t  T)\t  \n\t\t\n\t\teqETRates = interp1D(MarcusETRates)\n\t\tcalcDB['R_AC'], calcDB['R_CA'] = eqETRates(calcDB['V'], gam, lam, E_AC, T)\n\t\tcalcDB['R_BD'], calcDB['R_DB'] = eqETRates(calcDB['V'], gam*kappa, lam,\n\t\t\t\t\t\t\t\t\t\t\t\t   E_AC+chi, T)\n\t\t\n\t\teqBridge = interp1D(averageBridgePopulation)\n\t\tcalcDB['n_np'] = eqBridge(calcDB['V'], gammaL, gammaR, E_AB, eta, c, vg, T)\n\t\tcalcDB['n_p']  = eqBridge(calcDB['V'], gammaL*kappa, gammaR*kappa,\n\t\t\t\t\t\t\t\t  E_AB+chi, eta, c, vg, T)\n\t\t\n\t\tcalcDB['k_S0_S1'] = (1-calcDB['n_np'])*calcDB['R_AC'] + calcDB['n_np']*calcDB['R_BD']\n\t\tcalcDB['k_S1_S0'] = (1-calcDB['n_p'])*calcDB['R_CA'] + calcDB['n_p']*calcDB['R_DB']\n\t\t\t\n\t\tdelt = abs(vb[2]-vb[3])/u\n\t\tI = []\n\t\tParray = []\n\t\tdelArray = []\n\t\t\t\n\t\tfor i,V in enumerate(vb):\n\t\t\tV = np.round(V,2)\n\t\t\ttempDf =calcDB[calcDB['V']==np.round(V,2)].reset_index()\n\t\t\tcalcs = dict(tempDf.iloc[0])\n\t\t\t\n\t\t\tParray += [P]\n\t\t\tI += [((1-P)*calcs['I_np']+P*calcs['I_p'])]\n\t\t\t\n\t\t\tdPdt = calcs['k_S0_S1']-P*(calcs['k_S0_S1']+calcs['k_S1_S0'])\n\t\t\tdelArray += [dPdt]\n\t\t\tP = P+dPdt*delt\n\t\t\n\t\treturn I, Parray\n\t\n\tdef HysteresisModel_Fast(vb, n, gammaL, gammaR, kappa, sigma, E_AB, E_AC, chi, eta,\n\t\t\t\t  gam, lam, P, u, c, vg, T):\n\n\t\tvolts = list(set(np.round(vb,2)))\n\t\n\t\t#%% Calculate all currents:\n\t\tcalcDB = pd.DataFrame()\n\t\tcalcDB['V'] = sorted(volts)\n\t\t\n\t\teqSTL = np.vectorize(tunnelmodel_singleLevel)\n\t\tcalcDB['I_np'] = eqSTL(calcDB['V'], n, gammaL*gammaR, gammaL+gammaR, E_AB,\n\t\t\t\t\t\t\t\teta, sigma, c, vg, T)\n\t\tcalcDB['I_p'] = eqSTL(calcDB['V'], n, gammaL*gammaR*kappa**2,\n\t\t\t\t\t\t\t  (gammaL+gammaR)*kappa, E_AB+chi, eta, sigma, c, vg,\n\t\t\t\t\t\t\t  T)\t  \n\t\t\n\t\teqETRates = np.vectorize(MarcusETRates)\n\t\tcalcDB['R_AC'], calcDB['R_CA'] = eqETRates(calcDB['V'], gam, lam, E_AC, T)\n\t\tcalcDB['R_BD'], calcDB['R_DB'] = eqETRates(calcDB['V'], gam*kappa, lam,\n\t\t\t\t\t\t\t\t\t\t\t\t   E_AC+chi, T)\n\t\t\n\t\teqBridge = np.vectorize(averageBridgePopulation)\n\t\tcalcDB['n_np'] = eqBridge(calcDB['V'], gammaL, gammaR, E_AB, eta, c, vg, T)\n\t\tcalcDB['n_p']  = eqBridge(calcDB['V'], gammaL*kappa, gammaR*kappa,\n\t\t\t\t\t\t\t\t  E_AB+chi, eta, c, vg, T)\n\t\t\n\t\tcalcDB['k_S0_S1'] = (1-calcDB['n_np'])*calcDB['R_AC'] + calcDB['n_np']*calcDB['R_BD']\n\t\tcalcDB['k_S1_S0'] = (1-calcDB['n_p'])*calcDB['R_CA'] + calcDB['n_p']*calcDB['R_DB']\n\t\t\t\n\t\tdelt = abs(vb[2]-vb[3])/u\n\t\tI = []\n\t\tParray = []\n\t\tdelArray = []\n\t\t\t\n\t\tfor i,V in enumerate(vb):\n\t\t\tV = np.round(V,2)\n\t\t\ttempDf =calcDB[calcDB['V']==np.round(V,2)].reset_index()\n\t\t\tcalcs = dict(tempDf.iloc[0])\n\t\t\t\n\t\t\tParray += [P]\n\t\t\tI += [((1-P)*calcs['I_np']+P*calcs['I_p'])]\n\t\t\t\n\t\t\tdPdt = calcs['k_S0_S1']-P*(calcs['k_S0_S1']+calcs['k_S1_S0'])\n\t\t\tdelArray += [dPdt]\n\t\t\tP = P+dPdt*delt\n\t\t\n\t\treturn I, Parray\n\t\n\tinitpar = {\n\t\t\t\t'n'\t:1.50e+02,\n\t\t\t\t'gammaL'\t:5.52E-04,\n\t\t\t\t'gammaR'\t:2.03E-02,\n\t\t\t\t'kappa'\t:2.81,\n\t\t\t\t'sigma'\t:0.00e+00,\n\t\t\t\t'E_AB'\t:6.93e-01,\n\t\t\t\t'E_AC'\t:-7.17e-01,\n\t\t\t\t'chi'\t:1.58e+00,\n\t\t\t\t'eta'\t:5.23e-01,\n\t\t\t\t'gam'\t:7.12e-01,\n\t\t\t\t'lam'\t:1.21e+00,\n\t\t\t\t'P'\t:0.00e+00,\n\t\t\t\t'u'\t:1.00e-02,\n\t\t\t\t'c'\t:0.00e+00,\n\t\t\t\t'vg'\t:0.00e+00,\n\t\t\t\t'T'\t:3.00e+02\n\t\t\t}\n\t\n\tDataFile = 'Data\\\\AsymNeg_cont_Normalized.txt'\n\tdata = pd.read_csv(DataFile, delimiter = '\\t')\n\tcolV = '-2.00V_1'\n\t\n\tstart = time.time()\n\ty1,_ = HysteresisModel_Slow(data[colV],*list(initpar.values()))\n\ttime1 = time.time()-start\n\t\n\tstart = time.time()\n\ty2,_ = HysteresisModel_Fast(data[colV],*list(initpar.values()))\n\ttime2 = time.time()-start\n\t\n\tprint('Slow: %.2f\\t\\tFast: %.2f\\t\\tSpeed Increase: %.0f%%'%(time1,time2,time1/time2*100))\n\t\n\tplt.figure()\n\tplt.scatter(data[colV],np.abs(y1), color = 'black')\n\tplt.plot(   data[colV], np.abs(y2), color = 'red')\n\tplt.ylim(7.2e-10,2e-05)\n\tplt.yscale('log')\n\n", "description": null, "category": "math", "imports": ["from penguins.functions import tunnelmodel_singleLevel", "from penguins.functions import averageBridgePopulation", "from penguins.functions import MarcusETRates", "from penguins.functions import interp1D", "import numpy as np", "import matplotlib.pyplot as plt", "import time", "import pandas as pd"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(\"Error\", cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "ChangeInWeight", "data": "def ChangeInWeight(target, o, xi):\n\tn = 0.1\n\treturn (n * (target - o) * xi)\n\n", "description": null, "category": "math", "imports": ["import random"]}, {"term": "def", "name": "calcPerceptron", "data": "def calcPerceptron(weightArray, x1, x2):\n\ttempVal = weightArray[0] + (weightArray[1] * x1) + (weightArray[2] * x2)\n\tif tempVal > 0:\n\t\treturn 1\n\telse:\n\t\treturn -1\n", "description": null, "category": "math", "imports": ["import random"]}, {"term": "def", "name": "CalcWeights", "data": "def CalcWeights(targetArray, startingWeights):\n\tcurrentArray = [0,0,0,0]\n\twhile targetArray != currentArray:\n\t\tcurrentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n\t\tcurrentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n\t\tcurrentArray[2] = (calcPerceptron(startingWeights, 1, 0))\n\t\tcurrentArray[3] = (calcPerceptron(startingWeights, 1, 1))\n\t\twhile(currentArray[0] != targetArray[0]):\n\t\t\ttempVal = calcPerceptron(startingWeights, 0, 0)\n\t\t\tstartingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[0], tempVal, 1)\n\t\t\tstartingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[0], tempVal, 0)\n\t\t\tstartingWeights[2] = startingWeights[2] + ChangeInWeight(targetArray[0], tempVal, 0)\n\t\t\tcurrentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n\t\t\tcurrentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n\t\t\tcurrentArray[2] = (calcPerceptron(startingWeights, 1, 0))\n\t\t\tcurrentArray[3] = (calcPerceptron(startingWeights, 1, 1))\n\t\twhile(currentArray[1] != targetArray[1]):\n\t\t\ttempVal = calcPerceptron(startingWeights, 0, 1)\n\t\t\tstartingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[1], tempVal, 1)\n\t\t\tstartingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[1], tempVal, 0)\n\t\t\tstartingWeights[2] = startingWeights[2] + ChangeInWeight(targetArray[1], tempVal, 1)\n\t\t\tcurrentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n\t\t\tcurrentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n\t\t\tcurrentArray[2] = (calcPerceptron(startingWeights, 1, 0))\n\t\t\tcurrentArray[3] = (calcPerceptron(startingWeights, 1, 1))\n\t\twhile(currentArray[2] != targetArray[2]):\n\t\t\ttempVal = calcPerceptron(startingWeights, 1, 0)\n\t\t\tstartingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[2], tempVal, 1)\n\t\t\tstartingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[2], tempVal, 1)\n\t\t\tstartingWeights[2] = startingWeights[2] + ChangeInWeight(targetArray[2], tempVal, 0)\n\t\t\tcurrentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n\t\t\tcurrentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n\t\t\tcurrentArray[2] = (calcPerceptron(startingWeights, 1, 0))\n\t\t\tcurrentArray[3] = (calcPerceptron(startingWeights, 1, 1))\n\t\twhile(currentArray[3] != targetArray[3]):\n\t\t\ttempVal = calcPerceptron(startingWeights, 1, 1)\n\t\t\tstartingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[3], tempVal, 1)\n\t\t\tstartingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[3], tempVal, 1)\n\t\t\tstartingWeights[2] = startingWeights[2] + ChangeInWeight(targetArray[3], tempVal, 1)\n\t\t\tcurrentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n\t\t\tcurrentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n\t\t\tcurrentArray[2] = (calcPerceptron(startingWeights, 1, 0))\n\t\t\tcurrentArray[3] = (calcPerceptron(startingWeights, 1, 1))\n\treturn startingWeights\n", "description": null, "category": "math", "imports": ["import random"]}, {"term": "def", "name": "CalcNotWeights", "data": "def CalcNotWeights(targetArray, startingWeights):\n\tcurrentArray = [0,0,0,0]\n\twhile targetArray != currentArray:\n\t\tcurrentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n\t\tcurrentArray[1] = (calcPerceptron(startingWeights, 0, 1))\n\t\twhile(currentArray[0] != targetArray[0]):\n\t\t\ttempVal = calcPerceptron(startingWeights, 0, 0)\n\t\t\tstartingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[0], tempVal, 1)\n\t\t\tstartingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[0], tempVal, 0)\n\t\t\tcurrentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n\t\t\tcurrentArray[1] = (calcPerceptron(startingWeights, 1, 0))\n\t\twhile(currentArray[1] != targetArray[1]):\n\t\t\ttempVal = calcPerceptron(startingWeights, 1, 0)\n\t\t\tstartingWeights[0] = startingWeights[0] + ChangeInWeight(targetArray[1], tempVal, 1)\n\t\t\tstartingWeights[1] = startingWeights[1] + ChangeInWeight(targetArray[1], tempVal, 1)\n\t\t\tcurrentArray[0] = (calcPerceptron(startingWeights, 0, 0))\n\t\t\tcurrentArray[1] = (calcPerceptron(startingWeights, 1, 0))\n\treturn startingWeights\n", "description": null, "category": "math", "imports": ["import random"]}, {"term": "def", "name": "CalcXorValues", "data": "def CalcXorValues(andWeights, orWeights):\n\tcurrentValues = []\n\t\n\tandValue = calcPerceptron(andWeights, 0, 0)\n\tif andValue == -1:\n\t\tandValue = 0\n\torValue = calcPerceptron(orWeights, 0, 0)\n\txorValue = orValue - (andValue * 2)\n\tcurrentValues.append(xorValue)\n\t\n\tandValue = calcPerceptron(andWeights, 0, 1)\n\tif andValue == -1:\n\t\tandValue = 0\n\torValue = calcPerceptron(orWeights, 0, 1)\n\txorValue = orValue - (andValue * 2)\n\tcurrentValues.append(xorValue)\n\n\tandValue = calcPerceptron(andWeights, 1, 0)\n\tif andValue == -1:\n\t\tandValue = 0\n\torValue = calcPerceptron(orWeights, 1, 0)\n\txorValue = orValue - (andValue * 2)\n\tcurrentValues.append(xorValue)\n\n\tandValue = calcPerceptron(andWeights, 1, 1)\n\tif andValue == -1:\n\t\tandValue = 0\n\torValue = calcPerceptron(orWeights, 1, 1)\n\txorValue = orValue - (andValue * 2)\n\tcurrentValues.append(xorValue)\n\n\treturnValues = []\n\tfor x in currentValues:\n\t\tif x > 0:\n\t\t\treturnValues.append(1)\n\t\telse:\n\t\t\treturnValues.append(-1)\n\t\t\n\treturn returnValues\n", "description": null, "category": "math", "imports": ["import random"]}], [{"term": "def", "name": "testMockFunction", "data": "  def testMockFunction(self):\n\t@MockFunction\n\tdef calc(a, b, mult=1):\n\t  return (a + b) * mult\n\n\tself.assertTrue(*calc.CheckAndReset(0))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 1 call(s), got 0'), calc.CheckAndReset(1))\n\n\tself.assertEqual(20, calc(2, 3, mult=4))\n\tself.assertTrue(*calc.CheckAndReset(1))\n\tself.assertTrue(*calc.CheckAndReset(0))\n\n\tself.assertEqual(20, calc(2, 3, mult=4))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 0 call(s), got 1'), calc.CheckAndReset(0))\n\n\tself.assertEqual(3, calc(1, 2))\n\tself.assertEqual(0, calc(3, 4, mult=0))\n\tself.assertTrue(*calc.CheckAndReset(2))\n\tself.assertTrue(*calc.CheckAndReset(0))\n\n\tself.assertEqual(3, calc(1, 2))\n\tself.assertEqual(0, calc(3, 4, mult=0))\n\tself.assertEqual(\n\t\t(False, 'calc: expected 3 call(s), got 2'), calc.CheckAndReset(3))\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock_function import MockFunction"]}], [{"term": "class", "name": "classDerivative:", "data": "class Derivative:\n\tdef __init__(self, f, h=0.0001):\n\t\tself.f = f\n\t\tself.h = float(h)\n\n\tdef __call__(self, x):\n\t\tf, h = self.f, self.h\n\t\treturn (f(x+h) - f(x-h))/(2*h)\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "class", "name": "classDerivative2:", "data": "class Derivative2:\n\tdef __init__(self, f, h=0.0001):\n\t\tself.f = f\n\t\tself.h = float(h)\n\n\tdef __call__(self, x):\n\t\tf, h = self.f, self.h\n\t\treturn (f(x+h) - 2 * f(x) + f(x-h))/h**2\n\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "C", "data": "def C(n, k):\n\treturn math.factorial(n)/(math.factorial(n-k)*math.factorial(k))\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "b", "data": "def b(value):\n\tres = [0]\n\tsumm = 0\n\tfor i in range(1, value):\n\t\tsumm += i\n\tfor i in range(1, value):\n\t\tres.append(i/summ)\n\treturn res\n\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "class", "name": "classSolver:", "data": "class Solver:\n\n\tdef __init__(self, a, infin=3, fun = b):\n\t\tassert 0 < a < 1\n\t\tself.a = a\n\t\tself.inf = infin\n\t\tself.b = fun(self.inf)\n\t\tself.inA = 1 - a\n\t\tself.inB = self.calc_inB()\n\t\tself.q = []\n\t\tself.p = {}\n\t\tself.ro = self.a*self.inB\n\n\tdef reload(self, a, infin=3):\n\t\tassert 0 < a < 1\n\t\tself.a = a\n\t\tself.inf = infin\n\t\tself.b = b(self.inf)\n\t\tself.inA = 1 - a\n\t\tself.inB = self.calc_inB()\n\t\tself.ro = self.a*self.inB\n\n\tdef calc_inB(self):\n\t\tsumm = 0\n\t\tfor i in range(self.inf):\n\t\t\tsumm += i*self.b[i]\n\t\treturn summ\n\n\tdef calc_Bi(self, i):\n\t\tsumm = 0\n\t\tfor j in range(i, self.inf):\n\t\t\tsumm += self.b[j]\n\t\treturn summ\n\n\tdef calc_pmn(self, m, n):\n\t\tif self.p.get((m,n)):\n\t\t\treturn self.p.get((m,n))\n\t\tif m==0:\n\t\t\tif n==0:\n\t\t\t\tself.p[(m, n)] = 1 - self.a*self.calc_Bi(1)\n\t\t\t\treturn self.p[(m, n)]\n\t\t\telif n==1:\n\t\t\t\tself.p[(m, n)] = self.a*self.calc_Bi(1)\n\t\t\t\treturn self.p[(m, n)]\n\t\t\telse:\n\t\t\t\tself.p[(m, n)] = 0\n\t\t\t\treturn self.p[(m, n)]\n\t\telif n==0:\n\t\t\tself.p[(m, n)] = ((1-self.a*self.calc_Bi(m+1))*self.calc_pmn(m-1, 0))\n\t\t\treturn self.p[(m, n)]\n\t\telse:\n\t\t\tself.p[(m, n)] = ((1-self.a*self.calc_Bi(m+1))*self.calc_pmn(m-1,n) + self.a*self.calc_Bi(m+1) *\\\n\t\t\t\t\tself.calc_pmn(m-1, n-1))\n\t\t\treturn self.p[(m, n)]\n\n\tdef calc_Pz(self, z):\n\t\tmult = 1\n\t\tfor n in range(self.inf):\n\t\t\tmult *= (1-self.a*(1-z)*self.calc_Bi(n+1))\n\t\treturn mult\n\n\tdef calc_N1(self):\n\t\tdf = Derivative(self.calc_Pz)\n\t\treturn df(1)\n\n\tdef calc_N2(self):\n\t\tsumm = 0\n\t\tfor n in range(self.inf):\n\t\t\tsumm += self.calc_Bi(n+1)\n\t\treturn self.a*summ\n\n\tdef calc_N3(self):\n\t\tsumm = 0\n\t\tfor n in range(1, self.inf):\n\t\t\tsumm += n*self.calc_pmn(10, n)\n\t\treturn summ\n\n\tdef calc_D(self):\n\t\tdf = Derivative(self.calc_Pz)\n\t\tdf2 = Derivative2(self.calc_Pz)\n\t\treturn df2(1)+df(1)-df(1)**2\n", "description": null, "category": "math", "imports": ["import math"]}], [{"term": "def", "name": "test_forcecalc1", "data": "def test_forcecalc1():\n\tcalc = ForceCalc()\n\tf = Formula('C3HO3-')\n\tassert f in calc.get(f.mass(), base_group=Formula(\"-\"))\n\n\tcalc['H[2]'] = 100\n\tcalc['H'] = 0\n\tcalc['O[18]'] = 100\n\tassert calc['H[2]'] == 100\n\tassert calc['H'] == 0\n\tassert calc['O[18]'] == 100\n\tf = Formula('C10H[2]O[18]-')\n\tassert f in calc.get(f.mass(), base_group=Formula(\"-\"))\n\n", "description": null, "category": "math", "imports": ["from .. import ForceCalc, Formula", "from Orbitool.utils import formula"]}, {"term": "def", "name": "test_forcecalc2", "data": "def test_forcecalc2():\n\tcalc = ForceCalc()\n\tcalc['H[2]'] = 100\n\tcalc['O[18]'] = 100\n\t# f = Formula('C10H[2]O[18]-')\n\tf = Formula('C10H[2]O[18]-')\n\tassert f in calc.get(f.mass(), base_group=Formula(\"-\"))\n\n", "description": null, "category": "math", "imports": ["from .. import ForceCalc, Formula", "from Orbitool.utils import formula"]}, {"term": "def", "name": "test_forcecalc3", "data": "def test_forcecalc3():\n\tcalc = ForceCalc()\n\tcalc['C[13]'] = 3\n\tcalc['O[18]'] = 3\n\tcalc['N'] = 5\n\tcalc['H'] = 40\n\tcalc['C'] = 40\n\tcalc['O'] = 30\n\n\tsamples = ['C16H20O10O[18]2N3-', 'C10H17O10N3NO3-']\n\n\tsamples = [Formula(sample) for sample in samples]\n\n\tfor f in samples:\n\t\tret = calc.get(f.mass(), base_group=Formula(\"-\"))\n\t\tassert f in ret\n\t\tassert len(ret) < 25\n\t\tfor r in ret:\n\t\t\tassert abs(r.mass() / f.mass() - 1) < calc.rtol\n\n", "description": null, "category": "math", "imports": ["from .. import ForceCalc, Formula", "from Orbitool.utils import formula"]}, {"term": "def", "name": "test_forcecalc4", "data": "def test_forcecalc4():\n\tcalc = ForceCalc()\n\tcalc['C'] = 20\n\tcalc['H'] = 40\n\tcalc['C[13]'] = 3\n\tcalc['N'] = 5\n\tcalc['O'] = 999\n\tcalc['O[18]'] = 3\n\tcalc['H[2]'] = 10\n\tret = calc.get(242.158, Formula(\"-\"))\n\tassert Formula('C10H6H[2]10O6-') in ret\n\n", "description": null, "category": "math", "imports": ["from .. import ForceCalc, Formula", "from Orbitool.utils import formula"]}, {"term": "def", "name": "test_forcecalc5", "data": "def test_forcecalc5():\n\tcalc = ForceCalc()\n\tcalc['N'] = 999\n\tf = Formula('CH4+')  # +\n\tassert f in calc.get(f.mass(), base_group=Formula(\"+\"))\n\n", "description": null, "category": "math", "imports": ["from .. import ForceCalc, Formula", "from Orbitool.utils import formula"]}, {"term": "def", "name": "test_basegroup", "data": "def test_basegroup():\n\tcalc = ForceCalc()\n\tcalc['N'] = 10\n\tcalc['O'] = 10\n\tcalc['H'] = 10\n\tcalc['N[15]'] = 10\n\tcalc['O[18]'] = 10\n\tf = Formula(\"HNO3\")\n\tassert f in calc.get(f.mass(), base_group=Formula(\"NO3\"))\n\tf = Formula(\"HNO2O[18]\")\n\tassert f in calc.get(f.mass(), base_group=Formula(\"NO3\"))\n\tf = Formula(\"HNO3\")\n\tassert f in calc.get(f.mass(), base_group=Formula(\"HNO3\"))\n\n", "description": null, "category": "math", "imports": ["from .. import ForceCalc, Formula", "from Orbitool.utils import formula"]}, {"term": "def", "name": "test_basegroup_nonisotope", "data": "def test_basegroup_nonisotope():\n\tcalc = ForceCalc()\n\tcalc['N'] = 10\n\tcalc['O[18]'] = 0\n\tcalc['N[15]'] = 0\n\tf = Formula(\"HNO3\")\n\tassert f in calc.get(f.mass())\n", "description": null, "category": "math", "imports": ["from .. import ForceCalc, Formula", "from Orbitool.utils import formula"]}, {"term": "def", "name": "test_minus", "data": "def test_minus():\n\tcalc = ForceCalc()\n\tfor ei in calc.getEIList():\n\t\tcalc[ei] = 0\n\tcalc[\"C\"] = 10\n\tcalc[\"H\"] = 10\n\tf = Formula(\"CH5-\")\n\tret = calc.get(f.mass(), Formula(\"-\"))\n", "description": null, "category": "math", "imports": ["from .. import ForceCalc, Formula", "from Orbitool.utils import formula"]}], [{"term": "def", "name": "calc", "data": "def calc():\n\tns = Namespace(functions=CORE_LIBRARY)\n\treturn Calculator(ns).evaluate_expression\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_rgb", "data": "def test_rgb(calc):\n\tassert calc('rgb(128, 192, 224)') == Color.from_rgb(128/255, 192/255, 224/255)\n\tassert calc('rgb(20%, 40%, 60%)') == Color.from_rgb(0.2, 0.4, 0.6)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_rgba", "data": "def test_rgba(calc):\n\t# four args (css-style)\n\tassert calc('rgba(128, 192, 224, 0.5)') == Color.from_rgb(128/255, 192/255, 224/255, 0.5)\n\tassert calc('rgba(20%, 40%, 60%, 0.7)') == Color.from_rgb(0.2, 0.4, 0.6, 0.7)\n\n\t# two args (modify alpha of existing color)\n\tassert calc('rgba(red, 0.4)') == Color.from_rgb(1., 0., 0., 0.4)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_red", "data": "def test_red(calc):\n\tassert calc('red(orange)') == Number(255)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_green", "data": "def test_green(calc):\n\tassert calc('green(orange)') == Number(165)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_blue", "data": "def test_blue(calc):\n\tassert calc('blue(orange)') == Number(0)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_mix", "data": "def test_mix(calc):\n\t# Examples from the Ruby docs\n\t# Note that the results have been adjusted slightly; Ruby floors the mixed\n\t# channels, but we round\n\tassert calc('mix(#f00, #00f)') == calc('#800080')\n\tassert calc('mix(#f00, #00f, 25%)') == calc('#4000bf')\n\tassert calc('mix(rgba(255, 0, 0, 0.5), #00f)') == calc('rgba(64, 0, 191, 0.75)')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_hsl", "data": "def test_hsl(calc):\n\t# Examples from the CSS 3 color spec, which Sass uses\n\t# (http://www.w3.org/TR/css3-color/#hsl-color)\n\tassert calc('hsl(0, 100%, 50%)') == Color.from_rgb(1., 0., 0.)\n\tassert calc('hsl(120, 100%, 50%)') == Color.from_rgb(0., 1., 0.)\n\tassert calc('hsl(120, 100%, 25%)') == Color.from_rgb(0., 0.5, 0.)\n\tassert calc('hsl(120, 100%, 75%)') == Color.from_rgb(0.5, 1., 0.5)\n\tassert calc('hsl(120, 75%, 75%)') == Color.from_rgb(0.5625, 0.9375, 0.5625)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_hsla", "data": "def test_hsla(calc):\n\t# Examples from the CSS 3 color spec\n\tassert calc('hsla(120, 100%, 50%, 1)') == Color.from_rgb(0., 1., 0.,)\n\tassert calc('hsla(240, 100%, 50%, 0.5)') == Color.from_rgb(0., 0., 1., 0.5)\n\tassert calc('hsla(30, 100%, 50%, 0.1)') == Color.from_rgb(1., 0.5, 0., 0.1)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_hue", "data": "def test_hue(calc):\n\tassert calc('hue(yellow)') == Number(60, unit='deg')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_saturation", "data": "def test_saturation(calc):\n\tassert calc('saturation(yellow)') == Number(100, unit='%')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_lightness", "data": "def test_lightness(calc):\n\tassert calc('lightness(yellow)') == Number(50, unit='%')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_adjust_hue", "data": "def test_adjust_hue(calc):\n\t# Examples from the Ruby docs\n\tassert calc('adjust-hue(hsl(120, 30%, 90%), 60deg)') == calc('hsl(180, 30%, 90%)')\n\tassert calc('adjust-hue(hsl(120, 30%, 90%), -60deg)') == calc('hsl(60, 30%, 90%)')\n\tassert calc('adjust-hue(#811, 45deg)') == Color.from_rgb(136/255, 106.25/255, 17/255)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_lighten", "data": "def test_lighten(calc):\n\t# Examples from the Ruby docs\n\tassert calc('lighten(hsl(0, 0%, 0%), 30%)') == calc('hsl(0, 0, 30)')\n\tassert calc('lighten(#800, 20%)') == calc('#e00')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_darken", "data": "def test_darken(calc):\n\t# Examples from the Ruby docs\n\tassert calc('darken(hsl(25, 100%, 80%), 30%)') == calc('hsl(25, 100%, 50%)')\n\tassert calc('darken(#800, 20%)') == calc('#200')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_saturate", "data": "def test_saturate(calc):\n\t# Examples from the Ruby docs\n\tassert calc('saturate(hsl(120, 30%, 90%), 20%)') == calc('hsl(120, 50%, 90%)')\n\tassert calc('saturate(#855, 20%)') == Color.from_rgb(158.1/255, 62.9/255, 62.9/255)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_desaturate", "data": "def test_desaturate(calc):\n\t# Examples from the Ruby docs\n\tassert calc('desaturate(hsl(120, 30%, 90%), 20%)') == calc('hsl(120, 10%, 90%)')\n\tassert calc('desaturate(#855, 20%)') == Color.from_rgb(113.9/255, 107.1/255, 107.1/255)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_grayscale", "data": "def test_grayscale(calc):\n\tassert calc('grayscale(black)') == Color.from_rgb(0., 0., 0.)\n\tassert calc('grayscale(white)') == Color.from_rgb(1., 1., 1.)\n\tassert calc('grayscale(yellow)') == Color.from_rgb(0.5, 0.5, 0.5)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_grayscale_css_filter", "data": "def test_grayscale_css_filter(calc):\n\t# grayscale(number) is a CSS filter and should be left alone\n\tassert calc('grayscale(1)') == String(\"grayscale(1)\")\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_complement", "data": "def test_complement(calc):\n\tassert calc('complement(black)') == Color.from_rgb(0., 0., 0.)\n\tassert calc('complement(white)') == Color.from_rgb(1., 1., 1.)\n\tassert calc('complement(yellow)') == Color.from_rgb(0., 0., 1.)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_invert", "data": "def test_invert(calc):\n\tassert calc('invert(black)') == Color.from_rgb(1., 1., 1.)\n\tassert calc('invert(white)') == Color.from_rgb(0., 0., 0.)\n\tassert calc('invert(yellow)') == Color.from_rgb(0., 0., 1.)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_alpha_opacity", "data": "def test_alpha_opacity(calc):\n\tassert calc('alpha(black)') == Number(1.)\n\tassert calc('alpha(rgba(black, 0.5))') == Number(0.5)\n\tassert calc('alpha(rgba(black, 0))') == Number(0.)\n\n\t# opacity is a synonym\n\tassert calc('opacity(black)') == Number(1.)\n\tassert calc('opacity(rgba(black, 0.5))') == Number(0.5)\n\tassert calc('opacity(rgba(black, 0))') == Number(0.)\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_alpha_ie_filter", "data": "def test_alpha_ie_filter(calc):\n\t# alpha() is supposed to leave the IE filter syntax alone\n\tassert calc('alpha(filter=20)') == \"alpha(filter=20)\"\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_opacify_fadein", "data": "def test_opacify_fadein(calc):\n\t# Examples from the Ruby docs\n\tassert calc('opacify(rgba(0, 0, 0, 0.5), 0.1)') == calc('rgba(0, 0, 0, 0.6)')\n\tassert calc('opacify(rgba(0, 0, 17, 0.8), 0.2)') == calc('#001')\n\n\t# fade-in is a synonym\n\tassert calc('fade-in(rgba(0, 0, 0, 0.5), 0.1)') == calc('rgba(0, 0, 0, 0.6)')\n\tassert calc('fade-in(rgba(0, 0, 17, 0.8), 0.2)') == calc('#001')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_transparentize_fadeout", "data": "def test_transparentize_fadeout(calc):\n\t# Examples from the Ruby docs\n\tassert calc('transparentize(rgba(0, 0, 0, 0.5), 0.1)') == calc('rgba(0, 0, 0, 0.4)')\n\tassert calc('transparentize(rgba(0, 0, 0, 0.8), 0.2)') == calc('rgba(0, 0, 0, 0.6)')\n\n\t# fade-out is a synonym\n\tassert calc('fade-out(rgba(0, 0, 0, 0.5), 0.1)') == calc('rgba(0, 0, 0, 0.4)')\n\tassert calc('fade-out(rgba(0, 0, 0, 0.8), 0.2)') == calc('rgba(0, 0, 0, 0.6)')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_adjust_color", "data": "def test_adjust_color(calc):\n\t# Examples from the Ruby docs\n\tassert calc('adjust-color(#102030, $blue: 5)') == calc('#102035')\n\tassert calc('adjust-color(#102030, $red: -5, $blue: 5)') == calc('#0b2035')\n\tassert calc('adjust-color(hsl(25, 100%, 80%), $lightness: -30%, $alpha: -0.4)') == calc('hsla(25, 100%, 50%, 0.6)')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_scale_color", "data": "def test_scale_color(calc):\n\t# Examples from the Ruby docs\n\tassert calc('scale-color(hsl(120, 70, 80), $lightness: 50%)') == calc('hsl(120, 70, 90)')\n\tassert calc('scale-color(rgb(200, 150, 170), $green: -40%, $blue: 70%)') == calc('rgb(200, 90, 229)')\n\tassert calc('scale-color(hsl(200, 70, 80), $saturation: -90%, $alpha: -30%)') == calc('hsla(200, 7, 80, 0.7)')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_change_color", "data": "def test_change_color(calc):\n\t# Examples from the Ruby docs\n\tassert calc('change-color(#102030, $blue: 5)') == calc('#102005')\n\tassert calc('change-color(#102030, $red: 120, $blue: 5)') == calc('#782005')\n\tassert calc('change-color(hsl(25, 100%, 80%), $lightness: 40%, $alpha: 0.8)') == calc('hsla(25, 100%, 40%, 0.8)')\n\n\tassert calc('change-color(red, $hue: 240)') == calc('blue')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_ie_hex_str", "data": "def test_ie_hex_str(calc):\n\t# Examples from the Ruby docs\n\tassert calc('ie-hex-str(#abc)') == calc('\"#FFAABBCC\"')\n\tassert calc('ie-hex-str(#3322BB)') == calc('\"#FF3322BB\"')\n\tassert calc('ie-hex-str(rgba(0, 255, 0, 0.5))') == calc('\"#8000FF00\"')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_unquote", "data": "def test_unquote(calc):\n\t# Examples from the Ruby docs\n\tret = calc('unquote(\"foo\")')\n\tassert ret == String('foo')\n\tassert ret.quotes is None\n\tret = calc('unquote(foo)')\n\tassert ret == String('foo')\n\tassert ret.quotes is None\n\n\tassert calc('unquote((one, two, three))') == String('one, two, three')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_quote", "data": "def test_quote(calc):\n\t# Examples from the Ruby docs\n\tret = calc('quote(\"foo\")')\n\tassert ret == String('foo')\n\tassert ret.quotes == '\"'\n\tret = calc('quote(foo)')\n\tassert ret == String('foo')\n\tassert ret.quotes == '\"'\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_str_length", "data": "def test_str_length(calc):\n\t# Examples from the Ruby docs\n\tassert calc('str-length(\"foo\")') == calc('3')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_str_insert", "data": "def test_str_insert(calc):\n\t# Examples from the Ruby docs\n\tassert calc('str-insert(\"abcd\", \"X\", 1)') == calc('\"Xabcd\"')\n\tassert calc('str-insert(\"abcd\", \"X\", 4)') == calc('\"abcXd\"')\n\t# DEVIATION: see https://github.com/nex3/sass/issues/954\n\tassert calc('str-insert(\"abcd\", \"X\", 5)') == calc('\"abcdX\"')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_str_index", "data": "def test_str_index(calc):\n\t# Examples from the Ruby docs\n\tassert calc('str-index(abcd, a)') == calc('1')\n\tassert calc('str-index(abcd, ab)') == calc('1')\n\tassert calc('str-index(abcd, X)') == calc('0')\n\tassert calc('str-index(abcd, c)') == calc('3')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_str_slice", "data": "def test_str_slice(calc):\n\t# Examples from the Ruby docs\n\tassert calc('str-slice(\"abcd\", 2, 3)') == calc('\"bc\"')\n\tassert calc('str-slice(\"abcd\", 2)') == calc('\"bcd\"')\n\tassert calc('str-slice(\"abcd\", -3, -2)') == calc('\"bc\"')\n\tassert calc('str-slice(\"abcd\", 2, -2)') == calc('\"bc\"')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_to_upper_case", "data": "def test_to_upper_case(calc):\n\t# Examples from the Ruby docs\n\tassert calc('to-upper-case(abcd)') == calc('ABCD')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_to_lower_case", "data": "def test_to_lower_case(calc):\n\t# Examples from the Ruby docs\n\tassert calc('to-lower-case(ABCD)') == calc('abcd')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_percentage", "data": "def test_percentage(calc):\n\t# Examples from the Ruby docs\n\tassert calc('percentage(100px / 50px)') == calc('200%')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_round", "data": "def test_round(calc):\n\t# Examples from the Ruby docs\n\tassert calc('round(10.4px)') == calc('10px')\n\tassert calc('round(10.6px)') == calc('11px')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_ceil", "data": "def test_ceil(calc):\n\t# Examples from the Ruby docs\n\tassert calc('ceil(10.4px)') == calc('11px')\n\tassert calc('ceil(10.6px)') == calc('11px')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_floor", "data": "def test_floor(calc):\n\t# Examples from the Ruby docs\n\tassert calc('floor(10.4px)') == calc('10px')\n\tassert calc('floor(10.6px)') == calc('10px')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_abs", "data": "def test_abs(calc):\n\t# Examples from the Ruby docs\n\tassert calc('abs(10px)') == calc('10px')\n\tassert calc('abs(-10px)') == calc('10px')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_min", "data": "def test_min(calc):\n\t# Examples from the Ruby docs\n\tassert calc('min(1px, 4px)') == calc('1px')\n\tassert calc('min(5em, 3em, 4em)') == calc('3em')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_max", "data": "def test_max(calc):\n\t# Examples from the Ruby docs\n\tassert calc('max(1px, 4px)') == calc('4px')\n\tassert calc('max(5em, 3em, 4em)') == calc('5em')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_length", "data": "def test_length(calc):\n\t# Examples from the Ruby docs\n\tassert calc('length(10px)') == calc('1')\n\tassert calc('length(10px 20px 30px)') == calc('3')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_nth", "data": "def test_nth(calc):\n\t# Examples from the Ruby docs\n\tassert calc('nth(10px 20px 30px, 1)') == calc('10px')\n\tassert calc('nth((Helvetica, Arial, sans-serif), 3)') == calc('sans-serif')\n\tassert calc('nth((width: 10px, length: 20px), 2)') == calc('length, 20px')\n\n\tassert calc('nth(10px 20px 30px, -1)') == calc('30px')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_join", "data": "def test_join(calc):\n\t# Examples from the Ruby docs\n\tassert calc('join(10px 20px, 30px 40px)') == calc('10px 20px 30px 40px')\n\tassert calc('join((blue, red), (#abc, #def))') == calc('blue, red, #abc, #def')\n\tassert calc('join(10px, 20px)') == calc('10px 20px')\n\tassert calc('join(10px, 20px, comma)') == calc('10px, 20px')\n\tassert calc('join((blue, red), (#abc, #def), space)') == calc('blue red #abc #def')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_append", "data": "def test_append(calc):\n\t# Examples from the Ruby docs\n\tassert calc('append(10px 20px, 30px)') == calc('10px 20px 30px')\n\tassert calc('append((blue, red), green)') == calc('blue, red, green')\n\tassert calc('append(10px 20px, 30px 40px)') == calc('10px 20px (30px 40px)')\n\tassert calc('append(10px, 20px, comma)') == calc('10px, 20px')\n\tassert calc('append((blue, red), green, space)') == calc('blue red green')\n\n\t# TODO need to test for commas here\n\tassert calc('append((a, b), c)') == calc('a, b, c')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_zip", "data": "def test_zip(calc):\n\t# Examples from the Ruby docs\n\tassert calc('zip(1px 1px 3px, solid dashed solid, red green blue)') == calc('1px solid red, 1px dashed green, 3px solid blue')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_index", "data": "def test_index(calc):\n\t# Examples from the Ruby docs\n\tassert calc('index(1px solid red, solid)') == calc('2')\n\tassert calc('index(1px solid red, dashed)') == calc('false')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_list_separator", "data": "def test_list_separator(calc):\n\t# Examples from the Ruby docs\n\tassert calc('list-separator(1px 2px 3px)') == calc('space')\n\tassert calc('list-separator(1px, 2px, 3px)') == calc('comma')\n\tassert calc('list-separator(\"foo\")') == calc('space')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_set_nth", "data": "def test_set_nth(calc):\n\t# Examples from the Ruby docs\n\tassert calc('set-nth($list: 10px 20px 30px, $n: 2, $value: -20px)') == calc('10px -20px 30px')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_map_get", "data": "def test_map_get(calc):\n\t# Examples from the Ruby docs\n\tassert calc('map-get((\"foo\": 1, \"bar\": 2), \"foo\")') == calc('1')\n\tassert calc('map-get((\"foo\": 1, \"bar\": 2), \"bar\")') == calc('2')\n\tassert calc('map-get((\"foo\": 1, \"bar\": 2), \"baz\")') == calc('null')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_map_merge", "data": "def test_map_merge(calc):\n\t# Examples from the Ruby docs\n\tassert calc('map-merge((\"foo\": 1), (\"bar\": 2))') == calc('(\"foo\": 1, \"bar\": 2)')\n\tassert calc('map-merge((\"foo\": 1, \"bar\": 2), (\"bar\": 3))') == calc('(\"foo\": 1, \"bar\": 3)')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_map_keys", "data": "def test_map_keys(calc):\n\t# Examples from the Ruby docs\n\tassert calc('map-keys((\"foo\": 1, \"bar\": 2))') == calc('\"foo\", \"bar\"')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_map_values", "data": "def test_map_values(calc):\n\t# Examples from the Ruby docs\n\tassert calc('map-values((\"foo\": 1, \"bar\": 2))') == calc('1, 2')\n\tassert calc('map-values((\"foo\": 1, \"bar\": 2, \"baz\": 1))') == calc('1, 2, 1')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_map_has_key", "data": "def test_map_has_key(calc):\n\t# Examples from the Ruby docs\n\tassert calc('map-has-key((\"foo\": 1, \"bar\": 2), \"foo\")') == calc('true')\n\tassert calc('map-has-key((\"foo\": 1, \"bar\": 2), \"baz\")') == calc('false')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_type_of", "data": "def test_type_of(calc):\n\t# Examples from the Ruby docs\n\tassert calc('type-of(100px)') == calc('number')\n\tassert calc('type-of(asdf)') == calc('string')\n\tassert calc('type-of(\"asdf\")') == calc('string')\n\tassert calc('type-of(true)') == calc('bool')\n\tassert calc('type-of(#fff)') == calc('color')\n\tassert calc('type-of(blue)') == calc('color')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_unit", "data": "def test_unit(calc):\n\t# Examples from the Ruby docs\n\tassert calc('unit(100)') == calc('\"\"')\n\tassert calc('unit(100px)') == calc('\"px\"')\n\tassert calc('unit(3em)') == calc('\"em\"')\n\tassert calc('unit(10px * 5em)') == calc('\"em*px\"')\n\t# NOTE: the docs say \"em*px/cm*rem\", but even Ruby sass doesn't actually\n\t# return that\n\tassert calc('unit(10px * 5em / 30cm / 1rem)') == calc('\"em/rem\"')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_unitless", "data": "def test_unitless(calc):\n\t# Examples from the Ruby docs\n\tassert calc('unitless(100)') == calc('true')\n\tassert calc('unitless(100px)') == calc('false')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_comparable", "data": "def test_comparable(calc):\n\t# Examples from the Ruby docs\n\tassert calc('comparable(2px, 1px)') == calc('true')\n\tassert calc('comparable(100px, 3em)') == calc('false')\n\tassert calc('comparable(10cm, 3mm)') == calc('true')\n\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}, {"term": "def", "name": "test_if", "data": "def test_if(calc):\n\t# Examples from the Ruby docs\n\tassert calc('if(true, 1px, 2px)') == calc('1px')\n\tassert calc('if(false, 1px, 2px)') == calc('2px')\n", "description": null, "category": "math", "imports": ["from __future__ import division", "from scss.expression import Calculator", "from scss.functions.core import CORE_LIBRARY", "from scss.rule import Namespace", "from scss.types import Color, Number, String", "import pytest"]}], [], [{"term": "def", "name": "parsefile", "data": "def parsefile(infile):\n\tresults = []\n\twith open(infile) as filein:\n\t\tfor line in filein:\n\t\t\tresults.append(line.strip().split(' '))\n\n\tdata = []\n\tfor (idx,row) in enumerate(results):\n\t\tdata.append([])\n\t\tfor i in row:\n\t\t\tdata[idx].append(int(i))\n\n\tN = 0\n\tG = dict()\n\tfor (idx, line) in enumerate(data):\n\t\tG[idx] = set()\n\t\tfor elem in line:\n\t\t\tG[idx].add(elem)\n\t\tN += len(G[idx])\n\treturn (G, N)\n", "description": null, "category": "math", "imports": ["from scipy import *"]}, {"term": "def", "name": "determine_R_prime", "data": "def determine_R_prime(base_folder, calc_folder, infilename_root, outfile):\n\toutfile.write('t\\tR\\' %s\\n' % infilename_root)\n\tfor t in [1, 2, 3, 4, 5, 6, 7, 8]:\n\n\t\tinfilename_base_full = base_folder + infilename_root + '_gen_calc.txt'\n\t\tinfilename_calc_full = calc_folder + infilename_root + '_gen_graph_t' + str(t) + '_calc.txt'\n\n\t\t# infilename_base_full = base_folder + infilename_base + '.txt'\n\t\t# infilename_calc_full = calc_folder + infilename_calc + '.txt'\n\n\t\t(G_base, N1) = parsefile(infilename_base_full)\n\t\t(G_calc, N2) = parsefile(infilename_calc_full)\n\n\t\tif N1 != N2:\n\t\t\toutfile.write('%s\\tERROR -> N1 != N2\\n' % t)\n\t\telse:\n\t\t\tN = N1\n\t\t\tSumNormC1i2 = 0\n\t\t\tSumNormC2j2 = 0\n\t\t\tfor C1i in G_base:\n\t\t\t\tcnt = len(G_base[C1i])\n\t\t\t\tSumNormC1i2 += cnt * cnt\n\t\t\tfor C2j in G_calc:\n\t\t\t\tcnt = len(G_calc[C2j])\n\t\t\t\tSumNormC2j2 += cnt * cnt\n\n\t\t\tSumC1i_inter_C2j2 = 0\n\t\t\tfor C1i in G_base:\n\t\t\t\tfor C2j in G_calc:\n\t\t\t\t\tCinter = G_base[C1i].intersection(G_calc[C2j])\n\t\t\t\t\tcnt = len(Cinter)\n\t\t\t\t\tSumC1i_inter_C2j2 += cnt * cnt\n\n\t\t\tRprime = (N * N * SumC1i_inter_C2j2 - SumNormC1i2 * SumNormC2j2) / (\n\t\t\t0.5 * N * N * (SumNormC1i2 + SumNormC2j2) - SumNormC1i2 * SumNormC2j2)\n\n\t\t\tprint 'R\\' = %s' % Rprime\n\t\t\toutfile.write('%s\\t%s\\n' % (t, Rprime))\n\n\toutfile.write('\\n')\n\n", "description": null, "category": "math", "imports": ["from scipy import *"]}, {"term": "def", "name": "main", "data": "def main():\n\t#infilename_base = 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc'\n\t#infilename_calc = 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t1_calc'\n\n\tbase_folder = 'in/GRAPH3extra/'\n\tcalc_folder = 'out/GRAPH3extra/'\n\toutfilename = 'out/RprimeGRAPH3extra.txt'\n\toutfile = open(outfilename, \"w\")\n\n\t# for (infilename_base, infilename_calc) in \\\n\t# [ \\\n\t#\t ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t1_calc' ), \\\n\t#\t ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t2_calc' ), \\\n\t#\t ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t3_calc' ), \\\n\t#\t ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t4_calc' ), \\\n\t#\t ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t5_calc' ), \\\n\t#\t ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t6_calc' ), \\\n\t#\t ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t7_calc' ), \\\n\t#\t ( 'nreq600_k2_alpha2_qe0.4_(n600)_gen_calc', 'nreq600_k2_alpha2_qe0.4_(n600)_gen_graph_t8_calc' )\n\t# ]:\n\n\t#GRAPH1\n\t# for infilename_root in \\\n\t# [ \\\n\t#\t\t 'nreq600_k2_alpha2_qe0.4_(n600)', \\\n\t#\t\t 'nreq600_k3_alpha2_qe0.4_(n600)', \\\n\t#\t\t 'nreq600_k5_alpha2_qe0.4_(n600)', \\\n\t#\t\t 'nreq600_k6_alpha2_qe0.4_(n600)', \\\n\t#\t\t 'nreq600_k12_alpha2_qe0.4_(n600)', \\\n\t#\t\t 'nreq600_k24_alpha2_qe0.4_(n600)', \\\n\t#\t\t 'nreq600_k36_alpha2_qe0.4_(n576)' \\\n\t# ]:\n\n\t# GRAPH2\n\t# for infilename_root in \\\n\t# [ \\#\n\t#\t 'nreq300_k10_alpha2_qe0.4_(n300)', \\\n\t#\t 'nreq600_k10_alpha2_qe0.4_(n600)', \\\n\t#\t 'nreq900_k10_alpha2_qe0.4_(n900)', \\\n\t#\t 'nreq1200_k10_alpha2_qe0.4_(n1200)' \\\n\t# ]:\n\n\t# GRAPH3\n\t# for infilename_root in \\\n\t# [ \\\n\t#\t 'nreq600_k5_alpha2_qe0.1_(n6# 00)', \\\n\t#\t 'nreq600_k5_alpha2_qe0.2_(n600)', \\\n\t#\t 'nreq600_k5_alpha2_qe0.3_(n600)', \\\n\t#\t 'nreq600_k5_alpha2_qe0.4_(n600)', \\\n\t#\t 'nreq600_k5_alpha2_qe0.5_(n600)', \\\n\t#\t 'nreq600_k5_alpha2_qe0.6_(n600)', \\\n\t#\t 'nreq600_k5_alpha2_qe0.7_(n600)' \\\n\t# ]:\n\n\t# GRAPH3extra\n\tfor infilename_root in \\\n\t[ \\\n\t\t'nreq600_k5_alpha2_qe0.32_(n600)', \\\n\t\t'nreq600_k5_alpha2_qe0.34_(n600)', \\\n\t\t'nreq600_k5_alpha2_qe0.36_(n600)', \\\n\t\t'nreq600_k5_alpha2_qe0.38_(n600)' \\\n\t]:\n\n\t# GRAPH4\n\t# for infilename_root in \\\n\t# [ \\\n\t#   'nreq600_k5_alpha1_qe0.4_(n600)', \\\n\t#   'nreq600_k5_alpha2_qe0.4_(n600)', \\\n\t#   'nreq600_k5_alpha3_qe0.4_(n600)', \\\n\t#   'nreq600_k5_alpha4_qe0.4_(n600)', \\\n\t#   'nreq600_k5_alpha5_qe0.4_(n600)', \\\n\t#   'nreq600_k5_alpha6_qe0.4_(n600)', \\\n\t#   'nreq600_k5_alpha7_qe0.4_(n600)', \\\n\t# ]:\n\n\t\tdetermine_R_prime(base_folder, calc_folder, infilename_root, outfile)\n\n\toutfile.close()\n\treturn\n", "description": null, "category": "math", "imports": ["from scipy import *"]}], [], [{"term": "class", "name": "classcylinder:", "data": "class cylinder:\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "__init__", "data": "  def __init__(self,radius,height):\n\tself.set_radius(radius)\n\tself.set_height(height)\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "get_radius", "data": "  def get_radius(self):\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "set_height", "data": "  def set_height(self,height):\n\tif height>0:\n\t  self.height = height\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "calc_base_area", "data": "  def calc_base_area(self):\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "calc_surface_area", "data": "  def calc_surface_area(self):\n\treturn 2*(math.pi*self.radius)* self.height\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "calc_area", "data": "  def calc_area(self):\n\treturn 2* self.calc_base_area() + self.calc_surface_area\n", "description": null, "category": "math", "imports": ["import math"]}, {"term": "def", "name": "calc_volume", "data": "  def calc_volume(self):\n\treturn self.calc_base_area() * self.height\n", "description": null, "category": "math", "imports": ["import math"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "test_al", "data": "def test_al(factory):\n\trun(factory)\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "test_al_old", "data": "def test_al_old(name):\n\tfactory = ObsoleteFactoryWrapper(name)\n\trun(factory)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.test.factories import ObsoleteFactoryWrapper"]}, {"term": "def", "name": "run", "data": "def run(factory):\n\tname = factory.name\n\tpar = required.get(name, {})\n\t# What on earth does kpts=1.0 mean?  Was failing, I changed it.  --askhl\n\t# Disabled GPAW since it was failing anyway. --askhl\n\tkpts = [2, 2, 2]\n\tcalc = factory.calc(label=name, xc='LDA', kpts=kpts, **par)\n\tal = bulk('AlO', crystalstructure='rocksalt', a=4.5)\n\tal.calc = calc\n\te = al.get_potential_energy()\n\tcalc.set(xc='PBE', kpts=kpts)\n\tepbe = al.get_potential_energy()\n\tprint(e, epbe)\n\tcalc = factory.calc(restart=name)\n\tprint(calc.parameters, calc.results, calc.atoms)\n\tassert not calc.calculation_required(al, ['energy'])\n\tal = calc.get_atoms()\n\tprint(al.get_potential_energy())\n\tlabel = 'dir/' + name + '-2'\n\tcalc = factory.calc(label=label, atoms=al, xc='LDA', kpts=kpts,\n\t\t\t\t\t\t**par)\n\tprint(al.get_potential_energy())\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.test.factories import ObsoleteFactoryWrapper"]}], [{"term": "def", "name": "get_mag_from_mass", "data": "def get_mag_from_mass(mass, age_gyr, feh):\n\tlog_age = np.log10(age_gyr*1e9)\n\teep = mist.get_eep(mass, log_age, feh, accurate=True)\n\tteff, logg = mist.interp_value([eep, log_age, feh], ['Teff', 'logg'])\n\tmags = bc_grid.interp([teff, logg, feh, 0.],\n\t\t\t\t\t\t  ['u', 'g', 'r', 'i', 'z', 'V'])\n\trmag = mags[2]\n\treturn teff, rmag\n", "description": null, "category": "math", "imports": ["import numpy as np", "from isochrones.mist.bc import MISTBolometricCorrectionGrid", "from isochrones import get_ichrone"]}, {"term": "def", "name": "calc_distance_from_M", "data": "def calc_distance_from_M(M, m=24):\n\t# m - M = 5log(D) - 5\n\tD = 10**((m - M + 5)/5)\n\treturn D*1e-3\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from isochrones.mist.bc import MISTBolometricCorrectionGrid", "from isochrones import get_ichrone"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "test_turbomole_h2o", "data": "def test_turbomole_h2o():\n\tmol = molecule('H2O')\n\n\tparams = {\n\t\t'title': 'water',\n\t\t'task': 'geometry optimization',\n\t\t'use redundant internals': True,\n\t\t'basis set name': 'def2-SV(P)',\n\t\t'total charge': 0,\n\t\t'multiplicity': 1,\n\t\t'use dft': True,\n\t\t'density functional': 'b3-lyp',\n\t\t'use resolution of identity': True,\n\t\t'ri memory': 1000,\n\t\t'force convergence': 0.001,\n\t\t'geometry optimization iterations': 50,\n\t\t'scf iterations': 100\n\t}\n\n\tcalc = Turbomole(**params)\n\tmol.calc = calc\n\tcalc.calculate(mol)\n\tassert calc.converged\n\n\t# use the get_property() method\n\tprint(calc.get_property('energy', mol, False))\n\tprint(calc.get_property('forces', mol, False))\n\tprint(calc.get_property('dipole', mol, False))\n\n\t# use the get_results() method\n\tresults = calc.get_results()\n\tprint(results['molecular orbitals'])\n\n\t# use the __getitem__() method\n\tprint(calc['results']['molecular orbitals'])\n\tprint(calc['results']['geometry optimization history'])\n\n\t# perform a normal mode calculation with the optimized structure\n\n\tparams.update({\n\t\t'task': 'normal mode analysis',\n\t\t'density convergence': 1.0e-7\n\t})\n\n\tcalc = Turbomole(**params)\n\tmol.calc = calc\n\tcalc.calculate(mol)\n\n\tprint(calc['results']['vibrational spectrum'])\n\tprint(calc.todict(skip_default=False))\n", "description": null, "category": "math", "imports": ["from ase.calculators.turbomole import Turbomole", "from ase.build import molecule"]}], [{"term": "def", "name": "MCint_vec", "data": "def MCint_vec(f, a, b, n):\n\tx = random.uniform(a, b, n)\n\ts = sum(f(x))\n\tI = (float(b - a) / n) * s\n\treturn I\n\n", "description": null, "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "__main__", "data": "def __main__():\n\tprint separator\n\n\tmain_list = []\n\t# if file exists\n\ttry:\n\t\tprint u\"\u041f\u043e\u043f\u044b\u0442\u043a\u0430 \u0447\u0442\u0435\u043d\u0438\u044f \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \\\"input.txt\\\"\"\n\t\tinput_f = open(\"input.txt\")\n\t\tfor line in input_f:\n\t\t\tfor word in line.split():\n\t\t\t\tmain_list.append(float(word))\n\t\tprint u\"\u0424\u0430\u0439\u043b \u0441\u0447\u0438\u0442\u0430\u043d.\"\n\t# else generates new list\n\texcept IOError:\n\t\tprint u\"\u0424\u0430\u0439\u043b \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d. \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u0439 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438.\"\n\t\tfor i in xrange(default_count_of_list):\n\t\t\tmain_list.append(abs(gauss(0, 1) * 4))\n\n\tmain_list.sort()\n\tcount = len(main_list)\n\n\t# m - count of intervals\n\t# k - size of each interval\n\tm = 1 + 3.3221 * log(count) / log(10)\n\tm = int(ceil(m))\n\tk = (main_list[-1] - main_list[0]) / float(m)\n\n\t# calculates all needed parameters\n\tintervals_accum = calc_intervals_accum(main_list, m, k)\n\tintervals = calc_intervals(main_list, intervals_accum, m)\n\tx = calc_x(main_list, m, k)\n\taverage = calc_average(x, intervals, count, m)\n\tmedian = calc_median(main_list)\n\tmodes = calc_modes(x, intervals, m)\n\tlin_average = calc_lin_average(x, intervals, average, count, m)\n\tdispersion = calc_dispersion(x, intervals, average, count, m)\n\tsq_average = calc_sq_average(x, intervals, average, count, m)\n\tvariation = calc_variation(x, intervals, average, count, m)\n\tassim = calc_assim(x, intervals, average, count, m)\n\texcess = calc_excess(x, intervals, average, count, m)\n\taverage_rep = calc_average_rep(x, intervals, average, count, m)\n\taverage_norep = calc_average_norep(x, intervals, average, count, m)\n\n\t# prints all information about list\n\tprint u\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u043e\u0432 = \", m\n\tprint u\"\u0420\u0430\u0437\u043c\u0435\u0440 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u043e\u0432 = %.3f\" % k\n\tprint u\"\u041e\u0441\u043d\u043e\u0432\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043f\u0430\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438:\"\n\n\tinterval = main_list[0]\n\tfor i in xrange(m):\n\t\tprint '%2d %7.3f %7.3f - %6.3f %5d %5d %8.2f %8.2f' \\\n\t\t% (i + 1, x[i], interval, interval + k,\\\n\t\tintervals[i], intervals_accum[i], intervals[i] / float(count), \\\n\t\tintervals_accum[i] / float(count))\n\t\tinterval += k\n\n\tprint u\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 = %.3f\" % average\n\tprint u\"\u041c\u0435\u0434\u0438\u0430\u043d\u0430 = %.3f\" % median\n\n\tprint u\"\u041c\u043e\u0434\u044b:\"\n\tfor i in xrange(len(modes)):\n\t\tprint \"%11.3f\" % modes[i]\n\n\tprint u\"\u0420\u0430\u0437\u043c\u0430\u0445 = %.3f\" % (main_list[-1] - main_list[0])\n\tprint u\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u043b\u0438\u043d\u0435\u0439\u043d\u043e\u0435 \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 = %.3f\" % lin_average\n\tprint u\"\u0414\u0438\u0441\u043f\u0435\u0440\u0441\u0438\u044f = %.3f\" % dispersion\n\tprint u\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0438\u0435 = %.3f\" % sq_average\n\tprint u\"\u041a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0432\u0430\u0440\u0438\u0430\u0446\u0438\u0438 = %.3f\" % variation\n\tprint u\"\u041a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0430\u0441\u0438\u043c\u043c\u0435\u0442\u0440\u0438\u0438 = %.3f\" % assim\n\tprint u\"\u0415\u043a\u0441\u0446\u0435\u0441 = %.3f\" % excess\n\tlevel = 7.33\n\tprint u\"\u041e\u0446\u0435\u043d\u043a\u0430 \u0433\u0435\u043d\u0435\u0440\u0430\u043b\u044c\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u043e\u0441\u0442\u0438 P(X>=%.3f) = %.3f\" % (level, calc_freq(main_list, level))\n\tprint u\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u043f\u043e\u0432\u0442\u043e\u0440\u043d\u043e\u0439 \u0432\u044b\u0431\u043e\u0440\u043a\u0438 = %.3f\" % average_rep\n\tprint u\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435 \u0431\u0435\u0437\u043f\u043e\u0432\u0442\u043e\u0440\u043d\u043e\u0439 \u0432\u044b\u0431\u043e\u0440\u043a\u0438 = %.3f\" % average_norep\n\tprint separator\n\tprint\n\n", "description": null, "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_intervals_accum", "data": "def calc_intervals_accum(main_list, m, k):\n\t\"\"\"Accumulative sum of list.\"\"\"\n\n\tcount = len(main_list)\n\tintervals_accum = [0] * m\n\tinterval = main_list[0] + k\n\tfor i in xrange(m):\n\t\tfor j in xrange(count):\n\t\t\tif main_list[j] <= interval:\n\t\t\t\tintervals_accum[i] += 1\n\t\tinterval += k\n\treturn intervals_accum\n\n", "description": "Accumulative sum of list.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_intervals", "data": "def calc_intervals(main_list, intervals_accum, m):\n\t\"\"\"Calculates intervals.\"\"\"\n\n\tintervals = [0] * m\n\tintervals[0] = intervals_accum[0]\n\tfor i in xrange(1, m):\n\t\tintervals[i] = intervals_accum[i] - intervals_accum[i - 1]\n\treturn intervals\n\n", "description": "Calculates intervals.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_x", "data": "def calc_x(main_list, m, k):\n\t\"\"\"Calculates x values.\"\"\"\n\n\tx = [main_list[0]]\n\tfor i in xrange(1, m):\n\t\tx.append(x[i - 1] + k)\n\treturn x\n\n", "description": "Calculates x values.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_average", "data": "def calc_average(x, intervals, count, m):\n\t\"\"\"Calculates average.\"\"\"\n\n\taverage = 0\n\tfor i in xrange(m):\n\t\taverage += x[i] * intervals[i]\n\treturn average / float(count)\n\n", "description": "Calculates average.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_median", "data": "def calc_median(main_list):\n\t\"\"\"Calculates median.\"\"\"\n\n\tcount = len(main_list)\n\tif count % 2 == 0:\n\t\tmedian = (main_list[count / 2] + main_list[count / 2 + 1]) / 2\n\telse:\n\t\tmedian = main_list[count / 2]\n\treturn median\n\n", "description": "Calculates median.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_modes", "data": "def calc_modes(x, intervals, m):\n\t\"\"\"Calculates modas.\"\"\"\n\n\tmodes = []\n\tmaximum = x[0]\n\tfor i in xrange(m):\n\t\tif intervals[i] > maximum:\n\t\t\tmaximum = intervals[i]\n\t\t\tdel modes\n\t\t\tmodes = [x[i]]\n\t\telif intervals[i] == maximum:\n\t\t\tmodes.append(x[i])\n\n\treturn modes\n\n", "description": "Calculates modas.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_lin_average", "data": "def calc_lin_average(x, intervals, average, count, m):\n\t\"\"\"Calculates lin_average.\"\"\"\n\n\tlin_average = 0\n\tfor i in xrange(m):\n\t\tlin_average += abs(x[i] - average) * intervals[i]\n\treturn lin_average / float(count)\n\n", "description": "Calculates lin_average.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_dispersion", "data": "def calc_dispersion(x, intervals, average, count, m):\n\t\"\"\"Calculates dispersion.\"\"\"\n\n\tdispersion = 0\n\tfor i in xrange(m):\n\t\tdispersion += (x[i] - average) ** 2 * intervals[i]\n\treturn dispersion / float(count)\n\n", "description": "Calculates dispersion.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_sq_average", "data": "def calc_sq_average(x, intervals, average, count, m):\n\t\"\"\"Calculates square average.\"\"\"\n\treturn calc_dispersion(x, intervals, average, count, m) ** 0.5\n\n", "description": "Calculates square average.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_variation", "data": "def calc_variation(x, intervals, average, count, m):\n\t\"\"\"Calculates variation.\"\"\"\n\treturn  calc_sq_average(x, intervals, average, count, m) / average\n\n", "description": "Calculates variation.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_assim", "data": "def calc_assim(x, intervals, average, count, m):\n\t\"\"\"Calculates assimetrion.\"\"\"\n\treturn center_moment(x, intervals, average, count, m, 3) / \\\n\tcalc_sq_average(x, intervals, average, count, m) ** 3\n\n", "description": "Calculates assimetrion.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_excess", "data": "def calc_excess(x, intervals, average, count, m):\n\t\"\"\"Calculates excess.\"\"\"\n\treturn center_moment(x, intervals, average, count, m, 4) / \\\n\tcalc_sq_average(x, intervals, average, count, m) ** 4 - 3\n\n", "description": "Calculates excess.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "start_moment", "data": "def start_moment(x, intervals, count, m, k):\n\t\"\"\"Calculate start moment.\"\"\"\n\n\tresult = 0\n\tfor i in xrange(m):\n\t\tresult += x[i] ** k * intervals[i]\n\treturn result / float(count)\n\n", "description": "Calculate start moment.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "center_moment", "data": "def center_moment(x, intervals, average, count, m, k):\n\t\"\"\"Calculates center moment.\"\"\"\n\n\tresult = 0\n\tfor i in xrange(m):\n\t\tresult += (x[i] - average) \\\n\t\t** k * intervals[i]\n\treturn result / float(count)\n\n", "description": "Calculates center moment.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_freq", "data": "def calc_freq(main_list, level):\n\t\t\"\"\"Calculates frequrensy.\"\"\"\n\n\t\tresult = 0.\n\t\tfor i in main_list:\n\t\t\t\tif i >= level:\n\t\t\t\t\t\tresult += 1\n\n\t\treturn result / len(main_list)\n\n", "description": "Calculates frequrensy.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_average_rep", "data": "def calc_average_rep(x, intervals, average, count, m):\n\t\t\"\"\"Calculates average repetition.\"\"\"\n\t\treturn (calc_dispersion(x, intervals, average, count, m) / count) ** 0.5\n\n", "description": "Calculates average repetition.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}, {"term": "def", "name": "calc_average_norep", "data": "def calc_average_norep(x, intervals, average, count, m):\n\t\t\"\"\"Calculates averege without repetition.\"\"\"\n\t\treturn calc_average_rep(x, intervals, average, count, m) * (1. - count / gen_sel)\n", "description": "Calculates averege without repetition.", "category": "math", "imports": ["from random import gauss, random", "from math import log, ceil", "from numpy import *"]}], [{"term": "def", "name": "calc_commission_us", "data": "def calc_commission_us(trade_cnt, price):\n\t\"\"\"\n\t\u7f8e\u80a1\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u6bcf\u80a10.01\uff0c\u6700\u4f4e\u6d88\u8d392.99\n\t:param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n\t:param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u7f8e\u5143\uff09\uff08\u6682\u4e0d\u4f7f\u7528\uff0c\u53ea\u662f\u4fdd\u6301\u63a5\u53e3\u7edf\u4e00\uff09\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t\"\"\"\n\t# \u6bcf\u80a1\u624b\u7eed\u8d390.01\n\tcommission = trade_cnt * 0.01\n\tif commission < 2.99:\n\t\t# \u6700\u4f4e\u6d88\u8d392.99\n\t\tcommission = 2.99\n\treturn commission\n\n", "description": "\n\t\u7f8e\u80a1\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u6bcf\u80a10.01\uff0c\u6700\u4f4e\u6d88\u8d392.99\n\t:param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n\t:param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u7f8e\u5143\uff09\uff08\u6682\u4e0d\u4f7f\u7528\uff0c\u53ea\u662f\u4fdd\u6301\u63a5\u53e3\u7edf\u4e00\uff09\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t", "category": "math", "imports": ["from __future__ import print_function", "from __future__ import absolute_import", "from __future__ import division", "import logging", "from contextlib import contextmanager", "import numpy as np", "import pandas as pd", "from ..MarketBu.ABuSymbolFutures import AbuFuturesCn", "from ..CoreBu.ABuFixes import partial", "from ..CoreBu import ABuEnv", "from ..CoreBu.ABuEnv import EMarketTargetType", "from .ABuOrder import OrderMarket", "from ..MarketBu import ABuMarket"]}, {"term": "def", "name": "calc_commission_cn", "data": "def calc_commission_cn(trade_cnt, price):\n\t\"\"\"\n\ta\u80a1\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u5370\u82b1\u7a0e\uff0b\u4f63\u91d1\uff1a \u5370\u82b1\u7a0e\u4e073\uff0c\u4f63\u91d1\u4e072.5\n\t:param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n\t:param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u4eba\u6c11\u5e01\uff09\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t\"\"\"\n\tcost = trade_cnt * price\n\t# \u5370\u82b1\u7a0e\u4e073\uff0c\n\ttax = cost * 0.0003\n\t# \u4f63\u91d1\u4e072.5\n\tcommission = cost * 0.00025\n\t# \u4f63\u91d1\u6700\u4f4e5\n\tcommission = commission if commission > 5 else 5\n\tcommission += tax\n\treturn commission\n\n", "description": "\n\ta\u80a1\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u5370\u82b1\u7a0e\uff0b\u4f63\u91d1\uff1a \u5370\u82b1\u7a0e\u4e073\uff0c\u4f63\u91d1\u4e072.5\n\t:param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n\t:param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u4eba\u6c11\u5e01\uff09\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t", "category": "math", "imports": ["from __future__ import print_function", "from __future__ import absolute_import", "from __future__ import division", "import logging", "from contextlib import contextmanager", "import numpy as np", "import pandas as pd", "from ..MarketBu.ABuSymbolFutures import AbuFuturesCn", "from ..CoreBu.ABuFixes import partial", "from ..CoreBu import ABuEnv", "from ..CoreBu.ABuEnv import EMarketTargetType", "from .ABuOrder import OrderMarket", "from ..MarketBu import ABuMarket"]}, {"term": "def", "name": "calc_commission_hk", "data": "def calc_commission_hk(trade_cnt, price):\n\t\"\"\"\n\th\u80a1\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u5370\u82b1\u7a0e\uff0b\u4f63\u91d1\uff1a \u4f63\u91d1\u5343\u5206\u4e4b\u4e8c\uff0c\u5370\u82b1\u7a0e\u5343\u5206\u4e4b\u4e00\n\t:param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n\t:param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u4eba\u6c11\u5e01\uff09\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t\"\"\"\n\tcost = trade_cnt * price\n\t# \u5370\u82b1\u7a0e\u5343\u5206\u4e4b\u4e00\n\ttax = cost * 0.001\n\t# \u4f63\u91d1\u5343\u5206\u4e4b\u4e8c\uff0c\n\tcommission = cost * 0.002\n\tcommission += tax\n\treturn commission\n\n", "description": "\n\th\u80a1\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u5370\u82b1\u7a0e\uff0b\u4f63\u91d1\uff1a \u4f63\u91d1\u5343\u5206\u4e4b\u4e8c\uff0c\u5370\u82b1\u7a0e\u5343\u5206\u4e4b\u4e00\n\t:param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n\t:param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u4eba\u6c11\u5e01\uff09\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t", "category": "math", "imports": ["from __future__ import print_function", "from __future__ import absolute_import", "from __future__ import division", "import logging", "from contextlib import contextmanager", "import numpy as np", "import pandas as pd", "from ..MarketBu.ABuSymbolFutures import AbuFuturesCn", "from ..CoreBu.ABuFixes import partial", "from ..CoreBu import ABuEnv", "from ..CoreBu.ABuEnv import EMarketTargetType", "from .ABuOrder import OrderMarket", "from ..MarketBu import ABuMarket"]}, {"term": "def", "name": "calc_commission_tc", "data": "def calc_commission_tc(trade_cnt, price):\n\t\"\"\"\n\t\u5e01\u7c7b\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u53ea\u7b80\u5355\u8ba1\u7b97\u624b\u7eed\u8d39\uff0c\u53cc\u5411\u90fd\u4f7f\u7528\u6d41\u901a\u5e01\u8ba1\u7b97\u624b\u7eed\u8d39\uff0c\u4e0d\u6d89\u53ca\u5356\u51fa\u4f7f\u7528\u5e01\u7c7b\u7684\u624b\u7eed\u8ba1\u7b97\uff0c\n\t\u5982\u9700\u8981\u66f4\u7cbe\u786e\u8ba1\u7b97\uff0c\u8bf7\u4f7f\u7528\u81ea\u5b9a\u4e49\u8ba1\u7b97\u8d39\u7387\uff0c\u5373\u5728AbuCommission\u521d\u59cb\u5316\u4e2d\u81ea\u5b9a\u4e49\u8ba1\u7b97\u624b\u7eed\u8d39\u7684\u65b9\u6cd5\n\t:param trade_cnt: \u4ea4\u6613\u7684\u5e01\u4e2a\u6570\uff08int\uff09\n\t:param price: \u6bcf\u5e01\u7684\u4ef7\u683c\uff08\u4eba\u6c11\u5e01\uff09\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t\"\"\"\n\tcost = trade_cnt * price\n\t# \u53cc\u5411\u90fd\u4f7f\u7528\u6d41\u901a\u5e01\u8ba1\u7b97\u624b\u7eed\u8d39\uff0c\u5343\u5206\u4e4b2\n\tcommission = cost * 0.002\n\treturn commission\n\n", "description": "\n\t\u5e01\u7c7b\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u53ea\u7b80\u5355\u8ba1\u7b97\u624b\u7eed\u8d39\uff0c\u53cc\u5411\u90fd\u4f7f\u7528\u6d41\u901a\u5e01\u8ba1\u7b97\u624b\u7eed\u8d39\uff0c\u4e0d\u6d89\u53ca\u5356\u51fa\u4f7f\u7528\u5e01\u7c7b\u7684\u624b\u7eed\u8ba1\u7b97\uff0c\n\t\u5982\u9700\u8981\u66f4\u7cbe\u786e\u8ba1\u7b97\uff0c\u8bf7\u4f7f\u7528\u81ea\u5b9a\u4e49\u8ba1\u7b97\u8d39\u7387\uff0c\u5373\u5728AbuCommission\u521d\u59cb\u5316\u4e2d\u81ea\u5b9a\u4e49\u8ba1\u7b97\u624b\u7eed\u8d39\u7684\u65b9\u6cd5\n\t:param trade_cnt: \u4ea4\u6613\u7684\u5e01\u4e2a\u6570\uff08int\uff09\n\t:param price: \u6bcf\u5e01\u7684\u4ef7\u683c\uff08\u4eba\u6c11\u5e01\uff09\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t", "category": "math", "imports": ["from __future__ import print_function", "from __future__ import absolute_import", "from __future__ import division", "import logging", "from contextlib import contextmanager", "import numpy as np", "import pandas as pd", "from ..MarketBu.ABuSymbolFutures import AbuFuturesCn", "from ..CoreBu.ABuFixes import partial", "from ..CoreBu import ABuEnv", "from ..CoreBu.ABuEnv import EMarketTargetType", "from .ABuOrder import OrderMarket", "from ..MarketBu import ABuMarket"]}, {"term": "def", "name": "calc_commission_futures_cn", "data": "def calc_commission_futures_cn(trade_cnt, price, symbol_name):\n\t\"\"\"\n\t\u671f\u8d27\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u9996\u5148\u67e5\u8be2\u5bf9\u5e94\u5546\u54c1\u5355\u4f4d\u4ea4\u6613\u91cf\uff08\u6bcf\u624b\u5355\u4f4d\u6570\u91cf\uff09\uff0c\u4ee5\u53ca\u6bcf\u624b\u624b\u7eed\u8d39\uff0c\u518d\u8ba1\u7b97\u5bf9\u5e94\u624b\u7eed\u8d39\n\t:param trade_cnt: \u4ea4\u6613\u7684\u5355\u4f4d\u6570\u91cf\uff08int\uff09\n\t:param price: \u4e70\u5165\u7684\u4ef7\u683c\uff08\u6682\u4e0d\u4f7f\u7528\uff0c\u53ea\u662f\u4fdd\u6301\u63a5\u53e3\u7edf\u4e00\uff09\n\t:param symbol_name: \u5546\u54c1\u67e5\u8be2symbol\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t\"\"\"\n\tmin_unit = 10\n\tcommission_unit = 10\n\t# \u67e5\u8be2\u5546\u54c1\u671f\u8d27\u7684\u5bf9\u5e94df\n\tq_df = AbuFuturesCn().query_symbol(symbol_name)\n\tif q_df is not None:\n\t\t# \u6bcf\u624b\u5355\u4f4d\u6570\u91cf\n\t\tmin_unit = q_df.min_unit.values[0]\n\t\t# \u6bcf\u624b\u4ea4\u6613\u624b\u7eed\u8d39\n\t\tcommission_unit = q_df.commission.values[0]\n\tcommission = trade_cnt / min_unit * commission_unit\n\treturn commission\n\n", "description": "\n\t\u671f\u8d27\u8ba1\u7b97\u4ea4\u6613\u8d39\u7528\uff1a\u9996\u5148\u67e5\u8be2\u5bf9\u5e94\u5546\u54c1\u5355\u4f4d\u4ea4\u6613\u91cf\uff08\u6bcf\u624b\u5355\u4f4d\u6570\u91cf\uff09\uff0c\u4ee5\u53ca\u6bcf\u624b\u624b\u7eed\u8d39\uff0c\u518d\u8ba1\u7b97\u5bf9\u5e94\u624b\u7eed\u8d39\n\t:param trade_cnt: \u4ea4\u6613\u7684\u5355\u4f4d\u6570\u91cf\uff08int\uff09\n\t:param price: \u4e70\u5165\u7684\u4ef7\u683c\uff08\u6682\u4e0d\u4f7f\u7528\uff0c\u53ea\u662f\u4fdd\u6301\u63a5\u53e3\u7edf\u4e00\uff09\n\t:param symbol_name: \u5546\u54c1\u67e5\u8be2symbol\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t", "category": "math", "imports": ["from __future__ import print_function", "from __future__ import absolute_import", "from __future__ import division", "import logging", "from contextlib import contextmanager", "import numpy as np", "import pandas as pd", "from ..MarketBu.ABuSymbolFutures import AbuFuturesCn", "from ..CoreBu.ABuFixes import partial", "from ..CoreBu import ABuEnv", "from ..CoreBu.ABuEnv import EMarketTargetType", "from .ABuOrder import OrderMarket", "from ..MarketBu import ABuMarket"]}, {"term": "def", "name": "calc_options_us", "data": "def calc_options_us(trade_cnt, price):\n\t\"\"\"\n\t\u7f8e\u80a1\u671f\u6743\uff1a\u5dee\u522b\u5f88\u5927\uff0c\u6700\u597d\u5916\u90e8\u81ea\u5b9a\u4e49\u81ea\u5df1\u7684\u8ba1\u7b97\u65b9\u6cd5\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u6309\u71670.0035\u8ba1\u7b97\n\t:param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n\t:param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u7f8e\u5143\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t\"\"\"\n\tcost = trade_cnt * price\n\t# \u7f8e\u80a1\u671f\u6743\u5404\u4e2a\u5238\u5546\u4ee5\u53ca\u4e2a\u4eba\u65b9\u5f0f\u5dee\u522b\u5f88\u5927\uff0c\u6700\u597d\u5916\u90e8\u81ea\u5b9a\u4e49\u8ba1\u7b97\u65b9\u6cd5\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u6309\u71670.0035\u8ba1\u7b97\n\tcommission = cost * 0.0035\n\treturn commission\n\n", "description": "\n\t\u7f8e\u80a1\u671f\u6743\uff1a\u5dee\u522b\u5f88\u5927\uff0c\u6700\u597d\u5916\u90e8\u81ea\u5b9a\u4e49\u81ea\u5df1\u7684\u8ba1\u7b97\u65b9\u6cd5\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u6309\u71670.0035\u8ba1\u7b97\n\t:param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n\t:param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u7f8e\u5143\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t", "category": "math", "imports": ["from __future__ import print_function", "from __future__ import absolute_import", "from __future__ import division", "import logging", "from contextlib import contextmanager", "import numpy as np", "import pandas as pd", "from ..MarketBu.ABuSymbolFutures import AbuFuturesCn", "from ..CoreBu.ABuFixes import partial", "from ..CoreBu import ABuEnv", "from ..CoreBu.ABuEnv import EMarketTargetType", "from .ABuOrder import OrderMarket", "from ..MarketBu import ABuMarket"]}, {"term": "def", "name": "calc_commission_futures_global", "data": "def calc_commission_futures_global(trade_cnt, price):\n\t\"\"\"\n\t\u56fd\u9645\u671f\u8d27\uff1a\u5dee\u522b\u5f88\u5927\uff0c\u6700\u597d\u5916\u90e8\u81ea\u5b9a\u4e49\u81ea\u5df1\u7684\u8ba1\u7b97\u65b9\u6cd5\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u6309\u71670.002\u8ba1\u7b97\n\t:param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n\t:param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u7f8e\u5143\uff09\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t\"\"\"\n\tcost = trade_cnt * price\n\t# \u56fd\u9645\u671f\u8d27\u5404\u4e2a\u5238\u5546\u4ee5\u53ca\u4ee3\u7406\u65b9\u5f0f\u5dee\u522b\u5f88\u5927\uff0c\u6700\u597d\u5916\u90e8\u81ea\u5b9a\u4e49\u8ba1\u7b97\u65b9\u6cd5\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u6309\u71670.002\u8ba1\u7b97\n\tcommission = cost * 0.002\n\treturn commission\n\n", "description": "\n\t\u56fd\u9645\u671f\u8d27\uff1a\u5dee\u522b\u5f88\u5927\uff0c\u6700\u597d\u5916\u90e8\u81ea\u5b9a\u4e49\u81ea\u5df1\u7684\u8ba1\u7b97\u65b9\u6cd5\uff0c\u8fd9\u91cc\u53ea\u7b80\u5355\u6309\u71670.002\u8ba1\u7b97\n\t:param trade_cnt: \u4ea4\u6613\u7684\u80a1\u6570\uff08int\uff09\n\t:param price: \u6bcf\u80a1\u7684\u4ef7\u683c\uff08\u7f8e\u5143\uff09\n\t:return: \u8ba1\u7b97\u7ed3\u679c\u624b\u7eed\u8d39\n\t", "category": "math", "imports": ["from __future__ import print_function", "from __future__ import absolute_import", "from __future__ import division", "import logging", "from contextlib import contextmanager", "import numpy as np", "import pandas as pd", "from ..MarketBu.ABuSymbolFutures import AbuFuturesCn", "from ..CoreBu.ABuFixes import partial", "from ..CoreBu import ABuEnv", "from ..CoreBu.ABuEnv import EMarketTargetType", "from .ABuOrder import OrderMarket", "from ..MarketBu import ABuMarket"]}, {"term": "class", "name": "AbuCommission", "data": "class AbuCommission(object):\n\t\"\"\"\u4ea4\u6613\u624b\u7eed\u8d39\u8ba1\u7b97\uff0c\u8bb0\u5f55\uff0c\u5206\u6790\u7c7b\uff0c\u5728AbuCapital\u4e2d\u5b9e\u4f8b\u5316\"\"\"\n\n\tdef __init__(self, commission_dict):\n\t\t\"\"\"\n\t\t:param commission_dict: \u4ee3\u8868\u7528\u6237\u81ea\u5b9a\u4e49\u624b\u7eed\u8d39\u8ba1\u7b97dict\u5bf9\u8c61\uff0c\n\t\t\t\t\t\t\t\tkey\uff1abuy_commission_func\uff0c \u4ee3\u8868\u7528\u6237\u81ea\u5b9a\u4e49\u4e70\u5165\u8ba1\u7b97\u8d39\u7528\u65b9\u6cd5\n\t\t\t\t\t\t\t\tkey\uff1asell_commission_func\uff0c\u4ee3\u8868\u7528\u6237\u81ea\u5b9a\u4e49\u5356\u51fa\u8ba1\u7b97\u8d39\u7528\u65b9\u6cd5\n\t\t\"\"\"\n\t\tself.commission_dict = commission_dict\n\t\t# \u5bf9\u8c61\u5185\u90e8\u8bb0\u5f55\u4ea4\u6613\u7684pd.DataFrame\u5bf9\u8c61\uff0c\u5217\u8bbe\u5b9a\n\t\tself.df_columns = ['type', 'date', 'symbol', 'commission']\n\t\t# \u6784\u5efa\u624b\u7eed\u8d39\u8bb0\u5f55pd.DataFrame\u5bf9\u8c61commission_df\n\t\tself.commission_df = pd.DataFrame(columns=self.df_columns)\n\n\tdef __str__(self):\n\t\t\"\"\"\u6253\u5370\u5bf9\u8c61\u663e\u793a\uff1a\u5982\u679c\u6709\u624b\u7eed\u8d39\u8bb0\u5f55\uff0c\u6253\u5370\u8bb0\u5f55df\uff0c\u5426\u5219\u6253\u5370commission_df.info\"\"\"\n\t\tif self.commission_df.shape[0] == 0:\n\t\t\treturn str(self.commission_df.info())\n\t\treturn str(self.commission_df)\n\n\t__repr__ = __str__\n\n\t# noinspection PyMethodMayBeStatic\n\tdef _commission_enter(self, a_order):\n\t\t\"\"\"\n\t\t\u901a\u8fc7a_order\u5bf9\u8c61\u8fdb\u884c\u4ea4\u6613\u5bf9\u8c61\u5e02\u573a\u7c7b\u578b\u8f6c\u6362\uff0c\u5206\u914d\u5bf9\u5e94\u624b\u7eed\u8d39\u8ba1\u7b97\u65b9\u6cd5\n\t\t:param a_order: \u4ea4\u6613\u5355\u5bf9\u8c61AbuOrder\u5b9e\u4f8b\n\t\t:return:\n\t\t\"\"\"\n\n\t\t# \u5982\u679c\u4f7f\u7528env\u4e2d\u7edf\u4e00\u8bbe\u7f6e\uff0c\u5373\u4e0d\u9700\u8981\u901a\u8fc7OrderMarket\u5bf9\u5355\u5b50\u67e5\u8be2\u5e02\u573a\uff0c\u63d0\u9ad8\u8fd0\u884c\u6548\u7387\uff0c\u8be6ABuMarket\n\t\tmarket = ABuEnv.g_market_target if ABuMarket.g_use_env_market_set \\\n\t\t\telse OrderMarket(a_order).symbol_market\n\t\t# \u4e0d\u540c\u7684\u5e02\u573a\u4e0d\u540c\u7684\u8ba1\u7b97\u624b\u7eed\u8d39\u65b9\u6cd5\n\t\tif market == EMarketTargetType.E_MARKET_TARGET_US:\n\t\t\t# \u7f8e\u80a1\n\t\t\tcalc_commission_func = calc_commission_us\n\t\telif market == EMarketTargetType.E_MARKET_TARGET_CN:\n\t\t\t# a\u80a1\n\t\t\tcalc_commission_func = calc_commission_cn\n\t\telif market == EMarketTargetType.E_MARKET_TARGET_HK:\n\t\t\t# h\u80a1\n\t\t\tcalc_commission_func = calc_commission_hk\n\t\telif market == EMarketTargetType.E_MARKET_TARGET_TC:\n\t\t\t# \u5e01\u7c7b\n\t\t\tcalc_commission_func = calc_commission_tc\n\t\telif market == EMarketTargetType.E_MARKET_TARGET_FUTURES_CN:\n\t\t\t# \u671f\u8d27\n\t\t\tcalc_commission_func = partial(calc_commission_futures_cn, symbol_name=a_order.buy_symbol)\n\t\telif market == EMarketTargetType.E_MARKET_TARGET_OPTIONS_US:\n\t\t\t# \u7f8e\u80a1\u671f\u6743\n\t\t\tcalc_commission_func = calc_options_us\n\t\telif market == EMarketTargetType.E_MARKET_TARGET_FUTURES_GLOBAL:\n\t\t\t# \u56fd\u9645\u671f\u8d27\n\t\t\tcalc_commission_func = calc_commission_futures_global\n\t\telse:\n\t\t\traise TypeError('buy_stock market error!!!')\n\t\treturn calc_commission_func\n\n\t@contextmanager\n\tdef buy_commission_func(self, a_order):\n\t\t\"\"\"\n\t\t\u5916\u90e8\u7528with as \u8fd4\u56de\u7684list\u4e2d\u9700\u8981\u52a0\u5165\u8ba1\u7b97\u7684\u6700\u7ec8\u7ed3\u679c\uff0c\u5426\u5219\u4e0d\u8fdb\u884c\u5185\u90e8\u4ea4\u6613\u8d39\u7528\u8bb0\u5f55\n\t\t:param a_order: \u4e70\u5355\u5bf9\u8c61AbuOrder\u5b9e\u4f8b\n\t\t\"\"\"\n\t\tif self.commission_dict is not None and 'buy_commission_func' in self.commission_dict:\n\t\t\t# \u5982\u679c\u6709\u81ea\u5b9a\u4e49\u8ba1\u7b97\u4ea4\u6613\u8d39\u7684\u65b9\u6cd5\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684\n\t\t\tbuy_func = self.commission_dict['buy_commission_func']\n\t\telse:\n\t\t\tbuy_func = self._commission_enter(a_order)\n\n\t\t# \u4f7f\u7528list\u56e0\u4e3a\u662f\u53ef\u53d8\u7c7b\u578b\uff0c\u9700\u8981\u5c06\u5916\u9762\u7684\u7ed3\u679c\u5e26\u56de\u6765\n\t\tcommission_list = list()\n\t\tyield buy_func, commission_list\n\n\t\t# \u5982\u679c\u6709\u5916\u90e8\u6709append\uff0c\u8bf4\u660e\u9700\u8981\u8bb0\u5f55\u624b\u7eed\u8d39\uff0c\u4e14\u6267\u884c\u8ba1\u7b97\u6210\u529f\n\t\tif len(commission_list) == 1:\n\t\t\tcommission = commission_list[0]\n\t\t\t# \u5c06\u4e70\u5355\u5bf9\u8c61AbuOrder\u5b9e\u4f8b\u4e2d\u7684\u6570\u636e\u8f6c\u6362\u6210\u4ea4\u6613\u8bb0\u5f55\u9700\u8981\u7684np.array\u5bf9\u8c61\n\t\t\trecord = np.array(['buy', a_order.buy_date, a_order.buy_symbol, commission]).reshape(1, 4)\n\t\t\trecord_df = pd.DataFrame(record, columns=self.df_columns)\n\t\t\tself.commission_df = self.commission_df.append(record_df)\n\t\telse:\n\t\t\tlogging.info('buy_commission_func calc error')\n\n\t@contextmanager\n\tdef sell_commission_func(self, a_order):\n\t\t\"\"\"\n\t\t\u5916\u90e8\u7528with as \u8fd4\u56de\u7684list\u4e2d\u9700\u8981\u52a0\u5165\u8ba1\u7b97\u7684\u6700\u7ec8\u7ed3\u679c\uff0c\u5426\u5219\u4e0d\u8fdb\u884c\u5185\u90e8\u4ea4\u6613\u8d39\u7528\u8bb0\u5f55\n\t\t:param a_order: \u5356\u5355\u5bf9\u8c61AbuOrder\u5b9e\u4f8b\n\t\t\"\"\"\n\t\tif self.commission_dict is not None and 'sell_commission_func' in self.commission_dict:\n\t\t\t# \u5982\u679c\u6709\u81ea\u5b9a\u4e49\u8ba1\u7b97\u4ea4\u6613\u8d39\u7684\u65b9\u6cd5\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684\n\t\t\tsell_func = self.commission_dict['sell_commission_func']\n\t\telse:\n\t\t\tsell_func = self._commission_enter(a_order)\n\t\t# \u4f7f\u7528list\u56e0\u4e3a\u662f\u53ef\u53d8\u7c7b\u578b\uff0c\u9700\u8981\u5c06\u5916\u9762\u7684\u7ed3\u679c\u5e26\u56de\u6765\n\t\tcommission_list = list()\n\n\t\tyield sell_func, commission_list\n\n\t\tif len(commission_list) == 1:\n\t\t\tcommission = commission_list[0]\n\t\t\t# \u5c06\u5356\u5355\u5bf9\u8c61AbuOrder\u5b9e\u4f8b\u4e2d\u7684\u6570\u636e\u8f6c\u6362\u6210\u4ea4\u6613\u8bb0\u5f55\u9700\u8981\u7684np.array\u5bf9\u8c61\n\t\t\trecord = np.array(['sell', a_order.sell_date, a_order.buy_symbol, commission]).reshape(1, 4)\n\t\t\trecord_df = pd.DataFrame(record, columns=self.df_columns)\n\t\t\tself.commission_df = self.commission_df.append(record_df)\n\t\telse:\n\t\t\tlogging.info('sell_commission_func calc error!!!')\n", "description": "\u4ea4\u6613\u624b\u7eed\u8d39\u8ba1\u7b97\uff0c\u8bb0\u5f55\uff0c\u5206\u6790\u7c7b\uff0c\u5728AbuCapital\u4e2d\u5b9e\u4f8b\u5316", "category": "math", "imports": ["from __future__ import print_function", "from __future__ import absolute_import", "from __future__ import division", "import logging", "from contextlib import contextmanager", "import numpy as np", "import pandas as pd", "from ..MarketBu.ABuSymbolFutures import AbuFuturesCn", "from ..CoreBu.ABuFixes import partial", "from ..CoreBu import ABuEnv", "from ..CoreBu.ABuEnv import EMarketTargetType", "from .ABuOrder import OrderMarket", "from ..MarketBu import ABuMarket"]}], [{"term": "def", "name": "preprocessData", "data": "def preprocessData(df, end, shuffle1): \n\tif (1 == shuffle1):\n\t\tdf = shuffle(df)  \n\tdf = df.reset_index(drop=True)\n\tdf = df[:end]\t\n\tdf_reduced, mol_list, legends = get_molecules(df)\n\tprint(\"Size of original dataframe =\",len(df))\n\tprint(\"Size of reduced dataframe =\", len(df_reduced), \"(excluding the cases that could not be processed)\")   \n\twith open(\"../data/mol_list\", \"wb\") as fp:\n\t\tpickle.dump(mol_list, fp)\n\treturn(df_reduced, mol_list)\n", "description": null, "category": "math", "imports": ["import pandas as pd", "import numpy as np", "import subprocess", "from rdkit import Chem", "from rdkit.Chem import Descriptors, rdMolDescriptors", "import os", "from rdkit.Chem import ChemicalFeatures, rdMolChemicalFeatures", "from rdkit.Chem.rdMolChemicalFeatures import MolChemicalFeatureFactory", "from rdkit import RDConfig", "from rdkit.Chem.AllChem import EmbedMolecule", "from sklearn.utils import shuffle", "import pickle ", "import subprocess", "import gnn_tools as gnn", "import time", "import re"]}, {"term": "def", "name": "get_molecules", "data": "def get_molecules(dataframe):\n\tdataframe_reduced = dataframe\n\tdataframe_rejected = pd.DataFrame()\n\tnbrStruc = dataframe.shape[0]\n\tmol_list = []\n\tlegends = []\n\tfor i in range(nbrStruc):\n\t\trefcode = dataframe.at[i,\"refcode_csd\"]\n\t\t#print(refcode)\t   \n\t\tsmile = dataframe.at[i,\"smiles\"]\n\t\t#print(i, refcode, \"smile =\", smile)\n\t\t# NOW TRY TO CONVERT SMILE INTO MOLECULE\n\t\t# THERE COULD BE SOME PROBLEMS DOING THIS CONVERSION\n\t\t# WE NEED TO HANDLE THE EXCEPTIONS\n\n\t\tif smile is None:\n\t\t\tprint(\"\\n\\n\", i, refcode)\n\t\t\tdataframe_rejected = pd.concat([dataframe_rejected, dataframe_reduced[dataframe_reduced.refcode_csd == refcode]])\n\t\t\tdataframe_reduced = dataframe_reduced[dataframe_reduced.refcode_csd != refcode]\n\t\t\tdataframe_reduced = dataframe_reduced.reset_index(drop=True)\n\t\t\tprint(\"Smile code is not provided. Droping it from the dataframe\")\n\t\telse:\n\t\t\tmol = Chem.MolFromSmiles(smile)\n\t\t\n\t\t\tif mol is None:\n\t\t\t\tprint(\"\\n\\n\", i, refcode)\n\t\t\t\tdataframe_rejected = pd.concat([dataframe_rejected, dataframe_reduced[dataframe_reduced.refcode_csd == refcode]])\n\t\t\t\tdataframe_reduced = dataframe_reduced[dataframe_reduced.refcode_csd != refcode]\n\t\t\t\tdataframe_reduced = dataframe_reduced.reset_index(drop=True)\n\t\t\t\tprint(\"problem converting molecule. Droping it from the dataframe\")\n\n\t\t\telse:\t\n\t\t\t\tlegends.append(refcode)\n\t\t\t\t#mol = Chem.AddHs(mol)\n\t\t\t\tmol_list.append(mol)\n \n\tdataframe_rejected.to_csv(\"../data/df_rejected.csv\")\t  \n\t#Draw.MolsToGridImage(mol_list, molsPerRow=4, legends = legends)\n\treturn(dataframe_reduced, mol_list, legends)\n", "description": null, "category": "math", "imports": ["import pandas as pd", "import numpy as np", "import subprocess", "from rdkit import Chem", "from rdkit.Chem import Descriptors, rdMolDescriptors", "import os", "from rdkit.Chem import ChemicalFeatures, rdMolChemicalFeatures", "from rdkit.Chem.rdMolChemicalFeatures import MolChemicalFeatureFactory", "from rdkit import RDConfig", "from rdkit.Chem.AllChem import EmbedMolecule", "from sklearn.utils import shuffle", "import pickle ", "import subprocess", "import gnn_tools as gnn", "import time", "import re"]}, {"term": "def", "name": "get_molecular_features", "data": "def get_molecular_features(dataframe, mol_list):\n\tdf = dataframe\n\tfor i in range(len(mol_list)):\n\t\tprint(\"Getting molecular features for molecule: \", i)\n\t\tmol = mol_list[i]\n\t\tnatoms = mol.GetNumAtoms()\n\t\tnbonds = mol.GetNumBonds()\n\t\tmw = Descriptors.ExactMolWt(mol)\n\t\tdf.at[i,\"NbrAtoms\"] = natoms\n\t\tdf.at[i,\"NbrBonds\"] = nbonds\n\t\tdf.at[i,\"mw\"] = mw\n\t\tdf.at[i,'HeavyAtomMolWt'] = Chem.Descriptors.HeavyAtomMolWt(mol)\n\t\tdf.at[i,'NumValenceElectrons'] = Chem.Descriptors.NumValenceElectrons(mol)\n\t\t''' # These four descriptors are producing the value of infinity for refcode_csd = YOLJUF (CCOP(=O)(Cc1ccc(cc1)NC(=S)NP(OC(C)C)(OC(C)C)[S])OCC\\t\\n)\n\t\tdf.at[i,'MaxAbsPartialCharge'] = Chem.Descriptors.MaxAbsPartialCharge(mol)\n\t\tdf.at[i,'MaxPartialCharge'] = Chem.Descriptors.MaxPartialCharge(mol)\n\t\tdf.at[i,'MinAbsPartialCharge'] = Chem.Descriptors.MinAbsPartialCharge(mol)\n\t\tdf.at[i,'MinPartialCharge'] = Chem.Descriptors.MinPartialCharge(mol)\n\t\t'''\n\t\tdf.at[i,'FpDensityMorgan1'] = Chem.Descriptors.FpDensityMorgan1(mol)\n\t\tdf.at[i,'FpDensityMorgan2'] = Chem.Descriptors.FpDensityMorgan2(mol)\n\t\tdf.at[i,'FpDensityMorgan3'] = Chem.Descriptors.FpDensityMorgan3(mol)\n\t\t\n\t\t#print(natoms, nbonds)\n\t\t\n\t\t# Now get some specific features\n\t\tfdefName = os.path.join(RDConfig.RDDataDir,'BaseFeatures.fdef')\n\t\tfactory = ChemicalFeatures.BuildFeatureFactory(fdefName)\n\t\tfeats = factory.GetFeaturesForMol(mol)\n\t\t#df[\"Acceptor\"] = 0\n\t\t#df[\"Aromatic\"] = 0\n\t\t#df[\"Hydrophobe\"] = 0\n\t\tnbrAcceptor = 0\n\t\tnbrDonor = 0\n\t\tnbrHydrophobe = 0\n\t\tnbrLumpedHydrophobe = 0\n\t\tnbrPosIonizable = 0\n\t\tnbrNegIonizable = 0\n\t\tfor j in range(len(feats)):\n\t\t\t#print(feats[j].GetFamily(), feats[j].GetType())\n\t\t\tif ('Acceptor' == (feats[j].GetFamily())):\n\t\t\t\tnbrAcceptor = nbrAcceptor + 1\n\t\t\telif ('Donor' == (feats[j].GetFamily())):\n\t\t\t\tnbrDonor = nbrDonor + 1\n\t\t\telif ('Hydrophobe' == (feats[j].GetFamily())):\n\t\t\t\tnbrHydrophobe = nbrHydrophobe + 1\n\t\t\telif ('LumpedHydrophobe' == (feats[j].GetFamily())):\n\t\t\t\tnbrLumpedHydrophobe = nbrLumpedHydrophobe + 1\n\t\t\telif ('PosIonizable' == (feats[j].GetFamily())):\n\t\t\t\tnbrPosIonizable = nbrPosIonizable + 1\n\t\t\telif ('NegIonizable' == (feats[j].GetFamily())):\n\t\t\t\tnbrNegIonizable = nbrNegIonizable + 1\t\t\t\t\n\t\t\telse:\n\t\t\t\tpass#print(feats[j].GetFamily())\n\t\t\t\t\t\t\n\t\tdf.at[i,\"Acceptor\"] = nbrAcceptor\n\t\tdf.at[i,\"Donor\"] = nbrDonor\n\t\tdf.at[i,\"Hydrophobe\"] = nbrHydrophobe\n\t\tdf.at[i,\"LumpedHydrophobe\"] = nbrLumpedHydrophobe\n\t\tdf.at[i,\"PosIonizable\"] = nbrPosIonizable\n\t\tdf.at[i,\"NegIonizable\"] = nbrNegIonizable\n\t\t\n\t\t# We can also get some more molecular features using rdMolDescriptors\n\t\t\n\t\tdf.at[i,\"NumRotatableBonds\"] = rdMolDescriptors.CalcNumRotatableBonds(mol)\n\t\tdf.at[i,\"CalcChi0n\"] = rdMolDescriptors.CalcChi0n(mol)\n\t\tdf.at[i,\"CalcChi0v\"] = rdMolDescriptors.CalcChi0v(mol)\n\t\tdf.at[i,\"CalcChi1n\"] = rdMolDescriptors.CalcChi1n(mol)\n\t\tdf.at[i,\"CalcChi1v\"] = rdMolDescriptors.CalcChi1v(mol)\n\t\tdf.at[i,\"CalcChi2n\"] = rdMolDescriptors.CalcChi2n(mol)\n\t\tdf.at[i,\"CalcChi2v\"] = rdMolDescriptors.CalcChi2v(mol)\n\t\tdf.at[i,\"CalcChi3n\"] = rdMolDescriptors.CalcChi3n(mol)\n\t\t#df.at[i,\"CalcChi3v\"] = rdMolDescriptors.CalcChi3v(mol)\n\t\tdf.at[i,\"CalcChi4n\"] = rdMolDescriptors.CalcChi4n(mol)\n\t\tdf.at[i,\"CalcChi4v\"] = rdMolDescriptors.CalcChi4v(mol)\n\t\tdf.at[i,\"CalcFractionCSP3\"] = rdMolDescriptors.CalcFractionCSP3(mol)\n\t\tdf.at[i,\"CalcHallKierAlpha\"] = rdMolDescriptors.CalcHallKierAlpha(mol)\n\t\tdf.at[i,\"CalcKappa1\"] = rdMolDescriptors.CalcKappa1(mol)\n\t\tdf.at[i,\"CalcKappa2\"] = rdMolDescriptors.CalcKappa2(mol)\n\t\t#df.at[i,\"CalcKappa3\"] = rdMolDescriptors.CalcKappa3(mol)\n\t\tdf.at[i,\"CalcLabuteASA\"] = rdMolDescriptors.CalcLabuteASA(mol)\n\t\tdf.at[i,\"CalcNumAliphaticCarbocycles\"] = rdMolDescriptors.CalcNumAliphaticCarbocycles(mol)\n\t\tdf.at[i,\"CalcNumAliphaticHeterocycles\"] = rdMolDescriptors.CalcNumAliphaticHeterocycles(mol)\n\t\tdf.at[i,\"CalcNumAliphaticRings\"] = rdMolDescriptors.CalcNumAliphaticRings(mol)\n\t\tdf.at[i,\"CalcNumAmideBonds\"] = rdMolDescriptors.CalcNumAmideBonds(mol)\n\t\tdf.at[i,\"CalcNumAromaticCarbocycles\"] = rdMolDescriptors.CalcNumAromaticCarbocycles(mol)\n\t\tdf.at[i,\"CalcNumAromaticHeterocycles\"] = rdMolDescriptors.CalcNumAromaticHeterocycles(mol)\n\t\tdf.at[i,\"CalcNumAromaticRings\"] = rdMolDescriptors.CalcNumAromaticRings(mol)\n\t\tdf.at[i,\"CalcNumBridgeheadAtoms\"] = rdMolDescriptors.CalcNumBridgeheadAtoms(mol)\n\t\tdf.at[i,\"CalcNumHBA\"] = rdMolDescriptors.CalcNumHBA(mol)\n\t\tdf.at[i,\"CalcNumHBD\"] = rdMolDescriptors.CalcNumHBD(mol)\n\t\tdf.at[i,\"CalcNumHeteroatoms\"] = rdMolDescriptors.CalcNumHeteroatoms(mol)\n\t\tdf.at[i,\"CalcNumHeterocycles\"] = rdMolDescriptors.CalcNumHeterocycles(mol)\n\t\tdf.at[i,\"CalcNumLipinskiHBA\"] = rdMolDescriptors.CalcNumLipinskiHBA(mol)\n\t\tdf.at[i,\"CalcNumLipinskiHBD\"] = rdMolDescriptors.CalcNumLipinskiHBD(mol)\n\t\tdf.at[i,\"CalcNumRings\"] = rdMolDescriptors.CalcNumRings(mol)\n\t\tdf.at[i,\"CalcNumSaturatedCarbocycles\"] = rdMolDescriptors.CalcNumSaturatedCarbocycles(mol)\n\t\tdf.at[i,\"CalcNumSaturatedHeterocycles\"] = rdMolDescriptors.CalcNumSaturatedHeterocycles(mol)\n\t\tdf.at[i,\"CalcNumSaturatedRings\"] = rdMolDescriptors.CalcNumSaturatedRings(mol)\n\t\tdf.at[i,\"CalcNumSpiroAtoms\"] = rdMolDescriptors.CalcNumSpiroAtoms(mol)\n\t\tdf.at[i,\"CalcTPSA\"] = rdMolDescriptors.CalcTPSA(mol)\n", "description": null, "category": "math", "imports": ["import pandas as pd", "import numpy as np", "import subprocess", "from rdkit import Chem", "from rdkit.Chem import Descriptors, rdMolDescriptors", "import os", "from rdkit.Chem import ChemicalFeatures, rdMolChemicalFeatures", "from rdkit.Chem.rdMolChemicalFeatures import MolChemicalFeatureFactory", "from rdkit import RDConfig", "from rdkit.Chem.AllChem import EmbedMolecule", "from sklearn.utils import shuffle", "import pickle ", "import subprocess", "import gnn_tools as gnn", "import time", "import re"]}, {"term": "def", "name": "createXYZ_from_SMILES", "data": "def createXYZ_from_SMILES(df, mol_list):\n\tnew_mol_list = []\n\tprint(\"Creating XYZ coordinates from SMILES\")\n\tdf = df.astype('object')\n\tdf['xyz'] = ''\n\tfor i, row in df.iterrows():\n\t\t#print(i, \"Creating XYZ coordinates for mol with SMILES code = \", row['smiles'])\n\t\tmol = Chem.MolFromSmiles(row['smiles'])\n\t\tmol = Chem.AddHs(mol)\n\t\tEmbedMolecule(mol)\n\t\txyz = Chem.rdmolfiles.MolToXYZBlock(mol)\n\t\tif (xyz is ''):\n\t\t\tprint(i, \"Unable to create XYZ coordinates for\", row['smiles'], \"Droping it from the dataframe\")\t\t\n\t\t\tdf.at[i,\"xyz\"] = 'drop'\n\t\telse:\n\t\t\tnew_mol_list.append(mol_list[i])\t   \n\t\t\tdf.at[i,\"xyz\"] = xyz\n\tdf = df[df[\"xyz\"] != 'drop']\n\tdf = df.reset_index(drop=True)\n\treturn(df, new_mol_list)\n\n\n\t\n", "description": null, "category": "math", "imports": ["import pandas as pd", "import numpy as np", "import subprocess", "from rdkit import Chem", "from rdkit.Chem import Descriptors, rdMolDescriptors", "import os", "from rdkit.Chem import ChemicalFeatures, rdMolChemicalFeatures", "from rdkit.Chem.rdMolChemicalFeatures import MolChemicalFeatureFactory", "from rdkit import RDConfig", "from rdkit.Chem.AllChem import EmbedMolecule", "from sklearn.utils import shuffle", "import pickle ", "import subprocess", "import gnn_tools as gnn", "import time", "import re"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "kpts_changed", "data": "def kpts_changed(calc, x):\n\t'''\n\tcheck if kpt grid has changed.\n\n\twe have to take care to generate the right k-points from x if\n\tneeded. if a user provides (4,4,4) we need to generate the MP\n\tgrid, etc...\n\n\tSince i changed the MP code in set_kpts, there is some\n\tincompatibility with old jacapo calculations and their MP\n\tgrids.\n\t'''\n\t#chadi-cohen\n\tif isinstance(x, str):\n\t\texec('from ase.dft.kpoints import %s' % x)\n\t\tlistofkpts = eval(x)\n\t#monkhorst-pack grid\n\telif np.array(x).shape == (3,):\n\t\tfrom ase.dft.kpoints import monkhorst_pack\n\t\tN1, N2, N3 = x\n\t\tlistofkpts = monkhorst_pack((N1, N2, N3))\n\t#user-defined list is provided\n\telif len(np.array(x).shape) == 2:\n\t\tlistofkpts = np.array(x)\n\telse:\n\t\traise Exception, 'apparent invalid setting for kpts'\n\n\tgrid = calc.get_kpts()\n\t\n\tif grid.shape != listofkpts.shape:\n\t\treturn True\n\n\tif (abs(listofkpts - grid) < 1e-6).all():\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "electronic_minimization_changed", "data": "def electronic_minimization_changed(calc, x):\n\tmyx = calc.get_electronic_minimization()\n\n\tfor key in myx:\n\t\tif myx[key] != x[key]:\n\t\t\tprint key, myx[key], ' changed to ', x[key]\n\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "spinpol_changed", "data": "def spinpol_changed(calc, x):\n\tif x != calc.get_spinpol():\n\t\treturn True\n\telse:\n\t\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "symmetry_changed", "data": "def symmetry_changed(calc, x):\n\tif x != calc.get_symmetry():\n\t\treturn True\n\telse:\n\t\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "xc_changed", "data": "def xc_changed(calc, x):\n\tif x != calc.get_xc():\n\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "calculate_stress_changed", "data": "def calculate_stress_changed(calc, x):\n\tif x != calc.get_calculate_stress():\n\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "ados_changed", "data": "def ados_changed(calc, x):\n\tados = calc.get_ados()\n\n\t#ados may not be defined, and then None is returned\n\tif ados is None and x is None:\n\t\treturn False\n\telif ados is None and x is not None:\n\t\treturn True\n\telif ados is not None and x is None:\n\t\treturn True\n\n\t#getting here means ados and x are not none so we compare them\n\tfor key in x:\n\t\ttry:\n\t\t\tif x[key] != ados[key]:\n\t\t\t\treturn True\n\t\texcept ValueError:\n\t\t\tif (x[key] != ados[key]).all():\n\t\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "convergence_changed", "data": "def convergence_changed(calc, x):\n\tconv = calc.get_convergence()\n\tfor key in x:\n\t\tif x[key] != conv[key]:\n\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "charge_mixing_changed", "data": "def charge_mixing_changed(calc, x):\n\tcm = calc.get_charge_mixing()\n\tif x is None and cm is None:\n\t\treturn False\n\telse:\n\t\treturn True\n\t\t\n\tfor key in x:\n\t\tif x[key] != cm[key]:\n\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "decoupling_changed", "data": "def decoupling_changed(calc, x):\n\tpars = calc.get_decoupling()\n\tfor key in x:\n\t\tif x[key] != pars[key]:\n\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "dipole_changed", "data": "def dipole_changed(calc, x):\n\n\tpars = calc.get_dipole() #pars stored in calculator\n\n\t# pars = False if no dipole variables exist\n\tif (pars is False and x is False):\n\t\treturn False #no change\n\telif (pars is False and x is not False):\n\t\treturn True\n\n\t# both x and pars is a dictionary\n\tif (type(pars) == type(dict) and\n\t\ttype(pars) == type(x)):\n\t\tfor key in x:\n\t\t\tif key == 'position':\t# dipole layer position is never writen to the nc file\n\t\t\t\tprint 'need to do something special'\n\t\t\t\tcontinue\n\t\t\tif x[key] != pars[key]:\n\t\t\t\treturn True\n\n\t#nothing seems to have changed.\n\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "extpot_changed", "data": "def extpot_changed(calc, x):\n\textpot = calc.get_extpot()\n\tif (x == extpot).all():\n\t\treturn False\n\treturn True\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "fftgrid_changed", "data": "def fftgrid_changed(calc, x):\n\tvalidkeys = ['soft', 'hard']\n\n\tmyx = calc.get_fftgrid()\n\tif (myx['soft'] == x['soft'] and myx['hard'] == x['hard']):\n\t\treturn False\n\telse:\n\t\treturn True\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "nbands_changed", "data": "def nbands_changed(calc, x):\n\tif calc.get_nbands() == x:\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "occupationstatistics_changed", "data": "def occupationstatistics_changed(calc, x):\n\tif calc.get_occupationstatistics() == x:\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "pw_changed", "data": "def pw_changed(calc, x):\n\tif calc.get_pw() == x:\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "dw_changed", "data": "def dw_changed(calc, x):\n\tif calc.get_dw() == x:\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "ft_changed", "data": "def ft_changed(calc, x):\n\tif calc.get_ft() == x:\n\t\treturn False\n\telse:\n\t\treturn True\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "mdos_changed", "data": "def mdos_changed(calc,x):\n\n\tmyx = calc.get_mdos()\n\n\tlog.debug('myx = %s' % str(myx))\n\tlog.debug('x = %s' % str(x))\n\n\tif x is None and myx is None:\n\t\treturn False\n\telif ((x is None and myx is not None)\n\t\tor (x is not None and myx is None)):\n\t\treturn True\n\telse:\n\t\tfor key in x:\n\t\t\tif x[key] != myx[key]:\n\t\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "pseudopotentials_changed", "data": "def pseudopotentials_changed(calc,x):\n\n\tmypsp = calc.get_pseudopotentials()\n\n\tif len(mypsp) != len(x):\n\t\treturn True\n\n\tfor key in x:\n\t\tif key not in mypsp:\n\t\t\treturn True\n\t\tif mypsp[key] != x[key]:\n\t\t\treturn True\n\n\tfor key in mypsp:\n\t\tif key not in x:\n\t\t\treturn True\n\t\tif mypsp[key] != x[key]:\n\t\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}, {"term": "def", "name": "status_changed", "data": "def status_changed(calc,x):\n\tif calc.get_status() != x:\n\t\treturn True\n\treturn False\n", "description": null, "category": "math", "imports": ["import numpy as np", "import logging", "\t\texec('from ase.dft.kpoints import %s' % x)", "\t\tfrom ase.dft.kpoints import monkhorst_pack"]}], [{"term": "class", "name": "ActiveProjectsCalculatorTests", "data": "class ActiveProjectsCalculatorTests(TestCase):\n\tdef setUp(self):\n\t\tnow = timezone.now()\n\t\tself.interval_start = now - timedelta(days=365)\n\t\tself.interval_end = self.interval_start + timedelta(days=365)\n\n\tdef test_calc_on_empty_db(self):\n\t\tcalc = ActiveProjectsCalculator()\n\t\tcalc.calc(self.interval_start, self.interval_end)\n\n", "description": null, "category": "math", "imports": ["from datetime import timedelta", "import unittest", "from django.conf import settings", "from django.test import TestCase", "from django.utils import timezone", "from django.utils.dateparse import parse_datetime", "from dmt.main.models import UserProfile", "from dmt.main.tests.factories import (", "from dmt.report.calculators import ("]}, {"term": "class", "name": "StaffReportCalculatorTests", "data": "class StaffReportCalculatorTests(TestCase):\n\tdef setUp(self):\n\t\tnow = timezone.now()\n\t\tself.week_start = now + timedelta(days=-now.weekday())\n\t\tself.week_end = self.week_start + timedelta(days=6)\n\n\tdef test_calc(self):\n\t\tUserProfileFactory()\n\t\tUserProfileFactory()\n\t\tUserProfileFactory()\n\t\tcalc = StaffReportCalculator(UserProfile.objects.all())\n\t\tcalc.calc(self.week_start, self.week_end)\n\n\tdef test_calc_on_empty_db(self):\n\t\tcalc = StaffReportCalculator(UserProfile.objects.all())\n\t\tcalc.calc(self.week_start, self.week_end)\n\n", "description": null, "category": "math", "imports": ["from datetime import timedelta", "import unittest", "from django.conf import settings", "from django.test import TestCase", "from django.utils import timezone", "from django.utils.dateparse import parse_datetime", "from dmt.main.models import UserProfile", "from dmt.main.tests.factories import (", "from dmt.report.calculators import ("]}, {"term": "class", "name": "TimeSpentByUserCalculatorTest", "data": "class TimeSpentByUserCalculatorTest(TestCase):\n\tdef test_calc(self):\n\t\tProjectFactory()\n\t\tcalc = TimeSpentByUserCalculator()\n\t\tcalc.calc()\n\n\tdef test_calc_on_empty_db(self):\n\t\tcalc = TimeSpentByUserCalculator()\n\t\tcalc.calc()\n\n", "description": null, "category": "math", "imports": ["from datetime import timedelta", "import unittest", "from django.conf import settings", "from django.test import TestCase", "from django.utils import timezone", "from django.utils.dateparse import parse_datetime", "from dmt.main.models import UserProfile", "from dmt.main.tests.factories import (", "from dmt.report.calculators import ("]}, {"term": "class", "name": "TimeSpentByProjectCalculatorTest", "data": "class TimeSpentByProjectCalculatorTest(TestCase):\n\tdef test_calc(self):\n\t\tProjectFactory()\n\t\tcalc = TimeSpentByProjectCalculator()\n\t\tcalc.calc()\n\n\tdef test_calc_on_empty_db(self):\n\t\tcalc = TimeSpentByProjectCalculator()\n\t\tcalc.calc()\n\n", "description": null, "category": "math", "imports": ["from datetime import timedelta", "import unittest", "from django.conf import settings", "from django.test import TestCase", "from django.utils import timezone", "from django.utils.dateparse import parse_datetime", "from dmt.main.models import UserProfile", "from dmt.main.tests.factories import (", "from dmt.report.calculators import ("]}, {"term": "class", "name": "ProjectStatusCalculatorTest", "data": "class ProjectStatusCalculatorTest(TestCase):\n\tdef test_calc(self):\n\t\tProjectFactory()\n\t\tUserProfileFactory()\n\t\tUserProfileFactory()\n\t\tUserProfileFactory()\n\t\tcalc = ProjectStatusCalculator()\n\t\tcalc.calc()\n\n\tdef test_calc_on_empty_db(self):\n\t\tcalc = ProjectStatusCalculator()\n\t\tcalc.calc()\n\n", "description": null, "category": "math", "imports": ["from datetime import timedelta", "import unittest", "from django.conf import settings", "from django.test import TestCase", "from django.utils import timezone", "from django.utils.dateparse import parse_datetime", "from dmt.main.models import UserProfile", "from dmt.main.tests.factories import (", "from dmt.report.calculators import ("]}, {"term": "class", "name": "StaffCapacityCalculatorTest", "data": "class StaffCapacityCalculatorTest(TestCase):\n\n\tdef test_capacity_skip_weekend(self):\n\t\tUserProfileFactory()\n\t\tstart = parse_datetime('2018-05-14 00:00:00-04:00')\n\t\tend = parse_datetime('2018-05-25 23:59:59.999999-04:00')\n\n\t\tcalc = StaffCapacityCalculator(\n\t\t\tUserProfile.objects.all(), start, end)\n\t\tself.assertEquals(calc.days(), 10)\n\t\tself.assertEquals(calc.capacity_for_range(), 60)\n\n\tdef test_capacity_skip_holiday(self):\n\t\tUserProfileFactory()\n\t\tstart = parse_datetime('2018-05-28 00:00:00-04:00')\n\t\tend = parse_datetime('2018-06-01 23:59:59.999999-04:00')\n\n\t\tcalc = StaffCapacityCalculator(\n\t\t\tUserProfile.objects.all(), start, end)\n\t\tself.assertEquals(calc.days(), 4)\n\t\tself.assertEquals(calc.capacity_for_range(), 24)\n\n\tdef test_calc(self):\n\t\tstart = parse_datetime('2017-05-15 00:00:00-04:00')\n\t\tend = parse_datetime('2017-05-26 23:59:59.999999-04:00')\n\t\ttarget = parse_datetime('2017-05-16 00:00:00-04:00')\n\n\t\tprofile = UserProfileFactory()\n\t\tItemFactory(assigned_user=profile.user,\n\t\t\t\t\testimated_time=timedelta(hours=5),\n\t\t\t\t\ttarget_date=target)\n\t\tItemFactory(assigned_user=profile.user,\n\t\t\t\t\testimated_time=timedelta(hours=1))\n\n\t\tcalc = StaffCapacityCalculator(\n\t\t\tUserProfile.objects.filter(user__id=profile.user.id),\n\t\t\tstart, end)\n\t\tself.assertEquals(calc.days(), 10)\n\t\tself.assertEquals(calc.capacity_for_range(), 60)\n\n\t\tdata = calc.calc()\n\t\tself.assertEquals(len(data), 1)\n\t\tself.assertEquals(data[0]['user'], profile)\n\t\tself.assertEquals(data[0]['booked'], 5)\n\t\tself.assertEquals(data[0]['percent_booked'], '8.3')\n\t\tself.assertEquals(data[0]['available'], 55)\n\t\tself.assertEquals(data[0]['percent_available'], '91.7')\n", "description": null, "category": "math", "imports": ["from datetime import timedelta", "import unittest", "from django.conf import settings", "from django.test import TestCase", "from django.utils import timezone", "from django.utils.dateparse import parse_datetime", "from dmt.main.models import UserProfile", "from dmt.main.tests.factories import (", "from dmt.report.calculators import ("]}], [{"term": "class", "name": "ApEnWidget", "data": "class ApEnWidget(QWidget):\n\tdef __init__(self, parent):\n\t\tsuper(QWidget, self).__init__(parent)\n\t\tself.fileName = \".memory\"\n\t\tself.files_selected = False  # represent if FileChooserWidget has any files selected\n\t\tself.is_in_progress = False  # represent if calculation is in progress\n\t\tself.init_ui()\n\n\tdef init_ui(self):\n\t\tlayout = QVBoxLayout(self)\n\n\t\t# Initialize tab screen\n\t\tself.tabs = QTabWidget()\n\t\tself.tab1 = QWidget()\n\t\tself.tabs.resize(500, 600)\n\n\t\t# Add tabs\n\t\tself.tabs.addTab(self.tab1, \"Entropy\")\n\n\t\t# Create first tab\n\t\tenth_grid = self.config_entropy_tab()\n\n\t\tself.tab1.setLayout(enth_grid)\n\n\t\t# Add tabs to widget\n\t\tlayout.addWidget(self.tabs)\n\t\tself.setLayout(layout)\n\t\tself.check_run_button_state()\n\n\tdef config_entropy_tab(self):\n\t\tmLabel = QLabel('m (length of vectors)or n (for pertropy only) ')\n\t\tself.mEdit = QLineEdit(\"2\")\n\n\t\tself.window_cb = QCheckBox('Use sliding windows', self)\n\t\tself.is_windows_enabled = True\n\t\tself.window_cb.setChecked(self.is_windows_enabled)\n\t\tself.window_cb.clicked.connect(self.toggle_window_checkbox)\n\n\t\tself.window_analysis_widget = WindowAnalysisWidget(self)\n\n\t\tself.is_use_ent_cb = QCheckBox('Calculate Sample/Approximate Entropy?', self)\n\t\tself.is_calc_ent = True\n\t\tself.is_use_ent_cb.setChecked(self.is_calc_ent)\n\t\tself.is_use_ent_cb.clicked.connect(self.toggle_calc_ent_cb)\n\n\t\tself.ent_widget = EntropyWidget(self)\n\n\t\tself.is_use_pertropy_cb = QCheckBox('Calculate Permutation Entropy?', self)\n\t\tself.is_calc_pertropy = True\n\t\tself.is_use_pertropy_cb.setChecked(self.is_calc_pertropy)\n\t\tself.is_use_pertropy_cb.clicked.connect(self.toggle_calc_pertropy_cb)\n\n\t\tself.pertropy_widget = PertropyWidget(self)\n\n\t\tself.is_use_cor_dim_cb = QCheckBox('Calculate correlation dimension?', self)\n\t\tself.is_calc_cor_dim = True\n\t\tself.is_use_cor_dim_cb.setChecked(self.is_calc_cor_dim)\n\t\tself.is_use_cor_dim_cb.clicked.connect(self.toggle_calc_cor_dim_cb)\n\n\t\tself.is_use_frac_dim_cb = QCheckBox('Calculate fractal dimension?', self)\n\t\tself.is_calc_frac_dim = True\n\t\tself.is_use_frac_dim_cb.setChecked(self.is_calc_cor_dim)\n\t\tself.is_use_frac_dim_cb.clicked.connect(self.toggle_calc_frac_dim_cb)\n\n\t\tself.run_calculate = QPushButton(\"Run calculation\", self)\n\t\tself.run_calculate.clicked.connect(self.calculate)\n\n\t\tgrid = QGridLayout()\n\t\tgrid.addWidget(mLabel, 0, 0)\n\t\tgrid.addWidget(self.mEdit, 0, 1)\n\t\tgrid.addWidget(self.window_cb, 0, 3)\n\t\tgrid.addWidget(self.window_analysis_widget, 1, 4)\n\t\tgrid.addWidget(self.is_use_ent_cb, 2, 0)\n\t\tgrid.addWidget(self.ent_widget, 3, 1)\n\n\t\tgrid.addWidget(self.is_use_pertropy_cb, 2, 3)\n\t\tgrid.addWidget(self.pertropy_widget, 3, 4)\n\n\t\tself.cor_dim_widget = CorDimWidget(self)\n\t\tgrid.addWidget(self.is_use_cor_dim_cb, 4, 3)\n\t\tgrid.addWidget(self.cor_dim_widget, 5, 4)\n\n\t\tself.frac_dim_widget = FracDimWidget(self)\n\t\tgrid.addWidget(self.is_use_frac_dim_cb, 6, 3)\n\t\tgrid.addWidget(self.frac_dim_widget, 7, 4)\n\n\t\tself.file_chooser_widget = FileChooserWidget(self, self.fileName)\n\t\tself.file_chooser_widget.new_files_chosen.connect(self.on_new_files_chosen)\n\t\tself.file_chooser_widget.erased_files.connect(self.on_erased_files)\n\t\tgrid.addWidget(self.file_chooser_widget, 4, 0, 5, 3)\n\n\t\tgrid.addWidget(self.run_calculate, 14, 0, 1, 3)\n\n\t\t# Creating a label\n\t\tself.progress_label = QLabel('Calculation progress', self)\n\n\t\t# Creating a progress bar and setting the value limits\n\t\tself.progress_bar = QProgressBar(self)\n\t\tself.progress_bar.setMaximum(100)\n\t\tself.progress_bar.setMinimum(0)\n\t\tgrid.addWidget(self.progress_label, 18, 0)\n\t\tgrid.addWidget(self.progress_bar, 18, 1)\n\n\t\treturn grid\n\n\tdef on_new_files_chosen(self):\n\t\tself.files_selected = True\n\t\tself.check_run_button_state()\n\n\tdef on_erased_files(self):\n\t\tself.files_selected = False\n\t\tself.check_run_button_state()\n\n\tdef calculate(self):\n\t\tis_ent_enabled = self.is_use_ent_cb.isChecked()\n\t\tis_cord_dim_enabled = self.is_use_cor_dim_cb.isChecked()\n\t\tis_frac_dim_enabled = self.is_use_frac_dim_cb.isChecked()\n\t\tis_pertropy_enabled = self.is_use_pertropy_cb.isChecked()\n\t\tis_pertropy_normalized = self.pertropy_widget.is_normalize_used\n\t\tis_pertropy_stride = self.pertropy_widget.is_stride_used\n\n\t\tfiles_list = self.file_chooser_widget.get_file_names()\n\t\tdimension = int(self.mEdit.text())\n\t\twindow_size = self.get_window_size()\n\t\tstep_size = self.get_step_size()\n\n\t\tcor_dim_radius = self.cor_dim_widget.get_radius() if is_cord_dim_enabled else 0\n\t\tis_samp_en = self.ent_widget.is_samp_en() if is_ent_enabled else False\n\t\tis_ap_en = self.ent_widget.is_ap_en() if is_ent_enabled else False\n\t\ten_threshold_value, en_dev_coef_value, en_calculation_type, en_use_threshold = (self.get_entropy_parameters()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif is_ent_enabled else [0, 0, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0])\n\t\tfd_max_k = self.get_frac_dim_parameters() if is_frac_dim_enabled else 0\n\t\tpertropy_stride = self.pertropy_widget.get_stride() if is_pertropy_stride else 1\n\n\t\tself.calc_thread = CalculationThread(is_cord_dim_enabled, files_list, dimension,\n\t\t\t\t\t\t\t\t\t\t\t window_size, step_size,\n\t\t\t\t\t\t\t\t\t\t\t cor_dim_radius, is_samp_en, is_ap_en, en_use_threshold,\n\t\t\t\t\t\t\t\t\t\t\t en_threshold_value, en_dev_coef_value, en_calculation_type,\n\t\t\t\t\t\t\t\t\t\t\t is_frac_dim_enabled, fd_max_k,\n\t\t\t\t\t\t\t\t\t\t\t is_pertropy_enabled, is_pertropy_normalized, pertropy_stride)\n\n\t\tself.set_in_progress(True)\n\t\tself.calc_thread.done.connect(self.show_message)\n\t\tself.calc_thread.done.connect(self.erase_in_progress)\n\t\tself.calc_thread.progress.connect(self.track_ui_progress)\n\t\tself.calc_thread.start()\n\n\tdef track_ui_progress(self, val):\n\t\tself.progress_bar.setValue(val if val < 100 else 0)\n\n\tdef show_message(self, source, file_names, report_path=None):\n\t\tself.ok_button = QPushButton('Ok', self)\n\t\tself.dialog = QMessageBox(self)\n\t\tself.dialog.setWindowModality(False)\n\t\tall_files = \"\".join([\"- {} \\n\".format(i) for i in file_names.split(',')])\n\t\tdialog_text = \"{} calculated for: \\n {}\".format(source, all_files)\n\t\tif report_path:\n\t\t\tdialog_text += '\\n Saved report in {}'.format(report_path)\n\t\tself.dialog.setText(dialog_text)\n\t\tself.dialog.setDefaultButton(self.ok_button)\n\t\tself.dialog.show()\n\n\tdef set_in_progress(self, v):\n\t\tself.is_in_progress = v\n\t\tself.track_ui_progress(0)\n\t\tself.check_run_button_state()\n\n\tdef erase_in_progress(self):\n\t\tself.set_in_progress(False)\n\n\tdef toggle_calc_ent_cb(self):\n\t\tself.is_calc_ent = not self.is_calc_ent\n\t\tself.ent_widget.set_ap_en(self.is_calc_ent)\n\t\tself.ent_widget.set_samp_en(self.is_calc_ent)\n\t\tif not self.is_calc_ent:\n\t\t\tself.ent_widget.reset_to_default()\n\t\tself.check_run_button_state()\n\t\tself.ent_widget.setHidden(not self.is_calc_ent)\n\n\tdef toggle_calc_pertropy_cb(self):\n\t\tself.is_calc_pertropy = not self.is_calc_pertropy\n\t\tself.check_run_button_state()\n\t\tself.pertropy_widget.setHidden(not self.is_calc_pertropy)\n\t\tif not self.is_calc_pertropy:\n\t\t\tself.pertropy_widget.reset_to_default()\n\n\tdef toggle_window_checkbox(self):\n\t\tself.is_windows_enabled = not self.is_windows_enabled\n\t\tself.window_analysis_widget.setHidden(not self.is_windows_enabled)\n\n\tdef check_run_button_state(self):\n\t\tany_algo_used = self.is_calc_ent or self.is_calc_cor_dim or self.is_calc_frac_dim or self.is_calc_pertropy\n\t\tself.run_calculate.setEnabled(any_algo_used and\n\t\t\t\t\t\t\t\t\t  self.files_selected and not self.is_in_progress)\n\n\tdef toggle_calc_cor_dim_cb(self):\n\t\tself.is_calc_cor_dim = not self.is_calc_cor_dim\n\t\tself.check_run_button_state()\n\t\tself.cor_dim_widget.setHidden(not self.is_calc_cor_dim)\n\n\tdef toggle_calc_frac_dim_cb(self):\n\t\tself.is_calc_frac_dim = not self.is_calc_frac_dim\n\t\tself.check_run_button_state()\n\t\tself.frac_dim_widget.setHidden(not self.is_calc_frac_dim)\n\n\tdef get_entropy_parameters(self):\n\t\tthreshold_value = self.ent_widget.get_threshold()\n\t\tdev_coef_value = self.ent_widget.get_dev_coef_value()\n\t\tcalculation_type = self.ent_widget.get_calculation_type()\n\t\tuse_threshold = self.ent_widget.is_threshold()\n\t\treturn threshold_value, dev_coef_value, calculation_type, use_threshold\n\n\tdef get_frac_dim_parameters(self):\n\t\tfd_max_k = self.frac_dim_widget.get_max_k()\n\t\treturn fd_max_k\n\n\tdef get_window_size(self):\n\t\treturn int(self.window_analysis_widget.get_window_size()) if self.is_windows_enabled else None\n\n\tdef get_step_size(self):\n\t\treturn int(self.window_analysis_widget.get_window_step()) if self.is_windows_enabled else None\n", "description": null, "category": "math", "imports": ["from PyQt5.QtWidgets import QWidget, QVBoxLayout, QTabWidget, QPushButton, QGridLayout, QLabel, QCheckBox, \\", "from src.gui.threads.CalculationThread import CalculationThread", "from src.gui.widgets.cor_dim_widget import CorDimWidget", "from src.gui.widgets.entropy_widget import EntropyWidget", "from src.gui.widgets.file_chooser_widget import FileChooserWidget", "from src.gui.widgets.frac_dim_widget import FracDimWidget", "from src.gui.widgets.pertropy_widget import PertropyWidget", "from src.gui.widgets.window_analysis_widget import WindowAnalysisWidget"]}], [], [{"term": "def", "name": "calc_v_ej_avg", "data": "def calc_v_ej_avg(v_imp,g,d):\n\t#Average ejection velocity due to splashing.\t \n\ta_ej_avg=0.15   #Kok 2009a Table 1.\n\ta=0.02\t\t  #Kok 2009a Table 1.\n\tv_ej_avg=(a_ej_avg*np.sqrt(g*d)/a)*(1-np.exp(v_imp/(-40*np.sqrt(g*d))))\n\treturn v_ej_avg\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_P_v_ej", "data": "def calc_P_v_ej(v_ej,v_imp,g,d):\n\t#Probability distribution function value of ejection velocities at\n\t#a particular ejection velocity.\n\tP_v_ej=np.exp(-1*v_ej/calc_v_ej_avg(v_imp,g,d))/calc_v_ej_avg(v_imp,g,d)\n\treturn P_v_ej\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_v_ej_less", "data": "def calc_v_ej_less(v_imp,g,d,dist_frxn):\n\t#Velocity below which dist_frxn of  particles are ejected\n\tv_ej_less=-1*calc_v_ej_avg(v_imp,g,d)*np.log(1-dist_frxn)\n\treturn v_ej_less\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_s", "data": "def calc_s(rho_p,rho_a):\n\treturn rho_p/rho_a\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_u_ft", "data": "def calc_u_ft(rho_p,rho_a,d,g):\t\n\tan=0.0123\n\tzeta=5e-4\t  #These are from Shao & Lu\n\tprint_str='WARNING: To replicate Pluto version we have to move replace\\n'+\\\n\t\t\t\t'Shao and Lu Constant with different constant OUTSIDE square\\n'+\\\n\t\t\t\t'square root, NOTE: order of operations'\n\tprint(print_str)\n\t\n\tustar=np.sqrt(an*(d*g*calc_s(rho_p,rho_a) + zeta/(rho_a*d)))\t\n\treturn ustar\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_u_t", "data": "def calc_u_t(mu,rho_p,rho_a,d,g,nu):\n\tkappa=0.4   #von Karman constant\n\teta=0.1\t #Efficiency of wind accel. of grains (Paehtz et al. 2012)\n\t\n\tut=kappa*(calc_Vr(mu,rho_p,rho_a,d,g)+calc_Vo(rho_p,rho_a,d,g))/\\\n\t\t\t((1-eta)*np.log(calc_z_mt(mu,rho_p,rho_a,d,g)/\\\n\t\t\t  calc_z_o_grain_low_Re(mu,rho_p,rho_a,d,g)))\n\treturn ut\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_gt", "data": "def calc_gt(rho_p,rho_a,g):\n\t#This is g_tilda.\n\tgt=g*(calc_s(rho_p,rho_a)-1)/calc_s(rho_p,rho_a)\n\treturn gt\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_gf", "data": "def calc_gf(rho_p,rho_a,d,g):\n\tzeta=5e-4\n\tgf=calc_gt(rho_p,rho_a,g)+6.*zeta/(np.pi*rho_p*d**2.)\n\treturn gf\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_Vo", "data": "def calc_Vo(rho_p,rho_a,d,g):\n\tVo=16.2*np.sqrt(calc_gf(rho_p,rho_a,d,g)*d)\n\treturn Vo\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_Vt", "data": "def calc_Vt(mu,rho_p,rho_a,d,g):\n\teta=0.1\n\tVt=(calc_Vo(rho_p,rho_a,d,g)+eta*calc_Vr(mu,rho_p,rho_a,d,g))/(1-eta)\n\treturn Vt\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_z_mt", "data": "def calc_z_mt(mu,rho_p,rho_a,d,g):\n\talpha=1.02\n\tbeta_t=0.095\n\tgamma=0.17\n\t\n\tz_mt=(alpha*beta_t*gamma*calc_Vr(mu,rho_p,rho_a,d,g)**(1/2.)*\\\n\t\t  calc_Vt(mu,rho_p,rho_a,d,g)**(3/2.))/calc_gt(rho_p,rho_a,g)\n\treturn z_mt\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_z_o_grain_low_Re", "data": "def calc_z_o_grain_low_Re(mu,rho_p,rho_a,d,g):\n\t#This is the relation for particle Reynolds # < 3, equation E.3 in\n\t#Paehtz et al. 2012.\n\tz_o_grain=mu/(9.*rho_a*calc_u_ft(rho_p,rho_a,d,g))\n\treturn z_o_grain\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "Vr_func", "data": "def Vr_func(Vr, *constants):\n\tmu,rho_p,rho_a,d,g=constants\n\talpha=1.02\n\tVr_func=-1.*(4*calc_s(rho_p,rho_a)*calc_gt(rho_p,rho_a,g)*d/(3*alpha))+\\\n\t\t\t(Vr**2.)*(1+(32.*mu/(Vr*rho_a*d))**(2/3.))**(3/2.)\n\treturn Vr_func\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}, {"term": "def", "name": "calc_Vr", "data": "def calc_Vr(mu,rho_p,rho_a,d,g):\n\tVr=np.ones(d.shape[0])*np.nan\n\tfor di, d_val in enumerate(d):\n\t\tconstants=(mu,rho_p,rho_a,d_val,g)\n\t\tVr[di]=fsolve(Vr_func,10,args=constants)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from scipy.optimize import fsolve"]}], [{"term": "def", "name": "signal_handler", "data": "def signal_handler(signum, frame):\n\tmsg = 'FAILED`recv signal ' + str(signum) + '. exit now.'\n\tcommon.info(my_log, log_tag, time_tag + msg)\n\n\tif os.path.isfile(my_pidfile):\n\t\tos.remove(my_pidfile)\n\t\n\tsys.exit(0)\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "create_obc_hdf", "data": "def create_obc_hdf(name_tage,hfile,numpy_data, obc_setting):\n\t\n\n\ttry:\n\t\t\n\t\tprevious_idx = 0 # time idx = 0\n\t\tfor one_setting in obc_setting:\n\t\t\tstart_idx = previous_idx + 1\n\t\t\tfor one_column in xrange(1, one_setting['columns'] + 1):\n\t\t\t\tif one_setting['columns'] == 1:\n\t\t\t\t\tds_name = one_setting['db_field'] + '_' + name_tage\n\t\t\t\telse:\n\t\t\t\t\tds_name = one_setting['db_field'] + str(one_column) + '_'+ name_tage\n\n\t\t\t\tidx = start_idx + one_column - 1\n\t\t\t\t#factor = int(one_setting['factor'])\n\t\t\t\t#print one_setting['factor'] \n\t\t\t\tfactor =one_setting['factor']\t\t \n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_one_channel", "data": "def draw_one_channel(channel):\n\tif len(channel_table_3day) <= 0:\n\t\treturn True\n\tif len(channel_table_1month) <= 0:\n\t\treturn True\n\tif len(Calc_channel_table_3day) <= 0:\n\t\treturn True\n\tif len(Calc_channel_table_1month) <= 0:\n\t\treturn True\n\t\n\ttmpfile3day = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n\t\t\t+ '.ch' + format(channel, '02d') + '.3day'\n\tsql_3day = common.get_obc_3dim_sql(ins_conf.obc_3dim_to_db.values(),str(channel),\n\t\t\t\t\t\t\t\t  channel_table_3day, conf.obc_select_prefix_sql,\n\t\t\t\t\t\t\t\t  conf.obc_3dim_where_sql) \\\n\t\t+ conf.export_txt%(tmpfile3day + '.txt')\n\tbegin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + channel_table_3day[0] \\\n\t\t\t\t+ conf.obc_3dim_where_sql + str(channel) + \" limit 1\"\n\t\t\t\t\n\ttmpfile1month = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n\t\t\t+ '.ch' + format(channel, '02d')+ '.1month' \n\tsql_1month = common.get_obc_3dim_sql(ins_conf.obc_3dim_to_db.values(),str(channel),\n\t\t\t\t\t\t\t\t  channel_table_1month, conf.obc_select_prefix_sql,\n\t\t\t\t\t\t\t\t  conf.obc_3dim_where_sql) \\\n\t\t+ conf.export_txt%(tmpfile1month + '.txt')\n\t\t\n\t\t\n\ttmpfile3day_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n\t\t\t+ '.ch' + format(channel, '02d') + '.3day_calc'\n\tsql_3day_calc = common.get_obc_3dim_sql(ins_conf.calc_3dim_to_db.values(),str(channel),\n\t\t\t\t\t\t\t\t  Calc_channel_table_3day, conf.obc_select_prefix_sql,\n\t\t\t\t\t\t\t\t  conf.obc_3dim_where_sql) \\\n\t\t+ conf.export_txt%(tmpfile3day_calc + '.txt')\n\t\n\t\t\t\t\n\ttmpfile1month_calc = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() \\\n\t\t\t+ '.ch' + format(channel, '02d')+ '.1month_calc' \n\tsql_1month_calc = common.get_obc_3dim_sql(ins_conf.calc_3dim_to_db.values(),str(channel),\n\t\t\t\t\t\t\t\t  Calc_channel_table_1month, conf.obc_select_prefix_sql,\n\t\t\t\t\t\t\t\t  conf.obc_3dim_where_sql) \\\n\t\t+ conf.export_txt%(tmpfile1month_calc + '.txt')\t\n\t\t\n\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor(MySQLdb.cursors.DictCursor)\n\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\t  \n\t\tcur.execute(sql_3day)\n\t\tcur.execute(sql_1month)\n\t\t#print Calc_channel_table_3day\n\t\t#print \"-------------------------------------\"\n\t\t#print sql_1month_calc\n\t\tcur.execute(sql_3day_calc)\n\t\tcur.execute(sql_1month_calc)\n\t\tcur.execute(begin_sql_3day)\n\t\tbegin_data = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\t# do NOT exit in thread!! To avoid zombie process.\n\t\tmsg = 'draw obc 3-dim ch' + str(channel) + ' png`Mysql Fatal Error[' \\\n\t\t\t+ str(e.args[0]) + ']: ' + e.args[1]\t\t\t  \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\n\ttmpfile1year = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() + '.CH' + format(channel, '02d') +'.1year' + '.obc'\n\ttmpfilelife = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() + '.CH' + format(channel, '02d') +'.life' + '.obc'\n\n\tget_channel_txt(tmpfile1year,tmpfilelife,'agc_control_volt_count',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'antenna_bt_calibration_coef1',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'antenna_bt_calibration_coef2',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'synthetic_bright_temp',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count1',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count2',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count3',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count4',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count5',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count6',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count7',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count8',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count9',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count10',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count11',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count12',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count13',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count14',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count15',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count16',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count17',channel)\n\tget_channel_txt(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count18',channel)\n\t\n\t\n\n\t\n\t\n\ttmphdf = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS()+ '.CH' +format(channel, '02d')+'.HDF'\n\tprint tmphdf\n\t# trans txt result to numpy fmt, to easy hdf create.\n\tdata_3day = numpy.loadtxt(tmpfile3day + '.txt', dtype='str', delimiter=',')\n\tdata_1month = numpy.loadtxt(tmpfile1month + '.txt', dtype='str', delimiter=',')\n\t\n\tdata_3day_calc = numpy.loadtxt(tmpfile3day_calc + '.txt', dtype='str', delimiter=',')\n\tdata_1month_calc = numpy.loadtxt(tmpfile1month_calc + '.txt', dtype='str', delimiter=',')\n\t\n\n\thfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_1month[:, 0]) )\n\thfile.create_dataset(\"time_1month\", data = ymdh_arr.astype(numpy.int32))\n\t\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n\thfile.create_dataset(\"time_1month_calc\", data = ymdh_arr.astype(numpy.int32))\n\t \n\tret = create_obc_hdf('1month',hfile,data_1month, ins_conf.obc_3dim_to_db_out.values())\n\tret = create_obc_hdf('1month',hfile,data_1month_calc, ins_conf.calc_3dim_to_db_out.values())\n\tif not ret:\n\t\treturn False\n\t\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_3day[:, 0]) )\n\thfile.create_dataset(\"time_3day\", data = ymdh_arr.astype(numpy.int32)) \n\t\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n\thfile.create_dataset(\"time_3day_calc\", data = ymdh_arr.astype(numpy.int32))\n\t\t\n\tret = create_obc_hdf('3day',hfile,data_3day, ins_conf.obc_3dim_to_db_out.values())\n\tret = create_obc_hdf('3day',hfile,data_3day_calc, ins_conf.calc_3dim_to_db_out.values())\n\tif not ret:\n\t\treturn False\n\t\n\t#hfile = h5.File(tmphdf, 'w') # w: rewrite if hdf already exist.\n\t#ymdh_arr = numpy.array(map(common.time_to_arr, data_1month_calc[:, 0]) )\n\t#hfile.create_dataset(\"time_1month_channel_calc\", data = ymdh_arr.astype(numpy.int32)) \n\t#ret = create_obc_hdf('1month',hfile,data_1month_calc, ins_conf.calc_3dim_to_db.values())\n\t#if not ret:\n\t#\treturn False\n\t\n\t#ymdh_arr = numpy.array(map(common.time_to_arr, data_3day_calc[:, 0]) )\n\t#hfile.create_dataset(\"time_3day_channel_calc\", data = ymdh_arr.astype(numpy.int32))\t \n\t#ret = create_obc_hdf('3day',hfile,data_3day_calc, ins_conf.calc_3dim_to_db.values())\n\t#if not ret:\n\t#\treturn False\n\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'agc_control_volt_count','agc_control_volt_count',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'antenna_bt_calibration_coef1','antenna_bt_calibration_scale',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'antenna_bt_calibration_coef2','antenna_bt_calibration_offset',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'synthetic_bright_temp','synthetic_bright_temp',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count1','Scan_warm_observation_counts1',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count2','Scan_warm_observation_counts2',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count3','Scan_warm_observation_counts3',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count4','Scan_warm_observation_counts4',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count5','Scan_warm_observation_counts5',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count6','Scan_warm_observation_counts6',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count7','Scan_warm_observation_counts7',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count8','Scan_warm_observation_counts8',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count9','Scan_warm_observation_counts9',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count10','Scan_warm_observation_counts10',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count11','Scan_warm_observation_counts11',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count12','Scan_warm_observation_counts12',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count13','Scan_cold_observation_counts1',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count14','Scan_cold_observation_counts2',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count15','Scan_cold_observation_counts3',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count16','Scan_cold_observation_counts4',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count17','Scan_cold_observation_counts5',hfile)\n\tcreate_1year_hdf_channel(tmpfile1year,tmpfilelife,'sp_it_cal_obs_count18','Scan_cold_observation_counts6',hfile)\n\t\n\t\n\n\thfile.close()\n\t\n\t#return \n\t\n\n\n\t# like: FY3C_MWTS_20140303_0259_TO_20140428_1159_12H_CH01_[PRT|INS_TEMP|...]\n\tpng_title = sat.upper() + '_' + ins.upper() + '_' \\\n\t\t\t\t+ begin_data[0]['ymdhms'].strftime(\"%Y%m%d\") + '_' \\\n\t\t\t\t+ begin_data[0]['ymdhms'].strftime(\"%H%M\") + '_TO_' \\\n\t\t\t\t+ datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d') \\\n\t\t\t\t+ '_' \\\n\t\t\t\t+ datetime.utcfromtimestamp(timespan['end_t']).strftime('%H%M') \\\n\t\t\t\t+ '_' \\\n\t\t\t\t+ format(int(hour_span), '02d') + 'H_CH' \\\n\t\t\t\t+ format(channel,'02d')\n\t\n\tret = draw_channel(tmphdf, format(channel,'02d'), png_title,begin_data[0]['ymdhms'].strftime(\"%Y%m%d\"),\\\n\t\t\t\t\t   datetime.utcfromtimestamp(timespan['end_t']).strftime('%Y%m%d'))\n\t\n\treturn True\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_channel", "data": "def draw_channel(tmphdf, channel, png_title, begin_time, end_time):\n\tcmd = []\n\tsds_len = len(conf.draw_ncl_new[ins]['ncl_prog_channel'])\n\tfor i in xrange(0, sds_len): \n\t\tfile_out = \"/home/fymonitor/MONITORFY3C/py2/plot/\" + png_title + '_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png']\n\t\tncl_name = \"/home/fymonitor/MONITORFY3C/py2/plot/\" + sat.upper() + '_' + ins.upper()+'_' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + '_4SUB.ncl'\n\t\ttemp_log = conf.tmp_path + '/monitor.' + log_tag + '.ch' + channel+'.' + conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] +'.log'\n\t\ttemp_cmd = conf.ncl + \" 'sat=\\\"\" + sat.upper() + \"\\\"' \" \\\n\t\t\t+ \"'instrument=\\\"\" + ins.upper() + \"\\\"' channel=\" + str(channel) \\\n\t\t\t+ \" 'file_in=\\\"\" + tmphdf + \"\\\"' \" \\\n\t\t\t+ \" 'file_out=\\\"\" + file_out + \"\\\"' \" \\\n\t\t\t+ \" 'file_title=\\\"\" + png_title + '_' +conf.draw_ncl_new[ins]['ncl_prog_channel'][i]['tmp_png'] + \"\\\"' \" +  ncl_name \\\n\t\t\t+ ' > ' + temp_log + ' 2>&1'\n\t\tprint temp_cmd\n\t\t\n\t\tcmd.append(temp_cmd)\n\n\t#print cmd\n\n\t#use map:16.6s ; not use map:44.52s\n\ttimeuse_begin = time.time()\n\t\n\tfor cmd_temp in cmd:\n\t\tprint cmd_temp\n\t\t(status, output) = commands.getstatusoutput(cmd_temp)\n\t\tcommon.debug(my_log, log_tag, str(status) + '`' + cmd_temp + '`' + output)\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "get_channel_txt", "data": "def get_channel_txt(tmpfile1year,tmpfilelife,type,channel):\n\t#now_time = datetime.datetime.now()\n\tnow_time = datetime.now()\n\t#yes_time = now_time + datetime.timedelta(days=(-365))\n\tyes_time = now_time + timedelta(days=(-365))\n\tlast_year = yes_time.strftime('%Y-%m-%d %H:%M:%S')\n\n\t#select * from FY3C_MWTS_DAILY order by ymdh desc limit 365;\n\tsql_1year = 'select * from FY3C_MWRI_DAILY_10 where type = \\''+type + \\\n\t\t\t\t'\\'' + ' and channel = ' + str(channel) +' and ymdh > ' + '\\'' +last_year + '\\'' + \\\n\t\t\t\tconf.export_txt%(tmpfile1year +'.' +type + '.txt')\n\n\tsql_life = 'select * from FY3C_MWRI_DAILY_10 where type = \\''+type + \\\n\t\t\t\t'\\''  + ' and channel = ' + str(channel)\\\n\t\t\t\t+ conf.export_txt%(tmpfilelife +'.' +type + '.txt')\n\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor(MySQLdb.cursors.DictCursor)\n\t\tconn.select_db(conf.db_setting['stat_db'])\t  \n\t\tcur.execute(sql_1year)\n\t\tcur.execute(sql_life)\n\t\tbegin_data = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\t# do NOT exit in thread!! To avoid zombie process.\n\t\tmsg = 'export channel date `Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1] \n\t\tprint msg\t\t\t \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\n\n\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "get_obc_txt", "data": "def get_obc_txt(tmpfile1year,tmpfilelife,type):\n\t#now_time = datetime.datetime.now()\n\tnow_time = datetime.now()\n\t#yes_time = now_time + datetime.timedelta(days=(-365))\n\tyes_time = now_time + timedelta(days=(-365))\n\tlast_year = yes_time.strftime('%Y-%m-%d %H:%M:%S')\n\t\n\t\n\t#select * from FY3C_MWTS_DAILY order by ymdh desc limit 365;\n\tsql_1year = 'select * from FY3C_MWRI_DAILY where type = \\''+type + \\\n\t\t\t\t'\\'' + ' and ymdh > ' + '\\'' +last_year + '\\'' + \\\n\t\t\t\tconf.export_txt%(tmpfile1year +'.' +type + '.txt')\n\tsql_life = 'select * from FY3C_MWRI_DAILY where type = \\''+type + '\\''\\\n\t\t\t\t+ conf.export_txt%(tmpfilelife +'.' +type + '.txt')\n\t\t\t\t\n\t#print sql_1year\n\t#print \"----------\"\n\t#print sql_life\n\n\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor(MySQLdb.cursors.DictCursor)\n\t\tconn.select_db(conf.db_setting['stat_db'])\t  \n\t\tcur.execute(sql_1year)\n\t\tcur.execute(sql_life)\n\t\tbegin_data = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\t# do NOT exit in thread!! To avoid zombie process.\n\t\tmsg = 'qqqdraw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1] \n\t\tprint msg\t\t\t \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "create_1year_hdf", "data": "def create_1year_hdf(tmpfile1year,tmpfilelife,type1,type,hfile):\n\tdata_1year = numpy.loadtxt(tmpfile1year +'.' +type1 + '.txt', dtype='str', delimiter=',')\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_1year[:, 0]) )\n\thfile.create_dataset(type+\"_time_1year\", data = ymdh_arr.astype(numpy.int32))\n\thfile.create_dataset(type+\"_avg_1year\",data=data_1year[: ,3].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_max_1year\",data=data_1year[: ,4].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_min_1year\",data=data_1year[: ,5].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_std_1year\",data=data_1year[: ,6].astype(numpy.float32)) \n\t\n\t\n\tdata_life = numpy.loadtxt(tmpfilelife +'.' +type1 + '.txt', dtype='str', delimiter=',')\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_life[:, 0]) )\n\thfile.create_dataset(type+\"_time_life\", data = ymdh_arr.astype(numpy.int32))\n\thfile.create_dataset(type+\"_avg_life\",data=data_life[: ,3].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_max_life\",data=data_life[: ,4].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_min_life\",data=data_life[: ,5].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_std_life\",data=data_life[: ,6].astype(numpy.float32)) \n\t  \n\treturn True\n\t\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "create_1year_hdf_channel", "data": "def create_1year_hdf_channel(tmpfile1year,tmpfilelife,type1,type,hfile):\n\tdata_1year = numpy.loadtxt(tmpfile1year +'.' +type1 + '.txt', dtype='str', delimiter=',')\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_1year[:, 0]) )\n\thfile.create_dataset(type+\"_time_1year\", data = ymdh_arr.astype(numpy.int32))\n\thfile.create_dataset(type+\"_avg_1year\",data=data_1year[: ,4].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_max_1year\",data=data_1year[: ,5].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_min_1year\",data=data_1year[: ,6].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_std_1year\",data=data_1year[: ,7].astype(numpy.float32)) \n\t\n\t\n\tdata_life = numpy.loadtxt(tmpfilelife +'.' +type1 + '.txt', dtype='str', delimiter=',')\n\tymdh_arr = numpy.array(map(common.time_to_arr, data_life[:, 0]) )\n\thfile.create_dataset(type+\"_time_life\", data = ymdh_arr.astype(numpy.int32))\n\thfile.create_dataset(type+\"_avg_life\",data=data_life[: ,4].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_max_life\",data=data_life[: ,5].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_min_life\",data=data_life[: ,6].astype(numpy.float32)) \n\thfile.create_dataset(type+\"_std_life\",data=data_life[: ,7].astype(numpy.float32)) \n\t  \n\treturn True\n\t \n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_just_obc", "data": "def draw_just_obc():\n\tif len(obc_table_3day) <= 0:\n\t\treturn True\n\tif len(obc_table_1month) <= 0:\n\t\treturn True\n\t\n\t\n\ttmpfile3day = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.3day' +'.obc'\n\tsql_3day = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n\t\t\t\t\t\t\t\t  obc_table_3day, conf.obc_select_prefix_sql) \\\n\t\t+ conf.export_txt%(tmpfile3day + '.txt')\n\tbegin_sql_3day = conf.obc_select_prefix_sql + ' 1 from ' + obc_table_3day[0] \\\n\t\t\t\t+ \" limit 1\"   \n\t\n\ttmpfile1month = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.1month' +'.obc'\n\tsql_1month = common.get_obc_2dim_sql(ins_conf.obc_to_db.values(),ins_conf.channels,\n\t\t\t\t\t\t\t\t  obc_table_1month, conf.obc_select_prefix_sql) \\\n\t\t+ conf.export_txt%(tmpfile1month + '.txt')\n\t\t\n\n\n\t\n\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor(MySQLdb.cursors.DictCursor)\n\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\t  \n\t\tcur.execute(sql_3day)\n\t\tcur.execute(sql_1month)\n\t\t\n\t\tcur.execute(begin_sql_3day)\n\t\tbegin_data = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\t# do NOT exit in thread!! To avoid zombie process.\n\t\t#print sql_3day\n\t\t#print \"------------------\"\n\t\t#print sql_1month\n\t\t#print \"------------------\"\n\t\t#print sql_3day_calc\n\t\t#print \"------------------\"\n\t\t#print sql_1month_calc\n\t\t#print \"------------------\"\n\t\t#print begin_sql_3day\n\t\t#print \"------------------\"\n\t\tmsg = '??draw obc 2-dim png`Mysql Fatal Error[' + str(e.args[0]) \\\n\t\t\t+ ']: ' + e.args[1] \n\t\tprint msg\t\t\t \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\treturn False\n\t\n \n\ttmpfile1year = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.1year' + '.obc'\n\ttmpfilelife = '/assimilation/fymonitor/DATA/TMP/' + my_tag + '.' + common.utc_YmdHMS() +'.life' + '.obc'\n\n\t\n\tsds_len = len(ins_conf.sds_name)\n\tfor i in xrange(1, sds_len+1):\n\t\tget_obc_txt(tmpfile1year,tmpfilelife,ins_conf.sds_name[i]['name'])\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_nochannel", "data": "def draw_nochannel(tmphdf, png_title, begin_time, end_time):\t\n\tcmd = []\n\tsds_len = len(conf.draw_ncl_new[ins]['ncl_prog_no_channel'])\n\tfor i in xrange(0, sds_len): \n\t\tfile_out = conf.plot_path + '/'+ png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png']\n\t\tfile_title = png_title + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png']\n\t\tncl_name = conf.plot_path +'/' + sat.upper() +'_' + ins.upper() +'_'+ conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] + '_4SUB.ncl'\n\t\ttemp_log = conf.tmp_path + '/monitor.' + log_tag +'.' + conf.draw_ncl_new[ins]['ncl_prog_no_channel'][i]['tmp_png'] +'.log'\n\t\ttemp_cmd = conf.ncl + \" 'sat=\\\"\" + sat.upper() + \"\\\"' \" \\\n\t\t\t+ \"'instrument=\\\"\" + ins.upper() + \"\\\"\" +'\\'' \\\n\t\t\t+ \" 'file_in=\\\"\" + tmphdf + \"\\\"' \" \\\n\t\t\t+ \" 'file_out=\\\"\" + file_out + \"\\\"' \" \\\n\t\t\t+ \" 'file_title=\\\"\" + file_title + \"\\\"' \" +  ncl_name \\\n\t\t\t+ ' > ' + temp_log + ' 2>&1'\n\t\tprint temp_cmd\n\t\tcmd.append(temp_cmd)\n\n\t#print cmd\n \n\ttimeuse_begin = time.time()\n\t\n\tfor cmd_temp in cmd:\n\t\tprint cmd_temp\n\t\t(status, output) = commands.getstatusoutput(cmd_temp)\n\t\tcommon.debug(my_log, log_tag, str(status) + '`' + cmd_temp + '`' + output)\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "draw_obc", "data": "def draw_obc(input):\n", "description": null, "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}, {"term": "def", "name": "main", "data": "def main():\n\tglobal my_channel_table\n\tglobal my_Calc_channel_table\n\tglobal my_obc_table\n\tglobal my_Calc_table\n\t\n\tcommon.wt_file(my_pidfile, str(pid))\n\tcommon.info(my_log, log_tag, time_tag + 'program start')\n\n\t# register signal function.\n\tsignal.signal(signal.SIGTERM, signal_handler)   \n\tsignal.signal(signal.SIGINT, signal_handler)\t  \n\t\n\t# check ps result, kill previous same program, avoiding hang.\n\t# we do NOT grep --date=2014-04-27-18 for convenience.\n\tcmd = conf.ps + ' -elf | ' + conf.grep + ' ' + conf.bin_path + ' | ' \\\n\t\t+ conf.grep + ' -v grep | ' + conf.grep + ' -v tail | ' + conf.grep \\\n\t\t+ ' -v bash | ' + conf.grep + ' ' + fname + ' | ' + conf.grep \\\n\t\t+ \" '\\-\\-sat=\" + sat + \"' | \" + conf.grep + \" '\\-\\-ins=\" + ins \\\n\t\t+ \"' | \" + conf.grep + \" '\\-\\-span=\" + hour_span + \"' | \" \\\n\t\t+ conf.awk + \" '{print $4}'\"\n\t(status, value) = commands.getstatusoutput(cmd)\n\tpid_list = value.split()\n\tfor one_pid in pid_list:\n\t\tif int(one_pid) != pid:\n\t\t\tmsg = 'more then one prog find, kill old same prog[' + one_pid + ']'\n\t\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\t\tcmd = conf.kill + ' -kill ' + one_pid\n\t\t\tcommands.getstatusoutput(cmd)\n\t\n\t#get the correct tables. we MUST get table name from INFO db, not show tables!!\n\t\"\"\"\n\tWe MUST create fy3b-mwts table's info, for easy time search\n\talso, there is a BUG... ...\n\t\"\"\"\n\ttry:\n\t\tconn=MySQLdb.connect(host=conf.db_setting['master']['ip'], \n\t\t\t\t\t\t\t user=conf.db_setting['master']['user'],\n\t\t\t\t\t\t\t passwd=conf.db_setting['master']['pwd'], \n\t\t\t\t\t\t\t port=conf.db_setting['master']['port'])\n\t\tcur=conn.cursor()\n\t\tconn.select_db(conf.table_setting[sat][ins]['data_db'])\n\t\tcur.execute('show tables') # the result is already sorted by ascii.\n\t\tall_tables = cur.fetchall()\n\t\tcur.close()\n\t\tconn.close()\n\texcept MySQLdb.Error, e:\n\t\tmsg = 'Mysql Fatal Error[' + str(e.args[0])+']: '+e.args[1] \n\t\tcommon.err(my_log, log_tag, time_tag + msg)\n\t\tsys.exit(3)\n\t\t\n\t# ignore L1B table.\n\tall_obc_table = [ x for x in all_tables if 'OBCXX_MS' in x[0] ]\n\t\n\tCalc_tag = 'OBCXX_MS_CALC'\n\tCalc_channel_tag='OBCXX_MS_CALC_'\n\tCalc_table = [ x for x in all_obc_table if Calc_tag in x[0]]\n\tCalc_channel_table=[ x for x in Calc_table if Calc_channel_tag in x[0]]\n\tCalc_table =[ x for x in Calc_table if Calc_channel_tag not in x[0]]\n\t\n\tchannel_tag = 'OBCXX_MS_' + str(ins_conf.channels)\n\tchannel_table = [ x for x in all_obc_table if channel_tag in x[0]]\n\tchannel_table=list(set(channel_table).difference(set(Calc_table)).difference(set(Calc_channel_table)))\n\t\n\tobc_table = list(set(all_obc_table).difference(set(Calc_table)).difference(set(channel_table)).difference(set(Calc_channel_table))) #return in all_obc_table but no in channel_table\n\t#print obc_table\n\t#print \"-------------------------\"\n\t#print Calc_table\n\t#print \"-------------------------\"\n\t#print channel_table\n\t#print \"-------------------------\"\n\t#print Calc_channel_table\n\n\n\tfor idx, one_table in enumerate(Calc_table):\n\t\ttable_t = one_table[0][19:32] # FY3B_MWTSX_GBAL_L1_20131123_0501_060KM_MS\n\t\ttimeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n\t\tcur_timeStamp = time.mktime(timeArray)\n\t\tif idx < len(all_tables) - 1:\n\t\t\ttable_t = all_tables[idx+1][0][19:32]\n\t\t\ttimeArray = time.strptime(table_t, \"%Y%m%d_%H%M\")\n\t\t\tnext_timeStamp = time.mktime(timeArray)\n\t\telse:\n\t\t\ttimeArray = time.strptime('3013-12-08 00:00', \"%Y-%m-%d %H:%M\")\n\t\t\tnext_timeStamp = time.mktime(timeArray)\n\t\t\n\t\tif timespan['begin_t'] == cur_timeStamp:\n\t\t\tmy_Calc_table.extend([one_table[0]])\n\t\telif timespan['begin_t'] > cur_timeStamp \\\n\t\t\tand timespan['begin_t'] < next_timeStamp:\n\t\t\tmy_Calc_table.extend([one_table[0]])\n\t\telif timespan['begin_t'] < cur_timeStamp \\\n\t\t\tand timespan['end_t'] > cur_timeStamp:\n\t\t\tmy_Calc_table.extend([one_table[0]])\n\t\telif timespan['end_t'] == cur_timeStamp:\n\t\t\tbreak\n\t\t\t\n\tif len(my_Calc_table)<=0:\n\t\tmsg = time_tag + 'no table found for my_Calc_table data'\n\t\tcommon.warn(my_log, log_tag, msg)\n\t\t\n\t#now_time = datetime.datetime.now()\n\tnow_time = datetime.now() - timedelta(days = 3)\n\tshifen = now_time.strftime(\"%H%M\")\n\t\n\tif int(shifen)< 0030:\n\t\tfor i in range(0, 3):\n\t\t\tyes_time = now_time + datetime.timedelta(days=(-3 + i))\n\t\t\tymd = yes_time.strftime('%Y%m%d')\n\t\t\tymd = '201410'+ymd[6:8]\n\t\t\tfor idx, one_table in enumerate(my_channel_table):\n\t\t\t\tif ymd in one_table:\n\t\t\t\t\tCalc_table_3day.extend([one_table])\n\telse:\n\t\tfor i in range(0, 3):\n\t\t\t#yes_time = now_time + datetime.timedelta(days=(-2 + i))\n\t\t\tyes_time = now_time + timedelta(days=(-2 + i))\n\t\t\tymd = yes_time.strftime('%Y%m%d')\n\t\t\tymd = '201410'+ymd[6:8]\n\t\t\tfor idx, one_table in enumerate(my_Calc_table):\n\t\t\t\tif ymd in one_table:\n\t\t\t\t\tCalc_table_3day.extend([one_table])\n   \n\tfor i in range(0, 30):\n\t\t#yes_time = now_time + datetime.timedelta(days=(-30 + i))\n\t\tyes_time = now_time + timedelta(days=(-30 + i))\n\t\tymd = yes_time.strftime('%Y%m%d')\n\t\tymd = '201410'+ymd[6:8]\n\t\tfor idx, one_table in enumerate(my_Calc_table):\n\t\t\tif ymd in one_table:\n\t\t\t\tCalc_table_1month.extend([one_table])\n\n", "description": "\n\tWe MUST create fy3b-mwts table's info, for easy time search\n\talso, there is a BUG... ...\n\t", "category": "math", "imports": ["import os", "import sys", "import time", "import numpy", "import signal", "import commands", "import warnings", "import MySQLdb", "import h5py as h5", "import shutil", "#import datetime", "#from datetime import *", "from datetime import datetime", "from datetime import timedelta", "from multiprocessing import Pool", "from multiprocessing.dummy import Pool as ThreadPool ", "conf = __import__('conf')", "common = __import__('common')", "docopt = __import__('docopt')", "ins_conf = __import__(ins_conf_file)"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "class", "name": "classSolution:", "data": "class Solution:\n\tdef calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n\n\t\tcalc_results = defaultdict(lambda: {})\n\t\tfor i in range(len(equations)):\n\t\t\tnumerator, denominator = equations[i]\n\t\t\tcalc_results[numerator][denominator] = values[i]\n\t\t\tcalc_results[denominator][numerator] = 1 / values[i]\n\t\t\tcalc_results[denominator][denominator] = 1\n\t\t\tcalc_results[numerator][numerator] = 1\n\n\t\tdef calc(n, d, path):\n\t\t\t# print('{} {} {}'.format(n,d, path))\n\t\t\tif n in calc_results and d in calc_results:\n\t\t\t\tif d in calc_results[n]:\n\t\t\t\t\treturn calc_results[n][d]\n\t\t\t\telse:\n\t\t\t\t\tfor candidate in calc_results[n]:\n\t\t\t\t\t\tif candidate not in path:\n\t\t\t\t\t\t\tval = calc(candidate, d, path + [candidate])\n\t\t\t\t\t\t\tif val != -1:\n\t\t\t\t\t\t\t\treturn calc_results[n][candidate] * val\n\t\t\t\t\treturn -1\n\t\t\telse:\n\t\t\t\treturn -1\n\n\t\tans = []\n\t\tfor q in queries:\n\t\t\tfound = False\n\t\t\tn, d = q[0], q[1]\n\t\t\tans.append(calc(n, d, [n]))\n\n", "description": null, "category": "math", "imports": ["from collections import defaultdict"]}], [{"term": "class", "name": "classSolution:", "data": "class Solution:\n\tdef calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n\n\t\tcalc_results = defaultdict(lambda: {})\n\t\tfor i in range(len(equations)):\n\t\t\tnumerator, denominator = equations[i]\n\t\t\tcalc_results[numerator][denominator] = values[i]\n\t\t\tcalc_results[denominator][numerator] = 1 / values[i]\n\t\t\tcalc_results[denominator][denominator] = 1\n\t\t\tcalc_results[numerator][numerator] = 1\n\n\t\tdef calc(n, d, path):\n\t\t\t# print('{} {} {}'.format(n,d, path))\n\t\t\tif n in calc_results and d in calc_results:\n\t\t\t\tif d in calc_results[n]:\n\t\t\t\t\treturn calc_results[n][d]\n\t\t\t\telse:\n\t\t\t\t\tfor candidate in calc_results[n]:\n\t\t\t\t\t\tif candidate not in path:\n\t\t\t\t\t\t\tval = calc(candidate, d, path + [candidate])\n\t\t\t\t\t\t\tif val != -1:\n\t\t\t\t\t\t\t\treturn calc_results[n][candidate] * val\n\t\t\t\t\treturn -1\n\t\t\telse:\n\t\t\t\treturn -1\n\n\t\tans = []\n\t\tfor q in queries:\n\t\t\tfound = False\n\t\t\tn, d = q[0], q[1]\n\t\t\tans.append(calc(n, d, [n]))\n\n", "description": null, "category": "math", "imports": ["from collections import defaultdict"]}], [{"term": "class", "name": "ScenarioDamageTestCase", "data": "class ScenarioDamageTestCase(CalculatorTestCase):\n\n\tdef assert_ok(self, pkg, job_ini, exports='csv', kind='damages'):\n\t\ttest_dir = os.path.dirname(pkg.__file__)\n\t\tout = self.run_calc(test_dir, job_ini, exports=exports)\n\t\ttry:\n\t\t\tgot = out['%s-rlzs' % kind, exports]\n\t\texcept KeyError:  # in case_5a\n\t\t\tgot = out['%s-stats' % kind, exports]\n\t\texpected_dir = os.path.join(test_dir, 'expected')\n\t\texpected = sorted(f for f in os.listdir(expected_dir)\n\t\t\t\t\t\t  if f.endswith(exports) and 'by_taxon' not in f)\n\t\tself.assertEqual(len(got), len(expected))\n\t\tfor fname, actual in zip(expected, got):\n\t\t\tself.assertEqualFiles('expected/%s' % fname, actual, delta=1E-5)\n\n\tdef test_case_1(self):\n\t\t# test with a single event and a missing tag\n\t\tself.assert_ok(case_1, 'job_risk.ini')\n\t\tview('num_units', self.calc.datastore)\n\n\t\t# test agg_damages, 1 realization x 3 damage states\n\t\t[dmg] = extract(self.calc.datastore, 'agg_damages/structural?'\n\t\t\t\t\t\t'taxonomy=RC&CRESTA=01.1')\n\t\taac([1482., 489., 29.], dmg, atol=1E-4)\n\t\t# test no intersection\n\t\tdmg = extract(self.calc.datastore, 'agg_damages/structural?'\n\t\t\t\t\t  'taxonomy=RM&CRESTA=01.1')\n\t\tself.assertEqual(dmg.shape, ())\n\n\t\t# missing fragility functions\n\t\twith self.assertRaises(InvalidFile) as ctx:\n\t\t\tself.run_calc(case_1.__file__, 'job_bad.ini')\n\t\tself.assertIn('Missing fragility files', str(ctx.exception))\n\n\tdef test_case_1c(self):\n\t\t# this is a case with more hazard sites than exposure sites\n\t\t# it is also a case with asset numbers > 65535 and < 1\n\t\t# and also a case with modal_damage_state\n\t\ttest_dir = os.path.dirname(case_1c.__file__)\n\t\tself.run_calc(test_dir, 'job.ini', exports='csv')\n\n\t\t# check damages-rlzs\n\t\t[fname] = export(('damages-rlzs', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/' + strip_calc_id(fname), fname)\n\t\tdf = self.calc.datastore.read_df('damages-rlzs', 'asset_id')\n\t\tself.assertEqual(list(df.columns),\n\t\t\t\t\t\t ['rlz', 'loss_type', 'dmg_state', 'value'])\n\n\t\t# check risk_by_event\n\t\t[fname] = export(('risk_by_event', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/' + strip_calc_id(fname), fname,\n\t\t\t\t\t\t\t  delta=1E-5)\n\n\t\t# check agg_damages extraction\n\t\ttotal = extract(self.calc.datastore, 'agg_damages/structural')\n\t\taac(total, [[37312.8, 30846.1, 4869.6, 1271.5, 5700.7]], atol=.1)\n\n\t\t# check extract gmf_data works with a filtered site collection\n\t\tgmf_data = dict(extract(self.calc.datastore, 'gmf_data'))\n\t\tself.assertEqual(gmf_data['rlz-000'].shape, (2,))  # 2 assets\n\n\tdef test_case_2(self):\n\t\tself.assert_ok(case_2, 'job_risk.ini')\n\n\tdef test_case_3(self):\n\t\tself.assert_ok(case_3, 'job_risk.ini')\n\n\tdef test_case_4(self):\n\t\tself.assert_ok(case_4, 'job_haz.ini,job_risk.ini')\n\n\tdef test_case_4b(self):\n\t\t# sensitive to shapely version\n\t\tself.run_calc(case_4b.__file__, 'job_haz.ini,job_risk.ini')\n\n\t\t[fname] = export(('risk_by_event', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/' + strip_calc_id(fname), fname,\n\t\t\t\t\t\t\t  delta=5E-4)\n\n\t\treturn  # TODO: fix avg_losses\n\t\tfnames = export(('avg_losses-rlzs', 'csv'), self.calc.datastore)\n\t\tself.assertEqual(len(fnames), 2)  # one per realization\n\t\tfor fname in fnames:\n\t\t\tself.assertEqualFiles('expected/' + strip_calc_id(fname), fname,\n\t\t\t\t\t\t\t\t  delta=2E-4)\n\n\tdef test_wrong_gsim_lt(self):\n\t\twith self.assertRaises(InvalidFile) as ctx:\n\t\t\tself.run_calc(os.path.dirname(case_4b.__file__), 'job_err.ini')\n\t\tself.assertIn('must contain a single branchset, found 2!',\n\t\t\t\t\t  str(ctx.exception))\n\n\tdef test_case_5(self):\n\t\t# this is a test for the rupture filtering\n\t\t# NB: the exposure file is imported twice on purpose, to make\n\t\t# sure that nothing changes; the case is very tricky since the\n\t\t# hazard site collection is filtered by the maximum_distance,\n\t\t# there is no region_constraint in hazard and there is in risk\n\t\tself.assert_ok(case_5, 'job_haz.ini,job_risk.ini')\n\n\tdef test_case_5a(self):\n\t\t# this is a case with two gsims and one asset\n\t\tself.assert_ok(case_5a, 'job_haz.ini,job_risk.ini')\n\t\tdmg = extract(self.calc.datastore, 'agg_damages/structural?taxonomy=*')\n\t\tself.assertEqual(dmg.array.shape, (1, 2, 5))  # (T, R, D)\n\t\taac(dmg.array[0].sum(axis=0),\n\t\t\t[0.72431, 0.599795, 0.292081, 0.15108, 0.232734], atol=1E-5)\n\n\tdef test_case_6(self):\n\t\t# this is a case with 5 assets on the same point\n\t\tself.assert_ok(case_6, 'job_h.ini,job_r.ini')\n\t\tdmg = extract(self.calc.datastore, 'agg_damages/structural?taxonomy=*')\n\t\ttmpname = write_csv(None, dmg, fmt='%.5E')  # (T, R, D) == (5, 1, 5)\n\t\tself.assertEqualFiles('expected/dmg_by_taxon.csv', tmpname,\n\t\t\t\t\t\t\t  delta=1E-5)\n\n\tdef test_case_7(self):\n\t\t# this is a case with three loss types\n\t\tself.assert_ok(case_7, 'job_h.ini,job_r.ini', exports='csv')\n\n\t\t# just run the npz export\n\t\t[npz] = export(('damages-rlzs', 'npz'), self.calc.datastore)\n\t\tself.assertEqual(strip_calc_id(npz), 'damages-rlzs.npz')\n\n\t\t# check the risk_by_event is readable by pandas\n\t\tK = self.calc.datastore.get_attr('risk_by_event', 'K')\n\t\tdf = self.calc.datastore.read_df(\n\t\t\t'risk_by_event', ['event_id', 'loss_id', 'agg_id'],\n\t\t\tdict(agg_id=K))\n\t\tself.assertEqual(len(df), 300)\n\t\tself.assertEqual(len(df[df.dmg_1 > 0]), 76)  # only 76/300 are nonzero\n\n\tdef test_case_8(self):\n\t\t# case with a shakemap\n\t\tself.run_calc(case_8.__file__, 'prejob.ini')\n\t\tself.run_calc(case_8.__file__, 'job.ini',\n\t\t\t\t\t  hazard_calculation_id=str(self.calc.datastore.calc_id))\n\t\t[fname] = export(('risk_by_event', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/risk_by_event.csv', fname)\n\n\tdef test_case_9(self):\n\t\t# case with noDamageLimit==0 that had NaNs in the past\n\t\tself.run_calc(case_9.__file__, 'job.ini')\n\n\t\t[fname] = export(('damages-stats', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/damages.csv', fname, delta=2E-5)\n\n\t\t# check risk_by_event\n\t\tK = self.calc.datastore.get_attr('risk_by_event', 'K')\n\t\tdf = self.calc.datastore.read_df('risk_by_event', 'event_id',\n\t\t\t\t\t\t\t\t\t\t {'agg_id': K})\n\t\tdmg = df.loc[1937]  # damage caused by the event 1937\n\t\tself.assertEqual(dmg.dmg_1.sum(), 49)\n\t\tself.assertEqual(dmg.dmg_2.sum(), 62)\n\t\tself.assertEqual(dmg.dmg_3.sum(), 42)\n\t\tself.assertEqual(dmg.dmg_4.sum(), 25)\n\n\t\t[fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/aggrisk.csv', fname, delta=1E-4)\n\n\tdef test_case_10(self):\n\t\tself.run_calc(case_10.__file__, 'job.ini')\n\t\tself.assertTrue(self.calc.nodamage)\n\n\tdef test_case_11(self):\n\t\t# secondary perils without secondary simulations\n\t\tself.run_calc(case_11.__file__, 'job.ini',\n\t\t\t\t\t  secondary_simulations=\"{}\")\n\t\tcalc1 = self.calc.datastore\n\t\t[fname] = export(('risk_by_event', 'csv'), calc1)\n\t\tself.assertEqualFiles('expected/risk_by_event_1.csv', fname)\n\n\t\t# secondary perils with secondary simulations\n\t\tself.run_calc(case_11.__file__, 'job.ini')\n\t\tcalc2 = self.calc.datastore\n\t\t[fname] = export(('risk_by_event', 'csv'), calc2)\n\t\tself.assertEqualFiles('expected/risk_by_event_2.csv', fname)\n\n\t\t# check mean_perils\n\t\tfname = gettemp(text_table(view('mean_perils', self.calc.datastore)))\n\t\tself.assertEqualFiles('expected/mean_perils.rst', fname)\n\n\t\t# check damages-rlzs\n\t\t[fname] = export(('damages-rlzs', 'csv'), calc1)\n\t\tself.assertEqualFiles('expected/avg_damages1.csv', fname)\n\t\t[fname] = export(('damages-rlzs', 'csv'), calc2)\n\t\tself.assertEqualFiles('expected/avg_damages2.csv', fname)\n\n\tdef test_case_12(self):\n\t\t# secondary perils from rupture\n\t\tself.run_calc(case_12.__file__, 'job.ini')\n\t\t[fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/aggrisk.csv', fname)\n\t\thc_id = str(self.calc.datastore.calc_id)\n\n\t\t# same with discrete damage distribution\n\t\tself.run_calc(case_12.__file__, 'job.ini',\n\t\t\t\t\t  discrete_damage_distribution='true',\n\t\t\t\t\t  hazard_calculation_id=hc_id)\n\t\t[fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/aggrisk2.csv', fname)\n\n\tdef test_case_13(self):\n\t\t# 3 realizations and consequences\n\t\tself.run_calc(case_13.__file__, 'job.ini')\n\t\t[fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/aggrisk.csv', fname)\n\t\t[fname] = export(('aggrisk-stats', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/aggrisk-stats.csv', fname)\n\n\tdef test_case_14(self):\n\t\t# inconsistent IDs between fragility and consequence\n\t\twith self.assertRaises(NameError) as ctx:\n\t\t\tself.run_calc(case_14.__file__, 'job.ini')\n\t\tself.assertIn(\n\t\t\t\"['CR+PC/LDUAL/HBET:8.19/m', 'CR+PC/LDUAL/HBET:8.19/m ']\",\n\t\t\tstr(ctx.exception))\n\n\tdef test_case_15(self):\n\t\t# infrastructure risk\n\t\tself.run_calc(case_15.__file__, 'job.ini')\n\t\tnodes = self.calc.datastore.read_df('functional_demand_nodes')\n\t\tgot = dict(zip(nodes.id, nodes.number))\n\t\texpected = {'D1': 38, 'D10': 24, 'D11': 24, 'D12': 22, 'D2': 38,\n\t\t\t\t\t'D3': 38, 'D4': 38, 'D5': 39, 'D6': 39, 'D7': 25,\n\t\t\t\t\t'D8': 24, 'D9': 25}\n\t\tself.assertEqual(got, expected)\n\n", "description": null, "category": "math", "imports": ["import os", "import numpy", "from openquake.hazardlib import InvalidFile", "from openquake.baselib.writers import write_csv", "from openquake.baselib.general import gettemp", "from openquake.qa_tests_data.scenario_damage import (", "from openquake.calculators.tests import CalculatorTestCase, strip_calc_id", "from openquake.calculators.extract import extract", "from openquake.calculators.export import export", "from openquake.calculators.views import view, text_table", "\t\t# NB: the exposure file is imported twice on purpose, to make"]}, {"term": "def", "name": "losses", "data": "def losses(aid, alt):\n\tE = len(alt.event_id.unique())\n\tlosses = numpy.zeros(E, int)\n\tdf = alt.loc[aid]\n\tlosses[df.event_id.to_numpy()] = df.loss.to_numpy()\n\treturn losses\n", "description": null, "category": "math", "imports": ["import os", "import numpy", "from openquake.hazardlib import InvalidFile", "from openquake.baselib.writers import write_csv", "from openquake.baselib.general import gettemp", "from openquake.qa_tests_data.scenario_damage import (", "from openquake.calculators.tests import CalculatorTestCase, strip_calc_id", "from openquake.calculators.extract import extract", "from openquake.calculators.export import export", "from openquake.calculators.views import view, text_table", "\t\t# NB: the exposure file is imported twice on purpose, to make"]}], [{"term": "def", "name": "click", "data": "def click(num):\r\n\tglobal op\r\n\top=op+str(num)\r\n", "description": null, "category": "math", "imports": ["from tkinter import *\r"]}, {"term": "def", "name": "evaluate", "data": "def evaluate():\r\n\tglobal op\r\n\toutput=str(eval(op))\r\n", "description": null, "category": "math", "imports": ["from tkinter import *\r"]}, {"term": "def", "name": "clearDisplay", "data": "def clearDisplay():\r\n\tglobal op\r\n\top=\"\"\r\n", "description": null, "category": "math", "imports": ["from tkinter import *\r"]}], [{"term": "class", "name": "CalcRecord", "data": "class CalcRecord():\n\t\"\"\"\n\t\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u7528\u306e\u8981\u7d20\u683c\u7d0d\u30af\u30e9\u30b9\n\t\"\"\"\n\tdef __init__(self, a,b,c,d,op1,op2,op3):\n\t\tself.a = a\n\t\tself.b = b\n\t\tself.c = c\n\t\tself.d = d\n\t\tself.op1 = op1\n\t\tself.op2 = op2\n\t\tself.op3 = op3\n\t\tself.result = -1\n\n\tdef print(self):\n\t\tprint(\"{0} {1} {2} {3} {4} {5} {6} {7}\".format(\n\t\t\tself.a,\n\t\t\tself.b,\n\t\t\tself.c,\n\t\t\tself.d,\n\t\t\tself.op1,\n\t\t\tself.op2,\n\t\t\tself.op3,\n\t\t\tself.result\n\t\t))\n\n", "description": "\n\t\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u7528\u306e\u8981\u7d20\u683c\u7d0d\u30af\u30e9\u30b9\n\t", "category": "math", "imports": ["import copy", "import time"]}, {"term": "def", "name": "main", "data": "def main():\n\n\tt1 = time.time() \n\texist_count = 0\n\t# src_list, count = calc_puzle(1, 3, 3, 7, detail_print = True)\n\t# src_list, count = calc_puzle(4, 6, 7, 9, detail_print = True)\n\t# if count > 0:\n\t#\t exist_count += 1\n\t# print(\"{0} count = {1}\".format(src_list, count))\n\t#\n\t#\u6570\u5b57\u306e\u91cd\u8907\u3092\u7701\u304f\n\t#(1,2,3,1) === (1,1,2,3)\n\tfor a in range(0, 10):\n\t\tfor b in range(a, 10):\n\t\t\tfor c in range(b, 10):\n\t\t\t\tfor d in range(c, 10):\n\t\t\t\t\tsrc_list, count = calc_puzle(a, b, c, d, detail_print = False)\n\t\t\t\t\tprint(\"{0} count = {1}\".format(src_list, count))\n\t\t\t\t\tif count > 0:\n\t\t\t\t\t\texist_count += 1\n\n\tprint(\"\u6210\u7acb\u500b\u6570\uff1a{0}\".format(exist_count))\n\tt2 = time.time()\n\tprint(\"\u5b9f\u884c\u6642\u9593\uff1a{0}\".format(t2-t1))\n", "description": null, "category": "math", "imports": ["import copy", "import time"]}, {"term": "def", "name": "calc_puzle", "data": "def calc_puzle(a,b,c,d, detail_print = False):\n\t\"\"\"\n\turban hacks\u89e3\u6cd5\u7dcf\u5f53\u308a\u8a08\u7b97\n\t\"\"\"\n\tans_count = 0\n\t#\u554f\u984c\u6587\u6570\u5b57\u30ea\u30b9\u30c8\n\tsrc_nums = [str(a), str(b), str(c), str(d)]\n\n\t#\u6f14\u7b97\u5b50\u30ea\u30b9\u30c8\n\top_list = [\"+\", \"-\", \"*\", \"/\"]\n\n\t#\u9806\u5217\u30db\u30eb\u30c0\u30fc\n\tnums_holder = [0] * len(src_nums)\n\n\t#\u5168\u9806\u5217\u683c\u7d0d\u7528\u30ea\u30b9\u30c8\n\tresult_list = []\n\n\t#\u9806\u5217\u3092\u4f5c\u6210\u3059\u308b\n\tmake_permutation(src_nums, 0, len(src_nums), nums_holder, result_list)\n\n\t#\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u5f0f\u8981\u7d20\u5168\u9806\u5217\u683c\u7d0d\u7528\u30ea\u30b9\u30c8\n\tcalc_list = []\n\n\t#\u6f14\u7b97\u5b50\u306e\u9806\u5217\u3092\u4f5c\u6210\u3057\u3001\u6570\u5217\u3068\u7d44\u307f\u5408\u308f\u305b\u3066\n\t#\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u5f0f\u8981\u7d20\u5168\u9806\u5217\u3092\u4f5c\u6210\u3059\u308b\n\tfor i in result_list:\n\t\tfor op1 in op_list:\n\t\t\tfor op2 in op_list:\n\t\t\t\tfor op3 in op_list:\n\t\t\t\t\tcalc_list.append(CalcRecord(\n\t\t\t\t\t\ti[0],\n\t\t\t\t\t\ti[1],\n\t\t\t\t\t\ti[2],\n\t\t\t\t\t\ti[3],\n\t\t\t\t\t\top1,\n\t\t\t\t\t\top2,\n\t\t\t\t\t\top3\n\t\t\t\t\t))\n\n\tcalc_work = []\n\n\n\t#\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u5f0f\u8981\u7d20\u5168\u9806\u5217\u3088\u308a4\u30d1\u30bf\u30fc\u30f3\u306e\n\t#\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5f0f\u3092\u8a08\u7b97\u3057\u7b54\u3048\u3092\u6c42\u3081\u308b\n\tfor cur_calc in calc_list:\n\t\tcalc_work.clear()\n\t\t#\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5f0f1\n\t\t# A B op1 C D op2 op3\n\t\t# (A op1 B) op3 (C op2 D)\n\t\t\n\t\tcalc_work.append(cur_calc.a)\n\t\tcalc_work.append(cur_calc.b)\n\t\texec_revpol(cur_calc.op1, calc_work)\n\t\tcalc_work.append(cur_calc.c)\n\t\tcalc_work.append(cur_calc.d)\n\t\texec_revpol(cur_calc.op2, calc_work)\n\t\texec_revpol(cur_calc.op3, calc_work)\n\t\tcur_calc.result = calc_work.pop()\n\n\t\t# print_formula(cur_calc, \"F1\")\n\t\tif 10 == cur_calc.result:\n\t\t\tans_count += 1\n\t\t\tif detail_print:\n\t\t\t\tprint_formula(cur_calc, \"F1\")\n\t\t\t# return [src_nums, ans_count]\n\n\t\tcalc_work.clear()\n\t\t#\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5f0f2\n\t\t# A B op1 C op2 D op3\n\t\t# ((A op1 B) op2 C) op3 D\n\t\tcalc_work.append(cur_calc.a)\n\t\tcalc_work.append(cur_calc.b)\n\t\texec_revpol(cur_calc.op1, calc_work)\n\t\tcalc_work.append(cur_calc.c)\n\t\texec_revpol(cur_calc.op2, calc_work)\n\t\tcalc_work.append(cur_calc.d)\n\t\texec_revpol(cur_calc.op3, calc_work)\n\t\tcur_calc.result = calc_work.pop()\n\n\t\t# print_formula(cur_calc, \"F2\")\n\t\tif 10 == cur_calc.result:\n\t\t\tans_count += 1\n\t\t\tif detail_print:\n\t\t\t\tprint_formula(cur_calc, \"F2\")\n\t\t\t# return [src_nums, ans_count]\n\n\t\tcalc_work.clear()\n\t\t#\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5f0f3\n\t\t# A B C op1 op2 D op3\n\t\t# (A op2 (B op1 C)) op3 D\n\t\tcalc_work.append(cur_calc.a)\n\t\tcalc_work.append(cur_calc.b)\n\t\tcalc_work.append(cur_calc.c)\n\t\texec_revpol(cur_calc.op1, calc_work)\n\t\texec_revpol(cur_calc.op2, calc_work)\n\t\tcalc_work.append(cur_calc.d)\n\t\texec_revpol(cur_calc.op3, calc_work)\n\t\tcur_calc.result = calc_work.pop()\n\n\t\t# print_formula(cur_calc, \"F3\")\n\t\tif 10 == cur_calc.result:\n\t\t\tans_count += 1\n\t\t\tif detail_print:\n\t\t\t\tprint_formula(cur_calc, \"F3\")\n\t\t\t# return [src_nums, ans_count]\n\n\t\tcalc_work.clear()\n\t\t#\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5f0f4\n\t\t# A B C D op1 op2 op3\n\t\t# A op3 (B op2 (C op1 D))\n\t\tcalc_work.append(cur_calc.a)\n\t\tcalc_work.append(cur_calc.b)\n\t\tcalc_work.append(cur_calc.c)\n\t\tcalc_work.append(cur_calc.d)\n\t\texec_revpol(cur_calc.op1, calc_work)\n\t\texec_revpol(cur_calc.op2, calc_work)\n\t\texec_revpol(cur_calc.op3, calc_work)\n\t\tcur_calc.result = calc_work.pop()\n\n\t\t# print_formula(cur_calc, \"F4\")\n\t\tif 10 == cur_calc.result:\n\t\t\tans_count += 1\n\t\t\tif detail_print:\n\t\t\t\tprint_formula(cur_calc, \"F4\")\n\t\t\t# return [src_nums, ans_count]\n\treturn [src_nums, ans_count]\n", "description": "\n\turban hacks\u89e3\u6cd5\u7dcf\u5f53\u308a\u8a08\u7b97\n\t", "category": "math", "imports": ["import copy", "import time"]}, {"term": "def", "name": "print_formula", "data": "def print_formula(cur_calc, msg):\n\t\"\"\"\n\t\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5b50\u8868\u793a\n\t\"\"\"\n\tif msg == \"F1\":\n\t\t# A B op1 C D op2 op3\n\t\t# (A op1 B) op3 (C op2 D)\n\t\tprint(\"{8}# {0} {1} {2} {3} {4} {5} {6}\\n(({0} {2} {1}) {5} {3}) {6} {4} = {7}\".format(\n\t\t\tcur_calc.a,\n\t\t\tcur_calc.b,\n\t\t\tcur_calc.op1,\n\t\t\tcur_calc.c,\n\t\t\tcur_calc.d,\n\t\t\tcur_calc.op2,\n\t\t\tcur_calc.op3,\n\t\t\tcur_calc.result,\n\t\t\tmsg\n\t\t))\n\telif msg == \"F2\":\n\t\t# A B op1 C op2 D op3\n\t\t# ((A op1 B) op2 C) op3 D\n\t\tprint(\"{8}# {0} {1} {2} {3} {4} {5} {6}\\n(({0} {2} {1}) {4} {3}) {6} {5}= {7}\".format(\n\t\t\tcur_calc.a,\n\t\t\tcur_calc.b,\n\t\t\tcur_calc.op1,\n\t\t\tcur_calc.c,\n\t\t\tcur_calc.op2,\n\t\t\tcur_calc.d,\n\t\t\tcur_calc.op3,\n\t\t\tcur_calc.result,\n\t\t\tmsg\n\t\t))\n\telif msg == \"F3\":\n\t\t# A B C op1 op2 D op3\n\t\t# (A op2 (B op1 C)) op3 D\n\t\tprint(\"{8}# {0} {1} {2} {3} {4} {5} {6}\\n({0} {4} ({1} {3} {2})) {6} {5} = {7}\".format(\n\t\t\tcur_calc.a,\n\t\t\tcur_calc.b,\n\t\t\tcur_calc.c,\n\t\t\tcur_calc.op1,\n\t\t\tcur_calc.op2,\n\t\t\tcur_calc.d,\n\t\t\tcur_calc.op3,\n\t\t\tcur_calc.result,\n\t\t\tmsg\n\t\t))\n\telse:\n\t\t# A B C D op1 op2 op3\n\t\t# A op3 (B op2 (C op1 D))\n\t\tprint(\"{8}# {0} {1} {2} {3} {4} {5} {6}\\n{0} {6} ({1} {5}({2} {4} {3})) = {7}\".format(\n\t\t\tcur_calc.a,\n\t\t\tcur_calc.b,\n\t\t\tcur_calc.c,\n\t\t\tcur_calc.d,\n\t\t\tcur_calc.op1,\n\t\t\tcur_calc.op2,\n\t\t\tcur_calc.op3,\n\t\t\tcur_calc.result,\n\t\t\tmsg\n\t\t))\n\t\n", "description": "\n\t\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u5b50\u8868\u793a\n\t", "category": "math", "imports": ["import copy", "import time"]}, {"term": "def", "name": "exec_revpol", "data": "def exec_revpol(op, work_list):\n\t\"\"\"\n\t\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u3092\u5b9f\u65bd\u3059\u308b\n\top\t\t- \u6f14\u7b97\u5b50\n\twork_list - \u6f14\u7b97\u306e\u8981\u7d20\u3068\u7d50\u679c\u3092\u683c\u7d0d\u3059\u308b\u30b9\u30bf\u30c3\u30af\n\t\"\"\"\n\ts2 = work_list.pop()\n\ts1 = work_list.pop()\n\tif (s1 == \"\u221e\" or s2 == \"\u221e\"):\n\t\twork_list.append(\"\u221e\")\n\t\treturn\n\n\tr2 = float(s2)\n\tr1 = float(s1)\n\tif op == \"+\":\n\t\t# print(\"{0} {1} {2} = {3}\".format(\n\t\t#\t r1,\n\t\t#\t op,\n\t\t#\t r2,\n\t\t#\t r1 + r2\n\t\t# ))\n\t\twork_list.append(r1 + r2)\n\telif  op == \"-\":\n\t\t# print(\"{0} {1} {2} = {3}\".format(\n\t\t#\t r1,\n\t\t#\t op,\n\t\t#\t r2,\n\t\t#\t r1 - r2\n\t\t# ))\n\t\twork_list.append(r1 - r2)\n\telif  op == \"*\":\n\t\t# print(\"{0} {1} {2} = {3}\".format(\n\t\t#\t r1,\n\t\t#\t op,\n\t\t#\t r2,\n\t\t#\t r1 * r2\n\t\t# ))\n\t\twork_list.append(r1 * r2)\n\telif  op == \"/\":\n\t\tif (0 == r2):\n\t\t\t# print(\"{0} {1} {2} = {3}\".format(\n\t\t\t#\t r1,\n\t\t\t#\t op,\n\t\t\t#\t r2,\n\t\t\t#\t \"\u221e\"\n\t\t\t# ))\n\t\t\twork_list.append(\"\u221e\")\n\t\telse:\n\t\t\t# print(\"{0} {1} {2} = {3}\".format(\n\t\t\t#\t r1,\n\t\t\t#\t op,\n\t\t\t#\t r2,\n\t\t\t#\t r1 / r2\n\t\t\t# ))\n\t\t\twork_list.append(r1 / r2)\n", "description": "\n\t\u9006\u30dd\u30fc\u30e9\u30f3\u30c9\u6f14\u7b97\u3092\u5b9f\u65bd\u3059\u308b\n\top\t\t- \u6f14\u7b97\u5b50\n\twork_list - \u6f14\u7b97\u306e\u8981\u7d20\u3068\u7d50\u679c\u3092\u683c\u7d0d\u3059\u308b\u30b9\u30bf\u30c3\u30af\n\t", "category": "math", "imports": ["import copy", "import time"]}, {"term": "def", "name": "make_permutation", "data": "def make_permutation(src_list, depth, org_depth, nums_holder, result_list):\n\t\"\"\"\n\t\u6570\u5b57\u306e\u9806\u5217\u4f5c\u6210(\u518d\u5e30)\n\tsrc_list\t - \u554f\u984c\u6570\u5b57\u5217(\u547c\u3073\u5143\u3067\u9078\u629e\u3055\u308c\u305f\u3082\u306e\u306f\u524a\u9664\u3055\u308c\u3066\u3044\u304f)\n\tdepth\t\t- \u518d\u5e30\u6df1\u3055\n\torg_depth\t- \u5143\u6587\u5b57\u5217\u306e\u9577\u3055\n\tnums_holder  - \u9806\u5217\u683c\u7d0d\u7528\n\tresult_list  - \u3059\u3079\u3066\u306e\u9806\u5217\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n\t\"\"\"\n\tfor idx in range(len(src_list)):\n\t\tlocal_list = copy.copy(src_list)\n\t\tnums_holder[depth] = local_list.pop(idx)\n\t\tif depth < org_depth - 1:\n\t\t\tmake_permutation(local_list, depth + 1, org_depth, nums_holder, result_list)\n\t\telse:\n\t\t\t# print(\"A:{0},B:{1},C:{2},D:{3}\".format(nums_holder[0],nums_holder[1],nums_holder[2],nums_holder[3]))\n\t\t\tresult_list.append([nums_holder[0],nums_holder[1],nums_holder[2],nums_holder[3]])\n\n", "description": "\n\t\u6570\u5b57\u306e\u9806\u5217\u4f5c\u6210(\u518d\u5e30)\n\tsrc_list\t - \u554f\u984c\u6570\u5b57\u5217(\u547c\u3073\u5143\u3067\u9078\u629e\u3055\u308c\u305f\u3082\u306e\u306f\u524a\u9664\u3055\u308c\u3066\u3044\u304f)\n\tdepth\t\t- \u518d\u5e30\u6df1\u3055\n\torg_depth\t- \u5143\u6587\u5b57\u5217\u306e\u9577\u3055\n\tnums_holder  - \u9806\u5217\u683c\u7d0d\u7528\n\tresult_list  - \u3059\u3079\u3066\u306e\u9806\u5217\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n\t", "category": "math", "imports": ["import copy", "import time"]}], [{"term": "class", "name": "classSpline:", "data": "class Spline:\n\tu\"\"\"\n\tCubic Spline class\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.b, self.c, self.d, self.w = [], [], [], []\n\n\t\tself.x = x\n\t\tself.y = y\n\n\t\tself.nx = len(x)  # dimension of x\n\t\th = np.diff(x)\n\n\t\t# calc coefficient c\n\t\tself.a = [iy for iy in y]\n\n\t\t# calc coefficient c\n\t\tA = self.__calc_A(h)\n\t\tB = self.__calc_B(h)\n\t\tself.c = np.linalg.solve(A, B)\n\t\t#  print(self.c1)\n\n\t\t# calc spline coefficient b and d\n\t\tfor i in range(self.nx - 1):\n\t\t\tself.d.append((self.c[i + 1] - self.c[i]) / (3.0 * h[i]))\n\t\t\ttb = (self.a[i + 1] - self.a[i]) / h[i] - h[i] * \\\n\t\t\t\t(self.c[i + 1] + 2.0 * self.c[i]) / 3.0\n\t\t\tself.b.append(tb)\n\n\tdef calc(self, t):\n\t\tu\"\"\"\n\t\tCalc position\n\n\t\tif t is outside of the input x, return None\n\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.a[i] + self.b[i] * dx + \\\n\t\t\tself.c[i] * dx ** 2.0 + self.d[i] * dx ** 3.0\n\n\t\treturn result\n\n\tdef calcd(self, t):\n\t\tu\"\"\"\n\t\tCalc first derivative\n\n\t\tif t is outside of the input x, return None\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = self.b[i] + 2.0 * self.c[i] * dx + 3.0 * self.d[i] * dx ** 2.0\n\t\treturn result\n\n\tdef calcdd(self, t):\n\t\tu\"\"\"\n\t\tCalc second derivative\n\t\t\"\"\"\n\n\t\tif t < self.x[0]:\n\t\t\treturn None\n\t\telif t > self.x[-1]:\n\t\t\treturn None\n\n\t\ti = self.__search_index(t)\n\t\tdx = t - self.x[i]\n\t\tresult = 2.0 * self.c[i] + 6.0 * self.d[i] * dx\n\t\treturn result\n\n\tdef __search_index(self, x):\n\t\tu\"\"\"\n\t\tsearch data segment index\n\t\t\"\"\"\n\t\treturn bisect.bisect(self.x, x) - 1\n\n\tdef __calc_A(self, h):\n\t\tu\"\"\"\n\t\tcalc matrix A for spline coefficient c\n\t\t\"\"\"\n\t\tA = np.zeros((self.nx, self.nx))\n\t\tA[0, 0] = 1.0\n\t\tfor i in range(self.nx - 1):\n\t\t\tif i != (self.nx - 2):\n\t\t\t\tA[i + 1, i + 1] = 2.0 * (h[i] + h[i + 1])\n\t\t\tA[i + 1, i] = h[i]\n\t\t\tA[i, i + 1] = h[i]\n\n\t\tA[0, 1] = 0.0\n\t\tA[self.nx - 1, self.nx - 2] = 0.0\n\t\tA[self.nx - 1, self.nx - 1] = 1.0\n\t\t#  print(A)\n\t\treturn A\n\n\tdef __calc_B(self, h):\n\t\tu\"\"\"\n\t\tcalc matrix B for spline coefficient c\n\t\t\"\"\"\n\t\tB = np.zeros(self.nx)\n\t\tfor i in range(self.nx - 2):\n\t\t\tB[i + 1] = 3.0 * (self.a[i + 2] - self.a[i + 1]) / \\\n\t\t\t\th[i + 1] - 3.0 * (self.a[i + 1] - self.a[i]) / h[i]\n\t\t#  print(B)\n\t\treturn B\n\n", "description": "\n\tCubic Spline class\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "class", "name": "classSpline2D:", "data": "class Spline2D:\n\tu\"\"\"\n\t2D Cubic Spline class\n\n\t\"\"\"\n\n\tdef __init__(self, x, y):\n\t\tself.s = self.__calc_s(x, y)\n\t\tself.sx = Spline(self.s, x)\n\t\tself.sy = Spline(self.s, y)\n\n\tdef __calc_s(self, x, y):\n\t\tdx = np.diff(x)\n\t\tdy = np.diff(y)\n\t\tself.ds = [math.sqrt(idx ** 2 + idy ** 2)\n\t\t\t\t   for (idx, idy) in zip(dx, dy)]\n\t\ts = [0]\n\t\ts.extend(np.cumsum(self.ds))\n\t\treturn s\n\n\tdef calc_position(self, s):\n\t\tu\"\"\"\n\t\tcalc position\n\t\t\"\"\"\n\t\tx = self.sx.calc(s)\n\t\ty = self.sy.calc(s)\n\n\t\treturn x, y\n\n\tdef calc_curvature(self, s):\n\t\tu\"\"\"\n\t\tcalc curvature\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tddx = self.sx.calcdd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tddy = self.sy.calcdd(s)\n\t\tk = (ddy * dx - ddx * dy) / (dx ** 2 + dy ** 2)\n\t\treturn k\n\n\tdef calc_yaw(self, s):\n\t\tu\"\"\"\n\t\tcalc yaw\n\t\t\"\"\"\n\t\tdx = self.sx.calcd(s)\n\t\tdy = self.sy.calcd(s)\n\t\tyaw = math.atan2(dy, dx)\n\t\treturn yaw\n\n", "description": "\n\t2D Cubic Spline class\n\n\t", "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "calc_spline_course", "data": "def calc_spline_course(x, y, ds=0.1):\n\tsp = Spline2D(x, y)\n\ts = list(np.arange(0, sp.s[-1], ds))\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\treturn rx, ry, ryaw, rk, s\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}, {"term": "def", "name": "main", "data": "def main():\n\tprint(\"Spline 2D test\")\n\timport matplotlib.pyplot as plt\n\tx = [-2.5, 0.0, 2.5, 5.0, 7.5, 3.0, -1.0]\n\ty = [0.7, -6, 5, 6.5, 0.0, 5.0, -2.0]\n\n\tsp = Spline2D(x, y)\n\ts = np.arange(0, sp.s[-1], 0.1)\n\n\trx, ry, ryaw, rk = [], [], [], []\n\tfor i_s in s:\n\t\tix, iy = sp.calc_position(i_s)\n\t\trx.append(ix)\n\t\try.append(iy)\n\t\tryaw.append(sp.calc_yaw(i_s))\n\t\trk.append(sp.calc_curvature(i_s))\n\n\tflg, ax = plt.subplots(1)\n\tplt.plot(x, y, \"xb\", label=\"input\")\n\tplt.plot(rx, ry, \"-r\", label=\"spline\")\n\tplt.grid(True)\n\tplt.axis(\"equal\")\n\tplt.xlabel(\"x[m]\")\n\tplt.ylabel(\"y[m]\")\n\tplt.legend()\n\n\tflg, ax = plt.subplots(1)\n\tplt.plot(s, [math.degrees(iyaw) for iyaw in ryaw], \"-r\", label=\"yaw\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"yaw angle[deg]\")\n\n\tflg, ax = plt.subplots(1)\n\tplt.plot(s, rk, \"-r\", label=\"curvature\")\n\tplt.grid(True)\n\tplt.legend()\n\tplt.xlabel(\"line length[m]\")\n\tplt.ylabel(\"curvature [1/m]\")\n\n\tplt.show()\n\n", "description": null, "category": "math", "imports": ["import math", "import numpy as np", "import bisect", "\timport matplotlib.pyplot as plt"]}], [{"term": "def", "name": "test_dftb_bandstructure", "data": "def test_dftb_bandstructure(dftb_factory):\n\t# We need to get the DFTB+ version to know\n\t# whether to skip this test or not.\n\t# For this, we need to run DFTB+ and grep\n\t# the version from the output header.\n\t# cmd = os.environ['ASE_DFTB_COMMAND'].split()[0]\n\t# cmd = dftb_factory.ex\n\tversion = dftb_factory.version()\n\tif tokenize_version(version) < tokenize_version('17.1'):\n\t\tpytest.skip('Band structure requires DFTB 17.1+')\n\n\tcalc = dftb_factory.calc(\n\t\tlabel='dftb',\n\t\tkpts=(3, 3, 3),\n\t\tHamiltonian_SCC='Yes',\n\t\tHamiltonian_SCCTolerance=1e-5,\n\t\tHamiltonian_MaxAngularMomentum_Si='d'\n\t)\n\n\tatoms = bulk('Si')\n\tatoms.calc = calc\n\tatoms.get_potential_energy()\n\n\tefermi = calc.get_fermi_level()\n\tassert abs(efermi - -2.90086680996455) < 1.\n\n\t# DOS does not currently work because of\n\t# missing \"get_k_point_weights\" function\n\t#from ase.dft.dos import DOS\n\t#dos = DOS(calc, width=0.2)\n\t#d = dos.get_dos()\n\t#e = dos.get_energies()\n\t#print(d, e)\n\n\tcalc = dftb_factory.calc(\n\t\tatoms=atoms,\n\t\tlabel='dftb',\n\t\tkpts={'path': 'WGXWLG', 'npoints': 50},\n\t\tHamiltonian_SCC='Yes',\n\t\tHamiltonian_MaxSCCIterations=1,\n\t\tHamiltonian_ReadInitialCharges='Yes',\n\t\tHamiltonian_MaxAngularMomentum_Si='d'\n\t)\n\n\tatoms.calc = calc\n\tcalc.calculate(atoms)\n\n\t#calc.results['fermi_levels'] = [efermi]\n\tcalc.band_structure()\n\t# Maybe write the band structure or assert something?\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk", "from ase.utils import tokenize_version", "\t#from ase.dft.dos import DOS"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [{"term": "def", "name": "fib", "data": "def fib(n, calc):\n\tif n == 0 or n == 1:\n\t\tif len(calc) < 2:\n\t\t\tcalc.append(n)\n\t\treturn calc[n], calc\n\n\telif len(calc)-1 >= n:\n\t\treturn calc[n], calc\n\n\telif n >= 2:\n\t\tres1, c = fib(n-1, calc)\n\t\tres2, c = fib(n-2, calc)\n\t\tres = res1 + res2\n\t\tcalc.append(res)\n\t\treturn res, calc\n\telse:\n\t\treturn calc[n], calc\n\n", "description": null, "category": "math", "imports": []}], [{"term": "def", "name": "tot_loss", "data": "def tot_loss(dstore):\n\treturn dstore.read_df('aggrisk').loss.sum() / 2\n\n", "description": null, "category": "math", "imports": ["import numpy", "import unittest", "from openquake.qa_tests_data.scenario_risk import (", "from openquake.baselib.general import gettemp", "from openquake.hazardlib import InvalidFile", "from openquake.hazardlib.gsim_lt import InvalidLogicTree", "from openquake.calculators.tests import CalculatorTestCase", "from openquake.calculators.views import view", "from openquake.calculators.export import export", "from openquake.calculators.extract import extract", "\t\t\timport shapefile"]}, {"term": "class", "name": "ScenarioRiskTestCase", "data": "class ScenarioRiskTestCase(CalculatorTestCase):\n\n\tdef test_case_1(self):\n\t\tout = self.run_calc(case_1.__file__, 'job_risk.ini', exports='csv')\n\t\t[fname] = out['aggrisk', 'csv']\n\t\tself.assertEqualFiles('expected/agg.csv', fname)\n\n\t\t# check the exported GMFs\n\t\t[fname, sitefile] = export(('gmf_data', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/gmf-FromFile.csv', fname)\n\t\tself.assertEqualFiles('expected/sites.csv', sitefile)\n\n\t\t[fname] = export(('risk_by_event', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/risk_by_event.csv', fname)\n\n\tdef test_case_2(self):\n\t\tout = self.run_calc(case_2.__file__, 'job_risk.ini', exports='csv')\n\t\t[fname] = out['aggrisk', 'csv']\n\t\tself.assertEqualFiles('expected/agg.csv', fname)\n\n\tdef test_case_2d(self):\n\t\t# time_event not specified in job_h.ini but specified in job_r.ini\n\t\tout = self.run_calc(case_2d.__file__, 'job_h.ini,job_r.ini',\n\t\t\t\t\t\t\texports='csv')\n\t\t# this is also a case with a single site but an exposure grid,\n\t\t# to test a corner case\n\t\t[fname] = out['avg_losses-rlzs', 'csv']\n\t\tself.assertEqualFiles(\n\t\t\t'expected/losses_by_asset.csv', fname, delta=1E-5)\n\n\t\t# test agglosses\n\t\ttot = extract(self.calc.datastore, 'agg_losses/occupants')\n\t\taac(tot.array, [0.03104], atol=2E-5)\n\n\t\t# test agglosses with *\n\t\ttbl = extract(self.calc.datastore, 'agg_losses/occupants?taxonomy=*')\n\t\tself.assertEqual(tbl.array.shape, (1, 1))  # 1 taxonomy, 1 rlz\n\n\tdef test_case_3(self):\n\t\t# a4 has a missing cost\n\t\tout = self.run_calc(case_3.__file__, 'job.ini', exports='csv')\n\n\t\t[fname] = out['avg_losses-rlzs', 'csv']\n\t\tself.assertEqualFiles('expected/asset-loss.csv', fname)\n\n\t\t[fname] = out['aggrisk', 'csv']\n\t\tself.assertEqualFiles('expected/agg_loss.csv', fname, delta=5E-6)\n\n\tdef test_case_4(self):\n\t\t# this test is sensitive to the ordering of the epsilons\n\t\tout = self.run_calc(case_4.__file__, 'job.ini', exports='csv')\n\t\tfname = gettemp(view('totlosses', self.calc.datastore))\n\t\tself.assertEqualFiles('expected/totlosses.txt', fname)\n\n\t\t[fname] = out['aggrisk', 'csv']\n\t\tself.assertEqualFiles('expected/agglosses.csv', fname, delta=1E-5)\n\n\tdef test_occupants(self):\n\t\tout = self.run_calc(occupants.__file__, 'job_haz.ini,job_risk.ini',\n\t\t\t\t\t\t\texports='csv')\n\t\t[fname] = out['avg_losses-rlzs', 'csv']\n\t\tself.assertEqualFiles('expected/asset-loss.csv', fname)\n\n\t\t[fname] = out['aggrisk', 'csv']\n\t\tself.assertEqualFiles('expected/agg_loss.csv', fname, delta=1E-5)\n\n\tdef test_case_5(self):\n\t\t# case with site model and 11 sites filled out of 17\n\t\tout = self.run_calc(case_5.__file__, 'job.ini', exports='csv')\n\t\t[fname] = out['avg_losses-rlzs', 'csv']\n\t\tself.assertEqualFiles('expected/losses_by_asset.csv', fname,\n\t\t\t\t\t\t\t  delta=1E-5)  # make macos happy\n\n\t\t# TODO: check pandas\n\t\t# df = self.calc.datastore.read_df('avg_losses-rlzs', 'asset_id')\n\t\t# self.assertEqual(list(df.columns), ['rlz', 'loss_type', 'value'])\n\n\tdef test_case_6a(self):\n\t\t# case with two gsims\n\t\tself.run_calc(case_6a.__file__, 'job_haz.ini,job_risk.ini',\n\t\t\t\t\t  exports='csv')\n\t\t[f] = export(('aggrisk', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/aggrisk.csv', f, delta=5E-5)\n\n\t\t# testing the totlosses view\n\t\tdstore = self.calc.datastore\n\t\tfname = gettemp(view('totlosses', dstore))\n\t\tself.assertEqualFiles('expected/totlosses.txt', fname, delta=5E-5)\n\n\t\t# testing portfolio_losses\n\t\tfname = gettemp(view('portfolio_losses', dstore))\n\t\tself.assertEqualFiles('expected/portfolio_losses.txt', fname,\n\t\t\t\t\t\t\t  delta=5E-5)\n\n\t\t# two equal gsims\n\t\twith self.assertRaises(InvalidLogicTree):\n\t\t\tself.run_calc(case_6a.__file__, 'job_haz.ini',\n\t\t\t\t\t\t  gsim_logic_tree_file='wrong_gmpe_logic_tree.xml')\n\n\tdef test_case_1g(self):\n\t\tout = self.run_calc(case_1g.__file__, 'job_haz.ini,job_risk.ini',\n\t\t\t\t\t\t\texports='csv')\n\t\t[_tot, fname] = out['aggrisk', 'csv']\n\t\tself.assertEqualFiles('expected/agg-gsimltp_@.csv', fname)\n\n\tdef test_case_1h(self):\n\t\t# this is a case with 2 assets spawning 2 tasks\n\t\tout = self.run_calc(case_1h.__file__, 'job.ini', exports='csv')\n\t\t[fname] = out['avg_losses-rlzs', 'csv']\n\t\tself.assertEqualFiles('expected/losses_by_asset.csv', fname)\n\n\t\t# with a single task\n\t\tout = self.run_calc(case_1h.__file__, 'job.ini', exports='csv',\n\t\t\t\t\t\t\tconcurrent_tasks='0')\n\t\t[fname] = out['avg_losses-rlzs', 'csv']\n\t\tself.assertEqualFiles('expected/losses_by_asset.csv', fname)\n\n\tdef test_case_master(self):\n\t\t# a case with two GSIMs\n\t\tself.run_calc(case_master.__file__, 'job.ini', exports='npz')\n\n\t\t# check realizations\n\t\t[fname] = export(('realizations', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/realizations.csv', fname)\n\n\t\t# extract losses by taxonomy\n\t\textract(self.calc.datastore, 'agg_losses/structural?'\n\t\t\t\t'taxonomy=*').array  # shape (T, R) = (3, 2)\n\n\t\t# extract agglosses with a * and a selection\n\t\tobj = extract(self.calc.datastore, 'agg_losses/structural?'\n\t\t\t\t\t  'state=*&cresta=0.11')\n\t\tself.assertEqual(obj.selected, [b'state=*', b'cresta=0.11'])\n\t\tself.assertEqual(obj.tags, [b'state=01'])\n\t\taac(obj.array, [[2764.5]], atol=.02)  # from avg_losses-stats\n\n\t\t# check portfolio_loss\n\t\tfname = gettemp(view('portfolio_loss', self.calc.datastore))\n\t\t# sensitive to shapely version\n\t\tself.assertEqualFiles('expected/portfolio_loss.txt', fname, delta=1E-4)\n\n\tdef test_collapse_gsim_logic_tree(self):\n\t\tself.run_calc(case_master.__file__, 'job.ini',\n\t\t\t\t\t  collapse_gsim_logic_tree='bs1')\n\t\tfname = gettemp(view('portfolio_loss', self.calc.datastore))\n\t\tself.assertEqualFiles(\n\t\t\t'expected/portfolio_loss2.txt', fname, delta=1E-5)\n\n\tdef test_case_7(self):\n\t\t# check independence from concurrent_tasks\n\t\tself.run_calc(case_7.__file__, 'job.ini', concurrent_tasks='10')\n\t\ttot10 = tot_loss(self.calc.datastore)\n\t\tself.run_calc(case_7.__file__, 'job.ini', concurrent_tasks='20')\n\t\ttot20 = tot_loss(self.calc.datastore)\n\t\taac(tot10, tot20, atol=.0001)  # must be around 230.0107\n\n\t\t# check aggregate_by site_id\n\t\t[_tot, fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/agglosses.csv', fname)\n\n\tdef test_case_8(self):\n\t\t# a complex scenario_risk from GMFs where the hazard sites are\n\t\t# not in the asset locations\n\t\tself.run_calc(case_8.__file__, 'job.ini')\n\t\t[_tot, fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/agglosses.csv', fname)\n\n\t\tagglosses = extract(self.calc.datastore, 'agg_losses/structural')\n\t\taac(agglosses.array, [1159325.6])\n\n\t\t# make sure the fullreport can be extracted\n\t\tview('fullreport', self.calc.datastore)\n\n\tdef test_case_10(self):\n\t\t# missing occupants in the exposure\n\t\twith self.assertRaises(InvalidFile):\n\t\t\tself.run_calc(case_10.__file__, 'job.ini')\n\n\tdef test_case_shakemap(self):\n\t\tself.run_calc(case_shakemap.__file__, 'pre-job.ini')\n\t\tself.run_calc(case_shakemap.__file__, 'job.ini',\n\t\t\t\t\t  hazard_calculation_id=str(self.calc.datastore.calc_id))\n\t\tsitecol = self.calc.datastore['sitecol']\n\t\tself.assertEqual(len(sitecol), 9)\n\t\tgmfdict = dict(extract(self.calc.datastore, 'gmf_data'))\n\t\tgmfa = gmfdict['rlz-000']\n\t\tself.assertEqual(gmfa.shape, (9,))\n\t\tself.assertEqual(\n\t\t\tgmfa.dtype.names,\n\t\t\t('custom_site_id', 'lon', 'lat', 'PGA', 'SA(0.3)', 'SA(1.0)'))\n\t\t[fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/agglosses.csv', fname)\n\n\t\t[fname] = export(('realizations', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/realizations.csv', fname)\n\n\tdef test_case_shapefile(self):\n\t\ttry:\n\t\t\timport shapefile\n\t\texcept ImportError:\n\t\t\traise unittest.SkipTest('Missing pyshp')\n\t\tself.run_calc(case_shapefile.__file__, 'prepare_job.ini')\n\t\tpre_id = str(self.calc.datastore.calc_id)\n\t\tself.run_calc(case_shapefile.__file__, 'job.ini',\n\t\t\t\t\t  hazard_calculation_id=pre_id)\n\t\tsitecol = self.calc.datastore['sitecol']\n\t\tself.assertEqual(len(sitecol), 7)\n\t\tgmfdict = dict(extract(self.calc.datastore, 'gmf_data'))\n\t\tgmfa = gmfdict['rlz-000']\n\t\tself.assertEqual(gmfa.shape, (7,))\n\t\tself.assertEqual(gmfa.dtype.names,\n\t\t\t\t\t\t ('custom_site_id', 'lon', 'lat', 'MMI'))\n\t\t[fname] = export(('aggrisk', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/agglosses.csv', fname)\n\n\t\t[fname] = export(('realizations', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/realizations.csv', fname)\n\n\t\t# also test case if shapefiles are together in a zip file\n\t\tself.run_calc(case_shapefile.__file__, 'job_zipped.ini',\n\t\t\t\t\t  hazard_calculation_id=pre_id)\n\t\t[fname] = export(('realizations', 'csv'), self.calc.datastore)\n\t\tself.assertEqualFiles('expected/realizations.csv', fname)\n", "description": null, "category": "math", "imports": ["import numpy", "import unittest", "from openquake.qa_tests_data.scenario_risk import (", "from openquake.baselib.general import gettemp", "from openquake.hazardlib import InvalidFile", "from openquake.hazardlib.gsim_lt import InvalidLogicTree", "from openquake.calculators.tests import CalculatorTestCase", "from openquake.calculators.views import view", "from openquake.calculators.export import export", "from openquake.calculators.extract import extract", "\t\t\timport shapefile"]}], [{"term": "class", "name": "TestCalcMasterSecret", "data": "class TestCalcMasterSecret(unittest.TestCase):\n\tdef test_with_empty_values(self):\n\t\tret = calcMasterSecret((3, 3), 0, bytearray(48), bytearray(32),\n\t\t\t\t\t\t\t   bytearray(32))\n\n\t\tself.assertEqual(bytearray(\n\t\t\tb'I\\xcf\\xae\\xe5[\\x86\\x92\\xd3\\xbbm\\xd6\\xeekSo/' +\n\t\t\tb'\\x17\\xaf\\xbc\\x84\\x18\\tGc\\xbc\\xb5\\xbe\\xd6\\xb0\\x05\\xad\\xf8' +\n\t\t\tb'\\x88\\xd0`\\xe4\\x8c^\\xb2&ls\\xcb\\x1a=-Kh'\n\t\t\t), ret)\n\t\tself.assertEqual(48, len(ret))\n", "description": null, "category": "math", "imports": ["\t\timport unittest2 as unittest", "\t\timport unittest", "from tlslite.mathtls import PRF_1_2, calcMasterSecret, calcFinished, \\", "from tlslite.handshakehashes import HandshakeHashes", "from tlslite.constants import CipherSuite"]}, {"term": "class", "name": "TestCalcExtendedMasterSecret", "data": "class TestCalcExtendedMasterSecret(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.handshakeHashes = HandshakeHashes()\n\t\tself.handshakeHashes.update(bytearray(48))\n\n\tdef test_with_TLS_1_0(self):\n\t\tret = calcExtendedMasterSecret((3, 1),\n\t\t\t\t\t\t\t\t\t   0,\n\t\t\t\t\t\t\t\t\t   bytearray(48),\n\t\t\t\t\t\t\t\t\t   self.handshakeHashes)\n\t\tself.assertEqual(ret, bytearray(\n\t\t\tb'/\\xe9\\x86\\xda\\xda\\xa9)\\x1eyJ\\xc9\\x13E\\xe4\\xfc\\xe7\\x842m7(\\xb4'\n\t\t\tb'\\x98\\xb7\\xbc\\xa5\\xda\\x1d\\xf3\\x15\\xea\\xdf:i\\xeb\\x9bA\\x8f\\xe7'\n\t\t\tb'\\xd4<\\xe0\\xe8\\x1d\\xa0\\xf0\\x10\\x83'\n\t\t\t))\n\n\tdef test_with_TLS_1_2(self):\n\t\tret = calcExtendedMasterSecret((3, 3),\n\t\t\t\t\t\t\t\t\t   0,\n\t\t\t\t\t\t\t\t\t   bytearray(48),\n\t\t\t\t\t\t\t\t\t   self.handshakeHashes)\n\t\tself.assertEqual(ret, bytearray(\n\t\t\tb'\\x03\\xc93Yx\\xcbjSEmz*\\x0b\\xc3\\xc04G\\xf3\\xe3{\\xee\\x13\\x8b\\xac'\n\t\t\tb'\\xd7\\xb7\\xe6\\xbaY\\x86\\xd5\\xf2o?\\x8f\\xc6\\xf2\\x19\\x1d\\x06\\xe0N'\n\t\t\tb'\\xb5\\xcaJX\\xe8\\x1d'\n\t\t\t))\n\n\tdef test_with_TLS_1_2_and_SHA384_PRF(self):\n\t\tret = calcExtendedMasterSecret((3, 3),\n\t\t\t\t\t\t\t\t\t   CipherSuite.\n\t\t\t\t\t\t\t\t\t   TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t\t\t\t\t\t\t\t\t   bytearray(48),\n\t\t\t\t\t\t\t\t\t   self.handshakeHashes)\n\t\tself.assertEqual(ret, bytearray(\n\t\t\tb\"\\xd6\\xed}K\\xfbo\\xb2\\xdb\\xa4\\xee\\xa1\\x0f\\x8f\\x07*\\x84w/\\xbf_\"\n\t\t\tb\"\\xbd\\xc1U^\\x93\\xcf\\xe8\\xca\\x82\\xb7_B\\xa3O\\xd9V\\x86\\x12\\xfd\\x08\"\n\t\t\tb\"$\\x92\\'L\\xae\\xc0@\\x01\"\n\t\t\t))\n", "description": null, "category": "math", "imports": ["\t\timport unittest2 as unittest", "\t\timport unittest", "from tlslite.mathtls import PRF_1_2, calcMasterSecret, calcFinished, \\", "from tlslite.handshakehashes import HandshakeHashes", "from tlslite.constants import CipherSuite"]}, {"term": "class", "name": "TestPRF1_2", "data": "class TestPRF1_2(unittest.TestCase):\n\tdef test_with_bogus_values(self):\n\t\tret = PRF_1_2(bytearray(1), b\"key expansion\", bytearray(1), 10)\n\n\t\tself.assertEqual(bytearray(b'\\xaa2\\xca\\r\\x8b\\x85N\\xad?\\xab'), ret)\n\n\tdef test_with_realistic_values(self):\n\t\tret = PRF_1_2(bytearray(48), b\"key expansion\", bytearray(64), 16)\n\n\t\tself.assertEqual(bytearray(b'S\\xb5\\xdb\\xc8T }u)BxuB\\xe4\\xeb\\xeb'), ret)\n", "description": null, "category": "math", "imports": ["\t\timport unittest2 as unittest", "\t\timport unittest", "from tlslite.mathtls import PRF_1_2, calcMasterSecret, calcFinished, \\", "from tlslite.handshakehashes import HandshakeHashes", "from tlslite.constants import CipherSuite"]}, {"term": "class", "name": "TestCalcFinished", "data": "class TestCalcFinished(unittest.TestCase):\n\tdef setUp(self):\n\t\tself.hhashes = HandshakeHashes()\n\t\tself.hhashes.update(bytearray(10))\n", "description": null, "category": "math", "imports": ["\t\timport unittest2 as unittest", "\t\timport unittest", "from tlslite.mathtls import PRF_1_2, calcMasterSecret, calcFinished, \\", "from tlslite.handshakehashes import HandshakeHashes", "from tlslite.constants import CipherSuite"]}, {"term": "class", "name": "TestCalcFinishedInSSL3", "data": "class TestCalcFinishedInSSL3(TestCalcFinished):\n\tdef setUp(self):\n\t\tsuper(TestCalcFinishedInSSL3, self).setUp()\n\n\t\tself.finished = calcFinished((3, 0),\n\t\t\t\t\t\t\t\t\t bytearray(48),\n\t\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t\t self.hhashes,\n\t\t\t\t\t\t\t\t\t True)\n\tdef test_client_value(self):\n\t\tself.assertEqual(bytearray(\n\t\t\tb'\\x15\\xa9\\xd7\\xf1\\x8bV\\xecY\\xab\\xee\\xbaS\\x9c}\\xffW\\xa0'+\n\t\t\tb'\\xa8\\\\q\\xe5x8\"\\xf4\\xedp\\xabl\\x8aV\\xd9G\\xab\\x0fz'),\n\t\t\tself.finished)\n\n\tdef test_server_value(self):\n\t\tret = calcFinished((3, 0), bytearray(48), 0, self.hhashes, False)\n\n\t\tself.assertEqual(bytearray(\n\t\t\tb'\\xe3^aCb\\x8a\\xfc\\x98\\xbf\\xd7\\x08\\xddX\\xdc[\\xeac\\x02\\xdb'+\n\t\t\tb'\\x9b\\x8aN\\xed\\xed\\xaaZ\\xcb\\xda\"\\x87K\\xff\\x89m\\xa9/'),\n\t\t\tret)\n\n\tdef test_if_multiple_runs_are_the_same(self):\n\t\tret2 = calcFinished((3, 0), bytearray(48), 0, self.hhashes, True)\n\n\t\tself.assertEqual(self.finished, ret2)\n\n\tdef test_if_client_and_server_values_differ(self):\n\t\tret_srv = calcFinished((3, 0), bytearray(48), 0, self.hhashes, False)\n\n\t\tself.assertNotEqual(self.finished, ret_srv)\n", "description": null, "category": "math", "imports": ["\t\timport unittest2 as unittest", "\t\timport unittest", "from tlslite.mathtls import PRF_1_2, calcMasterSecret, calcFinished, \\", "from tlslite.handshakehashes import HandshakeHashes", "from tlslite.constants import CipherSuite"]}, {"term": "class", "name": "TestCalcFinishedInTLS1_0", "data": "class TestCalcFinishedInTLS1_0(TestCalcFinished):\n\tdef setUp(self):\n\t\tsuper(TestCalcFinishedInTLS1_0, self).setUp()\n\n\t\tself.finished = calcFinished((3, 1),\n\t\t\t\t\t\t\t\t\t bytearray(48),\n\t\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t\t self.hhashes,\n\t\t\t\t\t\t\t\t\t True)\n\n\tdef test_client_value(self):\n\t\tself.assertEqual(12, len(self.finished))\n\t\tself.assertEqual(bytearray(\n\t\t\tb'\\xf8N\\x8a\\x8dx\\xb8\\xfe\\x9e1\\x0b\\x8a#'),\n\t\t\tself.finished)\n\n\tdef test_server_value(self):\n\t\tret_srv = calcFinished((3, 1), bytearray(48), 0, self.hhashes, False)\n\n\t\tself.assertEqual(12, len(ret_srv))\n\t\tself.assertEqual(bytearray(\n\t\t\tb'kYB\\xce \\x7f\\xbb\\xee\\xe5\\xe7<\\x9d'),\n\t\t\tret_srv)\n\n\tdef test_if_client_and_server_values_differ(self):\n\t\tret_srv = calcFinished((3, 1), bytearray(48), 0, self.hhashes, False)\n\n\t\tself.assertNotEqual(self.finished, ret_srv)\n\n\tdef test_if_values_for_TLS1_0_and_TLS1_0_are_same(self):\n\t\tret = calcFinished((3, 2), bytearray(48), 0, self.hhashes, True)\n\n\t\tself.assertEqual(self.finished, ret)\n", "description": null, "category": "math", "imports": ["\t\timport unittest2 as unittest", "\t\timport unittest", "from tlslite.mathtls import PRF_1_2, calcMasterSecret, calcFinished, \\", "from tlslite.handshakehashes import HandshakeHashes", "from tlslite.constants import CipherSuite"]}, {"term": "class", "name": "TestCalcFinishedInTLS1_2WithSHA256", "data": "class TestCalcFinishedInTLS1_2WithSHA256(TestCalcFinished):\n\tdef setUp(self):\n\t\tsuper(TestCalcFinishedInTLS1_2WithSHA256, self).setUp()\n\n\t\tself.finished = calcFinished((3, 3),\n\t\t\t\t\t\t\t\t\t bytearray(48),\n\t\t\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t\t\t self.hhashes,\n\t\t\t\t\t\t\t\t\t True)\n\n\tdef test_client_value(self):\n\t\tself.assertEqual(12, len(self.finished))\n\t\tself.assertEqual(bytearray(\n\t\t\tb'\\x8e\\x8c~\\x03lU$S\\x9fz\\\\\\xcc'),\n\t\t\tself.finished)\n\n\tdef test_server_value(self):\n\t\tret_srv = calcFinished((3, 3), bytearray(48), 0, self.hhashes, False)\n\n\t\tself.assertEqual(12, len(self.finished))\n\t\tself.assertEqual(bytearray(\n\t\t\tb'\\xa8\\xf1\\xdf8s|\\xedU\\\\Z=U'),\n\t\t\tret_srv)\n\n\tdef test_if_client_and_server_values_differ(self):\n\t   ret_srv = calcFinished((3, 3), bytearray(48), 0, self.hhashes, False)\n\n\t   self.assertNotEqual(ret_srv, self.finished)\n", "description": null, "category": "math", "imports": ["\t\timport unittest2 as unittest", "\t\timport unittest", "from tlslite.mathtls import PRF_1_2, calcMasterSecret, calcFinished, \\", "from tlslite.handshakehashes import HandshakeHashes", "from tlslite.constants import CipherSuite"]}, {"term": "class", "name": "TestCalcFinishedInTLS1_2WithSHA384", "data": "class TestCalcFinishedInTLS1_2WithSHA384(TestCalcFinished):\n\tdef setUp(self):\n\t\tsuper(TestCalcFinishedInTLS1_2WithSHA384, self).setUp()\n\n\t\tself.finished = calcFinished((3, 3),\n\t\t\t\t\t\t\t\t\t bytearray(48),\n\t\t\t\t\t\t\t\t\t CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t\t\t\t\t\t\t\t\t self.hhashes,\n\t\t\t\t\t\t\t\t\t True)\n\n\tdef test_client_value(self):\n\t\tself.assertEqual(12, len(self.finished))\n\t\tself.assertEqual(bytearray(\n\t\t\tb'UB\\xeeq\\x86\\xa5\\x88L \\x04\\x893'),\n\t\t\tself.finished)\n\n\tdef test_server_value(self):\n\t\tret_srv = calcFinished((3, 3), bytearray(48),\n\t\t\t\t\t\t\t   CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t\t\t\t\t\t\t   self.hhashes, False)\n\t\tself.assertEqual(bytearray(\n\t\t\tb'\\x02St\\x13\\xa8\\xe6\\xb6\\xa2\\x1c4\\xff\\xc5'),\n\t\t\tret_srv)\n\n\tdef test_if_client_and_server_values_differ(self):\n\t\tret_srv = calcFinished((3, 3), bytearray(48),\n\t\t\t\t\t\t\t   CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t\t\t\t\t\t\t   self.hhashes, False)\n\t\tself.assertNotEqual(self.finished, ret_srv)\n\n", "description": null, "category": "math", "imports": ["\t\timport unittest2 as unittest", "\t\timport unittest", "from tlslite.mathtls import PRF_1_2, calcMasterSecret, calcFinished, \\", "from tlslite.handshakehashes import HandshakeHashes", "from tlslite.constants import CipherSuite"]}, {"term": "class", "name": "TestParamStrength", "data": "class TestParamStrength(unittest.TestCase):\n\tdef test_480(self):\n\t\tself.assertEqual(48, paramStrength(2**480))\n\n\tdef test_512(self):\n\t\tself.assertEqual(56, paramStrength(2**512))\n\n\tdef test_768(self):\n\t\tself.assertEqual(64, paramStrength(2**768))\n\n\tdef test_900(self):\n\t\tself.assertEqual(72, paramStrength(2**900))\n\n\tdef test_1024(self):\n\t\tself.assertEqual(80, paramStrength(2**1024))\n\n\tdef test_1536(self):\n\t\tself.assertEqual(88, paramStrength(2**1536))\n\n\tdef test_2048(self):\n\t\tself.assertEqual(112, paramStrength(2**2048))\n\n\tdef test_3072(self):\n\t\tself.assertEqual(128, paramStrength(2**3072))\n\n\tdef test_4096(self):\n\t\tself.assertEqual(152, paramStrength(2**4096))\n\n\tdef test_6144(self):\n\t\tself.assertEqual(168, paramStrength(2**6144))\n\n\tdef test_7680(self):\n\t\tself.assertEqual(192, paramStrength(2**7680))\n\n\tdef test_8192(self):\n\t\tself.assertEqual(192, paramStrength(2**8192))\n\n\tdef test_15360(self):\n\t\tself.assertEqual(256, paramStrength(2**15360))\n", "description": null, "category": "math", "imports": ["\t\timport unittest2 as unittest", "\t\timport unittest", "from tlslite.mathtls import PRF_1_2, calcMasterSecret, calcFinished, \\", "from tlslite.handshakehashes import HandshakeHashes", "from tlslite.constants import CipherSuite"]}], [{"term": "class", "name": "TestCase", "data": "class TestCase(unittest.TestCase):\r\n\r\n\t# name of method should start with test_\r\n\tdef test_add(self):\r\n\t\tresult = calc.add(10, 5)\r\n\t\tself.assertEqual(result, 15)\r\n\t\tself.assertEqual(calc.add(10, -5), 5)\r\n\t\tself.assertEqual(calc.add(5, 0), 5)\r\n\t\tself.assertEqual(calc.add(-1, -3), -4)\r\n\r\n\tdef test_multiply(self):\r\n\t\tself.assertEqual(calc.multiply(10, -5), -50)\r\n\t\tself.assertEqual(calc.multiply(5, 0), 0)\r\n\t\tself.assertEqual(calc.multiply(1, 3), 3)\r\n\r\n\tdef test_divide(self):\r\n\t\tself.assertEqual(calc.divide(10, -5), -2)\r\n\t\tself.assertEqual(calc.divide(5, 1), 5)\r\n\t\tself.assertEqual(calc.divide(-3, -1), 3)\r\n\t\tself.assertEqual(calc.divide(5, 2), 2.5)\r\n\r\n\t\tself.assertRaises(ValueError, calc.divide, 10, 0)\r\n\r\n\t\twith self.assertRaises(ValueError):\r\n\t\t\tcalc.divide(3, 0)\r\n\r\n\tdef test_subtract(self):\r\n\t\tself.assertEqual(calc.subtract(10, -5), 15)\r\n\t\tself.assertEqual(calc.subtract(5, 0), 5)\r\n\t\tself.assertEqual(calc.subtract(-1, -3), 2)\r\n\r\n", "description": null, "category": "math", "imports": ["import unittest\r", "import calc\r"]}], [{"term": "def", "name": "check_duration", "data": "def check_duration(calc, current_time, duration, start_time, target_angle):\n\t# print(\"check_time \", current_time, \"duration\", duration, 'start time', start_time, \"target_angle\", target_angle, \"calc\", calc)\n\tif current_time > duration:\n\t\t# print(\"duration exception triggered\")\n\t\treturn target_angle\n\treturn calc\n", "description": null, "category": "math", "imports": ["from math import sin, cos, pi, sqrt"]}, {"term": "class", "name": "Transition", "data": "class Transition():\n\tdef linear_tween(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" simple linear tweening - no easing, no acceleration \"\"\"\n\t\tcalc = ((change_in_value * current_time) / duration) + start_value\n\t\t\n\t\tcalc = check_exceptions(calc, change_in_value, start_value)\n\t\tcalc = check_duration(calc, current_time, duration, start_time, target_angle)\n\t\treturn int(calc)\n\n\tdef ease_in_quad(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" quadratic easing in - accelerating from zero velocity \"\"\"\n\t\tcurrent_time /= duration\n\t\tcalc = change_in_value * current_time * current_time + start_value\n\t\tcalc = check_exceptions(calc, change_in_value, start_value)\n\t\tcalc = check_duration(calc, current_time, duration, start_time, target_angle)\n\t\treturn int(calc)\n\n\tdef ease_out_quad(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" quadratic easing out - decelerating to zero velocity \"\"\"\n\t\tcur_time = current_time\n\t\tcurrent_time /= duration\n\t\tcalc = ((1-change_in_value * current_time) * (current_time-2)) + start_value\n\n\t\tcalc = check_exceptions(calc, change_in_value, start_value)\n\t\tcalc = check_duration(calc, cur_time, duration, start_time, target_angle)\n\t\treturn int(calc)\n\n\tdef ease_in_out_quad(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" quadratic easing in/out - acceleration until halfway, then deceleration \"\"\"\n\t\tcur_time = current_time\n\t\tcurrent_time /= duration/2\n\t\tif (current_time < 1):\n\t\t\treturn change_in_value/2*current_time*current_time + start_value\n\t\tcurrent_time -=1\n\t\tcalc = (((1-current_time)/2 )* (current_time*(current_time-2)-1)) + start_value\n\t\tcalc = check_exceptions(calc, change_in_value, start_value)\n\t\tcalc = check_duration(calc, cur_time, duration, start_time, target_angle)\n\t\treturn int(calc)\n\n\tdef ease_in_cubic(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" cubic easing in - accelerating from zero velocity \"\"\"\n\t\tcurrent_time /= duration\n\t\tcalc = change_in_value*current_time*current_time*current_time + start_value\n\t\treturn int(calc)\n\n\tdef ease_out_cubic(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" cubic easing out - decelerating to zero velocity \"\"\"\n\t\tcurrent_time /= duration\n\t\tcurrent_time -=1\n\t\tcalc = change_in_value(current_time*current_time*current_time+1)+start_value\n\t\treturn int(calc)\n\n\tdef ease_in_out_cubic(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" cubic easing in/out - acceleration until halfway, then deceleration \"\"\"\n\t\tcurrent_time /= duration/2\n\t\tif (current_time < 1):\n\t\t\treturn change_in_value/2*current_time*current_time*current_time + start_value\n\t\tcurrent_time -= 2\n\t\tcalc = change_in_value/2 * (current_time*current_time*current_time + 2) + start_value\n\t\treturn int(calc)\n\n\tdef ease_in_quart(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" quartic easing in - accelerating from zero velocity \"\"\"\n\t\tcurrent_time /= duration\n\t\tcalc = change_in_value * current_time * current_time * current_time * current_time + start_value\n\t\treturn int(calc)\n\n\tdef ease_out_quart(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" quartic easing out - decelerating to zero velocity \"\"\"\n\t\tcurrent_time /= duration\n\t\tcurrent_time =-1\n\t\tcalc = 1-change_in_value * (current_time*current_time*current_time*current_time - 1) + start_value\n\t\treturn int(calc)\n\n\tdef ease_in_out_quart(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" quartic easing in/out - acceleration until halfway, then deceleration \"\"\"\n\t\tcurrent_time /= duration/2\n\t\tif (current_time < 1):\n\t\t\treturn change_in_value /2 * current_time * current_time * current_time* current_time + start_value\n\t\tcurrent_time -= 2\n\t\tcalc = 1-change_in_value/2 * (current_time * current_time * current_time * current_time -2) + start_value\n\t\treturn int(calc)\n\n\tdef ease_in_quint(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" quintic easing in - accelerating from zero velocity \"\"\"\n\t\tcurrent_time /= duration\n\t\tcalc = change_in_value * current_time * current_time * current_time * current_time * current_time + start_value\n\t\treturn int(calc)\n\n\tdef ease_out_quint(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" quintic easing out - decelerating to zero velocity \"\"\"\n\t\tcurrent_time = current_time / duration\n\t\tcurrent_time -= 1\n\t\tcalc = change_in_value(current_time*current_time*current_time*current_time*current_time + 1) + start_value\n\t\treturn int(calc)\n\n\tdef ease_in_out_quint(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" quintic easing in/out - acceleration until halfway, then deceleration \"\"\"\n\t\tcurrent_time /= duration / 2\n\t\tif (current_time < 1):\n\t\t\treturn change_in_value / 2 * current_time * current_time * current_time * current_time * current_time + start_value\n\t\tcurrent_time -= 2\n\t\tcalc = change_in_value /2 * (current_time * current_time * current_time * current_time * current_time + 2) + start_value\n\t\treturn int(calc)\n\n\tdef ease_in_sine(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" sinusoidal easing in - accelerating from zero velocity \"\"\"\n\t\tcalc = 1-change_in_value * cos(current_time / duration * (pi/2)) + change_in_value + start_value\n\t\treturn int(calc)\n\n\tdef ease_out_sine(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" sinusoidal easing out - decelerating to zero velocity \"\"\"\n\t\tcalc = change_in_value * sin(current_time / duration * (pi/2)) + start_value\n\t\treturn int(calc)\n\n\tdef ease_in_out_sine(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" sinusoidal easing in/out - accelerating until halfway, then decelerating \"\"\"\n\t\tcalc = 1-change_in_value/2 * (cos(pi*current_time/duration) - 1) + start_value\n\t\treturn int(calc)\n\n\tdef ease_in_expo(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" exponential easing in - accelerating from zero velocity \"\"\"\n\t\tcalc = current_time * pow(2, 10 * (current_time / duration - 1)) + start_value\n\t\treturn int(calc)\n\n\tdef ease_out_expo(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" exponential easing out - decelerating to zero velocity \"\"\"\n\t\tcalc = change_in_value * (pow (2, -10 * current_time / duration) + 1) + start_value\n\t\treturn int(calc)\n\n\tdef ease_in_out_expo(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" exponential easing in/out - accelerating until halfway, then decelerating \"\"\"\n\t\tcurrent_time /= duration/2\n\t\tif(current_time < 1):\n\t\t\tcalc = change_in_value/2 * pow(2, 10 * (current_time -1)) + start_value\n\t\t\treturn int(calc)\n\t\tcurrent_time -= 1\n\t\tcalc = change_in_value/2 * (pow(2, -10 * current_time) + 2) + start_value\n\t\treturn int(calc)\n\n\tdef ease_in_circ(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" circular easing in - accelerating from zero velocity \"\"\"\n\t\tcurrent_time /= duration\n\t\tcalc = 1-change_in_value * (sqrt(1 - current_time*current_time) - 1) + start_value\n\t\treturn int(calc)\n\n\tdef ease_out_circ(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" circular easing out - decelerating to zero velocity \"\"\"\n\t\tcurrent_time /= duration\n\t\tcurrent_time -= 1\n\t\tcalc = change_in_value * sqrt(1 - current_time*current_time) + start_value\n\t\treturn int(calc)\n\n\tdef ease_in_out_circ(self, current_time, start_value, change_in_value, duration, start_time, target_angle):\n\t\t\"\"\" circular easing in/out - acceleration until halfway, then deceleration \"\"\"\n\t\tcurrent_time /= duration/2\n\t\tif (current_time < 1):\n\t\t\tcalc = 1-change_in_value/2 * (sqrt(1 - current_time-current_time) -1) + start_value\n\t\t\treturn int(calc)\n\t\tcurrent_time -= 2\n\t\tcalc = change_in_value / 2 * (sqrt(1 - current_time*current_time) + 1) + start_value\n\t\treturn int(calc)\n", "description": " simple linear tweening - no easing, no acceleration ", "category": "math", "imports": ["from math import sin, cos, pi, sqrt"]}], [], [{"term": "class", "name": "LexTest", "data": "class LexTest(unittest.TestCase):\n\tdef test_dec(self):\n\t\tcalc = swisscalc.Calc()\n\t\ttok = calc._lexme('1234')[0]\n\t\tself.assertEqual(tok.type, 'decint')\n\t\tself.assertEqual(tok.value, 1234)\n\n\t\ttok = calc._lexme('01234')[0]\n\t\tself.assertNotEqual(tok.type, 'decint')\n\n\t\ttok = calc._lexme('0')[0]\n\t\tself.assertEqual(tok.type, 'decint')\n\t\tself.assertEqual(tok.value, 0)\n\n\t\ttok = calc._lexme('123af')[0]\n\t\tself.assertEqual(tok.type, 'decint')\n\t\tself.assertEqual(tok.value, 123)\n\n\tdef test_bin(self):\n\t\tcalc = swisscalc.Calc()\n\t\ttok = calc._lexme('0b11')[0]\n\t\tself.assertEqual(tok.type, 'binint')\n\t\tself.assertEqual(tok.value, 0b11)\n\n\t\ttok = calc._lexme('0B11')[0]\n\t\tself.assertEqual(tok.type, 'binint')\n\t\tself.assertEqual(tok.value, 0B11)\n\n\t\ttok = calc._lexme('0b132')[0]\n\t\tself.assertEqual(tok.type, 'binint')\n\t\tself.assertEqual(tok.value, 0b1)\n\n\tdef test_oct(self):\n\t\tcalc = swisscalc.Calc()\n\t\ttok = calc._lexme('0123')[0]\n\t\tself.assertEqual(tok.type, 'octint')\n\t\tself.assertEqual(tok.value, 0123)\n\n\t\ttok = calc._lexme('0o123')[0]\n\t\tself.assertEqual(tok.type, 'octint')\n\t\tself.assertEqual(tok.value, 0o123)\n\n\t\ttok = calc._lexme('0O123')[0]\n\t\tself.assertEqual(tok.type, 'octint')\n\t\tself.assertEqual(tok.value, 0O123)\n\n\t\ttok = calc._lexme('0789')[0]\n\t\tself.assertEqual(tok.type, 'octint')\n\t\tself.assertEqual(tok.value, 07)\n\n\tdef test_hex(self):\n\t\tcalc = swisscalc.Calc()\n\t\ttok = calc._lexme('0x123')[0]\n\t\tself.assertEqual(tok.type, 'hexint')\n\t\tself.assertEqual(tok.value, 0x123)\n\n\t\ttok = calc._lexme('0X123')[0]\n\t\tself.assertEqual(tok.type, 'hexint')\n\t\tself.assertEqual(tok.value, 0X123)\n\n\t\ttok = calc._lexme('0xdeadbeefhaha')[0]\n\t\tself.assertEqual(tok.type, 'hexint')\n\t\tself.assertEqual(tok.value, 0xdeadbeef)\n\n\tdef test_string(self):\n\t\tcalc = swisscalc.Calc()\n\n\t\ttok = calc._lexme(r\"\"\"'hello'\"\"\")[0]\n\t\tself.assertEqual(tok.type, 'string')\n\t\tself.assertEqual(tok.value, 'hello')\n\n\t\ttok = calc._lexme(r'\"world\"')[0]\n\t\tself.assertEqual(tok.type, 'string')\n\t\tself.assertEqual(tok.value, \"world\")\n\n\t\ttok = calc._lexme(r\"\"\"'\\'\\n'\"\"\")[0]\n\t\tself.assertEqual(tok.type, 'string')\n\t\tself.assertEqual(tok.value, '\\'\\n')\n\n\t\ttok = calc._lexme(r\"\"\"r'\\'\\n'\"\"\")[0]\n\t\tself.assertEqual(tok.type, 'string')\n\t\tself.assertEqual(tok.value, r'\\'\\n')\n\n\t\ttok = calc._lexme(r\"\"\"R'\\'\\n'\"\"\")[0]\n\t\tself.assertEqual(tok.type, 'string')\n\t\tself.assertEqual(tok.value, R'\\'\\n')\n\n\t\ttok = calc._lexme(r'\"\\\"\\n\"')[0]\n\t\tself.assertEqual(tok.type, 'string')\n\t\tself.assertEqual(tok.value, \"\\\"\\n\")\n\n\tdef test_pointfloat(self):\n\t\tcalc = swisscalc.Calc()\n\t\ttok = calc._lexme('3.14')[0]\n\t\tself.assertEqual(tok.type, 'pointfloat')\n\t\tself.assertEqual(tok.value, 3.14)\n\n\t\ttok = calc._lexme('0.0001')[0]\n\t\tself.assertEqual(tok.type, 'pointfloat')\n\t\tself.assertEqual(tok.value, 0.0001)\n\n\t\ttok = calc._lexme('003.14')[0]\n\t\tself.assertEqual(tok.type, 'pointfloat')\n\t\tself.assertEqual(tok.value, 003.14)\n\n\tdef test_exponentfloat(self):\n\t\tcalc = swisscalc.Calc()\n\t\ttok = calc._lexme('0e0')[0]\n\t\tself.assertEqual(tok.type, 'exponentfloat')\n\t\tself.assertEqual(tok.value, 0e0)\n\n\t\ttok = calc._lexme('3.14e-10')[0]\n\t\tself.assertEqual(tok.type, 'exponentfloat')\n\t\tself.assertEqual(tok.value, 3.14e-10)\n\n\t\ttok = calc._lexme('1.141e+10')[0]\n\t\tself.assertEqual(tok.type, 'exponentfloat')\n\t\tself.assertEqual(tok.value, 1.141e+10)\n\n\t\ttok = calc._lexme('123e123')[0]\n\t\tself.assertEqual(tok.type, 'exponentfloat')\n\t\tself.assertEqual(tok.value, 123e123)\n\n\tdef test_operator(self):\n\t\tcalc = swisscalc.Calc()\n\n\t\t# numeric operator\n\n\t\ttok = calc._lexme('+')[0]\n\t\tself.assertEqual(tok.type, 'add')\n\n\t\ttok = calc._lexme('-')[0]\n\t\tself.assertEqual(tok.type, 'subtract')\n\n\t\ttok = calc._lexme('*')[0]\n\t\tself.assertEqual(tok.type, 'multiply')\n\n\t\ttok = calc._lexme('/')[0]\n\t\tself.assertEqual(tok.type, 'divide')\n\n\t\ttok = calc._lexme('%')[0]\n\t\tself.assertEqual(tok.type, 'modulo')\n\n\t\ttok = calc._lexme('**')[0]\n\t\tself.assertEqual(tok.type, 'power')\n\n\t\ttok = calc._lexme('!')[0]\n\t\tself.assertEqual(tok.type, 'factorial')\n\n\t\t# bit operator\n\n\t\ttok = calc._lexme('<<')[0]\n\t\tself.assertEqual(tok.type, 'lshift')\n\n\t\ttok = calc._lexme('>>')[0]\n\t\tself.assertEqual(tok.type, 'rshift')\n\n\t\ttok = calc._lexme('&')[0]\n\t\tself.assertEqual(tok.type, 'and')\n\n\t\ttok = calc._lexme('~')[0]\n\t\tself.assertEqual(tok.type, 'not')\n\n\t\ttok = calc._lexme('|')[0]\n\t\tself.assertEqual(tok.type, 'or')\n\n\t\ttok = calc._lexme('^')[0]\n\t\tself.assertEqual(tok.type, 'xor')\n\n\tdef test_delimiter(self):\n\t\tcalc = swisscalc.Calc()\n\t\ttok = calc._lexme('=')[0]\n\t\tself.assertEqual(tok.type, 'assign')\n\n\t\ttok = calc._lexme('+=')[0]\n\t\tself.assertEqual(tok.type, 'addassign')\n\n\t\ttok = calc._lexme('-=')[0]\n\t\tself.assertEqual(tok.type, 'subassign')\n\n\t\ttok = calc._lexme('*=')[0]\n\t\tself.assertEqual(tok.type, 'mulassign')\n\n\t\ttok = calc._lexme('/=')[0]\n\t\tself.assertEqual(tok.type, 'divassign')\n\n\t\ttok = calc._lexme('%=')[0]\n\t\tself.assertEqual(tok.type, 'modassign')\n\n\t\ttok = calc._lexme('**=')[0]\n\t\tself.assertEqual(tok.type, 'powassign')\n\n\t\ttok = calc._lexme('<<=')[0]\n\t\tself.assertEqual(tok.type, 'lsftassign')\n\n\t\ttok = calc._lexme('>>=')[0]\n\t\tself.assertEqual(tok.type, 'rsftassign')\n\n\t\ttok = calc._lexme('&=')[0]\n\t\tself.assertEqual(tok.type, 'andassign')\n\n\t\ttok = calc._lexme('|=')[0]\n\t\tself.assertEqual(tok.type, 'orassign')\n\n\t\ttok = calc._lexme('^=')[0]\n\t\tself.assertEqual(tok.type, 'xorassign')\n\n\t\ttok = calc._lexme('(')[0]\n\t\tself.assertEqual(tok.type, 'lparen')\n\n\t\ttok = calc._lexme(')')[0]\n\t\tself.assertEqual(tok.type, 'rparen')\n\n\t\ttok = calc._lexme(',')[0]\n\t\tself.assertEqual(tok.type, 'comma')\n", "description": "'hello'", "category": "math", "imports": ["import unittest", "import swisscalc", "import math"]}, {"term": "class", "name": "yacc", "data": "class yacc(unittest.TestCase):\n\tdef test_binop(self):\n\t\tcalc = swisscalc.Calc()\n\n\t\tans = calc.execute('3 + 2')\n\t\tself.assertEqual(float(ans), 3 + 2)\n\n\t\tans = calc.execute('3.5 + 1.1')\n\t\tself.assertEqual(float(ans), 3.5 + 1.1)\n\n\t\tans = calc.execute('3 * 2')\n\t\tself.assertEqual(float(ans), 3 * 2)\n\n\t\tans = calc.execute('3.5 * 1.1')\n\t\tself.assertEqual(float(ans), 3.5 * 1.1)\n\n\t\tans = calc.execute('3 / 2')\n\t\tself.assertEqual(float(ans), 3 / 2.0)\n\n\t\tans = calc.execute('3.5 / 1.1')\n\t\tself.assertEqual(float(ans), 3.5 / 1.1)\n\n\t\tans = calc.execute('3 % 2')\n\t\tself.assertEqual(float(ans), 3 % 2)\n\n\t\tans = calc.execute('3.5 % 1.1')\n\t\tself.assertEqual(float(ans), 3.5 % 1.1)\n\n\t\tans = calc.execute('3 ** 2')\n\t\tself.assertEqual(float(ans), 3 ** 2)\n\n\t\tans = calc.execute('3.5 ** 1.1')\n\t\tself.assertEqual(float(ans), 3.5 ** 1.1)\n\n\t\tans = calc.execute('3 << 2')\n\t\tself.assertEqual(int(ans), 3 << 2)\n\n\t\tans = calc.execute('3.5 >> 1.1')\n\t\tself.assertEqual(int(ans), 3 >> 1)\n\n\t\tans = calc.execute('3 >> 2')\n\t\tself.assertEqual(int(ans), 3 >> 2)\n\n\t\tans = calc.execute('3.5 | 1.1')\n\t\tself.assertEqual(int(ans), 3 | 1)\n\n\t\tans = calc.execute('3 & 2')\n\t\tself.assertEqual(int(ans), 3 & 2)\n\n\t\tans = calc.execute('3.5 & 1.1')\n\t\tself.assertEqual(int(ans), 3 & 1)\n\n\t\tans = calc.execute('3 ^ 2')\n\t\tself.assertEqual(int(ans), 3 ^ 2)\n\n\tdef test_unaryop(self):\n\t\tcalc = swisscalc.Calc()\n\n\t\tans = calc.execute('8!')\n\t\tself.assertEqual(int(ans),  math.factorial(8))\n\n\t\tans = calc.execute('8.23!')\n\t\tself.assertEqual(int(ans), math.factorial(8))\n\n\t\tans = calc.execute('-8')\n\t\tself.assertEqual(int(ans), -8)\n\n\t\tans = calc.execute('-8.3')\n\t\tself.assertEqual(float(ans), -8.3)\n\n\t\tans = calc.execute('~8')\n\t\tself.assertEqual(int(ans), ~8)\n\n\tdef test_assign(self):\n\t\tcalc = swisscalc.Calc()\n\n\t\tcalc.execute('v = 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3)\n\n\t\tcalc.execute('v = 3.8')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3.8)\n\n\t\tcalc.execute('v = 3')\n\t\tcalc.execute('v += 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3 + 3)\n\n\t\tcalc.execute('v = 3.8')\n\t\tcalc.execute('v += 3.8')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3.8 + 3.8)\n\n\t\tcalc.execute('v = 3')\n\t\tcalc.execute('v -= 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3 - 3)\n\n\t\tcalc.execute('v = 3.8')\n\t\tcalc.execute('v -= 3.8')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3.8 - 3.8)\n\n\t\tcalc.execute('v = 3')\n\t\tcalc.execute('v *= 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3 * 3)\n\n\t\tcalc.execute('v = 3.8')\n\t\tcalc.execute('v *= 3.8')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3.8 * 3.8)\n\n\t\tcalc.execute('v = 3')\n\t\tcalc.execute('v /= 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3 / 3)\n\n\t\tcalc.execute('v = 3.8')\n\t\tcalc.execute('v /= 3.8')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3.8 / 3.8)\n\n\t\tcalc.execute('v = 3')\n\t\tcalc.execute('v %= 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3 % 3)\n\n\t\tcalc.execute('v = 3.8')\n\t\tcalc.execute('v %= 3.8')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3.8 % 3.8)\n\n\t\tcalc.execute('v = 3')\n\t\tcalc.execute('v **= 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3 ** 3)\n\n\t\tcalc.execute('v = 3.8')\n\t\tcalc.execute('v **= 3.8')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(float(ans), 3.8 ** 3.8)\n\n\t\tcalc.execute('v = 3')\n\t\tcalc.execute('v <<= 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(int(ans), 3 << 3)\n\n\t\tcalc.execute('v = 3')\n\t\tcalc.execute('v >>= 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(int(ans), 3 >> 3)\n\n\t\tcalc.execute('v = 3')\n\t\tcalc.execute('v &= 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(int(ans), 3 & 3)\n\n\t\tcalc.execute('v = 3')\n\t\tcalc.execute('v |= 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(int(ans), 3 | 3)\n\n\t\tcalc.execute('v = 3')\n\t\tcalc.execute('v ^= 3')\n\t\tans = calc.execute('v')\n\t\tself.assertEqual(int(ans), 3 ^ 3)\n\n\tdef test_func(self):\n\t\tcalc = swisscalc.Calc()\n\n\t\tans = calc.execute('log(2 ** 8, 2)')\n\t\tself.assertEqual(float(ans), math.log(2 ** 8, 2))\n", "description": null, "category": "math", "imports": ["import unittest", "import swisscalc", "import math"]}, {"term": "class", "name": "InterfaceTest", "data": "class InterfaceTest(unittest.TestCase):\n\tdef test_names(self):\n\t\tcalc = swisscalc.Calc()\n\n\t\tans = calc.execute('pi')\n\t\tself.assertEqual(float(ans), math.pi)\n\n\t\tans = calc.execute('e')\n\t\tself.assertEqual(float(ans), math.e)\n", "description": null, "category": "math", "imports": ["import unittest", "import swisscalc", "import math"]}], [{"term": "def", "name": "get_datas", "data": "def get_datas():\n\twith open(\"./datas/calc.yml\") as f:\n\t\tdatas = yaml.safe_load(f)\n\tadd_datas = datas['add']['datas']\n\tadd_ids = datas['add']['ids']\n\tprint(add_datas)\n\tprint(add_ids)\n\treturn [add_datas, add_ids]\n\n", "description": null, "category": "math", "imports": ["import pytest", "import yaml", "from Tools.demo.sortvisu import steps", "from pythoncode.calculator import Calculator"]}, {"term": "def", "name": "setup", "data": "def setup(addsetupfile, calc, a, b, expect):\n\twith open(addsetupfile) as f:\n\t\tsetup = yaml.safe_load(f)\n\n\tfor step in setup:\n\t\tif 'add' == step:\n\t\t\tprint(\"step: add\")\n\t\t\tresult = calc.add(a, b)\n\t\telif 'add1' == step:\n\t\t\tprint(\"step: add1\")\n\t\t\tresult = calc.add1(a, b)\n\n\t\tassert expect == result\n\n", "description": null, "category": "math", "imports": ["import pytest", "import yaml", "from Tools.demo.sortvisu import steps", "from pythoncode.calculator import Calculator"]}, {"term": "class", "name": "classTestCalc:", "data": "class TestCalc:\n\tdef setup_class(self):\n\t\tprint(\"\u8ba1\u7b97\u5f00\u59cb\")\n\t\tself.calc = Calculator()\n\n\tdef teardown_class(self):\n\t\tprint(\"\u8ba1\u7b97\u7ed3\u675f\")\n\n\t# def setup(self):\n\t#\t self.calc = Calculator()\n\n\t@pytest.mark.parametrize('a,b,expect', get_datas()[0], ids=get_datas()[1])\n\tdef test_add(self, a, b, expect):\n\t\t# calc = Calculator()\n\t\tresult = self.calc.add(a, b)\n\t\tassert result == expect\n\n\t@pytest.mark.parametrize('a,b,expect', [\n\t\t[0.1, 0.1, 0.2], [0.1, 0.2, 0.3]\n\t])\n\tdef test_add_float(self, a, b, expect):\n\t\tresult = self.calc.add(a, b)\n\t\tassert round(result, 2) == expect\n\n\t# def test_add1(self):\n\t#   #  calc = Calculator()\n\t#\t result = self.calc.add (100,100)\n\t#\t assert result == 200\n\t#\n\t# def test_add2(self):\n\t#   #  calc = Calculator()\n\t#\t result = self.calc.add (0.1,0.1)\n\t#\t assert result == 0.2\n\n", "description": null, "category": "math", "imports": ["import pytest", "import yaml", "from Tools.demo.sortvisu import steps", "from pythoncode.calculator import Calculator"]}, {"term": "class", "name": "classTestCalc1:", "data": "class TestCalc1:\n\tdef setup_class(self):\n\t\tprint(\"\u8ba1\u7b97\u5f00\u59cb\")\n\t\tself.calc = Calculator()\n\n\tdef teardown_class(self):\n\t\tprint(\"\u8ba1\u7b97\u7ed3\u675f\")\n\n\t@pytest.mark.parametrize('a,b,expect', [\n\t\t[1, 1, 1], [0, 1, 0], [10, 1, 10], [-10, 1, -10], [10, -1, -10],\n\t\t[-10, -1, 10], [1, 2, 0.5], [1, 3, 0.3333333333333333], [1, 100, 0.01], [0.1, 0.1, 1],\n\t\t[0.1, 1, 0.1], [0.1, 0.001, 100]\n\t], ids=['float1_case', 'float2_case', 'float3_case', 'float4_case',\n\t\t\t'float5_case', 'float6_case', 'float7_case'])\n\tdef test_div(self, a, b, expect):\n\t\t# calc = Calculator()\n\t\tresult = self.calc.div(a, b)\n\t\tassert result == expect\n\n\t@pytest.mark.parametrize('a,b', [\n\t\t[0.1, 0], [10, 0]\n\t])\n\tdef test_div(self, a, b):\n\t\twith pytest.raises(ZeroDivisionError):  # \u8865\u8d27\u5f02\u5e38\u573a\u666f\n\t\t\tself.calc.div(a, b)\n\n\t# def test_div(self):\n\t#\t with pytest.raises(ZeroDivisionError) :   #\u8865\u8d27\u5f02\u5e38\u573a\u666f\n\t#\t\t result = self.calc.div(1,0)\n\n\t# try:\n\t#\t result = self.calc.div(1,0)\n\t# except ZeroDivisionError :\n\t#\t print(\"\u9519\u8bef\")\n\n\tdef test_add_setup(self):\n\t\ta = 1\n\t\tb = 1\n\t\texpect = 2\n\t\tsetup(\"./setup/add_setup.yml\", self.calc, a, b, expect)\n\t\t# assert 2 ==self.calc.add(1,1)\n\t\t# assert 3 == self.calc.add1(1, 2)\n\t\t# assert 0 == self.calc.add(-1, 1)\n", "description": null, "category": "math", "imports": ["import pytest", "import yaml", "from Tools.demo.sortvisu import steps", "from pythoncode.calculator import Calculator"]}], [{"term": "class", "name": "classGenerateDistance:", "data": "class GenerateDistance:\n\tdef __init__(self, tableGenerator: GenerateTables) -> None:\n\t\tself.ListOfTfmCells = []\n\t\tself.saveF = SaveToFile(os.path.abspath(os.getcwd()))\n\t\tself.TableGenerator: GenerateTables = tableGenerator\n\n\tdef GenerateEuclidesDistance(self, ListOfTfmCellsData, printTable = True):\n\t\tcalcObject = CalcDistances()\n\t\titerator = 0\n\t\tbiggerOutputList = []\n\t\tfor i in ListOfTfmCellsData:\n\t\t\toutputList = []\n\t\t\tfor k in ListOfTfmCellsData:\n\t\t\t\toutputList.append(calcObject.CalcEuclides(i, k))\n\t\t\titerator += 1\n\t\t\tbiggerOutputList.append(outputList) \n\t\tif printTable:  \n\t\t\tself.TableGenerator.TextTable(biggerOutputList, \"Euclides.txt\")\n\t\treturn biggerOutputList\n\n\tdef GenerateCosineDistance(self, ListOfTfmCellsData, printTable = True):\n\t\tcalcObject = CalcDistances()\n\t\titerator = 0\n\t\tbiggerOutputList = []\n\t\tfor i in ListOfTfmCellsData:\n\t\t\toutputList = []\n\t\t\tfor k in ListOfTfmCellsData:\n\t\t\t\toutputList.append(calcObject.CalcCosine(i, k))\n\t\t\titerator += 1\n\t\t\tbiggerOutputList.append(outputList) \n\t\tif printTable:\n\t\t\tself.TableGenerator.TextTable(biggerOutputList, \"Cosine.txt\")\n\t\treturn biggerOutputList\n\n\tdef GenerateChebysheveDistance(self, ListOfTfmCellsData, printTable = True):\n\t\tcalcObject = CalcDistances()\n\t\titerator = 0\n\t\tbiggerOutputList = []\n\t\tfor i in ListOfTfmCellsData:\n\t\t\toutputList = []\n\t\t\tfor k in ListOfTfmCellsData:\n\t\t\t\toutputList.append(calcObject.CalcChebyshev(i, k))\n\t\t\titerator += 1\n\t\t\tbiggerOutputList.append(outputList) \n\t\tif printTable:  \n\t\t\tself.TableGenerator.TextTable(biggerOutputList, \"Chebyshev.txt\")\n\t\treturn biggerOutputList\n\n\tdef GenerateManhatanDistance(self, ListOfTfmCellsData,  printTable = True):\n\t\tcalcObject = CalcDistances()\n\t\titerator = 0\n\t\tbiggerOutputList = []\n\t\tfor i in ListOfTfmCellsData:\n\t\t\toutputList = []\n\t\t\tfor k in ListOfTfmCellsData:\n\t\t\t\toutputList.append(calcObject.CalcManhatan(i, k))\n\t\t\titerator += 1\n\t\t\tbiggerOutputList.append(outputList)\n\t\tif printTable:  \n\t\t\tself.TableGenerator.TextTable(biggerOutputList, \"Manhatan.txt\")\n\t\treturn biggerOutputList\n\n\tdef GeneratePowDistance(self,ListOfTfmCellsData,  p: int, r: int):\n\t\tcalcObject = CalcDistances()\n\t\titerator = 0\n\t\tbiggerOutputList = []\n\t\tfor i in ListOfTfmCellsData:\n\t\t\toutputList = []\n\t\t\tfor k in ListOfTfmCellsData:\n\t\t\t\toutputList.append(calcObject.CaclPowDistance(i, k, p, r))\n\t\t\titerator += 1\n\t\t\tbiggerOutputList.append(outputList) \n\t\tself.TableGenerator.TextTable(biggerOutputList, \"Pow{}{}.txt\".format(p, r))\n", "description": null, "category": "math", "imports": ["import os", "from CalcDistances import CalcDistances", "from GenerateTables import GenerateTables", "from SaveToFile import SaveToFile"]}], [{"term": "class", "name": "calcNode", "data": "class calcNode():\n\tdef __init__(self, input_dim, calc='~', permute_rate=0.5, input_rate=0.5):\n\t\tself.calc = calc\n\t\tself.left = 0\n\t\tself.right = 0\n\t\tself.mid = 0\n\t\tself.permute_rate = permute_rate\n\t\tself.permute_list = ['+', '-', '*', '/', '~', '@', 'sin', 'cos', 'tan']\n\t\tself.input_dim = input_dim\n\t\tself.input_rate = input_rate\n\n\n\tdef permute(self):\n\t\tif random.random() < self.permute_rate:\n\t\t\tpermute_idx = floor(random.random() * len(self.permute_list))\n\t\t\tself.calc = self.permute_list[permute_idx]\n\t\t\tself.left = {\n\t\t\t\t'+': calcNode(self.input_dim),\n\t\t\t\t'-': calcNode(self.input_dim),\n\t\t\t\t'*': calcNode(self.input_dim),\n\t\t\t\t'/': calcNode(self.input_dim),\n\t\t\t\t'~': 0,\n\t\t\t\t'@': 0,\n\t\t\t\t'sin': calcNode(self.input_dim),\n\t\t\t\t'cos': calcNode(self.input_dim),\n\t\t\t\t'tan': calcNode(self.input_dim),\n\t\t\t}.get(self.calc)\n\t\t\tself.right = {\n\t\t\t\t'+': calcNode(self.input_dim),\n\t\t\t\t'-': calcNode(self.input_dim),\n\t\t\t\t'*': calcNode(self.input_dim),\n\t\t\t\t'/': calcNode(self.input_dim),\n\t\t\t\t'~': 0,\n\t\t\t\t'@': 0,\n\t\t\t\t'sin': 0,\n\t\t\t\t'cos': 0,\n\t\t\t\t'tan': 0,\n\t\t\t}.get(self.calc)\n\t\t\tself.mid = {\n\t\t\t\t'+': 0,\n\t\t\t\t'-': 0,\n\t\t\t\t'*': 0,\n\t\t\t\t'/': 0,\n\t\t\t\t'~': (random.random() - 0.5) * 10,\n\t\t\t\t'@': random.randrange(0, self.input_dim),\n\t\t\t\t'sin': 0,\n\t\t\t\t'cos': 0,\n\t\t\t\t'tan': 0,\n\t\t\t}.get(self.calc)\n\t\t\tif isinstance(self.left, calcNode):\n\t\t\t\tself.left.permute()\n\t\t\tif isinstance(self.right, calcNode):\n\t\t\t\tself.right.permute()\n\t\telse:\n\t\t\treturn\n\n\n\n\tdef value(self, input_):  # input_ is a list []\n\t\tif self.calc == '+':\n\t\t\treturn self.left.value(input_) + self.right.value(input_)\n\t\tif self.calc == '-':\n\t\t\treturn self.left.value(input_) - self.right.value(input_)\n\t\tif self.calc == '*':\n\t\t\treturn self.left.value(input_) * self.right.value(input_)\n\t\tif self.calc == '/':\n\t\t\treturn self.left.value(input_) * self.right.value(input_)\n\t\tif self.calc == '~':\n\t\t\treturn self.mid\n\t\tif self.calc == '@':\n\t\t\treturn input_[self.mid]\n\t\tif self.calc == 'sin':\n\t\t\treturn math.sin(self.left.value(input_))\n\t\tif self.calc == 'cos':\n\t\t\treturn math.cos(self.left.value(input_))\n\t\tif self.calc == 'tan':\n\t\t\treturn math.tan(self.left.value(input_))\n\n\t\treturn 0\n\n\tdef diff(self, input, label):\n\t\treturn math.pow(self.value(input) - label, 2)\n\n\tdef print_(self):\n\t\tprint('(', end=' ')\n\t\tif self.calc not in ['~', '@'] :\n\t\t\tself.left.print_()\n\t\tprint(self.calc, end=' ')\n\t\tif self.calc in ['~', '@'] :\n\t\t\tprint(self.mid, end=' ')\n\t\tif self.calc in ['+', '-', '*', '/']:\n\t\t\tself.right.print_()\n\t\tprint(')', end=' ')\n\n\n\n\n\n\n\n", "description": null, "category": "math", "imports": ["from random import random", "from math import floor", "import math", "import random", "import copy", "import netCDF4", "from sklearn.datasets import load_boston"]}], [{"term": "class", "name": "EvaluatorTest", "data": "class EvaluatorTest(unittest.TestCase):\n\t\"\"\"\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t\"\"\"\n\n\tdef test_number_input(self):\n\t\t\"\"\"\n\t\tTest different kinds of float inputs\n\n\t\tSee also\n\t\t  test_trailing_period (slightly different)\n\t\t  test_exponential_answer\n\t\t  test_si_suffix\n\t\t\"\"\"\n\t\teasy_eval = lambda x: calc.evaluator({}, {}, x)\n\n\t\tself.assertEqual(easy_eval(\"13\"), 13)\n\t\tself.assertEqual(easy_eval(\"3.14\"), 3.14)\n\t\tself.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n\t\tself.assertEqual(easy_eval(\"-13\"), -13)\n\t\tself.assertEqual(easy_eval(\"-3.14\"), -3.14)\n\t\tself.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n\tdef test_period(self):\n\t\t\"\"\"\n\t\tThe string '.' should not evaluate to anything.\n\t\t\"\"\"\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '.')\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '1+.')\n\n\tdef test_trailing_period(self):\n\t\t\"\"\"\n\t\tTest that things like '4.' will be 4 and not throw an error\n\t\t\"\"\"\n\t\tself.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n\tdef test_exponential_answer(self):\n\t\t\"\"\"\n\t\tTest for correct interpretation of scientific notation\n\t\t\"\"\"\n\t\tanswer = 50\n\t\tcorrect_responses = [\n\t\t\t\"50\", \"50.0\", \"5e1\", \"5e+1\",\n\t\t\t\"50e0\", \"50.0e0\", \"500e-1\"\n\t\t]\n\t\tincorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n\t\tfor input_str in correct_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\t\tfor input_str in incorrect_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to not equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertNotEqual(answer, result, msg=fail_msg)\n\n\tdef test_si_suffix(self):\n\t\t\"\"\"\n\t\tTest calc.py's unique functionality of interpreting si 'suffixes'.\n\n\t\tFor instance 'k' stand for 'kilo-' so '1k' should be 1,000\n\t\t\"\"\"\n\t\ttest_mapping = [\n\t\t\t('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n\t\t\t('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n\t\t\t('5.4m', 0.0054), ('8.7u', 0.0000087),\n\t\t\t('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n\t\t]\n\n\t\tfor (expr, answer) in test_mapping:\n\t\t\ttolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n\t\t\tfail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n\t\t\tfail_msg = fail_msg.format(expr[-1], expr, answer)\n\t\t\tself.assertAlmostEqual(\n\t\t\t\tcalc.evaluator({}, {}, expr), answer,\n\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t)\n\n\tdef test_operator_sanity(self):\n\t\t\"\"\"\n\t\tTest for simple things like '5+2' and '5/2'\n\t\t\"\"\"\n\t\tvar1 = 5.0\n\t\tvar2 = 2.0\n\t\toperators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n\t\tfor (operator, answer) in operators:\n\t\t\tinput_str = \"{0} {1} {2}\".format(var1, operator, var2)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n\t\t\t\toperator, input_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\tdef test_raises_zero_division_err(self):\n\t\t\"\"\"\n\t\tEnsure division by zero gives an error\n\t\t\"\"\"\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0.0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({'x': 0.0}, {}, '1/x')\n\n\tdef test_parallel_resistors(self):\n\t\t\"\"\"\n\t\tTest the parallel resistor operator ||\n\n\t\tThe formula is given by\n\t\t\ta || b || c ...\n\t\t\t= 1 / (1/a + 1/b + 1/c + ...)\n\t\tIt is the resistance of a parallel circuit of resistors with resistance\n\t\ta, b, c, etc&. See if this evaulates correctly.\n\t\t\"\"\"\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n\t\tself.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n\tdef test_parallel_resistors_with_zero(self):\n\t\t\"\"\"\n\t\tCheck the behavior of the || operator with 0\n\t\t\"\"\"\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n\tdef assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n\t\t\"\"\"\n\t\tHelper function to test many values at once\n\n\t\tTest the accuracy of evaluator's use of the function given by fname\n\t\tSpecifically, the equality of `fname(ins[i])` against outs[i].\n\t\tThis is used later to test a whole bunch of f(x) = y at a time\n\t\t\"\"\"\n\n\t\tfor (arg, val) in zip(ins, outs):\n\t\t\tinput_str = \"{0}({1})\".format(fname, arg)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n\t\t\t\tfname, input_str, val\n\t\t\t)\n\t\t\tself.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n\tdef test_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the trig functions provided in calc.py\n\n\t\twhich are: sin, cos, tan, arccos, arcsin, arctan\n\t\t\"\"\"\n\n\t\tangles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n\t\tcos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n\t\ttan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n\t\t# Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n\t\tself.assert_function_values('sin', angles, sin_values)\n\t\tself.assert_function_values('cos', angles, cos_values)\n\t\tself.assert_function_values('tan', angles, tan_values)\n\n\t\t# Include those where the real part is between -pi/2 and pi/2\n\t\tarcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n\t\tarcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n\t\tself.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n\t\t# Rather than a complex number, numpy.arcsin gives nan\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n\t\t# Include those where the real part is between 0 and pi\n\t\tarccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n\t\tarccos_angles = [0, 0.524, 0.628, 1 + 1j]\n\t\tself.assert_function_values('arccos', arccos_inputs, arccos_angles)\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n\t\t# Has the same range as arcsin\n\t\tarctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n\t\tarctan_angles = arcsin_angles\n\t\tself.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n\tdef test_reciprocal_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the reciprocal trig functions provided in calc.py\n\n\t\twhich are: sec, csc, cot, arcsec, arccsc, arccot\n\t\t\"\"\"\n\t\tangles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n\t\tcsc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n\t\tcot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n\t\tself.assert_function_values('sec', angles, sec_values)\n\t\tself.assert_function_values('csc', angles, csc_values)\n\t\tself.assert_function_values('cot', angles, cot_values)\n\n\t\tarcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n\t\tarcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n\t\tself.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n\t\tarccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n\t\tarccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n\t\tself.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n\t\t# Has the same range as arccsc\n\t\tarccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n\t\tarccot_angles = arccsc_angles\n\t\tself.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n\tdef test_hyperbolic_functions(self):\n\t\t\"\"\"\n\t\tTest the hyperbolic functions\n\n\t\twhich are: sinh, cosh, tanh, sech, csch, coth\n\t\t\"\"\"\n\t\tinputs = ['0', '0.5', '1', '2', '1+j']\n\t\tneg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n\t\tnegate = lambda x: [-k for k in x]\n\n\t\t# sinh is odd\n\t\tsinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n\t\tself.assert_function_values('sinh', inputs, sinh_vals)\n\t\tself.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n\t\t# cosh is even - do not negate\n\t\tcosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n\t\tself.assert_function_values('cosh', inputs, cosh_vals)\n\t\tself.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n\t\t# tanh is odd\n\t\ttanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n\t\tself.assert_function_values('tanh', inputs, tanh_vals)\n\t\tself.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n\t\t# sech is even - do not negate\n\t\tsech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n\t\tself.assert_function_values('sech', inputs, sech_vals)\n\t\tself.assert_function_values('sech', neg_inputs, sech_vals)\n\n\t\t# the following functions do not have 0 in their domain\n\t\tinputs = inputs[1:]\n\t\tneg_inputs = neg_inputs[1:]\n\n\t\t# csch is odd\n\t\tcsch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n\t\tself.assert_function_values('csch', inputs, csch_vals)\n\t\tself.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n\t\t# coth is odd\n\t\tcoth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n\t\tself.assert_function_values('coth', inputs, coth_vals)\n\t\tself.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n\tdef test_hyperbolic_inverses(self):\n\t\t\"\"\"\n\t\tTest the inverse hyperbolic functions\n\n\t\twhich are of the form arc[X]h\n\t\t\"\"\"\n\t\tresults = [0, 0.5, 1, 2, 1 + 1j]\n\n\t\tsinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n\t\tself.assert_function_values('arcsinh', sinh_vals, results)\n\n\t\tcosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n\t\tself.assert_function_values('arccosh', cosh_vals, results)\n\n\t\ttanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n\t\tself.assert_function_values('arctanh', tanh_vals, results)\n\n\t\tsech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n\t\tself.assert_function_values('arcsech', sech_vals, results)\n\n\t\tresults = results[1:]\n\t\tcsch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n\t\tself.assert_function_values('arccsch', csch_vals, results)\n\n\t\tcoth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n\t\tself.assert_function_values('arccoth', coth_vals, results)\n\n\tdef test_other_functions(self):\n\t\t\"\"\"\n\t\tTest the non-trig functions provided in calc.py\n\n\t\tSpecifically:\n\t\t  sqrt, log10, log2, ln, abs,\n\t\t  fact, factorial\n\t\t\"\"\"\n\n\t\t# Test sqrt\n\t\tself.assert_function_values(\n\t\t\t'sqrt',\n\t\t\t[0, 1, 2, 1024],  # -1\n\t\t\t[0, 1, 1.414, 32]  # 1j\n\t\t)\n\t\t# sqrt(-1) is NAN not j (!!).\n\n\t\t# Test logs\n\t\tself.assert_function_values(\n\t\t\t'log10',\n\t\t\t[0.1, 1, 3.162, 1000000, '1+j'],\n\t\t\t[-1, 0, 0.5, 6, 0.151 + 0.341j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'log2',\n\t\t\t[0.5, 1, 1.414, 1024, '1+j'],\n\t\t\t[-1, 0, 0.5, 10, 0.5 + 1.133j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'ln',\n\t\t\t[0.368, 1, 1.649, 2.718, 42, '1+j'],\n\t\t\t[-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n\t\t)\n\n\t\t# Test abs\n\t\tself.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n\t\t# Test factorial\n\t\tfact_inputs = [0, 1, 3, 7]\n\t\tfact_values = [1, 1, 6, 5040]\n\t\tself.assert_function_values('fact', fact_inputs, fact_values)\n\t\tself.assert_function_values('factorial', fact_inputs, fact_values)\n\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n\tdef test_constants(self):\n\t\t\"\"\"\n\t\tTest the default constants provided in calc.py\n\n\t\twhich are: j (complex number), e, pi, k, c, T, q\n\t\t\"\"\"\n\n\t\t# Of the form ('expr', python value, tolerance (or None for exact))\n\t\tdefault_variables = [\n\t\t\t('i', 1j, None),\n\t\t\t('j', 1j, None),\n\t\t\t('e', 2.7183, 1e-4),\n\t\t\t('pi', 3.1416, 1e-4),\n\t\t\t('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n\t\t\t('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n\t\t\t('T', 298.15, 0.01),  # Typical room temperature (Kelvin)\n\t\t\t('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n\t\t]\n\t\tfor (variable, value, tolerance) in default_variables:\n\t\t\tfail_msg = \"Failed on constant '{0}', not within bounds\".format(\n\t\t\t\tvariable\n\t\t\t)\n\t\t\tresult = calc.evaluator({}, {}, variable)\n\t\t\tif tolerance is None:\n\t\t\t\tself.assertEqual(value, result, msg=fail_msg)\n\t\t\telse:\n\t\t\t\tself.assertAlmostEqual(\n\t\t\t\t\tvalue, result,\n\t\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t\t)\n\n\tdef test_complex_expression(self):\n\t\t\"\"\"\n\t\tCalculate combinations of operators and default functions\n\t\t\"\"\"\n\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n\t\t\t10.180,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n\t\t\t1.6,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"10||sin(7+5)\"),\n\t\t\t-0.567, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"sin(e)\"),\n\t\t\t0.41, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"k*T/q\"),\n\t\t\t0.025, delta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"e^(j*pi)\"),\n\t\t\t-1, delta=1e-5\n\t\t)\n\n\tdef test_explicit_sci_notation(self):\n\t\t\"\"\"\n\t\tExpressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^-3\"),\n\t\t\t-0.0016\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n\t\t\t-0.0016\n\t\t)\n\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^3\"),\n\t\t\t-1600\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(3)\"),\n\t\t\t-1600\n\t\t)\n\n\tdef test_simple_vars(self):\n\t\t\"\"\"\n\t\tSubstitution of variables into simple equations\n\t\t\"\"\"\n\t\tvariables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n\t\t# Should not change value of constant\n\t\t# even with different numbers of variables...\n\t\tself.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n\t\t# Easy evaluation\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n\t\t# Test a simple equation\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, '3*x-y'),\n\t\t\t21.25, delta=0.01  # = 3 * 9.72 - 7.91\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, 'x*y'),\n\t\t\t76.89, delta=0.01\n\t\t)\n\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(\n\t\t\t\t{'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n\t\t\t\t{}, \"5\"\n\t\t\t),\n\t\t\t5\n\t\t)\n\n\tdef test_variable_case_sensitivity(self):\n\t\t\"\"\"\n\t\tTest the case sensitivity flag and corresponding behavior\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n\t\t\t8.0\n\t\t)\n\n\t\tvariables = {'t': 1.0}\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(variables, {}, \"t\", case_sensitive=True),\n\t\t\t1.0\n\t\t)\n\t\t# Recall 'T' is a default constant, with value 298.15\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, \"T\", case_sensitive=True),\n\t\t\t298, delta=0.2\n\t\t)\n\n\tdef test_simple_funcs(self):\n\t\t\"\"\"\n\t\tSubsitution of custom functions\n\t\t\"\"\"\n\t\tvariables = {'x': 4.712}\n\t\tfunctions = {'id': lambda x: x}\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n\t\tfunctions.update({'f': numpy.sin})\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, functions, 'f(x)'),\n\t\t\t-1, delta=1e-3\n\t\t)\n\n\tdef test_function_case_insensitive(self):\n\t\t\"\"\"\n\t\tTest case insensitive evaluation\n\n\t\tNormal functions with some capitals should be fine\n\t\t\"\"\"\n\t\tself.assertAlmostEqual(\n\t\t\t-0.28,\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n\t\t\tdelta=1e-3\n\t\t)\n\n\tdef test_function_case_sensitive(self):\n\t\t\"\"\"\n\t\tTest case sensitive evaluation\n\n\t\tIncorrectly capitilized should fail\n\t\tAlso, it should pick the correct version of a function.\n\t\t\"\"\"\n\t\twith self.assertRaisesRegex(calc.UndefinedVariable, 'SiN'):\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n\t\t# With case sensitive turned on, it should pick the right function\n\t\tfunctions = {'f': lambda x: x, 'F': lambda x: x + 1}\n\t\tself.assertEqual(\n\t\t\t6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n\t\t)\n\t\tself.assertEqual(\n\t\t\t7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n\t\t)\n\n\tdef test_undefined_vars(self):\n\t\t\"\"\"\n\t\tCheck to see if the evaluator catches undefined variables\n\t\t\"\"\"\n\t\tvariables = {'R1': 2.0, 'R3': 4.0}\n\n\t\twith self.assertRaisesRegex(calc.UndefinedVariable, 'QWSEKO'):\n\t\t\tcalc.evaluator({}, {}, \"5+7*QWSEKO\")\n\t\twith self.assertRaisesRegex(calc.UndefinedVariable, 'r2'):\n\t\t\tcalc.evaluator({'r1': 5}, {}, \"r1+r2\")\n\t\twith self.assertRaisesRegex(calc.UndefinedVariable, 'r1 r3'):\n\t\t\tcalc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "description": "\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t", "category": "math", "imports": ["import unittest", "import numpy", "import calc", "from pyparsing import ParseException"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "do_math", "data": "def do_math(stack):\n\ta = stack.pop()\n\top = stack.pop()\n\tb = stack.pop()\n\tif op == '+':\n\t\tstack.append(str(int(b)+int(a)))\n\telif op == '*':\n\t\tstack.append(str(int(b)*int(a)))\n\treturn stack\n", "description": null, "category": "math", "imports": ["import os", "import re", "import time"]}, {"term": "def", "name": "do_calc1", "data": "def do_calc1(equation):\n\tcalc_stack = []\n\tfor a in equation:\n\t\tif not calc_stack:\n\t\t\tcalc_stack.append(a)\n\t\telif a == '+' or a == '*':\n\t\t\tcalc_stack.append(a)\n\t\telif a == '(':\n\t\t\tcalc_stack.append(a)\n\t\telif a.isdigit():\n\t\t\tif len(calc_stack) > 0:\n\t\t\t\top = calc_stack[-1]\n\t\t\t\tif op == '+' or op == '*':\n\t\t\t\t\tcalc_stack.append(a)\n\t\t\t\t\tcalc_stack = do_math(calc_stack)\n\t\t\t\telse:\n\t\t\t\t\tcalc_stack.append(a)\n\t\telif a == ')':\n\t\t\ttemp = 0\n\t\t\tc = calc_stack.pop()\n\t\t\twhile c != '(':\n\t\t\t\ttemp = c\n\t\t\t\tc = calc_stack.pop()\n\t\t\tif len(calc_stack) > 1:\n\t\t\t\top = calc_stack[-1]\n\t\t\t\tif op == '+' or op == '*':\n\t\t\t\t\tcalc_stack.append(temp)\n\t\t\t\t\tcalc_stack = do_math(calc_stack)\n\t\t\t\telse:\n\t\t\t\t\tcalc_stack.append(temp)\n\t\t\telse:\n\t\t\t\tcalc_stack.append(temp)\n\n\treturn int(calc_stack.pop())\n", "description": null, "category": "math", "imports": ["import os", "import re", "import time"]}, {"term": "def", "name": "add", "data": "def add(stack):\n\ta = stack.pop()\n\top = stack.pop()\n\tb = stack.pop()\n\tassert(op == '+')\n\tstack.append(str(int(b)+int(a)))\n\treturn stack\n", "description": null, "category": "math", "imports": ["import os", "import re", "import time"]}, {"term": "def", "name": "multiply", "data": "def multiply(stack):\n\ta = stack.pop()\n\top = stack.pop()\n\tb = stack.pop()\n\tassert(op == '*')\n\tstack.append(str(int(b)*int(a)))\n\treturn stack\n", "description": null, "category": "math", "imports": ["import os", "import re", "import time"]}, {"term": "def", "name": "do_calc2", "data": "def do_calc2(equation):\n\tcalc_stack = []\n\tfor a in equation:\n\t\tif not calc_stack:\n\t\t\tcalc_stack.append(a)\n\t\telif a == '+' or a == '*':\n\t\t\tcalc_stack.append(a)\n\t\telif a == '(':\n\t\t\tcalc_stack.append(a)\n\t\telif a.isdigit():\n\t\t\tif len(calc_stack) > 0:\n\t\t\t\top = calc_stack[-1]\n\t\t\t\tif op == '+':\n\t\t\t\t\tcalc_stack.append(a)\n\t\t\t\t\tcalc_stack = add(calc_stack)\n\t\t\t\t# this is different\n\t\t\t\telif op == '*':\n\t\t\t\t\tcalc_stack.append(a)\n\t\t\t\t\tif '*' in calc_stack:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\telse:\n\t\t\t\t\t\tcalc_stack = multiply(calc_stack)\n\t\t\t\telse:\n\t\t\t\t\tcalc_stack.append(a)\n\t\telif a == ')':\n\t\t\ttemp_stack = []\n\t\t\ttemp = 0\n\t\t\tc = calc_stack.pop()\n\t\t\twhile c != '(':\n\t\t\t\ttemp_stack.append(c)\n\t\t\t\tc = calc_stack.pop()\n\t\t\twhile len(temp_stack) > 1:\n\t\t\t\ttemp_stack = multiply(temp_stack)\n\t\t\ttemp = temp_stack.pop()\n\t\t\tif len(calc_stack) > 1:\n\t\t\t\top = calc_stack[-1]\n\t\t\t\tif op == '+':\n\t\t\t\t\tcalc_stack.append(temp)\n\t\t\t\t\tcalc_stack = add(calc_stack)\n\t\t\t\telif op == '*':\n\t\t\t\t\tcalc_stack.append(temp)\n\t\t\t\t\tif '*' in calc_stack:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tcalc_stack = multiply(calc_stack)\n\t\t\t\telse:\n\t\t\t\t\tcalc_stack.append(temp)\n\t\t\telse:\n\t\t\t\tcalc_stack.append(temp)\n\n\twhile len(calc_stack) > 1:\n\t\tcalc_stack = multiply(calc_stack)\n\n\treturn int(calc_stack.pop())\n", "description": null, "category": "math", "imports": ["import os", "import re", "import time"]}, {"term": "def", "name": "part1", "data": "def part1(data):\n\treg = re.compile(r'\\d+|[\\(\\)\\*\\+]')\n\tsum = 0\n\tfor line in data:\n\t\tchars = reg.findall(line)\n\t\tanswer = do_calc1(chars)\n\t\tif DEBUG:\n\t\t\tprint(\"{} = {}\".format(line, answer))\n\t\tsum += answer\n\tprint(\"Part 1: {}\".format(sum))\n", "description": null, "category": "math", "imports": ["import os", "import re", "import time"]}, {"term": "def", "name": "part2", "data": "def part2(data):\n\treg = re.compile(r'\\d+|[\\(\\)\\*\\+]')\n\tsum = 0\n\tfor line in data:\n\t\tchars = reg.findall(line)\n\t\tanswer = do_calc2(chars)\n\t\tif DEBUG:\n\t\t\tprint(\"{} = {}\".format(line, answer))\n\t\tsum += answer\n\tprint(\"Part 2: {}\".format(sum))\n", "description": null, "category": "math", "imports": ["import os", "import re", "import time"]}, {"term": "def", "name": "main", "data": "def main():\n\tprint(\"Day {}\".format(os.path.split(DIRPATH)[1]))\n\n\twith open(DATA) as file:\n\t\tdata = file.read().splitlines()\n\n\ttime1 = time.perf_counter()\n\tpart1(data)\n\ttime2 = time.perf_counter()\n\tprint(\"{} seconds\".format(time2-time1))\n\n\ttime1 = time.perf_counter()\n\tpart2(data)\n\ttime2 = time.perf_counter()\n\tprint(\"{} seconds\".format(time2-time1))\n", "description": null, "category": "math", "imports": ["import os", "import re", "import time"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "classTestCalculation:", "data": "class TestCalculation:\n\tdef setup(self):\n\t\tself.calc = Calculator\n\n\tdef test_multiply_calc_correct(self):\n\t\tassert self.calc.multiply(self, 2, 2) == 4\n\n\tdef test_division_calc_correct(self):\n\t\tassert self.calc.division(self, 10, 2) == 5\n\n\tdef test_substaction_calc_correct(self):\n\t\tassert self.calc.subtraction(self, 8, 2) == 6\n\n\tdef test_adding_calc_correct(self):\n", "description": null, "category": "math", "imports": ["from app.calculator import Calculator", "import pytest"]}], [{"term": "def", "name": "test_vasp_check_state", "data": "def test_vasp_check_state(factory, atoms_2co):\n\t\"\"\"\n\tRun tests to ensure that the VASP check_state() function call works correctly,\n\ti.e. correctly sets the working directories and works in that directory.\n\n\tThis is conditional on the existence of the VASP_COMMAND or VASP_SCRIPT\n\tenvironment variables\n\n\t\"\"\"\n\n\tatoms = atoms_2co  # aliasing\n\n\t# Test\n\tsettings = dict(xc='LDA',\n\t\t\t\t\tprec='Low',\n\t\t\t\t\talgo='Fast',\n\t\t\t\t\tismear=0,\n\t\t\t\t\tsigma=1.,\n\t\t\t\t\tistart=0,\n\t\t\t\t\tlwave=False,\n\t\t\t\t\tlcharg=False)\n\n\ts1 = atoms.get_chemical_symbols()\n\n\tcalc = factory.calc(**settings)\n\n\tatoms.calc = calc\n\n\ten1 = atoms.get_potential_energy()\n\n\t# Test JSON dumping and restarting works\n\tfi = 'json_test.json'\n\tcalc.write_json(filename=fi)\n\n\tassert os.path.isfile(fi)\n\n\tcalc2 = factory.calc()\n\tcalc2.read_json(fi)\n\tassert not calc2.calculation_required(atoms, ['energy', 'forces'])\n\ten2 = calc2.get_potential_energy()\n\tassert abs(en1 - en2) < 1e-8\n\tos.remove(fi)  # Clean up the JSON file\n\n\t# Check that the symbols remain in order (non-sorted)\n\ts2 = calc.atoms.get_chemical_symbols()\n\tassert s1 == s2\n\ts3 = sorted(s2)\n\tassert s2 != s3\n\n\t# Check that get_atoms() doesn't reset results\n\tr1 = dict(calc.results)  # Force a copy\n\tcalc.get_atoms()\n\tr2 = dict(calc.results)\n\tassert r1 == r2\n\n\t# Make a parameter change to the calculator\n\tcalc.set(sigma=0.5)\n\n\t# Check that we capture a change for float params\n\tassert calc.check_state(atoms) == ['float_params']\n\tassert calc.calculation_required(atoms, ['energy', 'forces'])\n\n\ten2 = atoms.get_potential_energy()\n\n\t# The change in sigma should result in a small change in energy\n\tassert (en1 - en2) > 1e-7\n\n\t# Now we make a change in input_params instead\n\tcalc.kpts = 2\n\n\t# Check that this requires a new calculation\n\tassert calc.check_state(atoms) == ['input_params']\n\tassert calc.calculation_required(atoms, ['energy', 'forces'])\n\n\t# Clean up\n\tcalc.clean()\n", "description": "\n\tRun tests to ensure that the VASP check_state() function call works correctly,\n\ti.e. correctly sets the working directories and works in that directory.\n\n\tThis is conditional on the existence of the VASP_COMMAND or VASP_SCRIPT\n\tenvironment variables\n\n\t", "category": "math", "imports": ["import os", "import pytest"]}], [{"term": "def", "name": "test_correct", "data": "def test_correct(bot_helper):\n\tcalc = bot_helper['calc']\n\tassert calc._calc(\"2^6\") == \"4\"\n\tassert calc._calc(\"2**6\") == \"64\"\n\tassert calc._calc(\"1 + 2*3**(4^5) / (6 + -7)\") == \"-5.0\"\n\tassert calc._calc(\"~5\") == \"-6\"\n\tassert calc._calc(\"pi + 3\") == \"6.141592653589793\"\n\tassert calc._calc(\"\") == \"You want to calculate something? Type in an expression then!\"\n\tassert calc._calc(\"N\") == \"6.0221412927e+23\"\n\tassert calc._calc(\"3 + \u00cf\u20ac\") == \"6.141592653589793\"  # Also tests unicode\n\tassert calc._calc(\"3 < 5\") == \"True\"\n\tassert calc._calc(\"3 < 5 <= 7\") == \"True\"\n\tassert calc._calc(\"456 == 1\") == \"False\"\n\tassert calc._calc(\"True ^ True\") == \"False\"\n\tassert calc._calc(\"True + 1\") == \"2\"\n\tassert calc._calc(\"~True\") == \"-2\"\n\tassert calc._calc(\"2 << 31 << 31 << 31\") == \"19807040628566084398385987584\"\n\tassert calc._calc(\"sin(5)\") == \"-0.9589242746631385\"\n\tassert calc._calc(\"factorial(factorial(4))\") == \"620448401733239439360000\"\n\n", "description": null, "category": "math", "imports": ["import sys", "import pytest"]}, {"term": "def", "name": "test_error", "data": "def test_error(bot_helper):\n\tcalc = bot_helper['calc']\n\tassert calc._calc(\"9999**9999\") == \"Error, would take too long to calculate\"\n\tassert calc._calc(\"1 / 0\") == \"Error, division by zero\"\n\tassert calc._calc(\"1 % 0\") == \"Error, division by zero\"\n\tassert calc._calc(\"1 // 0\") == \"Error, division by zero\"\n\tassert calc._calc(\"1 + \") == \"Error, invalid syntax\"\n\tassert calc._calc(\"e = 1\") == \"Error, invalid calculation\"\n\tassert calc._calc(\"sgdsdg + 3\") == \"Error, unknown constant or function\"\n\tassert calc._calc(\"2.0 << 2.0\") == \"Error, non-integer shift values\"\n\tassert calc._calc(\"2.0 >> 2.0\") == \"Error, non-integer shift values\"\n\tassert calc._calc(\"1 << (1 << (1 << 10))\") == \"Error, would take too long to calculate\"\n\tassert calc._calc(\"5 in 5\") == \"Error, invalid operator\"\n\tassert calc._calc(\"429496729 << 1000\") == \"Error, result too long to be printed\"\n\tassert calc._calc(\"factorial(101)\") == \"Error, would take too long to calculate\"\n\tassert calc._calc(\"2**(2 << 512)\") == \"Error, would take too long to calculate\"\n\tassert calc._calc(\"factorial(ceil)\") == \"Error, invalid arguments\"\n\tassert calc._calc(\"factorial(1 == 2)\"), \"Error, invalid arguments\"\n\tassert calc._calc(\"(lambda x: x)(1)\") == \"Error, invalid calculation\"\n\tassert calc._calc(\"10.0**1000\") == \"Error, too large to represent as float\"\n\tassert calc._calc(\"'B' > 'H'\") == \"Error, invalid argument\"\n\tassert calc._calc(\"e ^ pi\") == \"Error, invalid arguments\"\n\tassert calc._calc(\"factorial(-42)\") == \"Error, factorial() not defined for negative values\"\n\tif sys.version_info < (3, 10):\n\t\tassert calc._calc(\"factorial(4.2)\") == \"Error, factorial() only accepts integral values\"\n\telse:\n\t\tassert calc._calc(\"factorial(4.2)\") == \"Error, invalid arguments\"\n\tassert calc._calc(\"not await 1\").startswith(\"Error,\")   # ast SyntaxError in Python 3.6 but not 3.7\n\tif sys.version_info < (3, 9):\n\t\tassert calc._calc(\"(\" * 200 + \")\" * 200) == \"Error, unable to parse\"\n\tassert calc._calc(\"1@2\") == \"Error, invalid operator\"\n", "description": null, "category": "math", "imports": ["import sys", "import pytest"]}], [{"term": "class", "name": "classleast_squares:", "data": "class least_squares:\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "__init__", "data": "  def __init__(self, obs, calc):\n\tself.obs = obs\n\tself.calc = calc\n\ta, b = self.calc.real, self.calc.imag\n\tself.abs_calc = math.sqrt(a**2 + b**2)\n\tself.delta = self.obs - self.abs_calc\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "f", "data": "  def f(self):\n\t\"Mathematica: f=(obs-Sqrt[a^2+b^2])^2\"\n\treturn self.delta**2\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "da", "data": "  def da(self):\n\t\"Mathematica: D[f,a]\"\n\tif (self.abs_calc == 0): return 0\n\treturn -2 * self.delta * self.calc.real / self.abs_calc\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "db", "data": "  def db(self):\n\t\"Mathematica: D[f,b]\"\n\tif (self.abs_calc == 0): return 0\n\treturn -2 * self.delta * self.calc.imag / self.abs_calc\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "daa", "data": "  def daa(self):\n\t\"Mathematica: FortranForm[FullSimplify[D[f,a,a]]]\"\n\tac = self.abs_calc\n\tif (ac == 0):\n\t  if (self.obs == 0): return 2\n\t  return -1.e160\n\treturn 2 - (2*self.calc.imag**2*self.obs)/ac/ac/ac\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "dbb", "data": "  def dbb(self):\n\t\"Mathematica: FortranForm[FullSimplify[D[f,b,b]]]\"\n\tac = self.abs_calc\n\tif (ac == 0):\n\t  if (self.obs == 0): return 2\n\t  return -1.e160\n\treturn 2 - (2*self.calc.real**2*self.obs)/ac/ac/ac\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "dab", "data": "  def dab(self):\n\t\"Mathematica: FortranForm[FullSimplify[D[f,a,b]]]\"\n\tac = self.abs_calc\n\tif (ac == 0):\n\t  if (self.obs == 0): return 0\n\t  return 1.e160\n\treturn (2*self.calc.real*self.calc.imag*self.obs)/ac/ac/ac\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "class", "name": "classexp_i_alpha_sum:", "data": "class exp_i_alpha_sum:\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "__init__", "data": "  def __init__(self, alphas):\n\tself.alphas = alphas\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "f", "data": "  def f(self):\n\t\"Mathematica: f=Exp[I alpha]\"\n\tresult = 0\n\tfor alpha in self.alphas:\n\t  result += cmath.exp(1j*alpha)\n\treturn result\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "d_alphas", "data": "  def d_alphas(self):\n\t\"Mathematica: D[f,alpha]\"\n\treturn [1j*cmath.exp(1j*alpha) for alpha in self.alphas]\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "d2_alphas", "data": "  def d2_alphas(self):\n\t\"Mathematica: D[f,alpha,alpha]\"\n\treturn [-cmath.exp(1j*alpha) for alpha in self.alphas]\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "d_target_d_alphas", "data": "  def d_target_d_alphas(self, target):\n\t\"Rule for derivatives of sum of roots of unity.\"\n\tda, db = target.da(), target.db()\n\treturn [da * d.real + db * d.imag for d in self.d_alphas()]\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}, {"term": "def", "name": "d2_target_d_alphas", "data": "  def d2_target_d_alphas(self, target):\n\t\"Product rule applied to da * d.real + db * d.imag.\"\n\tresult = []\n\tda, db = target.da(), target.db()\n\tdaa, dbb, dab = target.daa(), target.dbb(), target.dab()\n\td = self.d_alphas()\n\td2 = self.d2_alphas()\n\tfor di,d2i in zip(d, d2):\n\t  row = []\n\t  for dj in d:\n\t\tsum = daa * di.real * dj.real \\\n\t\t\t+ dbb * di.imag * dj.imag \\\n\t\t\t+ dab * (di.real * dj.imag + di.imag * dj.real)\n\t\tif (di is dj):\n\t\t  sum += da * d2i.real + db * d2i.imag\n\t\trow.append(sum)\n\t  result.append(row)\n\treturn result\n", "description": null, "category": "math", "imports": ["from __future__ import absolute_import, division, print_function", "import cmath", "import math", "from six.moves import zip"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "test_calc_nodewise_row", "data": "def test_calc_nodewise_row():\n\n\tnp.random.seed(435265)\n\tX = np.random.normal(size=(50, 3))\n\tghat = _calc_nodewise_row(X, 0, 0.01)\n\tassert_equal(ghat.shape, (2,))\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_equal, assert_", "from statsmodels.stats.regularized_covariance import _calc_nodewise_row, _calc_nodewise_weight, _calc_approx_inv_cov, RegularizedInvCovariance"]}, {"term": "def", "name": "test_calc_nodewise_weight", "data": "def test_calc_nodewise_weight():\n\n\tnp.random.seed(435265)\n\tX = np.random.normal(size=(50, 3))\n\tghat = np.random.normal(size=2)\n\tthat = _calc_nodewise_weight(X, ghat, 0, 0.01)\n\tassert_(isinstance(that, float))\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_equal, assert_", "from statsmodels.stats.regularized_covariance import _calc_nodewise_row, _calc_nodewise_weight, _calc_approx_inv_cov, RegularizedInvCovariance"]}, {"term": "def", "name": "test_calc_approx_inv_cov", "data": "def test_calc_approx_inv_cov():\n\n\tnp.random.seed(435265)\n\tX = np.random.normal(size=(50, 3))\n\tghat_l = []\n\tthat_l = []\n\tfor i in range(3):\n\t\tghat = _calc_nodewise_row(X, i, 0.01)\n\t\tthat = _calc_nodewise_weight(X, ghat, i, 0.01)\n\t\tghat_l.append(ghat)\n\t\tthat_l.append(that)\n\ttheta_hat = _calc_approx_inv_cov(np.array(ghat_l), np.array(that_l))\n\tassert_equal(theta_hat.shape, (3, 3))\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_equal, assert_", "from statsmodels.stats.regularized_covariance import _calc_nodewise_row, _calc_nodewise_weight, _calc_approx_inv_cov, RegularizedInvCovariance"]}, {"term": "def", "name": "test_fit", "data": "def test_fit():\n\n\tnp.random.seed(435265)\n\tX = np.random.normal(size=(50, 3))\n\tinv = np.linalg.inv(np.cov(X.T))\n\tregcov = RegularizedInvCovariance(exog=X)\n\tregcov.fit()\n\t# check that unregularized is what we expect\n\tdiff = np.linalg.norm(regcov.approx_inv_cov() - inv)\n\tassert_(diff < 0.1)\n\n\t# check that regularizing actually does something\n\tregcov.fit(alpha=0.5)\n\tassert_(np.sum(regcov.approx_inv_cov() == 0) > np.sum(inv == 0))\n", "description": null, "category": "math", "imports": ["import numpy as np", "from numpy.testing import assert_equal, assert_", "from statsmodels.stats.regularized_covariance import _calc_nodewise_row, _calc_nodewise_weight, _calc_approx_inv_cov, RegularizedInvCovariance"]}], [], [{"term": "def", "name": "sqlForHistOpt", "data": "def sqlForHistOpt(calc,set_name,maxb,restriction,amino_code,res,rvalue,rfree,resL,rvalueL,rfreeL):\n\n\t# allow calc to be N-CA or N.CA or N_CA and convert it\n\tcalc = calc.replace(\".\",\"_\")\n\tcalc = calc.replace(\"-\",\"_\")\n\n\n\tres_constraint = \"\"\n\tif res != \"ALL\":\n\t\tres_constraint =  \"AND p.resolution < \" + res + \"\\n\"\n\trval_constraint = \"\"\n\tif rvalue != \"ALL\":\n\t\trval_constraint =  \"AND p.rvalue < \" +  rvalue + \"\\n\"\n\trfree_constraint = \"\"\n\tif rfree != \"ALL\":\n\t\trfree_constraint =  \"AND p.rfree < \" + rfree + \"\\n\"\n\n\tres_constraintL = \"\"\n\tif resL != \"ALL\":\n\t\tres_constraintL =  \"AND p.resolution >= \" + resL + \"\\n\"\n\trval_constraintL = \"\"\n\tif rvalueL != \"ALL\":\n\t\trval_constraintL =  \"AND p.rvalue >= \" +  rvalueL + \"\\n\"\n\trfree_constraintL = \"\"\n\tif rfreeL != \"ALL\":\n\t\trfree_constraintL =  \"AND p.rfree >= \" + rfreeL + \"\\n\"\n\n\tbfactor_restraint = \"\"\n\tif maxb != '':\n\t\tbfactor_restraint = \"AND p.bfactor < \" + maxb + \" \\n\"\n\n\tamino_restraint = \"\"\n\tif amino_code != \"NON\":\n\t\tamino_restraint = \"AND g.amino_code = '\" + amino_code + \"' \\n\"\n\n\thtml = \"\"\n\n\thtml += \"SELECT g.pdb_code, \" + calc + \" as geo, g.atoms_\" + calc + \" as atoms, g.aminos_\" + calc + \" as aminos \\n\"\n\t#html += \"from geo_core g, protein_set_c s, protein_structure_c p \\n\"\n\thtml += \"from \" + cfg.tableCore + \" g, \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n\thtml += \"WHERE \" + calc + \" IS NOT NULL\\n\"\n\thtml += \"AND s.pdb_code = g.pdb_code\\n\"\n\thtml += \"AND s.pdb_code = p.pdb_code\\n\"\n\thtml += \"AND g.pdb_code = p.pdb_code\\n\"\n\thtml += \"AND g.occupant = 'A'\\n\"\n\thtml += \"AND s.status = 'IN'\\n\"\n\thtml += bfactor_restraint\n\thtml += amino_restraint\n\thtml += \"AND s.set_name = '\" + set_name + \"'\\n\"\n\thtml += res_constraint + rval_constraint + rfree_constraint\n\thtml += res_constraintL + rval_constraintL + rfree_constraintL\n\thtml += restriction\n\thtml += \" ORDER BY geo ASC;\"\n", "description": null, "category": "math", "imports": ["import thesis_config as cfg"]}, {"term": "def", "name": "sqlForHistContact", "data": "def sqlForHistContact(calc,set_name,maxb,restriction, amino_code,res,rvalue,rfree,resL,rvalueL,rfreeL):\n\n\t# allow calc to be N-CA or N.CA or N_CA and convert it\n\tcalc = calc.replace(\".\",\"-\")\n\tcalc = calc.replace(\"_\",\"-\")\n\n\n\tres_constraint = \"\"\n\tif res != \"ALL\":\n\t\tres_constraint =  \"AND p.resolution < \" + res + \"\\n\"\n\trval_constraint = \"\"\n\tif rvalue != \"ALL\":\n\t\trval_constraint =  \"AND p.rvalue < \" +  rvalue + \"\\n\"\n\trfree_constraint = \"\"\n\tif rfree != \"ALL\":\n\t\trfree_constraint =  \"AND p.rfree < \" + rfree + \"\\n\"\n\n\tamino_restraint = \"\"\n\tif amino_code != \"NON\":\n\t\tamino_restraint += \"AND g.amino_code = '\" + amino_code + \"'\\n\"\n\n\tres_constraintL = \"\"\n\tif resL != \"ALL\":\n\t\tres_constraintL =  \"AND p.resolution >= \" + resL + \"\\n\"\n\trval_constraintL = \"\"\n\tif rvalueL != \"ALL\":\n\t\trval_constraintL =  \"AND p.rvalue >= \" +  rvalueL + \"\\n\"\n\trfree_constraintL = \"\"\n\tif rfreeL != \"ALL\":\n\t\trfree_constraintL =  \"AND p.rfree >= \" + rfreeL + \"\\n\"\n\n\tbfactor_restraint = \"\"\n\tif maxb != '':\n\t\tbfactor_restraint = \"AND p.bfactor < \" + maxb + \" \\n\"\n\n\thtml = \"\"\n\n\thtml += \"SELECT g.pdb_code, g.geo_value as geo, g.geo_atoms as atoms \\n\"\n\t#html += \"from geo_contact g, protein_set_c s, protein_structure_c p \\n\"\n\thtml += \"from \" + cfg.tableContact + \" g, \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n\thtml += \"WHERE g.geo_atoms = '\" + calc + \"' \\n\"\n\thtml += \"AND s.pdb_code = g.pdb_code\\n\"\n\thtml += \"AND s.pdb_code = p.pdb_code\\n\"\n\thtml += \"AND g.pdb_code = p.pdb_code\\n\"\n\thtml += \"AND g.occupant = 'A'\\n\"\n\thtml += \"AND s.status = 'IN'\\n\"\n\thtml += bfactor_restraint\n\thtml += \"AND amino_no < amino_no_b \\n\"\n\thtml += \"AND s.set_name = '\" + set_name + \"'\\n\"\n\thtml += res_constraint + rval_constraint + rfree_constraint + amino_restraint\n\thtml += res_constraintL + rval_constraintL + rfree_constraintL\n\thtml += restriction + \" \\n\"\n\thtml += \" ORDER BY geo ASC;\"\n\treturn (html)\n\n", "description": null, "category": "math", "imports": ["import thesis_config as cfg"]}, {"term": "def", "name": "sqlForCorrOpt", "data": "def sqlForCorrOpt(calcX,calcY,maxb,set_name, restriction,gradient,amino_code,res,rvalue,rfree,resL,rvalueL,rfreeL):\n\n\t# allow calc to be N-CA or N.CA or N_CA and convert it\n\tcalcX = calcX.replace(\".\",\"_\")\n\tcalcX = calcX.replace(\"-\",\"_\")\n\n\tcalcY = calcY.replace(\".\",\"_\")\n\tcalcY = calcY.replace(\"-\",\"_\")\n\n\tres_constraint = \"\"\n\tif res != \"ALL\":\n\t\tres_constraint =  \"AND p.resolution < \" + res + \"\\n\"\n\trval_constraint = \"\"\n\tif rvalue != \"ALL\":\n\t\trval_constraint =  \"AND p.rvalue < \" +  rvalue + \"\\n\"\n\trfree_constraint = \"\"\n\tif rfree != \"ALL\":\n\t\trfree_constraint =  \"AND p.rfree < \" + rfree + \"\\n\"\n\n\tres_constraintL = \"\"\n\tif resL != \"ALL\":\n\t\tres_constraintL =  \"AND p.resolution >= \" + resL + \"\\n\"\n\trval_constraintL = \"\"\n\tif rvalueL != \"ALL\":\n\t\trval_constraintL =  \"AND p.rvalue >= \" +  rvalueL + \"\\n\"\n\trfree_constraintL = \"\"\n\tif rfreeL != \"ALL\":\n\t\trfree_constraintL =  \"AND p.rfree >= \" + rfreeL + \"\\n\"\n\n\tbfactor_restraint = \"\"\n\tif maxb != '':\n\t\tbfactor_restraint = \"AND p.bfactor < \" + maxb + \" \\n\"\n\n\tamino_restraint = \"\"\n\tif amino_code != \"NON\":\n\t\tamino_restraint = \"AND g.amino_code = '\" + amino_code + \"' \\n\"\n\n\thtml = \"\"\n\n\t\n\thtml += \"SELECT g.pdb_code, \" + calcX + \" as geox, \" + calcY + \" as geoy, \" + gradient.lower() + \" as resolution \\n\"\n\t#html += \"from geo_core g, protein_set_c s, protein_structure_c p \\n\"\n\thtml += \"from \" + cfg.tableCore + \" g, \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n\n\thtml += \"WHERE \" + calcX + \" IS NOT NULL\\n\"\n\thtml += \"AND \" + calcY + \" IS NOT NULL\\n\"\n\t\n\thtml += \"AND s.pdb_code = g.pdb_code\\n\"\n\thtml += \"AND s.pdb_code = p.pdb_code\\n\"\n\thtml += \"AND g.pdb_code = p.pdb_code\\n\"\n\thtml += \"AND g.occupant = 'A'\\n\"\n\thtml += bfactor_restraint\n\thtml += amino_restraint\n\thtml += \"AND s.set_name = '\" + set_name + \"'\\n\"\n\thtml += res_constraint + rval_constraint + rfree_constraint\n\thtml += res_constraintL + rval_constraintL + rfree_constraintL\n\thtml += restriction\n\thtml += \" AND s.status = 'IN';\"\n", "description": null, "category": "math", "imports": ["import thesis_config as cfg"]}, {"term": "def", "name": "sqlForScatter3d", "data": "def sqlForScatter3d(calcX,calcY,calcZ,maxb,set_name, restriction,gradient,amino_code,res,rvalue,rfree,resL,rvalueL,rfreeL):\n\n\t# allow calc to be N-CA or N.CA or N_CA and convert it\n\tcalcX = calcX.replace(\".\",\"_\")\n\tcalcX = calcX.replace(\"-\",\"_\")\n\n\tcalcY = calcY.replace(\".\",\"_\")\n\tcalcY = calcY.replace(\"-\",\"_\")\n\n\tcalcZ = calcZ.replace(\".\",\"_\")\n\tcalcZ = calcZ.replace(\"-\",\"_\")\n\n\tres_constraint = \"\"\n\tif res != \"ALL\":\n\t\tres_constraint =  \"AND p.resolution < \" + res + \"\\n\"\n\trval_constraint = \"\"\n\tif rvalue != \"ALL\":\n\t\trval_constraint =  \"AND p.rvalue < \" +  rvalue + \"\\n\"\n\trfree_constraint = \"\"\n\tif rfree != \"ALL\":\n\t\trfree_constraint =  \"AND p.rfree < \" + rfree + \"\\n\"\n\n\tres_constraintL = \"\"\n\tif resL != \"ALL\":\n\t\tres_constraintL =  \"AND p.resolution >= \" + resL + \"\\n\"\n\trval_constraintL = \"\"\n\tif rvalueL != \"ALL\":\n\t\trval_constraintL =  \"AND p.rvalue >= \" +  rvalueL + \"\\n\"\n\trfree_constraintL = \"\"\n\tif rfreeL != \"ALL\":\n\t\trfree_constraintL =  \"AND p.rfree >= \" + rfreeL + \"\\n\"\n\n\tbfactor_restraint = \"\"\n\tif maxb != '':\n\t\tbfactor_restraint = \"AND p.bfactor < \" + maxb + \" \\n\"\n\n\tamino_restraint = \"\"\n\tif amino_code != \"NON\":\n\t\tamino_restraint = \"AND g.amino_code = '\" + amino_code + \"' \\n\"\n\t\t\n\thtml = \"\"\n\n\t\n\thtml += \"SELECT g.pdb_code, \" + calcX + \" as geox, \" + calcY + \" as geoy, \" + calcZ + \" as geoz, \" + gradient.lower() + \" as resolution \\n\"\n\t#html += \"from geo_core g, protein_set_c s, protein_structure_c p \\n\"\n\thtml += \"from \" + cfg.tableCore + \" g, \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n\n\thtml += \"WHERE \" + calcX + \" IS NOT NULL\\n\"\n\thtml += \"AND \" + calcY + \" IS NOT NULL\\n\"\n\thtml += \"AND \" + calcZ + \" IS NOT NULL\\n\"\n\t\n\thtml += \"AND s.pdb_code = g.pdb_code\\n\"\n\thtml += \"AND s.pdb_code = p.pdb_code\\n\"\n\thtml += \"AND g.pdb_code = p.pdb_code\\n\"\n\thtml += \"AND g.occupant = 'A'\\n\"\n\thtml += bfactor_restraint\n\thtml += amino_restraint\n\thtml += \"AND s.set_name = '\" + set_name + \"'\\n\"\n\thtml += res_constraint + rval_constraint + rfree_constraint\n\thtml += res_constraintL + rval_constraintL + rfree_constraintL\n\thtml += restriction\n\thtml += \" AND s.status = 'IN';\"\n\treturn (html)\n", "description": null, "category": "math", "imports": ["import thesis_config as cfg"]}, {"term": "def", "name": "sqlForOverlay", "data": "def sqlForOverlay(calcX,calcY,maxb,set_name,restriction, amino_code,res,rvalue,rfree,resL,rvalueL,rfreeL):\n\n\t# allow calc to be N-CA or N.CA or N_CA and convert it\n\tcalcX = calcX.replace(\".\",\"_\")\n\tcalcX = calcX.replace(\"-\",\"_\")\n\n\tcalcY = calcY.replace(\".\",\"_\")\n\tcalcY = calcY.replace(\"-\",\"_\")\n\n\tres_constraint = \"\"\n\tif res != \"ALL\":\n\t\tres_constraint =  \"AND p.resolution < \" + res + \"\\n\"\n\trval_constraint = \"\"\n\tif rvalue != \"ALL\":\n\t\trval_constraint =  \"AND p.rvalue < \" +  rvalue + \"\\n\"\n\trfree_constraint = \"\"\n\tif rfree != \"ALL\":\n\t\trfree_constraint =  \"AND p.rfree < \" + rfree + \"\\n\"\n\n\tres_constraintL = \"\"\n\tif resL != \"ALL\":\n\t\tres_constraintL =  \"AND p.resolution >= \" + resL + \"\\n\"\n\trval_constraintL = \"\"\n\tif rvalueL != \"ALL\":\n\t\trval_constraintL =  \"AND p.rvalue >= \" +  rvalueL + \"\\n\"\n\trfree_constraintL = \"\"\n\tif rfreeL != \"ALL\":\n\t\trfree_constraintL =  \"AND p.rfree >= \" + rfreeL + \"\\n\"\n\n\tbfactor_restraint = \"\"\n\tif maxb != '':\n\t\tbfactor_restraint = \"AND p.bfactor < \" + maxb + \" \\n\"\n\n\tamino_restraint = \"\"\n\tif amino_code != \"NON\":\n\t\tamino_restraint = \"AND g.amino_code = '\" + amino_code + \"' \\n\"\t\t\n\t\t\n\thtml = \"\"\n\n\thtml += \"SELECT g.pdb_code, \" + calcX + \" as geox, \" + calcY + \" as geoy, p.resolution \\n\"\n\t#html += \"from geo_core g, protein_set_c s, protein_structure_c p \\n\"\n\thtml += \"from \" + cfg.tableCore + \" g, \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n\n\thtml += \"WHERE \" + calcX + \" IS NOT NULL\\n\"\n\thtml += \"AND \" + calcY + \" IS NOT NULL\\n\"\n\n\thtml += \"AND s.pdb_code = g.pdb_code\\n\"\n\thtml += \"AND s.pdb_code = p.pdb_code\\n\"\n\thtml += \"AND g.pdb_code = p.pdb_code\\n\"\n\thtml += \"AND g.occupant = 'A'\\n\"\n\thtml += bfactor_restraint\n\thtml += amino_restraint\n\thtml += \"AND s.set_name = '\" + set_name + \"'\\n\"\n\thtml += res_constraint + rval_constraint + rfree_constraint\n\thtml += res_constraintL + rval_constraintL + rfree_constraintL\n\thtml += restriction + \" \\n\"\n\thtml += \"AND s.status = 'IN';\"\n\treturn (html)\n", "description": null, "category": "math", "imports": ["import thesis_config as cfg"]}, {"term": "def", "name": "createSqlContacts", "data": "def createSqlContacts(pdb, contact_atoms):\n\tsql = \"select * from \" + cfg.tableContact + \" \\n\"\n\tsql += \"WHERE pdb_code = '\" + pdb + \"'\\n\"\n\tsql += \"AND geo_value < 6 \\n\"\n\tsql += \"AND geo_atoms = '\" + contact_atoms + \"';\"\n", "description": null, "category": "math", "imports": ["import thesis_config as cfg"]}, {"term": "def", "name": "getHighPDBsSql", "data": "def getHighPDBsSql():\n\tsql = \"\"\n\tsql += \"select p.pdb_code, p.resolution, left(p.institution,20) as authors, left(p.refinement,10) as software, p.rfree,p.rvalue,p.residues \"\n\t#sql += \"FROM protein_structure_c p, protein_set_c s \"\n\tsql += \"from \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n\tsql += \"where p.pdb_code = s.pdb_code \"\n\tsql += \"AND s.set_name = 'HIGH'\"\n\tsql += \"AND s.status = 'IN' \"\n\tsql += \"order by p.pdb_code ASC;\"\n", "description": null, "category": "math", "imports": ["import thesis_config as cfg"]}, {"term": "def", "name": "get2019PDBsSql", "data": "def get2019PDBsSql():\n\tsql = \"\"\n\tsql += \"select p.pdb_code, p.resolution, left(p.institution,20) as authors, left(p.refinement,10) as software, p.rfree,p.rvalue,p.residues \"\n\t#sql += \"FROM protein_structure_c p, protein_set_c s \"\n\tsql += \"from \" + cfg.tableSet + \" s, \" + cfg.tablePdb + \" p \\n\"\n\tsql += \"where p.pdb_code = s.pdb_code \"\n\tsql += \"AND s.set_name = '2019'\"\n\tsql += \"AND s.status = 'IN' \"\n\tsql += \"order by p.pdb_code ASC;\"\n", "description": null, "category": "math", "imports": ["import thesis_config as cfg"]}, {"term": "def", "name": "getCalcsSql", "data": "def getCalcsSql():\n\tsql = \"\"\n\tsql += \"select * \"\n\tsql += \"from \" + cfg.tableCalcs + \";\"\n\treturn sql\n\n", "description": null, "category": "math", "imports": ["import thesis_config as cfg"]}], [], [{"term": "def", "name": "drawCalc", "data": "def drawCalc():\n\tglobal calcAns2\n\tansLen = len(str(calcAns))\n\tif ansLen >= 11:\n\t\tansLen = 11\n\tansLenWrk = 13 - ansLen\n\tcalcAnsWrk = \" \" * ansLenWrk\n\tcalcAns2 = calcAnsWrk + str(calcAns)\n", "description": null, "category": "math", "imports": ["from calcStr import *", "import sys, time, os"]}, {"term": "def", "name": "prgClose", "data": "def prgClose():\n\tprint(calcClose)\n\ttime.sleep(slpTime)\n\tos.system('clear')\n", "description": null, "category": "math", "imports": ["from calcStr import *", "import sys, time, os"]}, {"term": "def", "name": "outputHeader", "data": "def outputHeader():\n\tos.system('clear')\n", "description": null, "category": "math", "imports": ["from calcStr import *", "import sys, time, os"]}, {"term": "def", "name": "addHeader", "data": "def addHeader():\n\tos.system('clear')\n", "description": null, "category": "math", "imports": ["from calcStr import *", "import sys, time, os"]}, {"term": "def", "name": "subHeader", "data": "def subHeader():\n\tos.system('clear')\n", "description": null, "category": "math", "imports": ["from calcStr import *", "import sys, time, os"]}, {"term": "def", "name": "multHeader", "data": "def multHeader():\n\tos.system('clear')\n", "description": null, "category": "math", "imports": ["from calcStr import *", "import sys, time, os"]}, {"term": "def", "name": "divHeader", "data": "def divHeader():\n\tos.system('clear')\n", "description": null, "category": "math", "imports": ["from calcStr import *", "import sys, time, os"]}, {"term": "def", "name": "errHeader", "data": "def errHeader():\n\tos.system('clear')\n\tprint(valueE + empty)\n", "description": null, "category": "math", "imports": ["from calcStr import *", "import sys, time, os"]}], [{"term": "def", "name": "plot_amplification_evolv", "data": "def plot_amplification_evolv(\n\tcalc,\n\tmetric=\"accel_tf\",\n\tdepths=None,\n\tfreqs=None,\n\tnormalized=False,\n\twave_field_out=\"within\",\n\tdiverging_cmap=True,\n\tinclude_vs_profile=False,\n\tax=None,\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "def", "name": "fget_amp", "data": "\tdef get_amp(metric, depth):\n\t\tloc_output = calc.profile.location(wave_field_out, depth=depth)\n\t\tif metric == \"accel_tf\":\n\t\t\ty = np.abs(calc.calc_accel_tf(calc.loc_input, loc_output))\n\t\t\t# Interpolate the specific frequencies\n\t\t\ty = np.interp(ln_freqs, ln_freqs_mot, y)\n\t\telif metric == \"site_amp\":\n\t\t\tif get_amp.in_ars is None:\n\t\t\t\tget_amp.in_ars = calc.motion.calc_osc_accels(freqs, osc_damping)\n\n\t\t\tout_ars = calc.motion.calc_osc_accels(\n\t\t\t\tfreqs, osc_damping, calc.calc_accel_tf(calc.loc_input, loc_output)\n\t\t\t)\n\t\t\ty = out_ars / get_amp.in_ars\n\t\telse:\n\t\t\traise NotImplementedError\n\n\t\treturn y\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "OutputCollection", "data": "class OutputCollection(collections.abc.Collection):\n\tdef __init__(self, outputs):\n\t\tsuper().__init__()\n\t\tself.outputs = outputs\n\n\tdef __iter__(self):\n\t\treturn iter(self.outputs)\n\n\tdef __contains__(self, value):\n\t\treturn value in self.outputs\n\n\tdef __len__(self):\n\t\treturn len(self.outputs)\n\n\tdef __getitem__(self, key):\n\t\treturn self.outputs[key]\n\n\tdef __call__(self, calc, name=None):\n\t\t# Save results\n\t\tfor o in self:\n\t\t\to(calc, name=name)\n\n\tdef reset(self):\n\t\tfor o in self:\n\t\t\to.reset()\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "def", "name": "append_arrays", "data": "def append_arrays(many, single):\n\t\"\"\"Append an array to another padding with NaNs for constant length.\n\n\tParameters\n\t----------\n\tmany : array_like of rank (j, k)\n\t\tvalues appended to a copy of this array. This may be a 1-D or 2-D\n\t\tarray.\n\tsingle : array_like of rank l\n\t\tvalues to append. This should be a 1-D array.\n\n\tReturns\n\t-------\n\tappend : :class:`numpy.ndarray`\n\t\t2-D array with rank (j + 1, max(k, l)) with missing values padded\n\t\twith :class:`numpy.nan`\n\t\"\"\"\n\tassert np.ndim(single) == 1\n\n\t# Check if the values need to be padded to for equal length\n\tdiff = single.shape[0] - many.shape[0]\n\tif diff < 0:\n\t\tsingle = np.pad(single, (0, -diff), \"constant\", constant_values=np.nan)\n\telif diff > 0:\n\t\t# Need different padding based on if many is 1d or 2d.\n\t\tpadding = ((0, diff), (0, 0)) if len(many.shape) > 1 else (0, diff)\n\t\tmany = np.pad(many, padding, \"constant\", constant_values=np.nan)\n\telse:\n\t\t# No padding needed\n\t\tpass\n\treturn np.c_[many, single]\n\n", "description": "Append an array to another padding with NaNs for constant length.\n\n\tParameters\n\t----------\n\tmany : array_like of rank (j, k)\n\t\tvalues appended to a copy of this array. This may be a 1-D or 2-D\n\t\tarray.\n\tsingle : array_like of rank l\n\t\tvalues to append. This should be a 1-D array.\n\n\tReturns\n\t-------\n\tappend : :class:`numpy.ndarray`\n\t\t2-D array with rank (j + 1, max(k, l)) with missing values padded\n\t\twith :class:`numpy.nan`\n\t", "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "Output", "data": "class Output(object):\n\t_const_ref = False\n\n\txscale = \"log\"\n\tyscale = \"log\"\n\tdrawstyle = \"default\"\n\n\tdef __init__(self, refs=None):\n\t\tself._refs = np.asarray([] if refs is None else refs)\n\t\tself._values = None\n\t\tself._names = []\n\n\tdef __call__(self, calc, name=None):\n\t\tif name is None:\n\t\t\tif self.values is None:\n\t\t\t\ti = 1\n\t\t\telif len(self.values.shape) == 1:\n\t\t\t\ti = 2\n\t\t\telse:\n\t\t\t\ti = self.values.shape[1] + 1\n\t\t\tname = \"r%d\" % i\n\t\tself._names.append(name)\n\n\t@property\n\tdef refs(self):\n\t\treturn self._refs\n\n\t@property\n\tdef values(self):\n\t\treturn self._values\n\n\t@property\n\tdef names(self):\n\t\treturn self._names\n\n\tdef reset(self):\n\t\tself._values = None\n\t\tself._names = []\n\t\tif not self._const_ref:\n\t\t\tself._refs = np.array([])\n\n\tdef iter_results(self):\n\t\tshared_ref = len(self.refs.shape) == 1\n\t\tfor i, name in enumerate(self.names):\n\t\t\trefs = self.refs if shared_ref else self.refs[:, i]\n\t\t\tvalues = self.values if len(self.values.shape) == 1 else self.values[:, i]\n\t\t\tyield name, refs, values\n\n\tdef _add_refs(self, refs):\n\t\trefs = np.asarray(refs)\n\t\tif len(self._refs) == 0:\n\t\t\tself._refs = np.array(refs)\n\t\telse:\n\t\t\tself._refs = append_arrays(self._refs, refs)\n\n\tdef _add_values(self, values):\n\t\tvalues = np.asarray(values)\n\t\tif self._values is None:\n\t\t\tself._values = values\n\t\telse:\n\t\t\tself._values = append_arrays(self._values, values)\n\n\tdef calc_stats(self, as_dataframe=False):\n\t\tln_values = np.log(self.values)\n\t\tmedian = np.exp(np.nanmean(ln_values, axis=1))\n\t\tln_std = np.nanstd(ln_values, axis=1)\n\n\t\tstats = {\"ref\": self.refs, \"median\": median, \"ln_std\": ln_std}\n\t\tif as_dataframe and pd:\n\t\t\tstats = pd.DataFrame(stats).set_index(\"ref\")\n\t\t\tstats.index.name = self.ref_name\n\n\t\treturn stats\n\n\tdef to_dataframe(self):\n\t\tif not pd:\n\t\t\traise RuntimeError(\"Install `pandas` library.\")\n\n\t\tif isinstance(self.names[0], tuple):\n\t\t\tcolumns = pd.MultiIndex.from_tuples(self.names)\n\t\telse:\n\t\t\tcolumns = self.names\n\n\t\tdf = pd.DataFrame(self.values, index=self.refs, columns=columns)\n\n\t\treturn df\n\n\t@staticmethod\n\tdef _get_xy(refs, values):\n\t\treturn refs, values\n\n\tdef plot(self, ax=None, style=\"indiv\"):\n\t\tassert style in [\"stats\", \"indiv\"]\n\n\t\tif ax is None:\n\t\t\tfig, ax = plt.subplots()\n\n\t\tif style == \"stats\" and len(self.values.shape) > 1 and self.values.shape[1] < 3:\n\t\t\traise RuntimeError(\"Unable to plot stats for less than 3 values.\")\n\n\t\tif style == \"stats\":\n\t\t\tkwds = {\"color\": \"C0\", \"alpha\": 0.6, \"lw\": 0.8, \"drawstyle\": self.drawstyle}\n\t\telif style == \"indiv\":\n\t\t\tkwds = {\"lw\": 1.0, \"drawstyle\": self.drawstyle}\n\t\telse:\n\t\t\traise NotImplementedError(\"Valid options are: stats, indiv.\")\n\n\t\t# Add the data\n\t\tx, y = self._get_xy(self.refs, self.values)\n\t\tlines = ax.plot(x, y, **kwds)\n\n\t\tif style == \"stats\":\n\t\t\tlines[0].set_label(\"Realization\")\n\t\telse:\n\t\t\tfor layer, name in zip(lines, self.names):\n\t\t\t\tlayer.set_label(name)\n\n\t\tif style == \"stats\":\n\t\t\tstats = self.calc_stats()\n\n\t\t\tax.plot(\n\t\t\t\t*self._get_xy(stats[\"ref\"], stats[\"median\"]),\n\t\t\t\tcolor=\"C1\",\n\t\t\t\tlw=2,\n\t\t\t\tlabel=\"Median\",\n\t\t\t)\n\n\t\tax.set(\n\t\t\txlabel=self.xlabel,\n\t\t\txscale=self.xscale,\n\t\t\tylabel=self.ylabel,\n\t\t\tyscale=self.yscale,\n\t\t)\n\n\t\tif len(lines) > 1:\n\t\t\tax.legend()\n\n\t\treturn ax\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "OutputLocation", "data": "class OutputLocation(object):\n\tdef __init__(self, wave_field, depth=None, index=None):\n\t\tself._depth = depth\n\t\tself._index = index\n\t\tif not isinstance(wave_field, WaveField):\n\t\t\twave_field = WaveField[wave_field]\n\t\tself._wave_field = wave_field\n\n\t@property\n\tdef depth(self):\n\t\treturn self._depth\n\n\t@property\n\tdef index(self):\n\t\treturn self._index\n\n\t@property\n\tdef wave_field(self):\n\t\treturn self._wave_field\n\n\tdef __call__(self, profile):\n\t\t\"\"\"Lookup the location with the profile.\"\"\"\n\t\treturn profile.location(self.wave_field, depth=self.depth, index=self.index)\n\n", "description": "Lookup the location with the profile.", "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "LocationBasedOutput", "data": "class LocationBasedOutput(Output):\n\tdef __init__(self, ref, location):\n\t\tsuper().__init__(ref)\n\t\tself._location = location\n\n\t@property\n\tdef location(self):\n\t\treturn self._location\n\n\tdef __call__(self, calc, name=None):\n\t\traise NotImplementedError\n\n\tdef _get_location(self, calc):\n\t\t\"\"\"Locate location within the profile.\"\"\"\n\t\treturn self._location(calc.profile)\n\n", "description": "Locate location within the profile.", "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "TimeSeriesOutput", "data": "class TimeSeriesOutput(LocationBasedOutput):\n\txlabel = \"Time (sec)\"\n\txscale = \"linear\"\n\tylabel = NotImplemented\n\tyscale = \"linear\"\n\n\tref_name = \"time\"\n\n\tdef __init__(self, location):\n\t\tsuper().__init__(None, location)\n\n\t@property\n\tdef times(self):\n\t\treturn self.refs\n\n\tdef __call__(self, calc, name=None):\n\t\tif not isinstance(calc.motion, TimeSeriesMotion):\n\t\t\traise NotImplementedError\n\t\tOutput.__call__(self, calc, name)\n\t\t# Compute the response\n\t\tloc = self._get_location(calc)\n\t\ttf = self._get_trans_func(calc, loc)\n\t\tvalues = calc.motion.calc_time_series(tf)\n\t\tvalues = self._modify_values(calc, loc, values)\n\t\tself._add_values(values)\n\t\t# Add the reference\n\t\trefs = calc.motion.time_step * np.arange(len(values))\n\t\tself._add_refs(refs)\n\n\tdef _get_trans_func(self, calc, location):\n\t\traise NotImplementedError\n\n\tdef _modify_values(self, calc, location, values):\n\t\treturn values\n\n\tdef to_dataframe(self):\n\t\traise NotImplementedError\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "AccelerationTSOutput", "data": "class AccelerationTSOutput(TimeSeriesOutput):\n\tylabel = \"Acceleration (g)\"\n\n\tdef _get_trans_func(self, calc, location):\n\t\treturn calc.calc_accel_tf(calc.loc_input, location)\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "AriasIntensityTSOutput", "data": "class AriasIntensityTSOutput(AccelerationTSOutput):\n\tylabel = \"Arias Intensity (m/s)\"\n\n\tdef _modify_values(self, calc, location, values):\n\t\ttime_step = calc.motion.time_step\n\t\tvalues = scipy.integrate.cumtrapz(values**2, dx=time_step)\n\t\tvalues *= GRAVITY * np.pi / 2\n\t\treturn values\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "StrainTSOutput", "data": "class StrainTSOutput(TimeSeriesOutput):\n\tdef __init__(self, location, in_percent=False):\n\t\tsuper().__init__(location)\n\t\tself._in_percent = in_percent\n\t\tassert self.location.wave_field == WaveField.within\n\n\tdef _get_trans_func(self, calc, location):\n\t\treturn calc.calc_strain_tf(calc.loc_input, location)\n\n\tdef _modify_values(self, calc, location, values):\n\t\tif self._in_percent:\n\t\t\t# Convert to percent\n\t\t\tvalues *= 100.0\n\t\treturn values\n\n\t@property\n\tdef ylabel(self):\n\t\tsuffix = \"(%)\" if self._in_percent else \"(dec)\"\n\t\treturn \"Shear Strain \" + suffix\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "StressTSOutput", "data": "class StressTSOutput(TimeSeriesOutput):\n\tdef __init__(self, location, damped=False, normalized=False):\n\t\tsuper().__init__(location)\n\t\tself._damped = damped\n\t\tself._normalized = normalized\n\t\tassert self.location.wave_field == WaveField.within\n\n\t@property\n\tdef damped(self):\n\t\treturn self._damped\n\n\t@property\n\tdef ylabel(self):\n\t\tif self._normalized:\n\t\t\tylabel = \"Stress Ratio (\u03c4/\u03c3`\u1d65)\"\n\t\telse:\n\t\t\tylabel = \"Stress (\u03c4)\"\n\n\t\treturn ylabel\n\n\tdef _get_trans_func(self, calc, location):\n\t\ttf = calc.calc_stress_tf(calc.loc_input, location, self.damped)\n\n\t\tif self._normalized:\n\t\t\t# Correct by effective stress at depth\n\t\t\ttf /= location.stress_vert(effective=True)\n\n\t\treturn tf\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "FourierAmplitudeSpectrumOutput", "data": "class FourierAmplitudeSpectrumOutput(LocationBasedOutput):\n\t_const_ref = True\n\txlabel = \"Frequency (Hz)\"\n\tylabel = \"Fourier Ampl. (cm/s)\"\n\n\tref_name = \"freq\"\n\n\tdef __init__(self, freqs, location, ko_bandwidth=30):\n\t\tsuper().__init__(freqs, location)\n\t\tself._ko_bandwidth = ko_bandwidth\n\n\t@property\n\tdef freqs(self):\n\t\treturn self._refs\n\n\t@property\n\tdef ko_bandwidth(self):\n\t\treturn self._ko_bandwidth\n\n\tdef __call__(self, calc, name=None):\n\t\tOutput.__call__(self, calc, name)\n\t\tloc = self._get_location(calc)\n\t\ttf = calc.calc_accel_tf(calc.loc_input, loc)\n\n\t\tif self.ko_bandwidth:\n\t\t\tsmoothed = pykooh.smooth(\n\t\t\t\tself.freqs,\n\t\t\t\tcalc.motion.freqs,\n\t\t\t\tnp.abs(tf * calc.motion.fourier_amps),\n\t\t\t\tself.ko_bandwidth,\n\t\t\t)\n\n\t\tself._add_values(smoothed)\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "ResponseSpectrumOutput", "data": "class ResponseSpectrumOutput(LocationBasedOutput):\n\t_const_ref = True\n\txlabel = \"Frequency (Hz)\"\n\n\tref_name = \"freq\"\n\n\tdef __init__(self, freqs, location, osc_damping):\n\t\tsuper().__init__(freqs, location)\n\t\tself._osc_damping = osc_damping\n\n\t@property\n\tdef freqs(self):\n\t\treturn self._refs\n\n\t@property\n\tdef periods(self):\n\t\treturn 1.0 / np.asarray(self._refs)\n\n\t@property\n\tdef osc_damping(self):\n\t\treturn self._osc_damping\n\n\t@property\n\tdef ylabel(self):\n\t\treturn f\"{100 * self.osc_damping:g}%-Damped, Spec. Accel. (g)\"\n\n\tdef __call__(self, calc, name=None):\n\t\tOutput.__call__(self, calc, name)\n\t\tloc = self._get_location(calc)\n\t\ttf = calc.calc_accel_tf(calc.loc_input, loc)\n\t\tars = calc.motion.calc_osc_accels(self.freqs, self.osc_damping, tf)\n\t\tself._add_values(ars)\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "RatioBasedOutput", "data": "class RatioBasedOutput(Output):\n\t_const_ref = True\n\n\tdef __init__(self, refs, location_in, location_out):\n\t\tsuper().__init__(refs)\n\t\tself._location_in = location_in\n\t\tself._location_out = location_out\n\n\t@property\n\tdef location_in(self):\n\t\treturn self._location_in\n\n\t@property\n\tdef location_out(self):\n\t\treturn self._location_out\n\n\tdef __call__(self, calc, name=None):\n\t\traise NotImplementedError\n\n\tdef _get_locations(self, calc):\n\t\t\"\"\"Locate locations within the profile.\"\"\"\n\t\treturn (self._location_in(calc.profile), self._location_out(calc.profile))\n\n", "description": "Locate locations within the profile.", "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "AccelTransferFunctionOutput", "data": "class AccelTransferFunctionOutput(RatioBasedOutput):\n\txlabel = \"Frequency (Hz)\"\n\tylabel = \"Accel. Transfer Func.\"\n\n\tref_name = \"freq\"\n\n\tdef __init__(\n\t\tself, refs, location_in, location_out, ko_bandwidth=None, absolute=True\n\t):\n\t\tsuper().__init__(refs, location_in, location_out)\n\t\tself._ko_bandwidth = ko_bandwidth\n\t\tself._absolute = absolute\n\n\tdef __call__(self, calc, name=None):\n\t\tOutput.__call__(self, calc, name)\n\t\t# Locate position within the profile\n\t\tloc_in, loc_out = self._get_locations(calc)\n\t\t# Compute the response\n\t\tif self._absolute:\n\t\t\ttf = np.abs(calc.calc_accel_tf(loc_in, loc_out))\n\t\telse:\n\t\t\ttf = calc.calc_accel_tf(loc_in, loc_out)\n\n\t\tif self._ko_bandwidth is None:\n\t\t\ttf = np.interp(self.freqs, calc.motion.freqs, tf)\n\t\telse:\n\t\t\ttf = pykooh.smooth(self.freqs, calc.motion.freqs, tf, self._ko_bandwidth)\n\n\t\tself._add_values(tf)\n\n\t@property\n\tdef freqs(self):\n\t\treturn self._refs\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "ResponseSpectrumRatioOutput", "data": "class ResponseSpectrumRatioOutput(RatioBasedOutput):\n\txlabel = \"Frequency (Hz)\"\n\n\tref_name = \"freq\"\n\n\tdef __init__(self, freqs, location_in, location_out, osc_damping):\n\t\tsuper().__init__(freqs, location_in, location_out)\n\t\tself._osc_damping = osc_damping\n\n\t@property\n\tdef freqs(self):\n\t\treturn self._refs\n\n\t@property\n\tdef periods(self):\n\t\treturn 1.0 / np.asarray(self._refs)\n\n\t@property\n\tdef osc_damping(self):\n\t\treturn self._osc_damping\n\n\t@property\n\tdef ylabel(self):\n\t\treturn f\"{100 * self.osc_damping:g}%-Damped, Resp. Spectral Ratio\"\n\n\tdef __call__(self, calc, name=None):\n\t\tOutput.__call__(self, calc, name)\n\t\tloc_in, loc_out = self._get_locations(calc)\n\t\tin_ars = calc.motion.calc_osc_accels(\n\t\t\tself.freqs, self.osc_damping, calc.calc_accel_tf(calc.loc_input, loc_in)\n\t\t)\n\t\tout_ars = calc.motion.calc_osc_accels(\n\t\t\tself.freqs, self.osc_damping, calc.calc_accel_tf(calc.loc_input, loc_out)\n\t\t)\n\t\tratio = out_ars / in_ars\n\t\tself._add_values(ratio)\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "ProfileBasedOutput", "data": "class ProfileBasedOutput(Output):\n\tylabel = \"Depth (m)\"\n\tyscale = \"linear\"\n\tdrawstyle = \"steps-post\"\n\n\tref_name = \"depth\"\n\n\tdef __init__(self):\n\t\tsuper().__init__()\n\n\tdef __call__(self, calc, name=None):\n\t\tOutput.__call__(self, calc, name)\n\t\tdepths = np.r_[0, calc.profile.depth_mid[:-1]]\n\t\tself._add_refs(depths)\n\n\tdef calc_stats(self, as_dataframe=False, ref=None):\n\t\tif ref is None:\n\t\t\tref = np.linspace(0, np.nanmax(self.refs) * 1.05, num=512)\n\n\t\tn = self.values.shape[1]\n\t\twith np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n\t\t\t# Ignore zeros in the data\n\t\t\tln_values = np.array([self._ln_interp(i, ref) for i in range(n)]).T\n\t\t\tmedian = np.exp(np.nanmean(ln_values, axis=1))\n\t\t\tln_std = np.nanstd(ln_values, axis=1)\n\n\t\tstats = {\"ref\": ref, \"median\": median, \"ln_std\": ln_std}\n\t\tif as_dataframe and pd:\n\t\t\tstats = pd.DataFrame(stats).set_index(\"ref\")\n\t\t\tstats.index.name = self.ref_name\n\n\t\treturn stats\n\n\t@staticmethod\n\tdef _get_xy(refs, values):\n\t\treturn values, refs\n\n\tdef plot(self, ax=None, style=\"stats\"):\n\t\tax = Output.plot(self, ax, style)\n\t\tax.invert_yaxis()\n\t\treturn ax\n\n\tdef _ln_interp(self, i, ref):\n\t\t\"\"\"Interpolate the values in log-y space.\"\"\"\n\n\t\t_ref = self.refs[:, i]\n\t\t# Only select points with valid entries\n\t\tmask = np.isfinite(_ref)\n\t\t_ref = _ref[mask]\n\t\t_ln_values = np.log(self.values[mask, i])\n\n\t\tif np.any(mask):\n\t\t\tf = interp1d(\n\t\t\t\t_ref,\n\t\t\t\t_ln_values,\n\t\t\t\tkind=\"next\",\n\t\t\t\tfill_value=(_ln_values[0], _ln_values[-1]),\n\t\t\t\tbounds_error=False,\n\t\t\t)\n\t\t\t_ln_interped = f(ref)\n\t\telse:\n\t\t\tnans = np.empty_like(ref)\n\t\t\tnans[:] = np.nan\n\t\t\t_ln_interped = np.array(nans)\n\n\t\treturn _ln_interped\n\n\tdef to_dataframe(self, ref=None):\n\t\tif not pd:\n\t\t\traise RuntimeError(\"Install `pandas` library.\")\n\n\t\tif ref is None:\n\t\t\tref = np.linspace(0, np.nanmax(self.refs))\n\n\t\tif isinstance(self.names[0], tuple):\n\t\t\tcolumns = pd.MultiIndex.from_tuples(self.names)\n\t\telse:\n\t\t\tcolumns = self.names\n\n\t\t# Ignore zeros in the data\n\t\tn = self.values.shape[1]\n\t\tvalues = np.exp(np.array([self._ln_interp(i, ref) for i in range(n)])).T\n\n\t\tdf = pd.DataFrame(values, index=ref, columns=columns)\n\n\t\treturn df\n\n", "description": "Interpolate the values in log-y space.", "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "MaxStrainProfile", "data": "class MaxStrainProfile(ProfileBasedOutput):\n\txlabel = \"Max. Strain (dec)\"\n\n\tdef __init__(self):\n\t\tsuper().__init__()\n\n\tdef __call__(self, calc, name=None):\n\t\tProfileBasedOutput.__call__(self, calc, name)\n\t\tvalues = [0] + [layer.strain_max for layer in calc.profile[:-1]]\n\t\tself._add_values(values)\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "DampingProfile", "data": "class DampingProfile(ProfileBasedOutput):\n\txlabel = \"Damping (dec)\"\n\n\tdef __call__(self, calc, name=None):\n\t\tOutput.__call__(self, calc, name)\n\t\t# Add depth at top of layer\n\t\tself._add_refs(calc.profile.depth)\n\n\t\tvalues = [layer.damping for layer in calc.profile[:-1]]\n\t\t# Bring the first mid-layer value to the surface\n\t\tvalues.insert(0, values[0])\n\t\tself._add_values(values)\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "ShearModReducProfile", "data": "class ShearModReducProfile(ProfileBasedOutput):\n\txlabel = \"G/Gmax\"\n\n\tdef __call__(self, calc, name=None):\n\t\tOutput.__call__(self, calc, name)\n\t\t# Add depth at top of layer\n\t\tself._add_refs(calc.profile.depth)\n\n\t\tvalues = [layer.shear_mod_reduc for layer in calc.profile[:-1]]\n\t\t# Bring the first mid-layer value to the surface\n\t\tvalues.insert(0, values[0])\n\t\tself._add_values(values)\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "InitialVelProfile", "data": "class InitialVelProfile(ProfileBasedOutput):\n\txlabel = \"Initial Velocity (m/s)\"\n\n\tdef __init__(self):\n\t\tsuper().__init__()\n\n\tdef __call__(self, calc, name=None):\n\t\tOutput.__call__(self, calc, name)\n\t\t# Add depth at top of layer\n\t\tself._add_refs(calc.profile.depth)\n\n\t\tvalues = [layer.initial_shear_vel for layer in calc.profile[:-1]]\n\t\tvalues.insert(0, values[0])\n\t\tself._add_values(values)\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "CompatVelProfile", "data": "class CompatVelProfile(ProfileBasedOutput):\n\txlabel = \"Strain-Compatible Velocity (m/s)\"\n\n\tdef __init__(self):\n\t\tsuper().__init__()\n\n\tdef __call__(self, calc, name=None):\n\t\tOutput.__call__(self, calc, name)\n\t\t# Add depth at top of layer\n\t\tself._add_refs(calc.profile.depth)\n\n\t\tvalues = [np.min(layer.shear_vel) for layer in calc.profile[:-1]]\n\t\tvalues.insert(0, values[0])\n\t\tself._add_values(values)\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "CyclicStressRatioProfile", "data": "class CyclicStressRatioProfile(ProfileBasedOutput):\n\t# From Idriss and Boulanger (2008, pg. 70):\n\t# The 0.65 is a constant used to represent the reference stress\n\t# level. While being somewhat arbitrary it was selected in the\n\t# beginning of the development of liquefaction procedures in 1966\n\t# and has been in use ever since.\n\t_stress_level = 0.65\n\n\tdef __init__(self):\n\t\tsuper().__init__()\n\n\tdef __call__(self, calc, name=None):\n\t\tProfileBasedOutput.__call__(self, calc, name)\n\t\tvalues = [\n\t\t\tlayer.stress_shear_max / layer.stress_vert(layer.thickness / 2, True)\n\t\t\tfor layer in calc.profile[:-1]\n\t\t]\n\t\t# Repeat the first value for the surface\n\t\tvalues = self._stress_level * np.array([values[0]] + values)\n\t\tself._add_values(values)\n\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}, {"term": "class", "name": "MaxAccelProfile", "data": "class MaxAccelProfile(ProfileBasedOutput):\n\txlabel = \"Max. Accel. (g)\"\n\n\tdef __call__(self, calc, name=None):\n\t\tOutput.__call__(self, calc, name)\n\t\t# Add depth at top of layer\n\t\tdepths = calc.profile.depth\n\t\tvalues = [self._calc_accel(calc, depth) for depth in depths]\n\t\tself._add_refs(depths)\n\t\tself._add_values(values)\n\n\tdef _calc_accel(self, calc, depth):\n\t\treturn calc.motion.calc_peak(\n\t\t\tcalc.calc_accel_tf(\n\t\t\t\tcalc.loc_input, calc.profile.location(\"within\", depth=depth)\n\t\t\t)\n\t\t)\n", "description": null, "category": "math", "imports": ["import collections", "import matplotlib.pyplot as plt", "import numpy as np", "import scipy.integrate", "from matplotlib.colors import LogNorm", "from matplotlib.colors import TwoSlopeNorm", "from scipy.interpolate import interp1d", "\timport pandas as pd", "import pykooh", "from .motion import TimeSeriesMotion, WaveField, GRAVITY"]}], [{"term": "class", "name": "TestCalculadora", "data": "class TestCalculadora(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tself.calc = Calculadora()\n\n\tdef test_sumar_dos_mas_dos(self):\n\t\tresult = self.calc.suma(2, 2)\n\t\tself.assertEqual(\n\t\t\t4, result, \"2 + 2 = 4 El resultado no fue lo esperado\")\n\n\tdef test_sumar_0_mas_1(self):\n\t\tresult = self.calc.suma(0, 1)\n\t\tself.assertEqual(1, result)\n\n\tdef test_sumar_cinco_mas_veinte(self):\n\t\tresult = self.calc.suma(5, 20)\n\t\tself.assertEqual(\n\t\t\t25, result, \"5 + 20 = 25 El resultado no fue lo esperado\")\n\n\tdef test_solo_positivos(self):\n\t\tresult = self.calc.suma(4, -1)\n\t\tself.assertEqual(\"Solo numeros positivos\", result,\n\t\t\t\t\t\t \"El resultado no fue lo esperado\")\n\n\tdef test_sumar_4punto5_mas_menos1(self):\n\t\tresult = self.calc.suma(4.5, -1)\n\t\tself.assertEqual(\"Solo numeros enteros\", result)\n\n\tdef test_sumar_x_mas_5(self):\n\t\tresult = self.calc.suma('x', 5)\n\t\tself.assertEqual(\"Solo numeros\", result)\n\n\tdef test_restar_cero_menos_0(self):\n\t\tresult = self.calc.resta(0, 0)\n\t\tself.assertEqual(0, result)\n\n\tdef test_restar_0_menos_1(self):\n\t\tresult = self.calc.resta(0, 1)\n\t\tself.assertEqual(-1, result)\n\n\tdef test_restar_15_menos_menos3(self):\n\t\tresult = self.calc.resta(15, -1)\n\t\tself.assertEqual(\"Solo numeros positivos\", result)\n\n\tdef test_restar_4punto5_menos_menos1(self):\n\t\tresult = self.calc.resta(4.5, -1)\n\t\tself.assertEqual(\"Solo numeros enteros\", result)\n\n\tdef test_restar_x_menos_menos1(self):\n\t\tresult = self.calc.resta('x', -1)\n\t\tself.assertEqual(\"Solo numeros\", result)\n\n\tdef test_multiplicar_0_por_0(self):\n\t\tresult = self.calc.multiplica(0, 0)\n\t\tself.assertEqual(0, result)\n\n\tdef test_multiplicar_0_por_1(self):\n\t\tresult = self.calc.multiplica(0, 1)\n\t\tself.assertEqual(0, result)\n\n\tdef test_multiplicar_6_por_9(self):\n\t\tresult = self.calc.multiplica(6, 9)\n\t\tself.assertEqual(54, result)\n\n\tdef test_multiplicar_10_por_menos3(self):\n\t\tresult = self.calc.multiplica(10, -3)\n\t\tself.assertEqual(-30, result)\n\n\tdef test_multiplicar_menos10_por_menos3(self):\n\t\tresult = self.calc.multiplica(-10, -3)\n\t\tself.assertEqual(30, result)\n\n\tdef test_multiplicar_4punto5_por_menos1(self):\n\t\tresult = self.calc.multiplica(4.5, -1)\n\t\tself.assertEqual(\"Solo numeros enteros\", result)\n\n\tdef test_multiplicar_x_por_menos1(self):\n\t\tresult = self.calc.multiplica('x', -1)\n\t\tself.assertEqual(\"Solo numeros\", result)\n\n\tdef test_dividir_0_entre_0(self):\n\t\tresult = self.calc.divide(0, 0)\n\t\tself.assertEqual(\"Indefinido\", result)\n\n\tdef test_dividir_0_entre_1(self):\n\t\tresult = self.calc.divide(0, 1)\n\t\tself.assertEqual(0, result)\n\n\tdef test_dividir_1_entre_0(self):\n\t\tresult = self.calc.divide(1, 0)\n\t\tself.assertEqual(\"Indefinido\", result)\n\n\tdef test_dividir_4_entre_5(self):\n\t\tresult = self.calc.divide(4, 5)\n\t\tself.assertEqual(0.8, result)\n\n\tdef test_dividir_10_entre_5(self):\n\t\tresult = self.calc.divide(10, 5)\n\t\tself.assertEqual(2, result)\n\n\tdef test_dividir_menos30_entre_menos3(self):\n\t\tresult = self.calc.divide(-30, -3)\n\t\tself.assertEqual(10, result)\n\n\tdef test_dividir_menos30_entre_3(self):\n\t\tresult = self.calc.divide(-30, 3)\n\t\tself.assertEqual(-10, result)\n\n\tdef test_dividir_5punto5_entre_menos1(self):\n\t\tresult = self.calc.divide(5.5, -1)\n\t\tself.assertEqual(\"Solo numeros enteros\", result)\n\n\tdef test_dividir_x_entre_menos1(self):\n\t\tresult = self.calc.divide('x', -3)\n\t\tself.assertEqual(\"Solo numeros\", result)\n\n\tdef test_elevar_0_al_0(self):\n\t\tresult = self.calc.potencia(0, 0)\n\t\tself.assertEqual(\"Indefinido\", result)\n\n\tdef test_elevar_0_al_5(self):\n\t\tresult = self.calc.potencia(0, 5)\n\t\tself.assertEqual(0, result)\n\n\tdef test_elevar_11_al_0(self):\n\t\tresult = self.calc.potencia(11, 0)\n\t\tself.assertEqual(1, result)\n\n\tdef test_elevar_10_al_2(self):\n\t\tresult = self.calc.potencia(10, 2)\n\t\tself.assertEqual(100, result)\n\n\tdef test_elevar_2_al_menos2(self):\n\t\tresult = self.calc.potencia(2, -2)\n\t\tself.assertEqual(0.25, result)\n\n\tdef test_elevar_menos2_al_menos2(self):\n\t\tresult = self.calc.potencia(-2, -2)\n\t\tself.assertEqual(0.25, result)\n\n\tdef test_elevar_menos2_al_2(self):\n\t\tresult = self.calc.potencia(-2, 2)\n\t\tself.assertEqual(4, result)\n\n\tdef test_elevar_2punto5_al_2(self):\n\t\tresult = self.calc.potencia(2.5, 2)\n\t\tself.assertEqual(6.25, result)\n\n\tdef test_elevar_x_al_menos3(self):\n\t\tresult = self.calc.potencia('x', -3)\n\t\tself.assertEqual(\"Solo numeros\", result)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from calculadora import Calculadora"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.del_key(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(get_string(\"calc_1\"), buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=get_string(\"calc_1\"), buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tuser = e.query.user_id\n\tget = None\n\tif x == \"AC\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.edit(\n\t\t\tget_string(\"calc_1\"),\n\t\t\tbuttons=[Button.inline(get_string(\"calc_2\"), data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tif CALC.get(user):\n\t\t\tCALC.pop(user)\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get[:-1]})\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/100\"})\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"/\"})\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + \"*\"})\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = eval(get)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tCALC.pop(user)\n\t\t\t\tawait e.answer(get_string(\"sf_8\"), cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tif CALC.get(user):\n\t\t\tget = CALC[user]\n\t\tif get:\n\t\t\tCALC.update({user: get + x})\n\t\t\treturn await e.answer(str(get + x))\n\t\tCALC.update({user: x})\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(get_string(\"calc_1\"), buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import Button, asst, callback, get_string, in_pattern, udB, ultroid_cmd"]}], [], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "classTestCalc:", "data": "class TestCalc:\n\t# setup_class \u662f\u7c7b\u7ea7\u522b\u7684\n\tdef setup_class(self):\n\t\tprint(\"TestCalc \u5728\u6574\u4e2a\u7c7b\u7684\u524d\u6267\u884csetup_class\")\n\t\tself.calc = Calculator()\n\n\tdef teardown_class(self):\n\t\tprint(\"TestCalc\u5728\u6574\u4e2a\u7c7b\u7684\u540e\u6267\u884cteardown_class\")\n\n\t# setup \u662f\u65b9\u6cd5\u7ea7\u522b\u7684\n\tdef setup(self):\n\t\tprint(\"\u6d4b\u8bd5\u7528\u4f8b\u6267\u884c\u4e4b\u524d\u6267\u884csetup\")\n\t\tself.calc = Calculator()\n\n\tdef teardown(self):\n\t\tprint(\"\u6d4b\u8bd5\u7528\u4f8b\u6267\u884c\u4e4b\u540e\u6267\u884cteardown\")\n\n\t@pytest.mark.parametrize('a,b,c', [\n\t\t(1, 1, 2),\n\t\t(0.1, 0.1, 0.2),\n\t\t(-1, -1, -2),\n\t\t(100, 100, 200),\n\t\t(100, -100, 150),\n\t\t(1, 0.1, 1.1)\n\t])\n\tdef test_add(self, a, b, c):\n\t\t# calc = Calculator()\n\t\tallure.attach(\"\u8fd9\u662f\u4e00\u4e2a\u76f8\u52a0\u7684\u6d4b\u8bd5\u7528\u4f8b\", name='\u8fd9\u662f\u6587\u672c\u578b',\n\t\t\t\t\t  attachment_type=allure.attachment_type.TEXT)\n\t\tallure.attach(\n\t\t\t'',\n\t\t\tname='html\u7c7b\u578b',\n\t\t\tattachment_type=allure.attachment_type.HTML)\n\t\tassert c == self.calc.add(a, b)\n\n\tdef test_add1(self):\n\t\tdatalist = [\n\t\t\t(1, 1, 2),\n\t\t\t(0.1, 0.1, 0.2),\n\t\t\t(-1, -1, -2),\n\t\t\t(100, 100, 200),\n\t\t\t(100, -100, 150),\n\t\t\t(10000, 10000, 20000)\n\t\t]\n\t\tfor data in datalist:\n\t\t\t# calc = Calculator()\n\t\t\tassert data[2] == self.calc.add(data[0], data[1])\n\n\t# def test_add2(self):\n\t#\t calc = Calculator()\n\t#\t assert -2 == calc.add(-1,-1)\n\n\tdef test_div(self):\n\t\t# calc = Calculator()\n\t\tassert 1 == self.calc.div(1, 1)\n\n\tdef test_image(self):\n\t\tallure.attach.file('/Users/juanxu/Documents/\u970d\u683c\u6c83\u5179\u57f9\u8bad/\u516c\u5f00\u8bfe/\u57fa\u7840\u516c\u5f00\u8bfe\u6d3b\u7801/gkkxx.png',\n\t\t\t\t\t\t   name='\u56fe\u7247', attachment_type=allure.attachment_type.PNG)\n\t\tallure.attach.file('/Users/juanxu/Documents/\u970d\u683c\u6c83\u5179\u57f9\u8bad/02\u5f55\u64ad\u8bfe\u7a0b/python/python\u7b2c\u4e09\u65b9\u5e93/python\u7b2c\u4e09\u65b9\u5e93.mp4',\n\t\t\t\t\t\t   name='\u89c6\u9891', attachment_type=allure.attachment_type.MP4)\n\n", "description": null, "category": "math", "imports": ["import allure", "import pytest", "import sys", "from pythoncode.calc import Calculator"]}, {"term": "class", "name": "classTestCalcDemo:", "data": "class TestCalcDemo:\n\tdef setup_class(self):\n\t\tprint(\"TestCalcDemo \u5728\u6574\u4e2a\u7c7b\u7684\u524d\u6267\u884csetup_class\")\n\t\tself.calc = Calculator()\n\n\tdef teardown_class(self):\n\t\tprint(\"TestCalcDemo \u5728\u6574\u4e2a\u7c7b\u7684\u540e\u6267\u884cteardown_class\")\n\n\tdef test_add1(self):\n\t\tprint(\"\u6d4b\u8bd5\u76f8\u52a0\")\n\n\tdef div(self):\n\t\tprint(\"\u6d4b\u8bd5\u76f8\u9664\")\n\n", "description": null, "category": "math", "imports": ["import allure", "import pytest", "import sys", "from pythoncode.calc import Calculator"]}, {"term": "class", "name": "classTestCalcDemo:", "data": "class TestCalcDemo:\n\tdef setup_class(self):\n\t\tprint(\"setup_class\")\n\n\tdef teardown_class(self):\n\t\tprint(\"teardown_class\")\n\n\tdef test_add1(self):\n\t\tprint(\"\u6d4b\u8bd5\u76f8\u52a0\")\n\n\tdef div(self):\n\t\tprint(\"\u6d4b\u8bd5\u76f8\u9664\")\n", "description": null, "category": "math", "imports": ["import allure", "import pytest", "import sys", "from pythoncode.calc import Calculator"]}], [{"term": "class", "name": "CalcFibonacciTestCase", "data": "class CalcFibonacciTestCase(unittest.TestCase):\n\n\t@unittest.expectedFailure\n\tdef test_with_preceeding_lower_bound(self):\n\t\tcalc_fibonacci(-1)\n\n\tdef test_with_n_as_0(self):\n\t\tself.assertEqual(0, calc_fibonacci(0))\n\n\tdef test_with_n_as_1(self):\n\t\tself.assertEqual(1, calc_fibonacci(1))\n\n\tdef test_with_n_as_2(self):\n\t\tself.assertEqual(1, calc_fibonacci(2))\n\n\tdef test_with_n_as_3(self):\n\t\tself.assertEqual(2, calc_fibonacci(3))\n\n\tdef test_with_n_as_4(self):\n\t\tself.assertEqual(3, calc_fibonacci(4))\n\n\tdef test_with_n_as_5(self):\n\t\tself.assertEqual(5, calc_fibonacci(5))\n\n\tdef test_with_n_as_6(self):\n\t\tself.assertEqual(8, calc_fibonacci(6))\n\n\tdef test_with_n_as_7(self):\n\t\tself.assertEqual(13, calc_fibonacci(7))\n\n\tdef test_with_n_as_8(self):\n\t\tself.assertEqual(21, calc_fibonacci(8))\n\n\tdef test_with_n_as_9(self):\n\t\tself.assertEqual(34, calc_fibonacci(9))\n\n\tdef test_with_n_as_10(self):\n\t\tself.assertEqual(55, calc_fibonacci(10))\n\n\tdef test_with_n_as_20(self):\n\t\tself.assertEqual(6765, calc_fibonacci(20))\n\n\tdef test_with_n_as_30(self):\n\t\tself.assertEqual(832040, calc_fibonacci(30))\n\n\tdef test_with_n_as_40(self):\n\t\tself.assertEqual(102334155, calc_fibonacci(40))\n\n\tdef test_with_n_as_45(self):\n\t\tself.assertEqual(1134903170, calc_fibonacci(45))\n", "description": null, "category": "math", "imports": ["import unittest", "from fib import calc_fibonacci"]}], [{"term": "def", "name": "get_data", "data": "def get_data(name):\n\t#get list of properties\n\tif not name:\n\t\treturn list(props.keys())\n\n\t#get list of values for property\n\tr = []\n\tvalues = props.get(name, [])\n\tfor val in values:\n\t\tif type(val) is str:\n\t\t\tif val.startswith('<') and val.endswith('>'):\n\t\t\t\tmore = common_values.get(val[1:-1], [])\n\t\t\t\tfor m in more:\n\t\t\t\t\tif type(m) is str:\n\t\t\t\t\t\tr.append(m)\n\t\t\t\t\telif type(m) is list:\n\t\t\t\t\t\tr.append(m[0])\n\t\t\telse:\n\t\t\t\tr.append(val)\n\t\telif type(val) is list:\n\t\t\tr.append(val[0])\n\tr += for_all\n\treturn r\n", "description": null, "category": "math", "imports": ["\t'!important'"]}], [{"term": "def", "name": "get_data", "data": "def get_data(name):\n\t#get list of properties\n\tif not name:\n\t\treturn list(props.keys())\n\n\t#get list of values for property\n\tr = []\n\tvalues = props.get(name, [])\n\tfor val in values:\n\t\tif type(val) is str:\n\t\t\tif val.startswith('<') and val.endswith('>'):\n\t\t\t\tmore = common_values.get(val[1:-1], [])\n\t\t\t\tfor m in more:\n\t\t\t\t\tif type(m) is str:\n\t\t\t\t\t\tr.append(m)\n\t\t\t\t\telif type(m) is list:\n\t\t\t\t\t\tr.append(m[0])\n\t\t\telse:\n\t\t\t\tr.append(val)\n\t\telif type(val) is list:\n\t\t\tr.append(val[0])\n\tr += for_all\n\treturn r\n", "description": null, "category": "math", "imports": ["\t'!important'"]}], [{"term": "class", "name": "TestWriteCalcPr", "data": "class TestWriteCalcPr(unittest.TestCase):\n\t\"\"\"\n\tTest the Workbook _write_calc_pr() method.\n\n\t\"\"\"\n\n\tdef setUp(self):\n\t\tself.fh = StringIO()\n\t\tself.workbook = Workbook()\n\t\tself.workbook._set_filehandle(self.fh)\n\n\tdef test_write_calc_pr(self):\n\t\t\"\"\"Test the _write_calc_pr() method.\"\"\"\n\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef test_calc_mode_auto_except_tables(self):\n\t\t\"\"\"\n\t\tTest the _write_calc_pr() method with the calculation mode set\n\t\tto auto_except_tables.\n\n\t\t\"\"\"\n\n\t\tself.workbook.set_calc_mode(\"auto_except_tables\")\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef test_calc_mode_manual(self):\n\t\t\"\"\"\n\t\tTest the _write_calc_pr() method with the calculation mode set to\n\t\tmanual.\n\n\t\t\"\"\"\n\n\t\tself.workbook.set_calc_mode(\"manual\")\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef test_write_calc_pr(self):\n\t\t\"\"\"Test the _write_calc_pr() method with non-default calc id.\"\"\"\n\n\t\tself.workbook.set_calc_mode(\"auto\", 12345)\n\t\tself.workbook._write_calc_pr()\n\n\t\texp = \"\"\"\"\"\"\n\t\tgot = self.fh.getvalue()\n\n\t\tself.assertEqual(got, exp)\n\n\tdef tearDown(self):\n\t\tself.workbook.fileclosed = 1\n", "description": "\n\tTest the Workbook _write_calc_pr() method.\n\n\t", "category": "math", "imports": ["import unittest", "from ...compatibility import StringIO", "from ...workbook import Workbook"]}], [], [{"term": "class", "name": "classTestCalc:", "data": "class TestCalc:\n\tdef setup(self):\n\t\tself.calc = Calculator\n\n\tdef test_multiply_calculate_correctly(self):\n\t\tassert self.calc.multiply(self, 2, 2) == 4\n\n\tdef test_multiply_calculation_failed(self):\n\t\tassert self.calc.multiply(self, 2, 2) == 5\n\n\tdef test_multiply_calculator_correct(self):\n\t\tassert self.calc.divission(self, 8, 2) == 4\n\n\tdef test_multiply_calculator_correct(self):\n\t\tassert self.calc.subtraction(self, 15, 5) == 10\n\n\tdef test_multiply_calculator_corrrct(self):\n\t\tassert self.calc.adding(self, 5, 5) == 10\n", "description": null, "category": "math", "imports": ["import pytest", "from app.calculator import Calculator"]}], [{"term": "def", "name": "calc_params_NiH", "data": "def calc_params_NiH():\n\tcalc_params = {}\n\tcalc_params[\"lmpcmds\"] = [\n\t\t\"pair_style eam/alloy\",\n\t\t\"pair_coeff * * NiAlH_jea.eam.alloy Ni H\",\n\t]\n\tcalc_params[\"atom_types\"] = {\"Ni\": 1, \"H\": 2}\n\tcalc_params[\"log_file\"] = \"test.log\"\n\tcalc_params[\"keep_alive\"] = True\n\treturn calc_params\n\n", "description": null, "category": "math", "imports": ["import pytest"]}, {"term": "def", "name": "dimer_params", "data": "def dimer_params():\n\tdimer_params = {}\n\ta = 2.0\n\tdimer_params[\"symbols\"] = \"Ni\" * 2\n\tdimer_params[\"positions\"] = [(0, 0, 0), (a, 0, 0)]\n\tdimer_params[\"cell\"] = (1000 * a, 1000 * a, 1000 * a)\n\tdimer_params[\"pbc\"] = (False, False, False)\n\treturn dimer_params\n", "description": null, "category": "math", "imports": ["import pytest"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\tawait e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\tawait e.answer(\"Error\", cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\tawait e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tresults = await ultroid_bot.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\treturn await e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\treturn await e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\treturn await e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\treturn await e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\treturn await e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\treturn await e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\treturn await e.answer(\"Error\", cache_time=0, alert=True)\n\t\treturn await e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\treturn await e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\treturn await e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "class", "name": "TestDotProd", "data": "class TestDotProd(unittest.TestCase):\n\n\tdef test_dotProd_with_vectors_of_equal_length(self):\n\t\tA = [[1, 1, 1], [1, 1, 1], [45, 45, 45], [\n\t\t\t45, 45, 45], [45, 45, 45], [3, 3, 3]]\n\t\tB = [[1, 2, 3], [4, 5, 6], [-1, 0, 0],\n\t\t\t [0, -1, 0], [0, 0, -1], [0, 0, 0]]\n\t\texpected = [6, 15, -45, -45, -45, 0]\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(expected[i], dotProd(A[i], B[i]))\n\n\tdef test_dotProd_with_different_length_vectors(self):\n\t\ta = [1, 2, 3]\n\t\tb = [1, 1]\n\t\tself.assertRaises(AssertionError, dotProd, a, b)\n\n\tdef test_dotProd_with_multidimensional_arrays(self):\n\t\ta = [[1, 1], [2, 2]]\n\t\tb = [[1, 3], [5, 5]]\n\t\tself.assertRaises(AssertionError, dotProd, a, b)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}, {"term": "class", "name": "TestCalcAbsoluteArea", "data": "class TestCalcAbsoluteArea(unittest.TestCase):\n\n\tdef test_calcAbsoluteArea_with_two_negative_y_values(self):\n\t\ty = [-2, -3]\n\t\tx = [0, 1]\n\t\texpected = 2.5\n\t\tself.assertAlmostEqual(expected, calcAbsoluteArea(x, y))\n\n\tdef test_calcAbsoluteArea_with_two_positive_y_values(self):\n\t\ty = [2, 3]\n\t\tx = [0, 1]\n\t\texpected = 2.5\n\t\tself.assertAlmostEqual(expected, calcAbsoluteArea(x, y))\n\n\tdef test_calcAbsoluteArea_with_one_positive_and_one_negative_y_value(self):\n\t\ty = [2, -3]\n\t\tx = [0, 1]\n\t\texpected = 2.5\n\t\tself.assertAlmostEqual(expected, calcAbsoluteArea(x, y))\n\n\tdef test_calcAbsoluteArea_with_larger_sequence_of_y_values(self):\n\t\ty = [2, 3, -1]\n\t\tx = [0, 1, 2]\n\t\texpected = 4.5\n\t\tself.assertAlmostEqual(expected, calcAbsoluteArea(x, y))\n\n\tdef test_calcAbsoluteArea_with_unordered_x_values(self):\n\t\ty = [2, 3]\n\t\tx = [1, 0]\n\t\tself.assertRaises(AssertionError, calcAbsoluteArea, x, y)\n\n\tdef test_calcAbsoluteArea_with_different_length_x_and_y(self):\n\t\ty = [2, 3, 4]\n\t\tx = [0, 1]\n\t\tself.assertRaises(AssertionError, calcAbsoluteArea, x, y)\n\n\tdef test_calcAbsoluteArea_with_multidimensional_arrays(self):\n\t\ty = [[1, 1], [2, 3]]\n\t\tx = [[0, 1], [2, 3]]\n\t\tself.assertRaises(AssertionError, calcAbsoluteArea, x, y)\n\n\tdef test_calcAbsoluteArea_with_negative_x_element(self):\n\t\ty = [1, 2]\n\t\tx = [-2, 2]\n\t\tself.assertRaises(AssertionError, calcAbsoluteArea, x, y)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}, {"term": "class", "name": "TestCalcDotProdDiff", "data": "class TestCalcDotProdDiff(unittest.TestCase):\n\n\tdef test_calcDotProdDiff_with_nonzero_inputs_higher_analytical(self):\n\t\tanalytical = [3, 4]\n\t\tanalysis = [2, 3]\n\t\texpected = -12.0 / 25.0\n\t\tself.assertAlmostEqual(expected, calcDotProdDiff(analysis, analytical))\n\n\tdef test_calcDotProdDiff_with_nonzero_inputs_higher_analysis(self):\n\t\tanalytical = [2, 3]\n\t\tanalysis = [3, 4]\n\t\texpected = 12.0 / 13.0\n\t\tself.assertAlmostEqual(expected, calcDotProdDiff(analysis, analytical))\n\n\tdef test_calcDotProdDiff_with_zero_analysis_and_nonzero_analytical(self):\n\t\tanalytical = [3, 4]\n\t\tanalysis = [0, 0]\n\t\texpected = -1\n\t\tself.assertAlmostEqual(expected, calcDotProdDiff(analysis, analytical))\n\n\tdef test_calcDotProdDiff_with_zero_analytical_and_nonzero_analysis(self):\n\t\tanalytical = [0., 0.]\n\t\tanalysis = [3, 4]\n\t\tself.assertRaises(\n\t\t\tZeroDivisionError,\n\t\t\tcalcDotProdDiff,\n\t\t\tanalysis,\n\t\t\tanalytical)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}, {"term": "class", "name": "TestCalcAreaDiff", "data": "class TestCalcAreaDiff(unittest.TestCase):\n\n\tdef test_calcAreaDiff_with_nonzero_inputs_higher_analytical(self):\n\t\tangles = [0, 1]\n\t\tanalysisData = [2, 3]\n\t\tanalyticalData = [3, 4]\n\t\texpected = -1.0 / 3.5\n\t\tself.assertAlmostEqual(\n\t\t\texpected,\n\t\t\tcalcAreaDiff(\n\t\t\t\tangles,\n\t\t\t\tanalysisData,\n\t\t\t\tanalyticalData))\n\n\tdef test_calAreaDiff_with_nonzero_inputs_higher_analysis(self):\n\t\tangles = [0, 1]\n\t\tanalysisData = [3, 4]\n\t\tanalyticalData = [2, 3]\n\t\texpected = 1.0 / 2.5\n\t\tself.assertAlmostEqual(\n\t\t\texpected,\n\t\t\tcalcAreaDiff(\n\t\t\t\tangles,\n\t\t\t\tanalysisData,\n\t\t\t\tanalyticalData))\n\n\tdef test_calcAreaDiff_with_zero_analysis_and_nonzero_analytical(self):\n\t\tangles = [0, 1]\n\t\tanalysisData = [0, 0]\n\t\tanalyticalData = [1, 2]\n\t\texpected = -1\n\t\tself.assertAlmostEqual(\n\t\t\texpected,\n\t\t\tcalcAreaDiff(\n\t\t\t\tangles,\n\t\t\t\tanalysisData,\n\t\t\t\tanalyticalData))\n\n\tdef test_calcAreaDiff_with_zero_analytical_and_nonzero_analysis(self):\n\t\tangles = [0, 1]\n\t\tanalysisData = [1, 2]\n\t\tanalyticalData = [0, 0]\n\t\tself.assertRaises(ZeroDivisionError,\n\t\t\t\t\t\t  calcAreaDiff, angles, analysisData, analyticalData)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}, {"term": "class", "name": "TestContourAveraging", "data": "class TestContourAveraging(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tself.contEvenDict = {\n\t\t\t'cont_1': [5, 0, -5], 'cont_2': [1, 0, -1], 'cont_3': [9, 0, -9],\n\t\t\t'cont_4': [4, 0, -4], 'cont_5': [3, 0, -3], 'cont_6': [7, 0, -7]}\n\t\tself.contOddDict = {\n\t\t\t'cont_1': [5, 0, -5], 'cont_2': [1, 0, -1], 'cont_3': [9, 0, -9],\n\t\t\t'cont_4': [4, 0, -4], 'cont_5': [3, 0, -3]}\n\n\tdef test_contourAveraging_with_even_number_contours_and_even_numCont(self):\n\t\tnumCont = 4\n\t\texpected = [17.0 / 4., 0, -17.0 / 4.]\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(\n\t\t\t\texpected[i], contourAveraging(\n\t\t\t\t\tself.contEvenDict, numCont)[i])\n\n\tdef test_contourAveraging_with_even_number_contours_and_odd_numCont(self):\n\t\tnumCont = 3\n\t\texpected = [14.0 / 3., 0, -14.0 / 3.]\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(\n\t\t\t\texpected[i], contourAveraging(\n\t\t\t\t\tself.contEvenDict, numCont)[i])\n\n\tdef test_contourAveraging_with_odd_number_contours_and_even_numCont(self):\n\t\tnumCont = 4\n\t\texpected = [19.0 / 4., 0, -19.0 / 4.]\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(\n\t\t\t\texpected[i], contourAveraging(\n\t\t\t\t\tself.contOddDict, numCont)[i])\n\n\tdef test_contourAveraging_with_odd_number_contours_and_odd_numCont(self):\n\t\tnumCont = 3\n\t\texpected = [14.0 / 3., 0, -14.0 / 3.]\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(\n\t\t\t\texpected[i], contourAveraging(\n\t\t\t\t\tself.contOddDict, numCont)[i])\n\n\tdef test_contourAveraging_with_even_number_contours_and_one_numCont(self):\n\t\tnumCont = 1\n\t\texpected = [9., 0, -9.]\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(\n\t\t\t\texpected[i], contourAveraging(\n\t\t\t\t\tself.contEvenDict, numCont)[i])\n\n\tdef test_contourAveraging_with_odd_number_contours_and_one_numCont(self):\n\t\tnumCont = 1\n\t\texpected = [9.0, 0, -9.0]\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(\n\t\t\t\texpected[i], contourAveraging(\n\t\t\t\t\tself.contEvenDict, numCont)[i])\n\n\tdef test_contourAveraging_with_even_number_contours_over_all_contours(\n\t\t\tself):\n\t\tnumCont = len(self.contEvenDict.keys())\n\t\texpected = [29. / 6., 0, -29. / 6]\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(\n\t\t\t\texpected[i], contourAveraging(\n\t\t\t\t\tself.contEvenDict, numCont)[i])\n\n\tdef test_contourAveraging_with_odd_number_contours_over_all_contours(self):\n\t\tnumCont = len(self.contOddDict.keys())\n\t\texpected = [22. / 5, 0, -22. / 5]\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(\n\t\t\t\texpected[i], contourAveraging(\n\t\t\t\t\tself.contOddDict, numCont)[i])\n\n\tdef test_contourAveraging_with_larger_numCont_than_contours(self):\n\t\tnumCont = len(self.contEvenDict.keys()) + 1\n\t\tself.assertRaises(\n\t\t\tAssertionError, contourAveraging, self.contEvenDict, numCont)\n\n\tdef test_contourAveraging_over_zero_contours(self):\n\t\tnumCont = 0\n\t\tself.assertRaises(\n\t\t\tAssertionError, contourAveraging, self.contEvenDict, numCont)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}, {"term": "class", "name": "TestCalcErrors", "data": "class TestCalcErrors(unittest.TestCase):\n\n\tdef test_calcErrors_with_vectors_of_equal_lengths(self):\n\t\tanalysis = [\n\t\t\t-20, -5, 0, 5, 20,\n\t\t\t-20, -5, 0, 5, 20,\n\t\t\t-20, -5, 0, 5, 20]\n\t\tanalytical = [\n\t\t\t-10, -10, -10, -10, -10,\n\t\t\t0, 0, 0, 0, 0,\n\t\t\t10, 10, 10, 10, 10]\n\t\texpected = [\n\t\t\t10, -5, -10, -5, 10,\n\t\t\t20, 5, 0, 5, 20,\n\t\t\t10, -5, -10, -5, 10]\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(expected[i],\n\t\t\t\t\t\t\t\t   calcErrors(analytical, analysis)[i])\n\n\tdef test_calcErrors_with_vectors_of_different_lengths(self):\n\t\tanalysis = [1, 2, 3, 4, 5]\n\t\tanalytical = [1, 2, 3]\n\t\tself.assertRaises(AssertionError, calcErrors, analytical, analysis)\n\n\tdef test_calcErrors_with_multidimensional_arrays_with_equal_size(self):\n\t\tanalysis = [[1, 2, 3], [1, 2, 3]]\n\t\tanalytical = [[2, 3, 4], [4, 5, 6]]\n\t\tself.assertRaises(AssertionError, calcErrors, analytical, analysis)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}, {"term": "class", "name": "TestCalcDiffErrors", "data": "class TestCalcDiffErrors(unittest.TestCase):\n\tpass\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}, {"term": "class", "name": "TestCalcRMSD", "data": "class TestCalcRMSD(unittest.TestCase):\n\n\tdef test_calcRMSD_with_vectors_of_equal_length(self):\n\t\tanalytical = [-5, -1, 1, 2, 3, 4, 5, 6]\n\t\tanalysis = [-4, 2, -1, 0, 1, 2, 5, 9]\n\t\texpected = (35.0 / 8.0)**0.5\n\t\tself.assertAlmostEqual(expected, calcRMSD(analytical, analysis))\n\n\tdef test_calcRMSD_with_vectors_of_different_length(self):\n\t\tanalytical = [1, 2, 3, 4]\n\t\tanalysis = [1, 2, 3]\n\t\tself.assertRaises(AssertionError, calcRMSD, analytical, analysis)\n\n\tdef test_calcRMSD_with_arrays_of_different_size(self):\n\t\tanalytical = [[1, 2], [4, 5]]\n\t\tanalysis = [[1, 2, 3], [1, 2, 3]]\n\t\tself.assertRaises(AssertionError, calcRMSD, analytical, analysis)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}, {"term": "class", "name": "TestCalcNormErrors", "data": "class TestCalcNormErrors(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tself.domain = [0, 1, 2, 3, 4, 5]\n\n\tdef test_calcNormErrors_with_analysis_dotProd_larger(self):\n\t\tanalytical = [1, 2, 3, -4, -5, -6]\n\t\tanalysis = [2, 1, -7, -1, -9, 3]\n\t\t#expected =   [1, -1, -10, 3, -4, 9]\n\t\texpected = [\n\t\t\t0.16666666, -0.166666666, -1.666666666, 0.5, -0.666666666, 1.5]\n\t\tresult = calcNormErrors(analytical, analysis, self.domain, 'dotProd')\n\t\tself.assertEqual(1, result[1])\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(expected[i], result[0][i])\n\n\tdef test_calcNormErrors_with_analytical_dotProd_larger(self):\n\t\tanalysis = [1, 2, 3, -4, -5, -6]\n\t\tanalytical = [2, 1, -7, -1, -9, 3]\n\t\t#expected =  [-1, 1, 10, -3,  4, -9]\n\t\texpected = [-0.111111111, 0.111111111,\n\t\t\t\t\t1.11111111111, -0.333333333, 0.44444444, -1]\n\t\tresult = calcNormErrors(analytical, analysis, self.domain, 'dotProd')\n\t\tself.assertEqual(-1, result[1])\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(expected[i], result[0][i])\n\n\tdef test_calcNormErrors_with_analytical_areas_larger(self):\n\t\tanalysis = [1, 2, 3, -4, -5, -6]\n\t\tanalytical = [2, 1, -7, -1, -9, 3]\n\t\t#expected =  [-1, 1, 10, -3,  4, -9]\n\t\texpected = [-0.111111111, 0.111111111,\n\t\t\t\t\t1.11111111111, -0.333333333, 0.44444444, -1]\n\t\tresult = calcNormErrors(analytical, analysis, self.domain, 'areas')\n\t\tself.assertEqual(-1, result[1])\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(expected[i], result[0][i])\n\n\tdef test_calcNormErrors_with_analysis_areas_larger(self):\n\t\tanalytical = [1, 2, 3, -4, -5, -6]\n\t\tanalysis = [2, 1, -7, -1, -9, 3]\n\t\t#expected =   [1, -1, -10, 3, -4, 9]\n\t\texpected = [\n\t\t\t0.16666666, -0.166666666, -1.666666666, 0.5, -0.666666666, 1.5]\n\t\tresult = calcNormErrors(analytical, analysis, self.domain, 'areas')\n\t\tself.assertEqual(1, result[1])\n\t\tfor i in range(len(expected)):\n\t\t\tself.assertAlmostEqual(expected[i], result[0][i])\n\n\tdef test_calcNormErrors_with_unrecognized_eSignFactor(self):\n\t\tanalytical = [1, 2, 3, -4, -5, -6]\n\t\tanalysis = [2, 1, -7, -1, -9, 3]\n\t\tself.assertRaises(\n\t\t\tKeyError,\n\t\t\tcalcNormErrors,\n\t\t\tanalytical,\n\t\t\tanalysis,\n\t\t\tself.domain,\n\t\t\t'unrecognized key')\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}, {"term": "class", "name": "TestCalcAvgNormError", "data": "class TestCalcAvgNormError(unittest.TestCase):\n\n\tdef test_calcAvgNormError(self):\n\t\tdomain = [0, 1, 2, 3, 4, 5]\n\t\tanalysis = [1, 2, 3, -4, -5, -6]\n\t\tanalytical = [2, 1, -7, -1, -9, 3]\n\t\t#expected =  [-1, 1, 10, -3,  4, -9]\n\t\terrors = [-0.111111111, 0.111111111,\n\t\t\t\t  1.11111111111, -0.333333333, 0.44444444, -1]\n\t\texpected = -3.1111111111 / float(len(domain))\n\t\tmock = MagicMock(return_value=(np.array(errors), -1))\n\t\twith patch(modulePath + 'calcNormErrors', mock):\n\t\t\tresult = calcAvgNormError(analytical, analysis, domain, 'areas')\n\t\tself.assertAlmostEqual(expected, result)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}, {"term": "class", "name": "TestCalcMaxNormError", "data": "class TestCalcMaxNormError(unittest.TestCase):\n\n\tdef test_calcMaxNormError(self):\n\t\tdomain = [0, 1, 2, 3, 4, 5]\n\t\tanalysis = [1, 2, 3, -4, -5, -6]\n\t\tanalytical = [2, 1, -7, -1, -9, 3]\n\t\t#expected =  [-1, 1, 10, -3,  4, -9]\n\t\terrors = [-0.111111111, 0.111111111,\n\t\t\t\t  1.11111111111, -0.333333333, 0.44444444, -1]\n\t\tmock = MagicMock(return_value=(errors, -1))\n\t\twith patch(modulePath + 'calcNormErrors', mock):\n\t\t\tresult = calcMaxNormError(analytical, analysis, domain, 'areas')\n\t\tself.assertAlmostEqual(errors[2], result)\n\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}, {"term": "class", "name": "TestCalcStatsWrapper", "data": "class TestCalcStatsWrapper(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tself.areaDiffMock = MagicMock(return_value='areaDiffMock')\n\t\tself.dpMock = MagicMock(return_value='dpMock')\n\t\tself.avgNErrMock = MagicMock(return_value='avgNErrMock')\n\t\tself.maxNErrMock = MagicMock(return_value='maxNErrMock')\n\t\tself.diffErrMock = MagicMock(return_value='diffErrMock')\n\t\tself.rmsdMock = MagicMock(return_value='rmsdMock')\n\t\tself.patches = [\n\t\t\tpatch(modulePath + 'calcAreaDiff', self.areaDiffMock),\n\t\t\tpatch(modulePath + 'calcDotProdDiff', self.dpMock),\n\t\t\tpatch(modulePath + 'calcAvgNormError', self.avgNErrMock),\n\t\t\tpatch(modulePath + 'calcMaxNormError', self.maxNErrMock),\n\t\t\tpatch(modulePath + 'calcDiffErrors', self.diffErrMock),\n\t\t\tpatch(modulePath + 'calcRMSD', self.rmsdMock)]\n\t\tfor p in self.patches:\n\t\t\tp.start()\n\n\tdef tearDown(self):\n\t\tfor p in self.patches:\n\t\t\tp.stop()\n\n\tdef test_calcStatsWrapper_with_nonexisting_statKey(self):\n\t\tself.assertRaises(KeyError, calcStatsWrapper, 'statkey',\n\t\t\t\t\t\t  'angles', 'analytical', 'analysis', 'areas')\n\n\tdef test_calcStatsWrapper_with_areaDiff_statKey(self):\n\t\tself.assertEqual(\n\t\t\t'areaDiffMock',\n\t\t\tcalcStatsWrapper(\n\t\t\t\t'areaDiff',\n\t\t\t\t'angles',\n\t\t\t\t'analytical',\n\t\t\t\t'analysis',\n\t\t\t\t'areas'))\n\t\tself.areaDiffMock.assert_called_once_with(\n\t\t\tangles='angles',\n\t\t\tanalysisData='analysis',\n\t\t\tanalyticalData='analytical')\n\n\tdef test_calcStatsWrapper_with_dotProd_statKey(self):\n\t\tself.assertEqual(\n\t\t\t'dpMock',\n\t\t\tcalcStatsWrapper(\n\t\t\t\t'dotProd',\n\t\t\t\t'angles',\n\t\t\t\t'analytical',\n\t\t\t\t'analysis',\n\t\t\t\t'areas'))\n\t\tself.dpMock.assert_called_once_with(analysisData='analysis',\n\t\t\t\t\t\t\t\t\t\t\tanalyticalData='analytical')\n\n\tdef test_calcStatsWrapper_with_avgNormError(self):\n\t\tself.assertEqual(\n\t\t\t'avgNErrMock',\n\t\t\tcalcStatsWrapper(\n\t\t\t\t'avgNormError',\n\t\t\t\t'angles',\n\t\t\t\t'analytical',\n\t\t\t\t'analysis',\n\t\t\t\t'areas'))\n\t\tself.avgNErrMock.assert_called_once_with(\n\t\t\tanalytical='analytical',\n\t\t\tanalysis='analysis',\n\t\t\tdomain='angles',\n\t\t\teSignFactor='areas')\n\n\tdef test_calcStatsWrapper_with_maxNormError_statKey(self):\n\t\tself.assertEqual(\n\t\t\t'maxNErrMock',\n\t\t\tcalcStatsWrapper(\n\t\t\t\t'maxNormError',\n\t\t\t\t'angles',\n\t\t\t\t'analytical',\n\t\t\t\t'analysis',\n\t\t\t\t'areas'))\n\t\tself.maxNErrMock.assert_called_once_with(\n\t\t\tanalytical='analytical',\n\t\t\tanalysis='analysis',\n\t\t\tdomain='angles',\n\t\t\teSignFactor='areas')\n\n\tdef test_calcStatsWrapper_with_difference_statKey(self):\n\t\tself.assertEqual(\n\t\t\t'diffErrMock',\n\t\t\tcalcStatsWrapper(\n\t\t\t\t'difference',\n\t\t\t\t'angles',\n\t\t\t\t'analytical',\n\t\t\t\t'analysis',\n\t\t\t\t'areas'))\n\t\tself.diffErrMock.assert_called_once_with(analytical='analytical',\n\t\t\t\t\t\t\t\t\t\t\t\t analysis='analysis')\n\n\tdef test_calcStatsWrapper_with_rmsd_statKey(self):\n\t\tself.assertEqual(\n\t\t\t'rmsdMock',\n\t\t\tcalcStatsWrapper(\n\t\t\t\t'rmsd',\n\t\t\t\t'angles',\n\t\t\t\t'analytical',\n\t\t\t\t'analysis',\n\t\t\t\t'areas'))\n\t\tself.rmsdMock.assert_called_once_with(analytical='analytical',\n\t\t\t\t\t\t\t\t\t\t\t  analysis='analysis')\n", "description": null, "category": "math", "imports": ["import unittest", "from mock import Mock, MagicMock, patch", "from miscFuncs import *", "import numpy as np"]}], [{"term": "def", "name": "rmse", "data": "def rmse(modelated, measured, wind_direction):\n\n\timport pandas as pd\n\timport numpy as np\n\tfrom collections import OrderedDict\n\tfrom scipy import stats\n\timport direction_average as dir_avg\n\n\n\t# create table for calc\n\tcalc_tab = pd.DataFrame(OrderedDict({'modelated':modelated, 'measured':measured}))\n\t#calc_tab = pd.DataFrame(OrderedDict({'modelated':np.array([-.5,0,.5]), 'measured':np.array([-.1,0,.1])}))\n\t#calc_tab = pd.DataFrame(OrderedDict({'measured':err_tab.dd_med, 'modelated':err_tab.wrf_wind_dir}))\n\t# Residual error measured-model\n\tif wind_direction == True :\n\t\tcalc_tab.iloc[:,0][calc_tab.iloc[:,0] == 0] = 360\n\t\tcalc_tab.iloc[:,1][calc_tab.iloc[:,1] == 0] = 360\n\n\t# N\n\tN = len(calc_tab.iloc[:,0])\n\n\tif wind_direction == True :\n\n\t\tdir_err1 = calc_tab.iloc[:,0] - calc_tab.iloc[:,1]\n\t\tdir_err2 = calc_tab.iloc[:,1] + 360 - calc_tab.iloc[:,0]\n\n\t\tdir_err1[(dir_err1 >= 180)] = dir_err2[(dir_err1 >= 180)]\n\t\tdir_err1[(dir_err1 <= -180)] = dir_err1[(dir_err1 <= -180)] + 360\n\n\t\tcalc_tab['mod-med'] = dir_err1\n\t\t#calc_tab['mod-med'] = 100*calc_tab['mod-med']/calc_tab.iloc[:,1]\n\n\telse :\n\t\tcalc_tab['mod-med'] = calc_tab.iloc[:,0] - calc_tab.iloc[:,1]\n\t\t#calc_tab['mod-med'] = 100*calc_tab['mod-med']/calc_tab.iloc[:,1]\n\n\t# Mean Forecast Error (Bias)\n\tif wind_direction == True :\n\t\tbias = dir_avg.dir_avg(np.array(calc_tab['mod-med']))\n\telse :\n\t\tbias = np.mean(calc_tab['mod-med'])\n\t#mean_forecast_error = 100*sum(calc_tab['mod-med'])/sum(calc_tab.iloc[:,1])\n\t#mean_forecast_error_perc = np.mean(calc_tab['mod-med_perc'])\n\n\t# Mean Absolute Error (MAE)\n\tif wind_direction == True :\n\t\tmae = dir_avg.dir_avg(np.array(np.abs(calc_tab['mod-med'])))  #mean_absolute_error = np.absolute(mean_forecast_error) #np.mean(np.absolute(calc_tab['mod-med']))\n\telse :\n\t\tmae = np.mean(np.abs(calc_tab['mod-med']))\n\t#mean_absolute_error_perc = np.absolute(mean_forecast_error_perc) #np.mean(np.absolute(calc_tab['mod-med_perc']))\n\n\t# Mean Squared Error (MSE)\n\tif wind_direction == True :\n\t\tmse = dir_avg.dir_avg(np.array((calc_tab['mod-med'])**2)) #/len(calc_tab['mod-med']) #np.mean((calc_tab['mod-med'])**2)\n\telse :\n\t\tmse = np.mean((calc_tab['mod-med'])**2)\n\t#mean_squared_error_perc = mean_forecast_error_perc**2 #np.mean((calc_tab['mod-med_perc'])**2)\n\n\t# Root Mean Squared Error (RMSE)\n\tif wind_direction == True :\n\t\trmse =  np.sqrt(dir_avg.dir_avg(np.array((calc_tab['mod-med'])**2))) #mean_squared_error**(1/2) #np.sqrt(mean_squared_error)\n\telse :\n\t\trmse =  np.sqrt(np.mean((calc_tab['mod-med'])**2))\n\t#rmse_perc = mean_squared_error_perc**(1/2) #np.sqrt(mean_squared_error)\n\n", "description": null, "category": "math", "imports": ["\timport pandas as pd", "\timport numpy as np", "\tfrom collections import OrderedDict", "\tfrom scipy import stats", "\timport direction_average as dir_avg"]}], [{"term": "def", "name": "ncdeficalc", "data": "async def icalc(e):\n\tudB.delete(\"calc\")\n\tif e.client._bot:\n\t\treturn await e.reply(\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tresults = await e.client.inline_query(asst.me.username, \"calc\")\n\tawait results[0].click(e.chat_id, silent=True, hide_via=True)\n\tawait e.delete()\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tcalc = e.builder.article(\"Calc\", text=\"\u2022 Ultroid Inline Calculator \u2022\", buttons=lst)\n\tawait e.answer([calc])\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tx = (e.data_match.group(1)).decode()\n\tif x == \"AC\":\n\t\tudB.delete(\"calc\")\n\t\tawait e.edit(\n\t\t\t\"\u2022 Ultroid Inline Calculator \u2022\",\n\t\t\tbuttons=[Button.inline(\"Open Calculator Again\", data=\"recalc\")],\n\t\t)\n\telif x == \"C\":\n\t\tudB.delete(\"calc\")\n\t\tawait e.answer(\"cleared\")\n\telif x == \"\u232b\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get[:-1])\n\t\t\tawait e.answer(str(get[:-1]))\n\telif x == \"%\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/100\")\n\t\t\tawait e.answer(str(get + \"/100\"))\n\telif x == \"\u00f7\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"/\")\n\t\t\tawait e.answer(str(get + \"/\"))\n\telif x == \"x\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + \"*\")\n\t\t\tawait e.answer(str(get + \"*\"))\n\telif x == \"=\":\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tif get.endswith((\"*\", \".\", \"/\", \"-\", \"+\")):\n\t\t\t\tget = get[:-1]\n\t\t\tout = await calcc(get, e)\n\t\t\ttry:\n\t\t\t\tnum = float(out)\n\t\t\t\tawait e.answer(f\"Answer : {num}\", cache_time=0, alert=True)\n\t\t\texcept BaseException:\n\t\t\t\tudB.delete(\"calc\")\n\t\t\t\tawait e.answer(\"Error\", cache_time=0, alert=True)\n\t\tawait e.answer(\"None\")\n\telse:\n\t\tget = udB.get(\"calc\")\n\t\tif get:\n\t\t\tudB.set(\"calc\", get + x)\n\t\t\tawait e.answer(str(get + x))\n\t\tudB.set(\"calc\", x)\n\t\tawait e.answer(str(x))\n\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}, {"term": "def", "name": "ncdef_", "data": "async def _(e):\n\tm = [\n\t\t\"AC\",\n\t\t\"C\",\n\t\t\"\u232b\",\n\t\t\"%\",\n\t\t\"7\",\n\t\t\"8\",\n\t\t\"9\",\n\t\t\"+\",\n\t\t\"4\",\n\t\t\"5\",\n\t\t\"6\",\n\t\t\"-\",\n\t\t\"1\",\n\t\t\"2\",\n\t\t\"3\",\n\t\t\"x\",\n\t\t\"00\",\n\t\t\"0\",\n\t\t\".\",\n\t\t\"\u00f7\",\n\t]\n\ttultd = [Button.inline(f\"{x}\", data=f\"calc{x}\") for x in m]\n\tlst = list(zip(tultd[::4], tultd[1::4], tultd[2::4], tultd[3::4]))\n\tlst.append([Button.inline(\"=\", data=\"calc=\")])\n\tawait e.edit(\"Noice Inline Calculator\", buttons=lst)\n", "description": null, "category": "math", "imports": ["import re", "from . import *"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "classViewer:", "data": "class Viewer:\n\tdef __init__(self, text_edit, conn_type):\n\t\tself.text_edit = text_edit\n\t\tself.conn_type = conn_type\n\n\tdef displayProject(self, project_desc):\n\t\t# self.text_edit.append('PROJECT DESCRIPTION:')\n\t\tself.text_edit.append('Job No. : ' + project_desc['job_no'] + '\\t\\tProject Symbol : ' +\n\t\t\t\t\t\t\t  project_desc['project_symbol'])\n\t\t# self.text_edit.append('Project Symbol: ' + project_desc['project_symbol'])\n\t\tself.text_edit.append('Project Title\\t\\t: ' + project_desc['project_title'])\n\t\tself.text_edit.append('Client/Owner\\t\\t: ' + project_desc['client'])\n\t\tself.text_edit.append('Structure Tag\\t\\t: ' + project_desc['item'])\n\t\tself.text_edit.append('')\n\n\tdef displayMaterial(self, material):\n\t\tself.text_edit.append('MATERIAL SPECIFICATION:')\n\t\tself.text_edit.append('Structural Steel Section and Plates\\t: ' + material[0])\n\t\tself.text_edit.append('High Strength Bolt (HSB)\\t\\t: ' + material[1])\n\t\tself.text_edit.append('Weld Metal Filler Classification Strength\\t: ' + material[2])\n\t\tself.text_edit.append('')\n\n\tdef displayConnGeometry(self, geometry):\n\t\tself.text_edit.append('CONNECTION GEOMETRY:')\n\t\tself.text_edit.append('Connection Type \\t\\t: ' + self.conn_type)\n\t\tself.text_edit.append('Beam/Girder size\\t\\t: ' + geometry['size'])\n\t\tself.text_edit.append('Bolt diameter, in\\t\\t: ' + geometry['dia'])\n\t\tself.text_edit.append('No. of bolts\\t\\t\\t: ' + geometry['nos'])\n\t\tself.text_edit.append('No. of column of bolts\\t\\t: ' + geometry['col'])\n\t\tself.text_edit.append('Fillet weld size, in\\t\\t: ' + geometry['weld'])\n\t\tself.text_edit.append('Vertical edge distance, in\\t\\t: ' + geometry['ev'])\n\t\tself.text_edit.append('Horizontal edge distance, in\\t\\t: ' + geometry['eh'])\n\t\tself.text_edit.append('Gusset Plate thickness, in\\t\\t: ' + geometry['tg'])\n\t\tself.text_edit.append('Gusset Plate height, in\\t\\t: ' + geometry['H'])\n\t\tself.text_edit.append('Dist. from TOB to G.Plate,in\\t\\t: ' + geometry['c'])\n\t\tself.text_edit.append('Supporting member,\\t\\t: ' + geometry['size2'] + ' (' + geometry['support'] + ')')\n\t\tself.text_edit.append('')\n\n\tdef displayLoadings(self, loadings):\n\t\tself.text_edit.append('LOADINGS:')\n\t\tself.text_edit.append('No.\\tMember\\t' + 'L/C\\t' + 'Node\\t' + 'Fx(kip)\\t' + 'Fy(kip)\\t' + 'Fz(kip)\\t' +\n\t\t\t\t\t\t\t  'My(kip-in)\\t' + 'Mz(kip-in)')\n\t\tindex = 0\n\t\tfor load in loadings:\n\t\t\tself.text_edit.append(str(index + 1) + '\\t' + str(load[0]) + '\\t' + str(load[1]) + '\\t' + str(load[2]) + '\\t' +\n\t\t\t\t\t\t\t\t  str(load[3]) + '\\t' + str(load[4]) + '\\t' + str(load[5]) + '\\t' + str(load[6]) +\n\t\t\t\t\t\t\t\t  '\\t' + str(load[7]))\n\t\t\tindex += 1\n\t\tself.text_edit.append('')\n\n\tdef displayMaterialStrength(self, material):\n\t\tms = MaterialStrength(material[0], material[1], material[2])\n\t\tself.text_edit.append('MATERIAL STRENGTH:')\n\t\tself.text_edit.append('Structural steel yield strength, ksi\\t Fy = ' + str(ms.Fy))\n\t\tself.text_edit.append('Steel min. tensile strength, ksi\\t Fup = ' + str(ms.Fup))\n\t\tself.text_edit.append('HSB min. tensile strength, ksi\\t Fub = ' + str(ms.Fub))\n\t\tself.text_edit.append('HSB nominal shear stress, ksi\\t Fnv = ' + str(ms.Fnv))\n\t\tself.text_edit.append('HSB nominal tensile stress, ksi\\t Fnt = ' + str(ms.Fnt))\n\t\tself.text_edit.append('Weld metal nominal stress, ksi\\t Fnw = ' + str(ms.Fnw))\n\t\tself.text_edit.append('')\n\n\tdef displayCalculationResult(self, design_result, calc_result):\n\t\tself.text_edit.append('CALCULATION RESULTS:')\n\t\tself.text_edit.append('Bolt group modulus, in\\t\\t Zbx = ' + str(design_result.bolt_modulus[0]))\n\t\tself.text_edit.append('Bolt group modulus, in\\t\\t Zby = ' + str(design_result.bolt_modulus[1]))\n\t\tself.text_edit.append('Shear force eccentricity, in\\t\\t e =' + str(design_result.ecc))\n\t\tself.text_edit.append('')\n\t\tself.text_edit.append('Mode \\t\\t\\t\\tLoad \\tActual \\tProvided \\tU/R')\n\t\tself.text_edit.append('Bolt shear strength, kip\\t\\t\\t' + str(calc_result[0][0] + 1) + '\\t' + str(calc_result[0][1]) +\n\t\t\t\t\t\t\t  '\\t' + str(calc_result[0][2]) + '\\t' + str(calc_result[0][3]))\n\t\tself.text_edit.append('Bearing strength on bolt hole, kip\\t\\t' + str(calc_result[1][0] +1) + '\\t' +\n\t\t\t\t\t\t\t  str(calc_result[1][1]) + '\\t' + str(calc_result[1][2]) + '\\t' + str(calc_result[1][3]))\n\t\tself.text_edit.append('Plate block shear strength, kip\\t\\t' + str(calc_result[2][0] +1) + '\\t' +\n\t\t\t\t\t\t\t  str(calc_result[2][1]) + '\\t' + str(calc_result[2][2]) + '\\t' + str(calc_result[2][3]))\n\t\tself.text_edit.append('Plate shear yielding, kip\\t\\t\\t' + str(calc_result[3][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t  str(calc_result[3][1]) + '\\t' + str(calc_result[3][2]) + '\\t' + str(calc_result[3][3]))\n\t\tself.text_edit.append('Plate shear rupture, kip\\t\\t\\t' + str(calc_result[4][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t  str(calc_result[4][1]) + '\\t' + str(calc_result[4][2]) + '\\t' + str(calc_result[4][3]))\n\t\tself.text_edit.append('Plate tensile yielding, kip\\t\\t\\t' + str(calc_result[5][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t  str(calc_result[5][1]) + '\\t' + str(calc_result[5][2]) + '\\t' + str(calc_result[5][3]))\n\t\tself.text_edit.append('Plate tensile rupture, kip\\t\\t\\t' + str(calc_result[6][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t  str(calc_result[6][1]) + '\\t' + str(calc_result[6][2]) + '\\t' + str(calc_result[6][3]))\n\t\tself.text_edit.append('Plate in-plane bending, kip-in \\t\\t' + str(calc_result[7][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t  str(calc_result[7][1]) + '\\t' + str(calc_result[7][2]) + '\\t' + str(calc_result[7][3]))\n\t\tself.text_edit.append('Plate out-of-plane bending, kip-in\\t\\t' + str(calc_result[8][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t  str(calc_result[8][1]) + '\\t' + str(calc_result[8][2]) + '\\t' + str(calc_result[8][3]))\n\t\tself.text_edit.append('Weld shear strength, kip/in\\t\\t\\t' + str(calc_result[9][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t  str(calc_result[9][1]) + '\\t' + str(calc_result[9][2]) + '\\t' + str(calc_result[9][3]))\n\t\tself.text_edit.append('')\n\t\tif self.conn_type == 'ShearCope':\n\t\t\tself.text_edit.append('Web block shear strength, kip\\t\\t' + str(calc_result[10][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t\t  str(calc_result[10][1]) + '\\t' + str(calc_result[10][2]) + '\\t' + str(\n\t\t\t\tcalc_result[2][3]))\n\t\t\tself.text_edit.append('Web shear yielding, kip\\t\\t\\t' + str(calc_result[11][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t\t  str(calc_result[11][1]) + '\\t' + str(calc_result[11][2]) + '\\t' + str(\n\t\t\t\tcalc_result[3][3]))\n\t\t\tself.text_edit.append('Web shear rupture, kip\\t\\t\\t' + str(calc_result[12][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t\t  str(calc_result[12][1]) + '\\t' + str(calc_result[12][2]) + '\\t' + str(\n\t\t\t\tcalc_result[4][3]))\n\t\t\tself.text_edit.append('Web tensile yielding, kip\\t\\t\\t' + str(calc_result[13][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t\t  str(calc_result[13][1]) + '\\t' + str(calc_result[13][2]) + '\\t' + str(\n\t\t\t\tcalc_result[5][3]))\n\t\t\tself.text_edit.append('Web tensile rupture, kip\\t\\t\\t' + str(calc_result[14][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t\t  str(calc_result[14][1]) + '\\t' + str(calc_result[14][2]) + '\\t' + str(\n\t\t\t\tcalc_result[6][3]))\n\t\t\tself.text_edit.append('Web in-plane bending, kip-in \\t\\t' + str(calc_result[15][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t\t  str(calc_result[15][1]) + '\\t' + str(calc_result[15][2]) + '\\t' + str(\n\t\t\t\tcalc_result[7][3]))\n\t\t\tself.text_edit.append('Web out-of-plane bending, kip-in\\t\\t' + str(calc_result[16][0] + 1) + '\\t' +\n\t\t\t\t\t\t\t\t  str(calc_result[16][1]) + '\\t' + str(calc_result[16][2]) + '\\t' + str(\n\t\t\t\tcalc_result[16][3]))\n\t\t\tself.text_edit.append('')\n", "description": null, "category": "math", "imports": ["from connection.materialstrength import MaterialStrength"]}], [{"term": "def", "name": "create_OER_plots", "data": "def create_OER_plots(\n\tdata,\n\tplots_folder=\"OER_plots\"\n\t):\n\t\"\"\"I'm just wrapping Michals whole script in a method.\n\n\tArgs:\n\t\tdata:\n\t\tplots_folder:\n\t\"\"\"\n\t# | - create_OER_plots\n\tcalc_systems = data\n\n\t# | - Styling and Setup\n\t# settings size and font for revtex stylesheet\n\n\tfig_width_pt = 1.8 * 246.0  # Get this from LaTeX using \\showthe\\columnwidth\n\t#fig_width_pt *= 300./72 # convert to 300 dpi\n\tinches_per_pt = 1.0 / 72.27\t\t\t   # Convert pt to inches\n\t#inches_per_pt = 1.0/300\t\t\t   # Convert pt to inches\n\tgolden_mean = (np.sqrt(5) - 1.0) / 2.0\t\t # Aesthetic ratio\n\tfig_width = fig_width_pt * inches_per_pt  # width in inches\n\tfig_height = fig_width * golden_mean\t   # height in inches\n\tfig_size = [fig_width, fig_height]\n\tfig = plt.figure(figsize=fig_size, dpi=300)\n\n\tfont_size = 9\n\ttick_font_size = 8\n\txlabel_pad = 8\n\tylabel_pad = 18\n\tmatplotlib.rcParams['ps.usedistiller'] = 'xpdf'\n\n\tmatplotlib.rcParams['font.size'] = 10\n\t#matplotlib.rcParams['axes.labelsize'] = 2*font_size\n\tmatplotlib.rcParams['axes.labelsize'] = font_size\n\tmatplotlib.rcParams['legend.fontsize'] = font_size\n\tmatplotlib.rcParams['xtick.labelsize'] = tick_font_size\n\tmatplotlib.rcParams['ytick.labelsize'] = tick_font_size\n\n\tfont_default = 'helvetica'\n\t#font_default='cmss'\n\n\tdef setfont(font=font_default, unicode=True):\n\t\t\"\"\"Set font.\n\n\t\tSet Matplotlibs rcParams to use LaTeX for font rendering.\n\t\tRevert all changes by calling rcdefault() from matplotlib.\n\n\t\tParameters:\n\t\t-----------\n\t\tfont: string\n\t\t\t\"Helvetica\"\n\t\t\t\"Times\"\n\t\t\t\"Computer Modern\"\n\n\t\tusetex: Boolean\n\t\t\tUse unicode. Default: False.\n\n\t\t\"\"\"\n\t\t# | - setfont\n\t\t# Use TeX for all figure text!\n\t\tplt.rc('text', usetex=True)\n\n\t\tfont = font.lower().replace(\" \", \"\")\n\t\tif font == 'times':\n\t\t\t# Times\n\t\t\tfont = {'family': 'serif', 'serif': ['Times']}\n\t\t\tpreamble = r\"\"\"\n\t\t\t\t\t\t  \\usepackage{color}\n\t\t\t\t\t\t  \\usepackage{mathptmx}\n\t\t\t\t\t   \"\"\"\n\t\telif font == 'helvetica':\n\t\t\t# Helvetica\n\t\t\t# set serif, too. Otherwise setting to times and then\n\t\t\t# Helvetica causes an error.\n\t\t\tfont = {'family': 'sans-serif', 'sans-serif': ['Helvetica'],\n\t\t\t\t\t'serif': ['cm10']}\n\t\t\tpreamble = r\"\"\"\n\t\t\t\t\t\t  \\usepackage{color}\n\t\t\t\t\t\t  \\usepackage[tx]{sfmath}\n\t\t\t\t\t\t  \\usepackage{helvet}\n\t\t\t\t\t\t  \\usepackage{sansmath}\n\t\t\t\t\t   \"\"\"\n\t\telse:\n\t\t\t# Computer modern serif\n\t\t\tfont = {'family': 'serif', 'serif': ['cm10']}\n\t\t\t# preamble = r\"\"\"\n\t\t\tpreamble = r\"\"\"\n\t\t\t\t\t\t\\usepackage{color}\n\t\t\t\t\t\t\"\"\"\n\n\t\tif font == 'cmss':\n\t\t\t# Computer modern sans serif\n\t\t\tfont = {'family': 'sans-serif', 'serif': ['cmss']}\n\t\t\tpreamble = r\"\"\"\n\t\t\t\t\t\t  \\usepackage{color}\n\t\t\t\t\t\t  \\usepackage[tx]{sfmath}\n\t\t\t\t\t   \"\"\"\n\n\t\tif unicode:\n\t\t\t# Unicode for Tex\n\t\t\t#preamble =  r\"\"\"\\usepackage[utf8]{inputenc}\"\"\" + preamble\n\t\t\t# inputenc should be set automatically\n\t\t\tplt.rcParams['text.latex.unicode'] = True\n\n\t\t# print font, preamble\n\t\tplt.rc('font', **font)\n\t\tplt.rcParams['text.latex.preamble'] = preamble\n\t\t#__|\n\n\tsetfont(\n\t\tfont_default,\n\t\t# unicode=True,\n\t\tunicode=False,\n\t\t)\n\n\tmatplotlib.rcParams['lines.linewidth'] = 1.\n\n\t#matplotlib.rcParams['ytick.direction'] = 'out'\n\t#matplotlib.rcParams['xtick.direction'] = 'out'\n\n\tax = fig.add_axes([0.2, 0.2, 0.6, 0.6])\n\n\tzoom = 0.5\n\td1 = 3 * zoom\n\td2 = 4 * zoom\n\txcenter = 1.5  # 0.65\n\t#ycenter=1.23#2.4\n\tycenter = 0.8  # 2.4\n\n\tx1 = xcenter - d1  # -0.6\n\tx2 = xcenter + d1  # 2.2\n\ty1 = ycenter - d2  # 1#0.5\n\ty2 = ycenter + d2  # 5\n\tax.axis([x1, x2, y1, y2])\n\tax.set_xlabel(r'$\\Delta$G$_{\\sf O}$ - $\\Delta$G$_{\\sf OH}$ (eV)')\n\t#ax.set_ylabel(r'$\\Delta$G$_{\\sf OOH}$ -$\\Delta$G$_{\\sf O}$ (eV)')\n\tax.set_ylabel(r'$\\Delta$G$_{\\sf OH}$')\n\n\tdelta = 0.025\n\tx = np.arange(x1, x2 + delta, delta)\n\ty = np.arange(y1, y2 + delta, delta)\n\tX, Y = np.meshgrid(x, y)\n\n\t#Z1 = mlab.bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)\n\t#Z2 = mlab.bivariate_normal(X, Y, 1.5, 0.5, 1, 1)\n\t# difference of Gaussians\n\t#Z = 10.0 * (Z2 - Z1)\n\t#__|\n\n\t# | - Methods\n\t#fit=[0.84527288, 3.38026638]\n\tdef ooh_oh_scaling(doh):\n\t\t\"\"\"ooh_oh_scaling equation.\"\"\"\n\t\t# | - ooh_oh_scaling\n\t\t#like ambars\n\t\t#dooh=0.5*doh  + 3.0\t\t #O\n\t\t#normal one\n\n\t\tdooh = doh + 3.2\n\t\treturn(dooh)\n\t\t#__|\n\n\tdef overpotential(doh, do):\n\t\t\"\"\"Calculate overpotential.\n\n\t\tArgs:\n\t\t\tdoh:\n\t\t\tdo:\n\t\t\"\"\"\n\t\t# | - overpotential\n\t\tdooh = ooh_oh_scaling(doh)\n\t\tdg14 = [doh, do - doh, dooh - do, - dooh + 4.92]\n\t\tm = max(dg14)\n\t\treturn(m - 1.23)\n\t\t#return doh*do\n\t\t#__|\n\n\tdef overpotential2(x, doh):\n\t\t\"\"\"Calculate overpotential (version 2).\n\n\t\tArgs:\n\t\t\tx:\n\t\t\tdoh:\n\t\t\"\"\"\n\t\t# | - overpotential2\n\t\tdooh = ooh_oh_scaling(doh)\n\t\tdg14 = [doh, x, -x + 2.46, -dooh + 4.92]\n\t\tm = max(dg14)\n\t\treturn(m - 1.23)\n\t\t#return doh*do\n\t\t#__|\n\n\tdef overpotential3(x, doh):\n\t\t\"\"\"Calculate overpotential (version 3).\n\n\t\tArgs:\n\t\t\tx:\n\t\t\tdoh:\n\t\t\"\"\"\n\t\t# | - overpotential3\n\t\tdooh = ooh_oh_scaling(doh)\n\t\tdg14 = [doh, x, dooh - (x + doh), -dooh + 4.92]\n\t\tm = max(dg14)\n\t\treturn(m - 1.23)\n\n\t\t#return doh*do\n\t\t#__|\n\n\tdef overpotential_label(doh, do):\n\t\t\"\"\"Return overpotential label.\n\n\t\tArgs:\n\t\t\tdoh:\n\t\t\tdo:\n\t\t\"\"\"\n\t\t# | - overpotential_label\n\t\tdooh = ooh_oh_scaling(doh)\n\t\tdg14 = [doh, do - doh, dooh - do, -dooh + 4.92]\n\t\tm = max(dg14)\n\t\tfor i in range(len(dg14)):\n\t\t\tif(m == dg14[0]):\n\t\t\t\treturn(r'OH lim.')\n\t\t\tif(m == dg14[1]):\n\t\t\t\treturn(r'OH-O lim.')\n\t\t\tif(m == dg14[2]):\n\t\t\t\treturn(r'O-OOH lim.')\n\t\t\tif(m == dg14[3]):\n\t\t\t\treturn( r'OOH-O$_{\\sf 2}$ lim.')\n\t\t#return doh*do\n\t\t#__|\n\n\t#__|\n\n\t#Z=overpotential(X,Y)\n\n\t# | - OER_contour_plot *****************************************************\n\tZ = []\n\tfor j in y:\n\t\ttmp = []\n\t\tfor i in x:\n\t\t\ttmp.append(overpotential3(i, j))\n\t\tZ.append(tmp)\n\n\n\t#print overpotential(0.8,2.4)\n\n\tZ = np.array(Z)\n\n\n\t#im = plt.imshow(Z, origin='lower',interpolation='bilinear',\n\t#\t\t\t\tcmap=cm.jet_r, extent=(x1,x2,y1,y2), vmin=0, vmax=2)\n\n\torigin = 'lower'\n\tlevels = np.arange(0.0, 2, 0.1)\n\t#levels = np.arange(0.2, 2, 0.1)\n\tCS = plt.contourf(\n\t\tX,\n\t\tY,\n\t\tZ,\n\t\tlevels,\n\t\t#20,\n\t\t# [-1, -0.1, 0, 0.1],\n\t\t#alpha=0.8,\n\t\t#cmap=plt.cm.bone,\n\t\tcmap=plt.cm.jet_r,\n\t\t#extend='both',\n\t\textend='max',\n\t\torigin=origin,\n\t\t)\n\n\t# Note that in the following, we explicitly pass in a subset of\n\t# the contour levels used for the filled contours.  Alternatively,\n\t# We could pass in additional levels to provide extra resolution,\n\t# or leave out the levels kwarg to use all of the original levels.\n\n\tCS2 = plt.contour(\n\t\tCS,\n\t\tlevels=CS.levels,\n\t\tcolors='white',\n\t\tlinewidths=0.05,\n\t\talpha=0.3,\n\t\torigin=origin,\n\t\t# hold='on',\n\t\t)\n\n\t# | - __old__\n\t#levels = np.arange(0, 2, 0.05)\n\t#CS = plt.contourf(X,Y,Z, levels, cmap=cm.jet_r, origin='lower')\n\t#CS = plt.contourf(X,Y,Z, levels, origin='lower')\n\t#im = plt.imshow(Z, interpolation='bilinear', origin='lower',\n\t#\t\t\t\tcmap=cm.jet, extent=(x1,x2,y1,y2))\n\t#levels2 = [2.0]\n\t#CS2 = plt.contour(CS, levels2,\n\t#\t\t\t\t\t\tcolors = 'r',\n\t#\t\t\t\t\t\torigin='lower',\n\t#\t\t\t\t\t\thold='on')\n\t#CS = plt.contour(Z, levels,\n\t#\t\t\t\t origin='lower',\n\t#\t\t\t\t linewidths=0.5,\n\t#\t\t\t\t extent=(x1,x2,y1,y2))\n\t##Thicken the zero contour.\n\t#zc = CS.collections[6]\n\t#plt.setp(zc, linewidth=2)\n\t#__|\n\n\tcbar = plt.colorbar(CS)\n\t#cbar.ax.set_ylabel('Overpotential [V]')\n\t#cbar.ax.set_ylabel(r'$\\eta_{\\sf calc.}$')\n\tcbar.ax.set_ylabel(r'$\\eta_{\\sf OER}$')\n\n\t# | - __old__\n\t#cbar.add_lines(CS2)\n\t#plt.clabel(CS, levels[1::2],  # label every second level\n\t#\t\t   inline=1,\n\t#\t\t   fmt='%1.1f',\n\t#\t\t   fontsize='x-small')\n\t#plt.title('Lines with colorbar')\n\t# We can still add a colorbar for the image, too.\n\t# This makes the original colorbar look a bit out of place,\n\t# so let's improve its position.\n\t#__|\n\n\tax.tick_params(axis='both', direction='out')\n\tax.get_xaxis().tick_bottom()   # remove unneeded ticks\n\tax.get_yaxis().tick_left()\n\n\t# | - __old__\n\t#plot(x,ooh_oh_scaling(x),'--',color='orange',lw=1,\n\t# dashes=(3,1),label='$\\Delta$G$_{\\sf OOH}$=0.82G$_{\\sf OH}$+3.18 eV')\n\t#ax.text(x1+0.02,y2-0.3,\n\t# '$\\Delta$G$_{\\sf OOH}$=%.2fG$_{\\sf OH}$+%.2f eV' %(fit[0],fit[1]),\n\t# color='orange',fontsize='x-small',zorder=10,horizontalalignment='left')\n\t#ax.text(x1+0.02,y2-0.3,\n\t# '$\\Delta$G$_{\\sf OOH}$=%.2fG$_{\\sf OH}$+%.2f eV' %(0.82,3.18),\n\t# color='orange',fontsize='x-small',zorder=10,horizontalalignment='left')\n\t#plt.show()\n\t#__|\n\n\toffset = [0.0, 0.08]\n\n\t#foo=r': %f' % (calc_systems[i][3])\n\tfor i in range(len(calc_systems)):\n\t\t# ax.plot(calc_systems[i][1]-calc_systems[i][0], calc_systems[i][0],\n\t\t# 'or',color=calc_systems[i][5])\n\n\t\tax.plot(\n\t\t\tcalc_systems[i][1] - calc_systems[i][0],\n\t\t\tcalc_systems[i][0],\n\t\t\tcalc_systems[i][9],\n\t\t\tmec=calc_systems[i][5],\n\t\t\tmfc=calc_systems[i][10],\n\t\t\tmew=0.8,\n\t\t\tzorder=4,\n\t\t\tmarker=calc_systems[i][11],\n\t\t\tlabel=calc_systems[i][4] + ' : %.2f V' % (calc_systems[i][3])\n\t\t\t)\n\n\t# | - __old__\n\t# if i!=0 and 1:\n\t# ax.text(calc_systems[i][1]-calc_systems[i][0]+calc_systems[i][6],\n\t# calc_systems[i][0]+calc_systems[i][7],\n\t# calc_systems[i][4]+'(%.2f)' %(calc_systems[i][3]),color='black',\n\t# fontsize=6,horizontalalignment='center',rotation=0,zorder=1)\n\t#  else:\n\t#\t  ax.text(calc_systems[i][1]-calc_systems[i][0]+calc_systems[i][6],\n\t# calc_systems[i][0]+calc_systems[i][7],\n\t# calc_systems[i][4]+'(%.2f)' %(calc_systems[i][3]),\n\t# color='white',fontsize=6,horizontalalignment='center',\n\t# rotation=0,zorder=1)\n\t#ax.text(calc_systems[i][0],calc_systems[i][1],'%i' %(i+1),\n\t# color='black',fontsize=4,\n\t#\t\thorizontalalignment='center',\n\t#\t\tverticalalignment='center',\n\t#\t\trotation=0,zorder=2)\n\t#__|\n\n\tcorners = [\n\t\t[1.3, 1.0],\n\t\t[x1 + (x2 - x2) * 0.2, y1 + (y2 - y1) * 0.9],\n\t\t[x1 + (x2 - x2) * 0.8, y1 + (y2 - y1) * 0.1],\n\t\t[-2, 0],\n\t\t]\n\n\t#for i in range(len(corners)):\n\t#   ax.text(corners[i][0],corners[i][1], overpotential_label(corners[i][0],\n\t# corners[i][1]), color='white',fontsize='x-small',\n\t# horizontalalignment='center',rotation=0,zorder=3)\n\n\tax.legend(\n\t\tbbox_to_anchor=(1.25, 1.05),\n\t\tloc=2,\n\t\tborderaxespad=1,\n\t\tncol=1,\n\t\tfancybox=True,\n\t\tshadow=True,\n\t\tfontsize='x-small',\n\t\thandlelength=2,\n\t\t)\n\n\tfig_path_i = os.path.join(\n\t\tplots_folder,\n\t\t\"OER_contour_plot_v13.pdf\",\n\t\t)\n\n\tif not os.path.exists(plots_folder):\n\t\tos.makedirs(plots_folder)\n\n\tfig.savefig(\n\t\tfig_path_i,\n\t\tbbox_inches=\"tight\",\n\t\t)\n\n\t# fig.savefig('OER_contour_plot_v13.pdf', bbox_inches='tight')\n\tfig.clf()\n\n\t#__| **********************************************************************\n\n\t# | - OER_scaling **********************************************************\n\n\tfig = plt.figure(figsize=fig_size, dpi=300)\n\tax = fig.add_axes([0.2, 0.2, 0.6, 0.6])\n\tx1 = -1\n\tx2 = 2.5\n\tax.axis([x1, x2, x1, ooh_oh_scaling(x2)])\n\n\tax.set_xlabel(r'$\\Delta$G$_{\\sf OH}$ (eV)')\n\tax.set_ylabel(r'$\\Delta$G$_{\\sf OOH}$,$\\Delta$G$_{\\sf O}$ (eV)')\n\n\txdata = []\n\tydata = []\n\ty2data = []\n\n\t#for i in range(3):\n\tfor i in range(len(calc_systems)):\n\t\txdata.append(calc_systems[i][0])\n\t\tydata.append(calc_systems[i][2])\n\t\ty2data.append(calc_systems[i][1])\n\n\t# print(xdata)\n\t# print(ydata)\n\n\tfit = polyfit(xdata, ydata, 1)\n\tfit_fn = poly1d(fit)\n\t# print(fit_fn)\n\taa = fit_fn[1]\n\tbb = fit_fn[0]\n\n\tfit1 = polyfit(xdata, y2data, 1)\n\tfit_fn1 = poly1d(fit1)\n\t# print(fit_fn1)\n\n\t#print fit_fn[0], fit_fn[1]\n\t#how bad is scaling\n\tfor i in range(len(calc_systems)):\n\t\t\terror = calc_systems[i][2] - \\\n\t\t\t\t(fit_fn[1] * calc_systems[i][0] + fit_fn[0])\n\t\t\t# print(error, calc_systems[i])\n\n\txx = np.arange(x1, x2, delta)\n\n\t# Plotting Scaling Lines\n\tax.plot(xx, fit_fn[1] * xx + fit_fn[0], '--',\n\t\tlw=1, dashes=(3, 1), c='grey', label='OOH scaling',\n\t\t)\n\n\tax.plot(xx, xx + 3.2, '--', lw=1, dashes=(3, 1), c='black')\n\n\tax.plot(xx, xx, '--', lw=1, dashes=(3, 1), c='black')\n\n\tax.plot(xx, fit_fn1[1] * xx + fit_fn1[0], '--',\n\t\tlw=1, dashes=(3, 1), c='red', label='O scaling',\n\t\t)\n\n\tfor i in range(len(calc_systems)):\n\t\tax.plot(\n\t\t\tcalc_systems[i][0],\n\t\t\tcalc_systems[i][2],\n\t\t\t'ro',\n\t\t\tms=3,\n\t\t\tmarker=calc_systems[i][11],\n\t\t\t#alpha=0.2,\n\t\t\tcolor=calc_systems[i][10],\n\t\t\t)\n\n\t\tax.plot(\n\t\t\tcalc_systems[i][0],\n\t\t\tcalc_systems[i][1],\n\t\t\t'ro',\n\t\t\tms=3,\n\t\t\tmarker=calc_systems[i][11],\n\t\t\t#alpha=0.2,\n\t\t\tcolor=calc_systems[i][10],\n\t\t\t)\n\n\t\tax.plot(\n\t\t\tcalc_systems[i][0],\n\t\t\tcalc_systems[i][0],\n\t\t\tcalc_systems[i][9],\n\t\t\tmec=calc_systems[i][5],\n\t\t\tmfc=calc_systems[i][10],\n\t\t\tmew=0.8,\n\t\t\tzorder=4,\n\t\t\tmarker=calc_systems[i][11],\n\t\t\tlabel=calc_systems[i][4] + ' : %.2f V' % (calc_systems[i][3]),\n\t\t\t)\n\n\t\t# ax.text(calc_systems[i][0],\n\t\t# calc_systems[i][0]+calc_systems[i][7]+0.08,\n\t\t# calc_systems[i][4]+'(%.2f)' %(calc_systems[i][3]),\n\t\t# color='black',fontsize=6,horizontalalignment='center',\n\t\t# rotation=0,zorder=1)\n\n\tax.legend(\n\t\tbbox_to_anchor=(1.05, 1.05),\n\t\tloc=2,\n\t\tborderaxespad=0.5,\n\t\tncol=1,\n\t\tfancybox=True,\n\t\tshadow=True,\n\t\tfontsize='x-small',\n\t\thandlelength=2,\n\t\t)\n\n\n\tfig_path_i = os.path.join(\n\t\tplots_folder,\n\t\t\"OER_scaling.pdf\",\n\t\t)\n\n\tif not os.path.exists(plots_folder):\n\t\tos.makedirs(plots_folder)\n\n\tfig.savefig(\n\t\tfig_path_i,\n\t\tbbox_inches=\"tight\",\n\t\t)\n\n\t# fig.savefig('OER_scaling.pdf', bbox_inches='tight')\n\n\tfig.clf()\n\n\t#__| **********************************************************************\n\n\t# | - OER_1D_plot **********************************************************\n\tax = fig.add_axes([0.2, 0.2, 0.6, 0.6])\n\n\t#x1=1.23-1\n\t#x2=1.23+1\n\t#y2=1\n\t#y1=0\n\n\tx1 = 0.5\n\tx2 = 2.8\n\ty2 = 2.83\n\ty1 = 1.23\n\n\tax.axis([x1, x2, y1, y2])\n\tdelta = 0.01\n\tx = np.arange(x1, x2, delta)\n\n\tax.set_xlabel(r'$\\Delta$G$_{\\sf O}-\\Delta$G$_{\\sf OH}$ (eV)')\n\n\t#ax.set_ylabel(r'$\\Delta$G$_{\\sf O}$ (eV)')\n\t# ax.set_ylabel(r'U_{\\sf OER}$ (V)')\n\n\tax.set_ylabel(r'$\\eta_{\\sf OER}$')\n\tax.set_ylim(ax.get_ylim()[::-1])\n\tplot(\n\t\tx,\n\t\tnp.maximum(x, 3.2 - x),\n\t\t'--',\n\t\tcolor='black',\n\t\tlw=0.67,\n\t\tdashes=(3, 1),\n\t\tzorder=2,\n\t\t)\n\n\t# | - __old__\n\t#plot(x,1.23,'--',color='black',lw=0.67, dashes=(3,1),zorder=2)\n", "description": "I'm just wrapping Michals whole script in a method.\n\n\tArgs:\n\t\tdata:\n\t\tplots_folder:\n\t", "category": "math", "imports": ["import os", "import matplotlib", "import numpy as np", "import matplotlib.pyplot as plt", "from pylab import polyfit", "from pylab import poly1d", "from pylab import plot", "# from pylab import *", "# from matplotlib.ticker import *", "# from scipy import *", "# import matplotlib.cm as cm", "# import matplotlib.mlab as mlab", "# from math import pow", "# import matplotlib.pyplot as plt", "# import numpy as np", "# from matplotlib.path import Path", "# from matplotlib.patches import PathPatch", "# import subprocess", "# from matplotlib import rc"]}], [], [{"term": "def", "name": "verify", "data": "def verify(calc):\n\tassert calc.get_fermi_level() is not None\n\tassert calc.get_ibz_k_points() is not None\n\tassert calc.get_eigenvalues(spin=0, kpt=0) is not None\n\tassert calc.get_number_of_spins() is not None\n\tassert calc.get_k_point_weights() is not None\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_main", "data": "def test_main(espresso_factory):\n\tatoms = bulk('Si')\n\tatoms.calc = espresso_factory.calc()\n\tatoms.get_potential_energy()\n\tverify(atoms.calc)\n\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}, {"term": "def", "name": "test_smearing", "data": "def test_smearing(espresso_factory):\n\tatoms = bulk('Cu')\n\tinput_data = {'system':{'occupations': 'smearing',\n\t\t\t\t\t\t\t'smearing': 'fermi-dirac',\n\t\t\t\t\t\t\t'degauss': 0.02}}\n\tatoms.calc = espresso_factory.calc(input_data=input_data)\n\tatoms.get_potential_energy()\n\tverify(atoms.calc)\n", "description": null, "category": "math", "imports": ["import pytest", "from ase.build import bulk"]}], [{"term": "class", "name": "EvaluatorTest", "data": "class EvaluatorTest(unittest.TestCase):\n\t\"\"\"\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t\"\"\"\n\n\tdef test_number_input(self):\n\t\t\"\"\"\n\t\tTest different kinds of float inputs\n\n\t\tSee also\n\t\t  test_trailing_period (slightly different)\n\t\t  test_exponential_answer\n\t\t  test_si_suffix\n\t\t\"\"\"\n\t\teasy_eval = lambda x: calc.evaluator({}, {}, x)\n\n\t\tself.assertEqual(easy_eval(\"13\"), 13)\n\t\tself.assertEqual(easy_eval(\"3.14\"), 3.14)\n\t\tself.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n\t\tself.assertEqual(easy_eval(\"-13\"), -13)\n\t\tself.assertEqual(easy_eval(\"-3.14\"), -3.14)\n\t\tself.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n\tdef test_period(self):\n\t\t\"\"\"\n\t\tThe string '.' should not evaluate to anything.\n\t\t\"\"\"\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '.')\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '1+.')\n\n\tdef test_trailing_period(self):\n\t\t\"\"\"\n\t\tTest that things like '4.' will be 4 and not throw an error\n\t\t\"\"\"\n\t\tself.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n\tdef test_exponential_answer(self):\n\t\t\"\"\"\n\t\tTest for correct interpretation of scientific notation\n\t\t\"\"\"\n\t\tanswer = 50\n\t\tcorrect_responses = [\n\t\t\t\"50\", \"50.0\", \"5e1\", \"5e+1\",\n\t\t\t\"50e0\", \"50.0e0\", \"500e-1\"\n\t\t]\n\t\tincorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n\t\tfor input_str in correct_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\t\tfor input_str in incorrect_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to not equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertNotEqual(answer, result, msg=fail_msg)\n\n\tdef test_si_suffix(self):\n\t\t\"\"\"\n\t\tTest calc.py's unique functionality of interpreting si 'suffixes'.\n\n\t\tFor instance '%' stand for 1/100th so '1%' should be 0.01\n\t\t\"\"\"\n\t\ttest_mapping = [\n\t\t\t('4.2%', 0.042)\n\t\t]\n\n\t\tfor (expr, answer) in test_mapping:\n\t\t\ttolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n\t\t\tfail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n\t\t\tfail_msg = fail_msg.format(expr[-1], expr, answer)\n\t\t\tself.assertAlmostEqual(\n\t\t\t\tcalc.evaluator({}, {}, expr), answer,\n\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t)\n\n\tdef test_operator_sanity(self):\n\t\t\"\"\"\n\t\tTest for simple things like '5+2' and '5/2'\n\t\t\"\"\"\n\t\tvar1 = 5.0\n\t\tvar2 = 2.0\n\t\toperators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n\t\tfor (operator, answer) in operators:\n\t\t\tinput_str = \"{0} {1} {2}\".format(var1, operator, var2)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n\t\t\t\toperator, input_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\tdef test_raises_zero_division_err(self):\n\t\t\"\"\"\n\t\tEnsure division by zero gives an error\n\t\t\"\"\"\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0.0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({'x': 0.0}, {}, '1/x')\n\n\tdef test_parallel_resistors(self):\n\t\t\"\"\"\n\t\tTest the parallel resistor operator ||\n\n\t\tThe formula is given by\n\t\t\ta || b || c ...\n\t\t\t= 1 / (1/a + 1/b + 1/c + ...)\n\t\tIt is the resistance of a parallel circuit of resistors with resistance\n\t\ta, b, c, etc&. See if this evaulates correctly.\n\t\t\"\"\"\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n\t\tself.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n\tdef test_parallel_resistors_with_zero(self):\n\t\t\"\"\"\n\t\tCheck the behavior of the || operator with 0\n\t\t\"\"\"\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n\tdef assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n\t\t\"\"\"\n\t\tHelper function to test many values at once\n\n\t\tTest the accuracy of evaluator's use of the function given by fname\n\t\tSpecifically, the equality of `fname(ins[i])` against outs[i].\n\t\tThis is used later to test a whole bunch of f(x) = y at a time\n\t\t\"\"\"\n\n\t\tfor (arg, val) in zip(ins, outs):\n\t\t\tinput_str = \"{0}({1})\".format(fname, arg)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n\t\t\t\tfname, input_str, val\n\t\t\t)\n\t\t\tself.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n\tdef test_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the trig functions provided in calc.py\n\n\t\twhich are: sin, cos, tan, arccos, arcsin, arctan\n\t\t\"\"\"\n\n\t\tangles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n\t\tcos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n\t\ttan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n\t\t# Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n\t\tself.assert_function_values('sin', angles, sin_values)\n\t\tself.assert_function_values('cos', angles, cos_values)\n\t\tself.assert_function_values('tan', angles, tan_values)\n\n\t\t# Include those where the real part is between -pi/2 and pi/2\n\t\tarcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j', '-1.1', '1.1']\n\t\tarcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j, -1.570 + 0.443j, 1.570 - 0.443j]\n\t\tself.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n\n\t\t# Include those where the real part is between 0 and pi\n\t\tarccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j', '-1.1', '1.1']\n\t\tarccos_angles = [0, 0.524, 0.628, 1 + 1j, 3.141 - 0.443j, 0.443j]\n\t\tself.assert_function_values('arccos', arccos_inputs, arccos_angles)\n\n\t\t# Has the same range as arcsin\n\t\tarctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n\t\tarctan_angles = arcsin_angles\n\t\tself.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n\tdef test_reciprocal_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the reciprocal trig functions provided in calc.py\n\n\t\twhich are: sec, csc, cot, arcsec, arccsc, arccot\n\t\t\"\"\"\n\t\tangles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n\t\tcsc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n\t\tcot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n\t\tself.assert_function_values('sec', angles, sec_values)\n\t\tself.assert_function_values('csc', angles, csc_values)\n\t\tself.assert_function_values('cot', angles, cot_values)\n\n\t\tarcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n\t\tarcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n\t\tself.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n\t\tarccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n\t\tarccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n\t\tself.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n\t\t# Has the same range as arccsc\n\t\tarccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n\t\tarccot_angles = arccsc_angles\n\t\tself.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n\tdef test_hyperbolic_functions(self):\n\t\t\"\"\"\n\t\tTest the hyperbolic functions\n\n\t\twhich are: sinh, cosh, tanh, sech, csch, coth\n\t\t\"\"\"\n\t\tinputs = ['0', '0.5', '1', '2', '1+j']\n\t\tneg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n\t\tnegate = lambda x: [-k for k in x]\n\n\t\t# sinh is odd\n\t\tsinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n\t\tself.assert_function_values('sinh', inputs, sinh_vals)\n\t\tself.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n\t\t# cosh is even - do not negate\n\t\tcosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n\t\tself.assert_function_values('cosh', inputs, cosh_vals)\n\t\tself.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n\t\t# tanh is odd\n\t\ttanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n\t\tself.assert_function_values('tanh', inputs, tanh_vals)\n\t\tself.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n\t\t# sech is even - do not negate\n\t\tsech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n\t\tself.assert_function_values('sech', inputs, sech_vals)\n\t\tself.assert_function_values('sech', neg_inputs, sech_vals)\n\n\t\t# the following functions do not have 0 in their domain\n\t\tinputs = inputs[1:]\n\t\tneg_inputs = neg_inputs[1:]\n\n\t\t# csch is odd\n\t\tcsch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n\t\tself.assert_function_values('csch', inputs, csch_vals)\n\t\tself.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n\t\t# coth is odd\n\t\tcoth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n\t\tself.assert_function_values('coth', inputs, coth_vals)\n\t\tself.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n\tdef test_hyperbolic_inverses(self):\n\t\t\"\"\"\n\t\tTest the inverse hyperbolic functions\n\n\t\twhich are of the form arc[X]h\n\t\t\"\"\"\n\t\tresults = [0, 0.5, 1, 2, 1 + 1j]\n\n\t\tsinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n\t\tself.assert_function_values('arcsinh', sinh_vals, results)\n\n\t\tcosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n\t\tself.assert_function_values('arccosh', cosh_vals, results)\n\n\t\ttanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n\t\tself.assert_function_values('arctanh', tanh_vals, results)\n\n\t\tsech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n\t\tself.assert_function_values('arcsech', sech_vals, results)\n\n\t\tresults = results[1:]\n\t\tcsch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n\t\tself.assert_function_values('arccsch', csch_vals, results)\n\n\t\tcoth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n\t\tself.assert_function_values('arccoth', coth_vals, results)\n\n\tdef test_other_functions(self):\n\t\t\"\"\"\n\t\tTest the non-trig functions provided in calc.py\n\n\t\tSpecifically:\n\t\t  sqrt, log10, log2, ln, abs,\n\t\t  fact, factorial\n\t\t\"\"\"\n\n\t\t# Test sqrt\n\t\tself.assert_function_values(\n\t\t\t'sqrt',\n\t\t\t[0, 1, 2, 1024],  # -1\n\t\t\t[0, 1, 1.414, 32]  # 1j\n\t\t)\n\t\t# sqrt(-1) is NAN not j (!!).\n\n\t\t# Test logs\n\t\tself.assert_function_values(\n\t\t\t'log10',\n\t\t\t[0.1, 1, 3.162, 1000000, '1+j'],\n\t\t\t[-1, 0, 0.5, 6, 0.151 + 0.341j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'log2',\n\t\t\t[0.5, 1, 1.414, 1024, '1+j'],\n\t\t\t[-1, 0, 0.5, 10, 0.5 + 1.133j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'ln',\n\t\t\t[0.368, 1, 1.649, 2.718, 42, '1+j'],\n\t\t\t[-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n\t\t)\n\n\t\t# Test abs\n\t\tself.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n\t\t# Test factorial\n\t\tfact_inputs = [0, 1, 3, 7]\n\t\tfact_values = [1, 1, 6, 5040]\n\t\tself.assert_function_values('fact', fact_inputs, fact_values)\n\t\tself.assert_function_values('factorial', fact_inputs, fact_values)\n\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n\tdef test_constants(self):\n\t\t\"\"\"\n\t\tTest the default constants provided in calc.py\n\n\t\twhich are: j (complex number), e, pi\n\t\t\"\"\"\n\n\t\t# Of the form ('expr', python value, tolerance (or None for exact))\n\t\tdefault_variables = [\n\t\t\t('i', 1j, None),\n\t\t\t('j', 1j, None),\n\t\t\t('e', 2.7183, 1e-4),\n\t\t\t('pi', 3.1416, 1e-4),\n\t\t]\n\t\tfor (variable, value, tolerance) in default_variables:\n\t\t\tfail_msg = \"Failed on constant '{0}', not within bounds\".format(\n\t\t\t\tvariable\n\t\t\t)\n\t\t\tresult = calc.evaluator({}, {}, variable)\n\t\t\tif tolerance is None:\n\t\t\t\tself.assertEqual(value, result, msg=fail_msg)\n\t\t\telse:\n\t\t\t\tself.assertAlmostEqual(\n\t\t\t\t\tvalue, result,\n\t\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t\t)\n\n\tdef test_complex_expression(self):\n\t\t\"\"\"\n\t\tCalculate combinations of operators and default functions\n\t\t\"\"\"\n\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n\t\t\t10.180,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n\t\t\t1.6,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"10||sin(7+5)\"),\n\t\t\t-0.567, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"sin(e)\"),\n\t\t\t0.41, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"e^(j*pi)\"),\n\t\t\t-1, delta=1e-5\n\t\t)\n\n\tdef test_explicit_sci_notation(self):\n\t\t\"\"\"\n\t\tExpressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^-3\"),\n\t\t\t-0.0016\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n\t\t\t-0.0016\n\t\t)\n\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^3\"),\n\t\t\t-1600\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(3)\"),\n\t\t\t-1600\n\t\t)\n\n\tdef test_simple_vars(self):\n\t\t\"\"\"\n\t\tSubstitution of variables into simple equations\n\t\t\"\"\"\n\t\tvariables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4, \"f_0'\": 2.0, \"T_{ijk}^{123}''\": 5.2}\n\n\t\t# Should not change value of constant\n\t\t# even with different numbers of variables...\n\t\tself.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n\t\t# Easy evaluation\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"f_0'\"), 2.0)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"T_{ijk}^{123}''\"), 5.2)\n\n\t\t# Test a simple equation\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, '3*x-y'),\n\t\t\t21.25, delta=0.01  # = 3 * 9.72 - 7.91\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, 'x*y'),\n\t\t\t76.89, delta=0.01\n\t\t)\n\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(\n\t\t\t\t{'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n\t\t\t\t{}, \"5\"\n\t\t\t),\n\t\t\t5\n\t\t)\n\n\tdef test_variable_case_sensitivity(self):\n\t\t\"\"\"\n\t\tTest the case sensitivity flag and corresponding behavior\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n\t\t\t8.0\n\t\t)\n\n\t\tvariables = {'E': 1.0}\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(variables, {}, \"E\", case_sensitive=True),\n\t\t\t1.0\n\t\t)\n\t\t# Recall 'e' is a default constant, with value 2.718\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, \"e\", case_sensitive=True),\n\t\t\t2.718, delta=0.02\n\t\t)\n\n\tdef test_simple_funcs(self):\n\t\t\"\"\"\n\t\tSubsitution of custom functions\n\t\t\"\"\"\n\t\tvariables = {'x': 4.712}\n\t\tfunctions = {'id': lambda x: x}\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n\t\tfunctions.update({'f': numpy.sin})\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, functions, 'f(x)'),\n\t\t\t-1, delta=1e-3\n\t\t)\n\n\tdef test_function_case_insensitive(self):\n\t\t\"\"\"\n\t\tTest case insensitive evaluation\n\n\t\tNormal functions with some capitals should be fine\n\t\t\"\"\"\n\t\tself.assertAlmostEqual(\n\t\t\t-0.28,\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n\t\t\tdelta=1e-3\n\t\t)\n\n\tdef test_function_case_sensitive(self):\n\t\t\"\"\"\n\t\tTest case sensitive evaluation\n\n\t\tIncorrectly capitilized should fail\n\t\tAlso, it should pick the correct version of a function.\n\t\t\"\"\"\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n\t\t# With case sensitive turned on, it should pick the right function\n\t\tfunctions = {'f': lambda x: x, 'F': lambda x: x + 1}\n\t\tself.assertEqual(\n\t\t\t6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n\t\t)\n\t\tself.assertEqual(\n\t\t\t7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n\t\t)\n\n\tdef test_undefined_vars(self):\n\t\t\"\"\"\n\t\tCheck to see if the evaluator catches undefined variables\n\t\t\"\"\"\n\t\tvariables = {'R1': 2.0, 'R3': 4.0}\n\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n\t\t\tcalc.evaluator({}, {}, \"5+7*QWSEKO\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n\t\t\tcalc.evaluator({'r1': 5}, {}, \"r1+r2\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n\t\t\tcalc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n\n\tdef test_mismatched_parens(self):\n\t\t\"\"\"\n\t\tCheck to see if the evaluator catches mismatched parens\n\t\t\"\"\"\n\t\twith self.assertRaisesRegexp(calc.UnmatchedParenthesis, 'opened but never closed'):\n\t\t\tcalc.evaluator({}, {}, \"(1+2\")\n\t\twith self.assertRaisesRegexp(calc.UnmatchedParenthesis, 'no matching opening parenthesis'):\n\t\t\tcalc.evaluator({}, {}, \"(1+2))\")\n", "description": "\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t", "category": "math", "imports": ["import unittest", "import numpy", "import calc", "from pyparsing import ParseException"]}], [{"term": "class", "name": "Test", "data": "class Test(unittest.TestCase):\n\tdef test_bs(self):\n\t\tsb = StructureBuilder()\n\t\tatoms, *_ = sb.get_structure(\"C\", \"diamond\")\n\t\t# print(atoms)\n\t\tbase_dir = os.path.join(os.path.dirname(__file__),\n\t\t\t\t\t\t\t\t\"../../tmp/C-class/\")\n\t\tm_calc = MaterCalc(atoms=atoms,\n\t\t\t\t\t\t   base_dir=base_dir)\n\t\tself.assertTrue(m_calc.relax(fmax=0.002))  # Very tight limit!\n\t\tself.assertTrue(m_calc.ground_state())\n\t\t# get the PBE BS\n\t\tlattice_type = get_cellinfo(m_calc.atoms.cell).lattice\n\t\tself.assertTrue(lattice_type in special_paths.keys())\n\t\tkpts_bs = dict(path=special_paths[lattice_type],\n\t\t\t\t\t   npoints=120)\n\t\t# HSE06 base generate\n\t\tgs_file = os.path.join(base_dir, \"gs.gpw\")\n\t\t_calc = GPAW(restart=gs_file)\n\t\tatoms = _calc.atoms.copy()\n\t\tcalc = GPAW(**_calc.parameters)\n\t\tcalc.set(kpts=dict(gamma=True,\n\t\t\t\t\t\t   density=4))  # low density calculations\n\t\tcalc.atoms = atoms\n\t\tdel _calc\n\t\tcalc.get_potential_energy()\n\t\tcalc.write(os.path.join(base_dir, \"hse.gpw\"), mode=\"all\")\n\t\tcalc = GPAW(restart=os.path.join(base_dir, \"hse.gpw\"),\n\t\t\t\t\ttxt=None)\n\t\tns = calc.get_number_of_spins()\n\t\tnk = len(calc.get_ibz_k_points())\n\t\tnbands = calc.get_number_of_bands()\n\t\teigen_pbe = numpy.array([[calc.get_eigenvalues(spin=s,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   kpt=k) \\\n\t\t\t\t\t\t\t\t  for k in range(nk)]\\\n\t\t\t\t\t\t\t\t for s in range(ns)])\n\t\tparprint(\"EIGEN_PBE\", eigen_pbe.shape)\n\t\tvxc_pbe = vxc(calc, \"PBE\")\n\t\tparprint(\"VXC_PBE\", vxc_pbe.shape)\n\t\t# world.barrier()\n\t\t# HSE06 now\n\t\tcalc_hse = EXX(os.path.join(base_dir, \"hse.gpw\"),\n\t\t\t\t\t   xc=\"HSE06\",\n\t\t\t\t\t   bands=[0, nbands])\n\t\tcalc_hse.calculate()\n\t\tvxc_hse = calc_hse.get_eigenvalue_contributions()\n\t\tparprint(vxc_hse.shape)\n\t\tparprint(vxc_hse)\n\t\teigen_hse = eigen_pbe - vxc_pbe + vxc_hse\n\t\t\n\t\t# HSE bandgap from just kpts\n\t\tbg_hse_min, *_ = bandgap(eigenvalues=eigen_hse,\n\t\t\t\t\t\t\t\t efermi=calc.get_fermi_level(),\n\t\t\t\t\t\t\t\t direct=False)\n\t\tbg_hse_dir, *_ = bandgap(eigenvalues=eigen_hse,\n\t\t\t\t\t\t\t\t efermi=calc.get_fermi_level(),\n\t\t\t\t\t\t\t\t direct=True)\n\t\tparprint(\"HSE: E_min \\t E_dir\")\n\t\tparprint(\"{:.3f}\\t{:.3f}\".format(bg_hse_min, bg_hse_dir))\n\t\t\"\"\"\n\t\t# get the gllbsc by steps\n\t\tcalc_ = GPAW(restart=gpw_name)\n\t\tcalc_gllb = GPAW(**calc_.parameters)\n\t\tcalc_gllb.set(xc=\"GLLBSC\",\n\t\t\t\t\t  txt=os.path.join(base_dir, \"gllb-gs.txt\"))\n\t\tcalc_gllb.atoms = calc_.atoms\n\t\tdel calc_\n\t\tcalc_gllb.get_potential_energy()  # SC calculation\n\t\tcalc_gllb.write(\"gllb-gs.gpw\")\n\t\tcalc_gllb_bs = GPAW(restart=\"gllb-gs.gpw\",\n\t\t\t\t\t\t\tkpts=kpts_bs,\n\t\t\t\t\t\t\tfixdensity=True,\n\t\t\t\t\t\t\tsymmetry=\"off\",\n\t\t\t\t\t\t\ttxt=os.path.join(base_dir,\"gllb-bs.txt\"))\n\t\tworld.barrier()\n\t\tcalc_gllb_bs.get_potential_energy()\n\t\thomolumo = calc_gllb_bs.get_homo_lumo()\n\t\tbg_gllb_ks = homolumo[1] - homolumo[0]\n\t\tresponse = calc_gllb.hamiltonian.xc.xcs[\"RESPONSE\"]\n\t\tresponse.calculate_delta_xc( homolumo / Ha)\n\t\tEKs, Dxc = response.calculate_delta_xc_perturbation()\n\t\tbg_gllb_deltaxc = EKs + Dxc\n\n\t\tibz_kpts = calc_gllb_bs.get_ibz_k_points()\n\t\te_kn = numpy.array([calc_gllb_bs.get_eigenvalues(kpt=k) \\\n\t\t\t\t\t\t\tfor k in range(len(ibz_kpts))])\n\t\tefermi = calc_gllb_bs.get_fermi_level()\n\t\te_kn[e_kn > efermi] += Dxc\n\t\tbg_gllb_min, *_ = bandgap(eigenvalues=e_kn,\n\t\t\t\t\t\t\t   efermi=efermi,\n\t\t\t\t\t\t\t   direct=False)\n\t\tbg_gllb_dir, *_  = bandgap(eigenvalues=e_kn,\n\t\t\t\t\t\t\t   efermi=efermi,\n\t\t\t\t\t\t\t   direct=True)\n\n\t\tparprint(\"PBE: E_min \\t E_dir\")\n\t\tparprint(\"{:.3f}\\t{:.3f}\".format(bg_pbe_min, bg_pbe_dir))\n\t\tparprint(\"Gllb: EKS \\t E_deltaxc\")\n\t\tparprint(\"{:.3f}\\t{:.3f}\".format(bg_gllb_ks, bg_gllb_deltaxc))\n\t\tparprint(\"Gllb: E_min \\t E_dir\")\n\t\tparprint(\"{:.3f}\\t{:.3f}\".format(bg_gllb_min, bg_gllb_dir))\n\t\tbs_gllb = calc_gllb_bs.band_structure()\n\t\tbs_gllb.energies[bs_gllb.energies > bs_gllb.reference] += Dxc\n\t\tbs_gllb.plot(emin=-10, emax=10,\n\t\t\t\t\tfilename=os.path.join(base_dir, \"gllb-bs.png\"))\n\t\t\t\n\t\tcalc_gllb_bs.write(os.path.join(base_dir,\n\t\t\t\t\t\t\t\t\t\t\"gllb-bs.gpw\"))\n\t\t\"\"\"\n\n\t\n", "description": "\n\t\t# get the gllbsc by steps\n\t\tcalc_ = GPAW(restart=gpw_name)\n\t\tcalc_gllb = GPAW(**calc_.parameters)\n\t\tcalc_gllb.set(xc=\"GLLBSC\",\n\t\t\t\t\t  txt=os.path.join(base_dir, \"gllb-gs.txt\"))\n\t\tcalc_gllb.atoms = calc_.atoms\n\t\tdel calc_\n\t\tcalc_gllb.get_potential_energy()  # SC calculation\n\t\tcalc_gllb.write(\"gllb-gs.gpw\")\n\t\tcalc_gllb_bs = GPAW(restart=\"gllb-gs.gpw\",\n\t\t\t\t\t\t\tkpts=kpts_bs,\n\t\t\t\t\t\t\tfixdensity=True,\n\t\t\t\t\t\t\tsymmetry=\"off\",\n\t\t\t\t\t\t\ttxt=os.path.join(base_dir,\"gllb-bs.txt\"))\n\t\tworld.barrier()\n\t\tcalc_gllb_bs.get_potential_energy()\n\t\thomolumo = calc_gllb_bs.get_homo_lumo()\n\t\tbg_gllb_ks = homolumo[1] - homolumo[0]\n\t\tresponse = calc_gllb.hamiltonian.xc.xcs[\"RESPONSE\"]\n\t\tresponse.calculate_delta_xc( homolumo / Ha)\n\t\tEKs, Dxc = response.calculate_delta_xc_perturbation()\n\t\tbg_gllb_deltaxc = EKs + Dxc\n\n\t\tibz_kpts = calc_gllb_bs.get_ibz_k_points()\n\t\te_kn = numpy.array([calc_gllb_bs.get_eigenvalues(kpt=k) \\\n\t\t\t\t\t\t\tfor k in range(len(ibz_kpts))])\n\t\tefermi = calc_gllb_bs.get_fermi_level()\n\t\te_kn[e_kn > efermi] += Dxc\n\t\tbg_gllb_min, *_ = bandgap(eigenvalues=e_kn,\n\t\t\t\t\t\t\t   efermi=efermi,\n\t\t\t\t\t\t\t   direct=False)\n\t\tbg_gllb_dir, *_  = bandgap(eigenvalues=e_kn,\n\t\t\t\t\t\t\t   efermi=efermi,\n\t\t\t\t\t\t\t   direct=True)\n\n\t\tparprint(\"PBE: E_min \\t E_dir\")\n\t\tparprint(\"{:.3f}\\t{:.3f}\".format(bg_pbe_min, bg_pbe_dir))\n\t\tparprint(\"Gllb: EKS \\t E_deltaxc\")\n\t\tparprint(\"{:.3f}\\t{:.3f}\".format(bg_gllb_ks, bg_gllb_deltaxc))\n\t\tparprint(\"Gllb: E_min \\t E_dir\")\n\t\tparprint(\"{:.3f}\\t{:.3f}\".format(bg_gllb_min, bg_gllb_dir))\n\t\tbs_gllb = calc_gllb_bs.band_structure()\n\t\tbs_gllb.energies[bs_gllb.energies > bs_gllb.reference] += Dxc\n\t\tbs_gllb.plot(emin=-10, emax=10,\n\t\t\t\t\tfilename=os.path.join(base_dir, \"gllb-bs.png\"))\n\t\t\t\n\t\tcalc_gllb_bs.write(os.path.join(base_dir,\n\t\t\t\t\t\t\t\t\t\t\"gllb-bs.gpw\"))\n\t\t", "category": "math", "imports": ["import sys", "import os", "#However cannot use this for module importing", "import numpy", "from bulk.build import StructureBuilder", "from bulk.calc import MaterCalc", "import unittest", "from bulk.build import StructureBuilder", "from ase.parallel import parprint, world", "from ase.dft.bandgap import bandgap", "from ase.dft.kpoints import special_paths, get_cellinfo", "from ase.units import Ha", "from gpaw import GPAW, PW, FermiDirac", "from gpaw.xc.exx import EXX", "from gpaw.xc.tools import vxc"]}], [{"term": "def", "name": "weight_fun", "data": "def weight_fun(x, a, b, c):\n\treturn a + b * np.cos(x) + c * np.sin(x)\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calc_weights", "data": "def calc_weights(num_classes, coeffs):\n\tk2PI = 2* np.pi\n\tx = np.linspace(0, k2PI, num_classes)\n\tdata_len = coeffs.shape[0]\n\tweights = np.zeros((data_len, num_classes))\n\tfor i in range(data_len):\n\t\tweights[i] = weight_fun(x, *coeffs[i])\n\treturn weights\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calc_argmaxs_distances", "data": "def calc_argmaxs_distances(pred_arg_maxs, calc_arg_maxs, num_class):\n\treturn calculate_deltas_signed(calc_arg_maxs, pred_arg_maxs, num_class)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics_from_file", "data": "def calculate_metrics_from_file(directory, num_classes):\n\tcalc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n\tpreds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n\treturn calculate_metrics(calc_w, preds_w, num_classes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics", "data": "def calculate_metrics(calc_w, preds_w, num_classes):\n\tpred_arg_maxs = np.argmax(preds_w, axis=1)\n\tcalc_arg_maxs = np.argmax(calc_w, axis=1)\n\n\tk2PI = 2 * np.pi\n\tcalc_pred_argmaxs_abs_distances = calculate_deltas_unsigned( pred_arg_maxs, calc_arg_maxs, num_classes)\n\tcalc_pred_argmaxs_signed_distances = calculate_deltas_signed(pred_arg_maxs, calc_arg_maxs, num_classes)\n\tcalc_pred_argmaxs_abs_distances_rad = calc_pred_argmaxs_abs_distances * k2PI/(1.0*num_classes)\n\t\n\tmean_deltas = np.mean(calc_pred_argmaxs_signed_distances, dtype=np.float64)\n\tmean_deltas_err = stats.sem(calc_pred_argmaxs_signed_distances)\n\tmean_deltas_rad = mean_deltas * k2PI/(1.0*num_classes)\n\tmean_deltas_err_rad = mean_deltas_err * k2PI/(1.0*num_classes)\n\n\tacc0 = (calc_pred_argmaxs_abs_distances <= 0).mean()\n\tacc1 = (calc_pred_argmaxs_abs_distances <= 1).mean()\n\tacc2 = (calc_pred_argmaxs_abs_distances <= 2).mean()\n\tacc3 = (calc_pred_argmaxs_abs_distances <= 3).mean()\n\n\tacc0_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.25).mean()\n\tacc1_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.50).mean()\n\tacc2_rad = (calc_pred_argmaxs_abs_distances_rad <= 0.75).mean()\n\tacc3_rad = (calc_pred_argmaxs_abs_distances_rad <= 1.00).mean()\n\n\tl1_delta_w = np.mean(np.abs(calc_w - preds_w), dtype=np.float64)\n\tl2_delta_w = np.sqrt(np.mean((calc_w - preds_w)**2), dtype=np.float64)\n\t# problem with format, should not be array\n\tl2_delta_w_err = stats.sem((calc_w - preds_w)**2)\n\n\t# calc_w, preds_w normalisation to probability\n\tcalc_w_norm = calc_w / np.sum(calc_w, axis=1)[:, np.newaxis]\n\tpreds_w_norm = preds_w / np.sum(preds_w, axis=1)[:, np.newaxis]\n \n\tl1_delta_w_norm = np.mean(np.abs(calc_w_norm - preds_w_norm), dtype=np.float64)\n\tl2_delta_w_norm = np.sqrt(np.mean((calc_w_norm - preds_w_norm)**2), dtype=np.float64)\n\t# problem with format, should not be array\n\tl2_delta_w_norm_err = stats.sem((calc_w_norm - preds_w_norm)**2)\n  \n\t\n\treturn np.array([acc0, acc1, acc2, acc3, mean_deltas, l1_delta_w, l2_delta_w, mean_deltas_rad, acc0_rad, acc1_rad, acc2_rad, acc3_rad,l1_delta_w_norm, l2_delta_w_norm, mean_deltas_err, mean_deltas_err_rad, l2_delta_w_err, l2_delta_w_norm_err ]) \n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics_regr_c012s_from_file", "data": "def calculate_metrics_regr_c012s_from_file(directory, num_classes):\n\tcalc_c012s = np.load(os.path.join(directory,'test_regr_calc_c012s.npy'))\n\tpred_c012s = np.load(os.path.join(directory,'test_regr_preds_c012s.npy'))\n\n\treturn calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_metrics_regr_c012s", "data": "def calculate_metrics_regr_c012s(calc_c012s, pred_c012s, num_classes):\n\tcalc_w  = calc_weights(num_classes, calc_c012s)\n\tpreds_w = calc_weights(num_classes, pred_c012s)\n\n\treturn calculate_metrics(calc_w, preds_w, num_classes)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "get_filename_for_class", "data": "def get_filename_for_class(pathIN, class_num, subset=None):\n\td = '../monit_npy/nn_rhorho_Variant-All_Unweighted_False_NO_NUM_CLASSES_{class_num}'\n\tif subset:\n\t\td += \"_WEIGHTS_SUBS\" + str(subset)\n\treturn d\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "evaluate_roc_auc", "data": "def evaluate_roc_auc(preds, wa, wb):\n\tn = len(preds)\n\ttrue_labels = np.concatenate([np.ones(n), np.zeros(n)])\n\tpreds = np.concatenate([preds, preds])\n\tweights = np.concatenate([wa, wb])\n\t\n\treturn roc_auc_score(true_labels, preds, sample_weight=weights)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "calculate_roc_auc", "data": "def calculate_roc_auc(preds_w, calc_w, index_a, index_b):\n\tn, num_classes = calc_w.shape\n\ttrue_labels = np.concatenate([np.ones(n), np.zeros(n)])\n\tpreds = np.concatenate([preds_w[:, index_a], preds_w[:, index_a]])\n\tweights = np.concatenate([calc_w[:, index_a], calc_w[:, index_b]])\n\n\treturn roc_auc_score(true_labels, preds, sample_weight=weights)\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}, {"term": "def", "name": "test_roc_auc", "data": "def test_roc_auc(directory, num_class):\n\tcalc_w = np.load(os.path.join(directory, 'softmax_calc_w.npy'))\n\tpreds_w = np.load(os.path.join(directory, 'softmax_preds_w.npy'))\n\t\n\toracle_roc_auc = []\n\tpreds_roc_auc  = []\n\t\n\tfor i in range(0, num_class):\n\t\t oracle_roc_auc  += [calculate_roc_auc(calc_w, calc_w, 0, i)]\n\t\t preds_roc_auc   += [calculate_roc_auc(preds_w, calc_w, 0, i)]\n\t\t print(i,\n\t\t\t\t  'oracle_roc_auc: {}'.format(calculate_roc_auc(calc_w, calc_w, 0, i)),\n\t\t\t\t  'preds_roc_auc: {}'.format(calculate_roc_auc(preds_w, calc_w, 0, i)))\n\n\treturn oracle_roc_auc, preds_roc_auc\n", "description": null, "category": "math", "imports": ["import numpy as np", "import os", "from scipy import stats", "from sklearn.metrics import roc_auc_score", "from src_py.metrics_utils import calculate_deltas_unsigned, calculate_deltas_signed"]}], [{"term": "class", "name": "EvaluatorTest", "data": "class EvaluatorTest(unittest.TestCase):\n\t\"\"\"\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t\"\"\"\n\n\tdef test_number_input(self):\n\t\t\"\"\"\n\t\tTest different kinds of float inputs\n\n\t\tSee also\n\t\t  test_trailing_period (slightly different)\n\t\t  test_exponential_answer\n\t\t  test_si_suffix\n\t\t\"\"\"\n\t\teasy_eval = lambda x: calc.evaluator({}, {}, x)\n\n\t\tself.assertEqual(easy_eval(\"13\"), 13)\n\t\tself.assertEqual(easy_eval(\"3.14\"), 3.14)\n\t\tself.assertEqual(easy_eval(\".618033989\"), 0.618033989)\n\n\t\tself.assertEqual(easy_eval(\"-13\"), -13)\n\t\tself.assertEqual(easy_eval(\"-3.14\"), -3.14)\n\t\tself.assertEqual(easy_eval(\"-.618033989\"), -0.618033989)\n\n\tdef test_period(self):\n\t\t\"\"\"\n\t\tThe string '.' should not evaluate to anything.\n\t\t\"\"\"\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '.')\n\t\twith self.assertRaises(ParseException):\n\t\t\tcalc.evaluator({}, {}, '1+.')\n\n\tdef test_trailing_period(self):\n\t\t\"\"\"\n\t\tTest that things like '4.' will be 4 and not throw an error\n\t\t\"\"\"\n\t\tself.assertEqual(4.0, calc.evaluator({}, {}, '4.'))\n\n\tdef test_exponential_answer(self):\n\t\t\"\"\"\n\t\tTest for correct interpretation of scientific notation\n\t\t\"\"\"\n\t\tanswer = 50\n\t\tcorrect_responses = [\n\t\t\t\"50\", \"50.0\", \"5e1\", \"5e+1\",\n\t\t\t\"50e0\", \"50.0e0\", \"500e-1\"\n\t\t]\n\t\tincorrect_responses = [\"\", \"3.9\", \"4.1\", \"0\", \"5.01e1\"]\n\n\t\tfor input_str in correct_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\t\tfor input_str in incorrect_responses:\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Expected '{0}' to not equal {1}\".format(\n\t\t\t\tinput_str, answer\n\t\t\t)\n\t\t\tself.assertNotEqual(answer, result, msg=fail_msg)\n\n\tdef test_si_suffix(self):\n\t\t\"\"\"\n\t\tTest calc.py's unique functionality of interpreting si 'suffixes'.\n\n\t\tFor instance 'k' stand for 'kilo-' so '1k' should be 1,000\n\t\t\"\"\"\n\t\ttest_mapping = [\n\t\t\t('4.2%', 0.042), ('2.25k', 2250), ('8.3M', 8300000),\n\t\t\t('9.9G', 9.9e9), ('1.2T', 1.2e12), ('7.4c', 0.074),\n\t\t\t('5.4m', 0.0054), ('8.7u', 0.0000087),\n\t\t\t('5.6n', 5.6e-9), ('4.2p', 4.2e-12)\n\t\t]\n\n\t\tfor (expr, answer) in test_mapping:\n\t\t\ttolerance = answer * 1e-6  # Make rel. tolerance, because of floats\n\t\t\tfail_msg = \"Failure in testing suffix '{0}': '{1}' was not {2}\"\n\t\t\tfail_msg = fail_msg.format(expr[-1], expr, answer)\n\t\t\tself.assertAlmostEqual(\n\t\t\t\tcalc.evaluator({}, {}, expr), answer,\n\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t)\n\n\tdef test_operator_sanity(self):\n\t\t\"\"\"\n\t\tTest for simple things like '5+2' and '5/2'\n\t\t\"\"\"\n\t\tvar1 = 5.0\n\t\tvar2 = 2.0\n\t\toperators = [('+', 7), ('-', 3), ('*', 10), ('/', 2.5), ('^', 25)]\n\n\t\tfor (operator, answer) in operators:\n\t\t\tinput_str = \"{0} {1} {2}\".format(var1, operator, var2)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on operator '{0}': '{1}' was not {2}\".format(\n\t\t\t\toperator, input_str, answer\n\t\t\t)\n\t\t\tself.assertEqual(answer, result, msg=fail_msg)\n\n\tdef test_raises_zero_division_err(self):\n\t\t\"\"\"\n\t\tEnsure division by zero gives an error\n\t\t\"\"\"\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({}, {}, '1/0.0')\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tcalc.evaluator({'x': 0.0}, {}, '1/x')\n\n\tdef test_parallel_resistors(self):\n\t\t\"\"\"\n\t\tTest the parallel resistor operator ||\n\n\t\tThe formula is given by\n\t\t\ta || b || c ...\n\t\t\t= 1 / (1/a + 1/b + 1/c + ...)\n\t\tIt is the resistance of a parallel circuit of resistors with resistance\n\t\ta, b, c, etc&. See if this evaulates correctly.\n\t\t\"\"\"\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1'), 0.5)\n\t\tself.assertEqual(calc.evaluator({}, {}, '1||1||2'), 0.4)\n\t\tself.assertEqual(calc.evaluator({}, {}, \"j||1\"), 0.5 + 0.5j)\n\n\tdef test_parallel_resistors_with_zero(self):\n\t\t\"\"\"\n\t\tCheck the behavior of the || operator with 0\n\t\t\"\"\"\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, '0.0||1')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({'x': 0.0}, {}, 'x||1')))\n\n\tdef assert_function_values(self, fname, ins, outs, tolerance=1e-3):\n\t\t\"\"\"\n\t\tHelper function to test many values at once\n\n\t\tTest the accuracy of evaluator's use of the function given by fname\n\t\tSpecifically, the equality of `fname(ins[i])` against outs[i].\n\t\tThis is used later to test a whole bunch of f(x) = y at a time\n\t\t\"\"\"\n\n\t\tfor (arg, val) in zip(ins, outs):\n\t\t\tinput_str = \"{0}({1})\".format(fname, arg)\n\t\t\tresult = calc.evaluator({}, {}, input_str)\n\t\t\tfail_msg = \"Failed on function {0}: '{1}' was not {2}\".format(\n\t\t\t\tfname, input_str, val\n\t\t\t)\n\t\t\tself.assertAlmostEqual(val, result, delta=tolerance, msg=fail_msg)\n\n\tdef test_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the trig functions provided in calc.py\n\n\t\twhich are: sin, cos, tan, arccos, arcsin, arctan\n\t\t\"\"\"\n\n\t\tangles = ['-pi/4', '0', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsin_values = [-0.707, 0, 0.5, 0.588, -0.707, 0.707, 1.298 + 0.635j]\n\t\tcos_values = [0.707, 1, 0.866, 0.809, -0.707, 0.707, 0.834 - 0.989j]\n\t\ttan_values = [-1, 0, 0.577, 0.727, 1, 1, 0.272 + 1.084j]\n\t\t# Cannot test tan(pi/2) b/c pi/2 is a float and not precise...\n\n\t\tself.assert_function_values('sin', angles, sin_values)\n\t\tself.assert_function_values('cos', angles, cos_values)\n\t\tself.assert_function_values('tan', angles, tan_values)\n\n\t\t# Include those where the real part is between -pi/2 and pi/2\n\t\tarcsin_inputs = ['-0.707', '0', '0.5', '0.588', '1.298 + 0.635*j']\n\t\tarcsin_angles = [-0.785, 0, 0.524, 0.629, 1 + 1j]\n\t\tself.assert_function_values('arcsin', arcsin_inputs, arcsin_angles)\n\t\t# Rather than a complex number, numpy.arcsin gives nan\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arcsin(1.1)')))\n\n\t\t# Include those where the real part is between 0 and pi\n\t\tarccos_inputs = ['1', '0.866', '0.809', '0.834-0.989*j']\n\t\tarccos_angles = [0, 0.524, 0.628, 1 + 1j]\n\t\tself.assert_function_values('arccos', arccos_inputs, arccos_angles)\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(-1.1)')))\n\t\tself.assertTrue(numpy.isnan(calc.evaluator({}, {}, 'arccos(1.1)')))\n\n\t\t# Has the same range as arcsin\n\t\tarctan_inputs = ['-1', '0', '0.577', '0.727', '0.272 + 1.084*j']\n\t\tarctan_angles = arcsin_angles\n\t\tself.assert_function_values('arctan', arctan_inputs, arctan_angles)\n\n\tdef test_reciprocal_trig_functions(self):\n\t\t\"\"\"\n\t\tTest the reciprocal trig functions provided in calc.py\n\n\t\twhich are: sec, csc, cot, arcsec, arccsc, arccot\n\t\t\"\"\"\n\t\tangles = ['-pi/4', 'pi/6', 'pi/5', '5*pi/4', '9*pi/4', '1 + j']\n\t\tsec_values = [1.414, 1.155, 1.236, -1.414, 1.414, 0.498 + 0.591j]\n\t\tcsc_values = [-1.414, 2, 1.701, -1.414, 1.414, 0.622 - 0.304j]\n\t\tcot_values = [-1, 1.732, 1.376, 1, 1, 0.218 - 0.868j]\n\n\t\tself.assert_function_values('sec', angles, sec_values)\n\t\tself.assert_function_values('csc', angles, csc_values)\n\t\tself.assert_function_values('cot', angles, cot_values)\n\n\t\tarcsec_inputs = ['1.1547', '1.2361', '2', '-2', '-1.4142', '0.4983+0.5911*j']\n\t\tarcsec_angles = [0.524, 0.628, 1.047, 2.094, 2.356, 1 + 1j]\n\t\tself.assert_function_values('arcsec', arcsec_inputs, arcsec_angles)\n\n\t\tarccsc_inputs = ['-1.1547', '-1.4142', '2', '1.7013', '1.1547', '0.6215-0.3039*j']\n\t\tarccsc_angles = [-1.047, -0.785, 0.524, 0.628, 1.047, 1 + 1j]\n\t\tself.assert_function_values('arccsc', arccsc_inputs, arccsc_angles)\n\n\t\t# Has the same range as arccsc\n\t\tarccot_inputs = ['-0.5774', '-1', '1.7321', '1.3764', '0.5774', '(0.2176-0.868*j)']\n\t\tarccot_angles = arccsc_angles\n\t\tself.assert_function_values('arccot', arccot_inputs, arccot_angles)\n\n\tdef test_hyperbolic_functions(self):\n\t\t\"\"\"\n\t\tTest the hyperbolic functions\n\n\t\twhich are: sinh, cosh, tanh, sech, csch, coth\n\t\t\"\"\"\n\t\tinputs = ['0', '0.5', '1', '2', '1+j']\n\t\tneg_inputs = ['0', '-0.5', '-1', '-2', '-1-j']\n\t\tnegate = lambda x: [-k for k in x]\n\n\t\t# sinh is odd\n\t\tsinh_vals = [0, 0.521, 1.175, 3.627, 0.635 + 1.298j]\n\t\tself.assert_function_values('sinh', inputs, sinh_vals)\n\t\tself.assert_function_values('sinh', neg_inputs, negate(sinh_vals))\n\n\t\t# cosh is even - do not negate\n\t\tcosh_vals = [1, 1.128, 1.543, 3.762, 0.834 + 0.989j]\n\t\tself.assert_function_values('cosh', inputs, cosh_vals)\n\t\tself.assert_function_values('cosh', neg_inputs, cosh_vals)\n\n\t\t# tanh is odd\n\t\ttanh_vals = [0, 0.462, 0.762, 0.964, 1.084 + 0.272j]\n\t\tself.assert_function_values('tanh', inputs, tanh_vals)\n\t\tself.assert_function_values('tanh', neg_inputs, negate(tanh_vals))\n\n\t\t# sech is even - do not negate\n\t\tsech_vals = [1, 0.887, 0.648, 0.266, 0.498 - 0.591j]\n\t\tself.assert_function_values('sech', inputs, sech_vals)\n\t\tself.assert_function_values('sech', neg_inputs, sech_vals)\n\n\t\t# the following functions do not have 0 in their domain\n\t\tinputs = inputs[1:]\n\t\tneg_inputs = neg_inputs[1:]\n\n\t\t# csch is odd\n\t\tcsch_vals = [1.919, 0.851, 0.276, 0.304 - 0.622j]\n\t\tself.assert_function_values('csch', inputs, csch_vals)\n\t\tself.assert_function_values('csch', neg_inputs, negate(csch_vals))\n\n\t\t# coth is odd\n\t\tcoth_vals = [2.164, 1.313, 1.037, 0.868 - 0.218j]\n\t\tself.assert_function_values('coth', inputs, coth_vals)\n\t\tself.assert_function_values('coth', neg_inputs, negate(coth_vals))\n\n\tdef test_hyperbolic_inverses(self):\n\t\t\"\"\"\n\t\tTest the inverse hyperbolic functions\n\n\t\twhich are of the form arc[X]h\n\t\t\"\"\"\n\t\tresults = [0, 0.5, 1, 2, 1 + 1j]\n\n\t\tsinh_vals = ['0', '0.5211', '1.1752', '3.6269', '0.635+1.2985*j']\n\t\tself.assert_function_values('arcsinh', sinh_vals, results)\n\n\t\tcosh_vals = ['1', '1.1276', '1.5431', '3.7622', '0.8337+0.9889*j']\n\t\tself.assert_function_values('arccosh', cosh_vals, results)\n\n\t\ttanh_vals = ['0', '0.4621', '0.7616', '0.964', '1.0839+0.2718*j']\n\t\tself.assert_function_values('arctanh', tanh_vals, results)\n\n\t\tsech_vals = ['1.0', '0.8868', '0.6481', '0.2658', '0.4983-0.5911*j']\n\t\tself.assert_function_values('arcsech', sech_vals, results)\n\n\t\tresults = results[1:]\n\t\tcsch_vals = ['1.919', '0.8509', '0.2757', '0.3039-0.6215*j']\n\t\tself.assert_function_values('arccsch', csch_vals, results)\n\n\t\tcoth_vals = ['2.164', '1.313', '1.0373', '0.868-0.2176*j']\n\t\tself.assert_function_values('arccoth', coth_vals, results)\n\n\tdef test_other_functions(self):\n\t\t\"\"\"\n\t\tTest the non-trig functions provided in calc.py\n\n\t\tSpecifically:\n\t\t  sqrt, log10, log2, ln, abs,\n\t\t  fact, factorial\n\t\t\"\"\"\n\n\t\t# Test sqrt\n\t\tself.assert_function_values(\n\t\t\t'sqrt',\n\t\t\t[0, 1, 2, 1024],  # -1\n\t\t\t[0, 1, 1.414, 32]  # 1j\n\t\t)\n\t\t# sqrt(-1) is NAN not j (!!).\n\n\t\t# Test logs\n\t\tself.assert_function_values(\n\t\t\t'log10',\n\t\t\t[0.1, 1, 3.162, 1000000, '1+j'],\n\t\t\t[-1, 0, 0.5, 6, 0.151 + 0.341j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'log2',\n\t\t\t[0.5, 1, 1.414, 1024, '1+j'],\n\t\t\t[-1, 0, 0.5, 10, 0.5 + 1.133j]\n\t\t)\n\t\tself.assert_function_values(\n\t\t\t'ln',\n\t\t\t[0.368, 1, 1.649, 2.718, 42, '1+j'],\n\t\t\t[-1, 0, 0.5, 1, 3.738, 0.347 + 0.785j]\n\t\t)\n\n\t\t# Test abs\n\t\tself.assert_function_values('abs', [-1, 0, 1, 'j'], [1, 0, 1, 1])\n\n\t\t# Test factorial\n\t\tfact_inputs = [0, 1, 3, 7]\n\t\tfact_values = [1, 1, 6, 5040]\n\t\tself.assert_function_values('fact', fact_inputs, fact_values)\n\t\tself.assert_function_values('factorial', fact_inputs, fact_values)\n\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"fact(0.5)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(-1)\")\n\t\tself.assertRaises(ValueError, calc.evaluator, {}, {}, \"factorial(0.5)\")\n\n\tdef test_constants(self):\n\t\t\"\"\"\n\t\tTest the default constants provided in calc.py\n\n\t\twhich are: j (complex number), e, pi, k, c, T, q\n\t\t\"\"\"\n\n\t\t# Of the form ('expr', python value, tolerance (or None for exact))\n\t\tdefault_variables = [\n\t\t\t('i', 1j, None),\n\t\t\t('j', 1j, None),\n\t\t\t('e', 2.7183, 1e-4),\n\t\t\t('pi', 3.1416, 1e-4),\n\t\t\t('k', 1.3806488e-23, 1e-26),  # Boltzmann constant (Joules/Kelvin)\n\t\t\t('c', 2.998e8, 1e5),  # Light Speed in (m/s)\n\t\t\t('T', 298.15, 0.01),  # Typical room temperature (Kelvin)\n\t\t\t('q', 1.602176565e-19, 1e-22)  # Fund. Charge (Coulombs)\n\t\t]\n\t\tfor (variable, value, tolerance) in default_variables:\n\t\t\tfail_msg = \"Failed on constant '{0}', not within bounds\".format(\n\t\t\t\tvariable\n\t\t\t)\n\t\t\tresult = calc.evaluator({}, {}, variable)\n\t\t\tif tolerance is None:\n\t\t\t\tself.assertEqual(value, result, msg=fail_msg)\n\t\t\telse:\n\t\t\t\tself.assertAlmostEqual(\n\t\t\t\t\tvalue, result,\n\t\t\t\t\tdelta=tolerance, msg=fail_msg\n\t\t\t\t)\n\n\tdef test_complex_expression(self):\n\t\t\"\"\"\n\t\tCalculate combinations of operators and default functions\n\t\t\"\"\"\n\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"(2^2+1.0)/sqrt(5e0)*5-1\"),\n\t\t\t10.180,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"1+1/(1+1/(1+1/(1+1)))\"),\n\t\t\t1.6,\n\t\t\tdelta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"10||sin(7+5)\"),\n\t\t\t-0.567, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"sin(e)\"),\n\t\t\t0.41, delta=0.01\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"k*T/q\"),\n\t\t\t0.025, delta=1e-3\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator({}, {}, \"e^(j*pi)\"),\n\t\t\t-1, delta=1e-5\n\t\t)\n\n\tdef test_explicit_sci_notation(self):\n\t\t\"\"\"\n\t\tExpressions like 1.6*10^-3 (not 1.6e-3) it should evaluate.\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^-3\"),\n\t\t\t-0.0016\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(-3)\"),\n\t\t\t-0.0016\n\t\t)\n\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^3\"),\n\t\t\t-1600\n\t\t)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({}, {}, \"-1.6*10^(3)\"),\n\t\t\t-1600\n\t\t)\n\n\tdef test_simple_vars(self):\n\t\t\"\"\"\n\t\tSubstitution of variables into simple equations\n\t\t\"\"\"\n\t\tvariables = {'x': 9.72, 'y': 7.91, 'loooooong': 6.4}\n\n\t\t# Should not change value of constant\n\t\t# even with different numbers of variables...\n\t\tself.assertEqual(calc.evaluator({'x': 9.72}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, '13'), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, '13'), 13)\n\n\t\t# Easy evaluation\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'x'), 9.72)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'y'), 7.91)\n\t\tself.assertEqual(calc.evaluator(variables, {}, 'loooooong'), 6.4)\n\n\t\t# Test a simple equation\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, '3*x-y'),\n\t\t\t21.25, delta=0.01  # = 3 * 9.72 - 7.91\n\t\t)\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, 'x*y'),\n\t\t\t76.89, delta=0.01\n\t\t)\n\n\t\tself.assertEqual(calc.evaluator({'x': 9.72, 'y': 7.91}, {}, \"13\"), 13)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"13\"), 13)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(\n\t\t\t\t{'a': 2.2997471478310274, 'k': 9, 'm': 8, 'x': 0.6600949841121},\n\t\t\t\t{}, \"5\"\n\t\t\t),\n\t\t\t5\n\t\t)\n\n\tdef test_variable_case_sensitivity(self):\n\t\t\"\"\"\n\t\tTest the case sensitivity flag and corresponding behavior\n\t\t\"\"\"\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator({'R1': 2.0, 'R3': 4.0}, {}, \"r1*r3\"),\n\t\t\t8.0\n\t\t)\n\n\t\tvariables = {'t': 1.0}\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"t\"), 1.0)\n\t\tself.assertEqual(calc.evaluator(variables, {}, \"T\"), 1.0)\n\t\tself.assertEqual(\n\t\t\tcalc.evaluator(variables, {}, \"t\", case_sensitive=True),\n\t\t\t1.0\n\t\t)\n\t\t# Recall 'T' is a default constant, with value 298.15\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, {}, \"T\", case_sensitive=True),\n\t\t\t298, delta=0.2\n\t\t)\n\n\tdef test_simple_funcs(self):\n\t\t\"\"\"\n\t\tSubsitution of custom functions\n\t\t\"\"\"\n\t\tvariables = {'x': 4.712}\n\t\tfunctions = {'id': lambda x: x}\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator({}, functions, 'id(2.81)'), 2.81)\n\t\tself.assertEqual(calc.evaluator(variables, functions, 'id(x)'), 4.712)\n\n\t\tfunctions.update({'f': numpy.sin})\n\t\tself.assertAlmostEqual(\n\t\t\tcalc.evaluator(variables, functions, 'f(x)'),\n\t\t\t-1, delta=1e-3\n\t\t)\n\n\tdef test_function_case_insensitive(self):\n\t\t\"\"\"\n\t\tTest case insensitive evaluation\n\n\t\tNormal functions with some capitals should be fine\n\t\t\"\"\"\n\t\tself.assertAlmostEqual(\n\t\t\t-0.28,\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=False),\n\t\t\tdelta=1e-3\n\t\t)\n\n\tdef test_function_case_sensitive(self):\n\t\t\"\"\"\n\t\tTest case sensitive evaluation\n\n\t\tIncorrectly capitilized should fail\n\t\tAlso, it should pick the correct version of a function.\n\t\t\"\"\"\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'SiN'):\n\t\t\tcalc.evaluator({}, {}, 'SiN(6)', case_sensitive=True)\n\n\t\t# With case sensitive turned on, it should pick the right function\n\t\tfunctions = {'f': lambda x: x, 'F': lambda x: x + 1}\n\t\tself.assertEqual(\n\t\t\t6, calc.evaluator({}, functions, 'f(6)', case_sensitive=True)\n\t\t)\n\t\tself.assertEqual(\n\t\t\t7, calc.evaluator({}, functions, 'F(6)', case_sensitive=True)\n\t\t)\n\n\tdef test_undefined_vars(self):\n\t\t\"\"\"\n\t\tCheck to see if the evaluator catches undefined variables\n\t\t\"\"\"\n\t\tvariables = {'R1': 2.0, 'R3': 4.0}\n\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'QWSEKO'):\n\t\t\tcalc.evaluator({}, {}, \"5+7*QWSEKO\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r2'):\n\t\t\tcalc.evaluator({'r1': 5}, {}, \"r1+r2\")\n\t\twith self.assertRaisesRegexp(calc.UndefinedVariable, 'r1 r3'):\n\t\t\tcalc.evaluator(variables, {}, \"r1*r3\", case_sensitive=True)\n", "description": "\n\tRun tests for calc.evaluator\n\tGo through all functionalities as specifically as possible--\n\twork from number input to functions and complex expressions\n\tAlso test custom variable substitutions (i.e.\n\t  `evaluator({'x':3.0}, {}, '3*x')`\n\tgives 9.0) and more.\n\t", "category": "math", "imports": ["import unittest", "import numpy", "import calc", "from pyparsing import ParseException"]}], [{"term": "def", "name": "calc", "data": "def calc(operation, x, y):\n\toperations = {\n\t\t'+': lambda a, b: a + b,\n\t\t'-': lambda a, b: a - b,\n\t\t'*': lambda a, b: a * b,\n\t\t'/': lambda a, b: a / b,\n\t}\n\treturn False if operation == '/' and y == 0 else operations[operation](x, y)\n\n", "description": null, "category": "math", "imports": []}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow.compat.v1 as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "class", "name": "RegionSimilarityCalculatorBuilderTest", "data": "class RegionSimilarityCalculatorBuilderTest(tf.test.TestCase):\n", "description": null, "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIoaSimilarityCalculator", "data": "  def testBuildIoaSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  ioa_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IoaSimilarity))\n", "description": "\n\t  ioa_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildIouSimilarityCalculator", "data": "  def testBuildIouSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  iou_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.IouSimilarity))\n", "description": "\n\t  iou_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}, {"term": "def", "name": "testBuildNegSqDistSimilarityCalculator", "data": "  def testBuildNegSqDistSimilarityCalculator(self):\n\tsimilarity_calc_text_proto = \"\"\"\n\t  neg_sq_dist_similarity {\n\t  }\n\t\"\"\"\n\tsimilarity_calc_proto = sim_calc_pb2.RegionSimilarityCalculator()\n\ttext_format.Merge(similarity_calc_text_proto, similarity_calc_proto)\n\tsimilarity_calc = region_similarity_calculator_builder.build(\n\t\tsimilarity_calc_proto)\n\tself.assertTrue(isinstance(similarity_calc,\n\t\t\t\t\t\t\t   region_similarity_calculator.\n\t\t\t\t\t\t\t   NegSqDistSimilarity))\n\n", "description": "\n\t  neg_sq_dist_similarity {\n\t  }\n\t", "category": "math", "imports": ["import tensorflow as tf", "from google.protobuf import text_format", "from object_detection.builders import region_similarity_calculator_builder", "from object_detection.core import region_similarity_calculator", "from object_detection.protos import region_similarity_calculator_pb2 as sim_calc_pb2"]}], [{"term": "def", "name": "calc_input", "data": "def calc_input(p_rule = \" \"):\n\tif p_rule == \"buy\":\n\t\tdict_calc[\"ls_buy\"].append(10)\n\t\treturn dict_calc\n\telif p_rule == \"rent\":\n\t\tdict_calc[\"ls_rent\"].append(5)\n\t\treturn dict_calc\n\telif p_rule == \"short_trm\":\n\t\tdict_calc[\"ls_shrt_trm\"].append(2.5)\n\t\treturn dict_calc\n", "description": null, "category": "math", "imports": ["import pandas as pd"]}, {"term": "def", "name": "calc_rules", "data": "def calc_rules(dict_calc):\n\tls_buy = []\n\tls_rent = []\n\tls_a = []\n\t#userInput = input()#(rent)\t\n\t#dict_calc = calc_input(userInput)\n\t#print(\"--dict_calc-AA-\",dict_calc)\n\t#if dict_calc:\n\t\t\n\tdf = pd.DataFrame([dict_calc],columns=dict_calc.keys())\n\tprint(df)\n\t#dfA = pd.DataFrame()\n\tdfA = pd.concat([dfA, df], axis =0).reset_index()\n\n\t#dfA = df.append(dict_calc, ignore_index=True)\n\tprint(dfA)\n\tprint(\"--BBBB----\")\n\treturn dfA\n", "description": null, "category": "math", "imports": ["import pandas as pd"]}], [], [{"term": "def", "name": "calcContainer", "data": "def calcContainer(parent=None):\r\n\tfrm = Frame(parent)\r\n\tfrm.pack(expand=YES, fill=BOTH)\r\n\tLabel(frm, text='Calc Container').pack(side=TOP)\r\n\tCalcGui(frm)\r\n\tLabel(frm, text='Calc Container').pack(side=BOTTOM)\r\n\treturn frm\r\n", "description": null, "category": "math", "imports": ["from tkinter import *\r", "from calculator import CalcGui\r", "\timport sys\r"]}, {"term": "class", "name": "calcSubclass", "data": "class calcSubclass(CalcGui):\r\n\tdef makeWidgets(self, fg, bg, font):\r\n\t\tLabel(self, text='Calc Subclass').pack(side=TOP)\r\n\t\tLabel(self, text='Calc Subclass').pack(side=BOTTOM)\r\n\t\tCalcGui.makeWidgets(self, fg, bg, font)\r\n\t\t#Label(self, text='Calc Subclass').pack(side=BOTTOM)\r\n", "description": null, "category": "math", "imports": ["from tkinter import *\r", "from calculator import CalcGui\r", "\timport sys\r"]}], [{"term": "class", "name": "CalcDataSettingWidget", "data": "class CalcDataSettingWidget(QDialog):\n\t\n\tdef __init__(self, parent = None, dataSettingWidgetUi = None, dataSetSetting = {}):\n\t\tsuper(CalcDataSettingWidget, self).__init__(parent)\n\t\t\n\t\tself.tempDataSetSetting = dataSetSetting\n\t\tself.ui = dataSettingWidgetUi\n\n\t\tself.ui.calcDataTreeWidget.currentItemChanged.connect(lambda: self.setupUiCalcDataDetail(self.ui.calcDataTreeWidget.currentItem()))\n\n\t\tself.slot2 = lambda: self.setCalcDataSetting(name = self.ui.calcDataNameEdit.text(), \n\t\t\t\t\t\t\t\t\t\t\t\t\t firstCoefficient = self.ui.calcFirstDataCoefficientSpinBox.value(), \n\t\t\t\t\t\t\t\t\t\t\t\t\t firstDataIndex = self.ui.calcFirstDataComboBox.currentIndex(), \n\t\t\t\t\t\t\t\t\t\t\t\t\t operator = self.ui.operatorComboBox.currentText(), \n\t\t\t\t\t\t\t\t\t\t\t\t\t secondCoefficient = self.ui.calcSecondDataCoefficientSpinBox.value(), \n\t\t\t\t\t\t\t\t\t\t\t\t\t secondDataIndex = self.ui.calcSecondDataComboBox.currentIndex())\n\t\tself.ui.calcDataNameEdit.textChanged.connect(self.slot2)\n\t\tself.ui.calcFirstDataCoefficientSpinBox.valueChanged.connect(self.slot2)\n\t\tself.ui.calcFirstDataComboBox.currentIndexChanged.connect(self.slot2)\n\t\tself.ui.operatorComboBox.currentIndexChanged.connect(self.slot2)\n\t\tself.ui.calcSecondDataCoefficientSpinBox.valueChanged.connect(self.slot2)\n\t\tself.ui.calcSecondDataComboBox.currentIndexChanged.connect(self.slot2)\n\t\t\n\t\tself.ui.calcDataNewButton.clicked.connect(lambda: self.insertCalcDataSetting(index = self.ui.calcDataTreeWidget.indexOfTopLevelItem(self.ui.calcDataTreeWidget.currentItem())))\n\t\tself.ui.calcDataCopyButton.clicked.connect(lambda: self.insertCalcDataSetting(index = self.ui.calcDataTreeWidget.indexOfTopLevelItem(self.ui.calcDataTreeWidget.currentItem()), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  calcDataProperty = self.ui.calcDataTreeWidget.currentItem().clone()))\n\t\tself.ui.calcDataUpButton.clicked.connect(lambda: self.moveTreeWidgetItem(treeWidget = self.ui.calcDataTreeWidget, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t index = self.ui.calcDataTreeWidget.indexOfTopLevelItem(self.ui.calcDataTreeWidget.currentItem()), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t direction = -1))\n\t\tself.ui.calcDataDownButton.clicked.connect(lambda: self.moveTreeWidgetItem(treeWidget = self.ui.calcDataTreeWidget, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   index = self.ui.calcDataTreeWidget.indexOfTopLevelItem(self.ui.calcDataTreeWidget.currentItem()), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   direction = +1))\n\t\tself.ui.calcDataDeleteButton.clicked.connect(lambda: self.deleteShortcutSetting(treeWidget = self.ui.calcDataTreeWidget, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   index = self.ui.calcDataTreeWidget.indexOfTopLevelItem(self.ui.calcDataTreeWidget.currentItem())))\n\n\n\tdef setupUi(self):\n\t\tself.ui.calcDataTreeWidget.setHeaderLabels([\"Name\", \"First Coefficient\", \"First Data (ID)\", \"Operator\", \"First Coefficient\", \"Second Data (ID)\", \"First Data\", \"Second Data\"])\n\t\tself.ui.calcDataTreeWidget.setColumnHidden(1, True)\n\t\tself.ui.calcDataTreeWidget.setColumnHidden(2, True)\n\t\tself.ui.calcDataTreeWidget.setColumnHidden(4, True)\n\t\tself.ui.calcDataTreeWidget.setColumnHidden(5, True)\n\t\theader = self.ui.calcDataTreeWidget.header()\n\t\t#header.moveSection(0, 0) # \"Name\" -> 0\n\t\theader.moveSection(6, 1) # \"First Data\" -> 1\n\t\theader.moveSection(4, 2) # \"Operator\" -> 2\n\t\theader.moveSection(7, 3) # \"Second Data\" -> 3\n\t\t\t\n\t\ti = 0\n\t\twhile i < len(self.tempDataSetSetting[\"calcData\"]):\n\t\t\tcalcDataProperty = self.getCalcDataPropertyFromSetting(self.tempDataSetSetting[\"calcData\"][\"calcData\" + str(i + 1)])\n\n\t\t\tself.ui.calcDataTreeWidget.addTopLevelItem(calcDataProperty)\n\n\t\t\ti += 1\n\t\t\n\t\tself.updateCalcDataComboBox()\n\t\tself.ui.operatorComboBox.addItems([\"+\", \"-\", \"\"])\n\t\t\n\t\tself.ui.calcFirstDataCoefficientSpinBox.setDecimals(6)\n\t\tself.ui.calcSecondDataCoefficientSpinBox.setDecimals(6)\n\t\tself.ui.calcFirstDataCoefficientSpinBox.setRange(-999999999999., 999999999999.)\n\t\tself.ui.calcSecondDataCoefficientSpinBox.setRange(-999999999999., 999999999999.)\n\n\t\t\t\n\tdef setupUiCalcDataDetail(self, calcDataProperty):\n\t\tif calcDataProperty:\n\t\t\tself.ui.calcDataNameEdit.textChanged.disconnect(self.slot2)\n\t\t\tself.ui.calcFirstDataCoefficientSpinBox.valueChanged.disconnect(self.slot2)\n\t\t\tself.ui.calcFirstDataComboBox.currentIndexChanged.disconnect(self.slot2)\n\t\t\tself.ui.operatorComboBox.currentIndexChanged.disconnect(self.slot2)\n\t\t\tself.ui.calcSecondDataCoefficientSpinBox.valueChanged.disconnect(self.slot2)\n\t\t\tself.ui.calcSecondDataComboBox.currentIndexChanged.disconnect(self.slot2)\n\n\t\t\tself.ui.calcDataNameEdit.setText(calcDataProperty.text(0))\n\t\t\tself.ui.calcFirstDataCoefficientSpinBox.setValue(float(calcDataProperty.text(1)))\n\t\t\tself.ui.calcFirstDataComboBox.setCurrentIndex(self.getDataIndex(calcDataProperty.text(2)))\n\t\t\tself.ui.calcSecondDataCoefficientSpinBox.setValue(float(calcDataProperty.text(4)))\n\t\t\tself.ui.calcSecondDataComboBox.setCurrentIndex(self.getDataIndex(calcDataProperty.text(5)))\n\t\t\n\t\t\tindex = self.ui.operatorComboBox.findText(calcDataProperty.text(3))\n\t\t\tself.ui.operatorComboBox.setCurrentIndex(index)\n\t\t   \n\t\t\tself.ui.calcDataNameEdit.textChanged.connect(self.slot2)\n\t\t\tself.ui.calcFirstDataCoefficientSpinBox.valueChanged.connect(self.slot2)\n\t\t\tself.ui.calcFirstDataComboBox.currentIndexChanged.connect(self.slot2)\n\t\t\tself.ui.operatorComboBox.currentIndexChanged.connect(self.slot2)\n\t\t\tself.ui.calcSecondDataCoefficientSpinBox.valueChanged.connect(self.slot2)\n\t\t\tself.ui.calcSecondDataComboBox.currentIndexChanged.connect(self.slot2)\n\t\t\n\n\tdef setCalcDataSetting(self, name = \"\", firstCoefficient = 1.0, firstDataIndex = 0, operator = \"\", secondCoefficient = 1.0, secondDataIndex = 0):\n\t\tif self.ui.calcDataTreeWidget.currentItem():\n\t\t\tcalcDataProperty = self.ui.calcDataTreeWidget.currentItem()\n\n\t\t\tcalcDataProperty.setText(0, name)\n\t\t\tcalcDataProperty.setText(1, str(firstCoefficient))\n\t\t\tcalcDataProperty.setText(2, self.getDataID(firstDataIndex))\n\t\t\tcalcDataProperty.setText(3, operator)\n\t\t\tcalcDataProperty.setText(4, str(secondCoefficient))\n\t\t\tcalcDataProperty.setText(5, self.getDataID(secondDataIndex))\n\t\t\tcalcDataProperty.setText(6, self.getDataNameList()[firstDataIndex])\n\t\t\tcalcDataProperty.setText(7, self.getDataNameList()[secondDataIndex])\n\n\t\n\tdef getCalcDataPropertyFromSetting(self, calcDataSetting = Setting().getInitSettings()[\"dataSet\"][\"dataSet1\"][\"calcData\"][\"calcData1\"]):\n\t\tcalcDataProperty = QTreeWidgetItem([\"\"])\n\t\tcalcDataProperty.setText(0, calcDataSetting[\"name\"])\n\t\tcalcDataProperty.setText(1, str(calcDataSetting[\"firstCoefficient\"]))\n\t\tcalcDataProperty.setText(2, calcDataSetting[\"firstData\"])\n\t\tcalcDataProperty.setText(3, calcDataSetting[\"operator\"])\n\t\tcalcDataProperty.setText(4, str(calcDataSetting[\"secondCoefficient\"]))\n\t\tcalcDataProperty.setText(5, calcDataSetting[\"secondData\"])\n\t\tcalcDataProperty.setText(6, self.getDataNameList()[self.getDataIndex(calcDataSetting[\"firstData\"])])\n\t\tcalcDataProperty.setText(7, self.getDataNameList()[self.getDataIndex(calcDataSetting[\"secondData\"])])\n\n\t\treturn calcDataProperty\n\n\n\tdef getDataNameList(self):#############\n\t\tdataNameList = list()\n\t\t\n\t\tdataNameList.append(\"Default data 1: Data index\")\n\t\tdataNameList.append(\"Default data 2: 1 (Constant num)\")\n\t\t\n\t\ti = 0\n\t\twhile i < self.ui.rawDataTreeWidget.topLevelItemCount():\n\t\t\tdataNameList.append(\"Raw data \" + str(i + 1) + \": \" + self.ui.rawDataTreeWidget.topLevelItem(i).text(1))\n\t\t\ti += 1\n\n\t\treturn dataNameList\n\n\n\tdef getDataIndex(self, dataID):\n\t\tdefaultDataNum = 2\n\t\trawDataNum = len(self.tempDataSetSetting[\"rawData\"])##############\n\t\tcalcDataNum = len(self.tempDataSetSetting[\"calcData\"])############\n\n\t\tif dataID[0] == \"d\":\n\t\t\treturn int(dataID[1:]) - 1\n\t\telif dataID[0] == \"r\":\n\t\t\treturn defaultDataNum + int(dataID[1:]) - 1\n\t\telif dataID[0] == \"c\":\n\t\t\treturn defaultDataNum + rawDataNum + int(dataID[1:]) - 1\n\n\n\tdef getDataID(self, dataIndex):\n\t\tdefaultDataNum = 2\n\t\trawDataNum = len(self.tempDataSetSetting[\"rawData\"])###############\n\t\tcalcDataNum = len(self.tempDataSetSetting[\"calcData\"])#############\n\n\t\tif dataIndex <= 1:\n\t\t\treturn \"d\" + str(dataIndex + 1)\n\t\telif dataIndex <= rawDataNum + 1:\n\t\t\treturn \"r\" + str(dataIndex - defaultDataNum + 1)\n\t\telif dataIndex <= rawDataNum + calcDataNum + 1:\n\t\t\treturn \"c\" + str(dataIndex - defaultDataNum - rawDataNum + 1)\n\n\n\tdef updateCalcDataComboBox(self):\n\t\tdataNameList = self.getDataNameList()\n\n\t\tif self.ui.calcFirstDataComboBox.currentIndex() != -1:\n\t\t\tcalcFirstDataComboBoxIndex = self.ui.calcFirstDataComboBox.currentIndex()\n\t\telse:\n\t\t\tcalcFirstDataComboBoxIndex = 0\n\t\tif self.ui.calcSecondDataComboBox.currentIndex() != -1:\n\t\t\tcalcSecondDataComboBoxIndex = self.ui.calcSecondDataComboBox.currentIndex()\n\t\telse:\n\t\t\tcalcSecondDataComboBoxIndex = 0\n\n\t\tself.ui.calcFirstDataComboBox.clear()\n\t\tself.ui.calcSecondDataComboBox.clear()\n\t\t\n\t\ti = 0\n\t\twhile i < len(dataNameList):\n\t\t\tself.ui.calcFirstDataComboBox.addItem(dataNameList[i])\n\t\t\tself.ui.calcSecondDataComboBox.addItem(dataNameList[i])\n\t\t\ti += 1\n\n\t\tself.ui.calcFirstDataComboBox.setCurrentIndex(calcFirstDataComboBoxIndex)\n\t\tself.ui.calcSecondDataComboBox.setCurrentIndex(calcSecondDataComboBoxIndex)\n\n\n\tdef insertCalcDataSetting(self, index = -1, calcDataProperty = None):\n\t\tif calcDataProperty is None:\n\t\t\tcalcDataProperty = self.getCalcDataPropertyFromSetting()\n\n\t\tif index != -1:\n\t\t\tself.ui.calcDataTreeWidget.insertTopLevelItem(index + 1, calcDataProperty)\n\t\telse:\n\t\t\tself.ui.calcDataTreeWidget.addTopLevelItem(calcDataProperty)\n\n\n\tdef moveTreeWidgetItem(self, treeWidget = None, index = 0, direction = 0):\n\t\tif treeWidget is None:\n\t\t\treturn\n\t\tif index == 0 and direction == -1:\n\t\t\treturn\n\t\tif index == treeWidget.topLevelItemCount() - 1 and direction == +1:\n\t\t\treturn\n\n\t\titem = treeWidget.takeTopLevelItem(index)\n\t\ttreeWidget.insertTopLevelItem(index + direction, item)\n\t\ttreeWidget.setCurrentItem(item)\n\n\t\tif treeWidget is self.ui.rawDataTreeWidget:\n\t\t\tself.updateRawDataTreeWidgetIndexNum()\n\n\n\tdef deleteShortcutSetting(self, treeWidget = None, index = -1):\n\t\titem = treeWidget.takeTopLevelItem(index)\n\t\tdel item\n\n\t\t\n\tdef getCurrentCalcDataSetting(self):\n\t\tcalcDataSetting = dict()\n\n\t\ti = 0\n\t\twhile i < self.ui.calcDataTreeWidget.topLevelItemCount():\n\t\t\tcalcDataSetting[\"calcData\" + str(i + 1)] = {}\n\t\t\tcalcDataSetting[\"calcData\" + str(i + 1)][\"name\"] = self.ui.calcDataTreeWidget.topLevelItem(i).text(0)\n\t\t\tcalcDataSetting[\"calcData\" + str(i + 1)][\"firstCoefficient\"] = float(self.ui.calcDataTreeWidget.topLevelItem(i).text(1))\n\t\t\tcalcDataSetting[\"calcData\" + str(i + 1)][\"firstData\"] = self.ui.calcDataTreeWidget.topLevelItem(i).text(2)\n\t\t\tcalcDataSetting[\"calcData\" + str(i + 1)][\"operator\"] = self.ui.calcDataTreeWidget.topLevelItem(i).text(3)\n\t\t\tcalcDataSetting[\"calcData\" + str(i + 1)][\"secondCoefficient\"] = float(self.ui.calcDataTreeWidget.topLevelItem(i).text(4))\n\t\t\tcalcDataSetting[\"calcData\" + str(i + 1)][\"secondData\"] = self.ui.calcDataTreeWidget.topLevelItem(i).text(5)\n\n\t\t\ti += 1\n\n", "description": null, "category": "math", "imports": ["import sys", "from PySide.QtCore import *", "from PySide.QtGui import *", "from setting import Setting"]}], [{"term": "def", "name": "crystal_calc", "data": "def crystal_calc(test_crystal_code, crystal_calc_parameters, test_structure_data, test_basis_family_predefined):\n\tfrom aiida.common.extendeddicts import AttributeDict\n\tfrom aiida.orm import Bool\n\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation\n\n\tinputs = AttributeDict()\n\tinputs.metadata = AttributeDict({'options':\n\t\t\t\t\t\t\t\t\t {'resources':\n\t\t\t\t\t\t\t\t\t  {\"num_machines\": 1, \"num_mpiprocs_per_machine\": 1}\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t })\n\tinputs.code = test_crystal_code\n\tinputs.structure = test_structure_data\n\tinputs.parameters = crystal_calc_parameters\n\tinputs.basis_family = test_basis_family_predefined\n\tinputs.guess_oxistates = Bool(False)\n\tinputs.high_spin_preferred = Bool(False)\n\tinputs.is_magnetic = Bool(True)\n\tcalc = CrystalSerialCalculation(inputs)\n\treturn calc\n\n", "description": null, "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "calc_results", "data": "def calc_results():\n\tfrom aiida.orm import FolderData\n\tfrom aiida_crystal_dft.tests import TEST_DIR\n\n\tdef get_results(files=None, prefix=\"mgo_sto3g\"):\n\t\t\"\"\"\n\t\tReturn a FolderData with the results of the calculation\n\t\t:param files: a dictionary corresponding files to directories\n\t\t:param prefix: a folder with all output files for the test calculation\n\t\t:return: a FolderData instance\n\t\t\"\"\"\n\t\tdata = FolderData()\n\t\tif files is None:\n\t\t\tfiles = {}\n\t\t# copy files from prefix\n\t\troot_dir = os.path.join(TEST_DIR, 'output_files', prefix)\n\t\tfor entry in os.listdir(root_dir):\n\t\t\tif os.path.isfile(os.path.join(root_dir, entry)):\n\t\t\t\t# non-default file location\n\t\t\t\tif entry in files:\n\t\t\t\t\tfile_dir = os.path.join(TEST_DIR, 'output_files', files[entry])\n\t\t\t\t\twith open(os.path.join(file_dir, entry), 'rb') as f:\n\t\t\t\t\t\tdata.put_object_from_filelike(f, entry, mode='wb')\n\t\t\t\t\tcontinue\n\t\t\t\t# default file location\n\t\t\t\twith open(os.path.join(root_dir, entry), 'rb') as f:\n\t\t\t\t\tdata.put_object_from_filelike(f, entry, mode='wb')\n\t\treturn data\n\n\treturn get_results\n\n", "description": "\n\t\tReturn a FolderData with the results of the calculation\n\t\t:param files: a dictionary corresponding files to directories\n\t\t:param prefix: a folder with all output files for the test calculation\n\t\t:return: a FolderData instance\n\t\t", "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "crystal_calc_node", "data": "def crystal_calc_node(crystal_calc, calc_results):\n\t\"\"\"Returns CalcJobNode corresponding to CrystalCalc CalcJob\"\"\"\n\tfrom aiida.orm import CalcJobNode\n\tfrom aiida.common.links import LinkType\n\n\tdef get_calcnode(files=None, prefix=\"mgo_sto3g\"):\n\t\tcomputer = crystal_calc.inputs.code.get_remote_computer()\n\t\tprocess_type = 'aiida.calculations:{}'.format('crystal_dft.serial')\n\t\tnode = CalcJobNode(computer=computer, process_type=process_type)\n\t\tnode.set_process_label('CrystalSerialCalculation')\n\t\tnode.set_attribute('input_filename', 'INPUT')\n\t\tnode.set_attribute('output_filename', 'crystal.out')\n\t\tnode.set_option('resources', {'num_machines': 1, 'num_mpiprocs_per_machine': 1})\n\t\tnode.add_incoming(crystal_calc.inputs.code, link_type=LinkType.INPUT_CALC, link_label='code')\n\t\tnode.add_incoming(crystal_calc.inputs.structure, link_type=LinkType.INPUT_CALC, link_label='structure')\n\t\tnode.add_incoming(crystal_calc.inputs.parameters, link_type=LinkType.INPUT_CALC, link_label='parameters')\n\t\tnode.add_incoming(crystal_calc.inputs.basis_family, link_type=LinkType.INPUT_CALC, link_label='basis_family')\n\t\tnode.store()\n\t\tretrieved = calc_results(files, prefix)\n\t\tretrieved.add_incoming(node, link_type=LinkType.CREATE, link_label='retrieved')\n\t\tretrieved.store()\n\t\treturn node\n\n\treturn get_calcnode\n\n", "description": "Returns CalcJobNode corresponding to CrystalCalc CalcJob", "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "properties_calc", "data": "def properties_calc(test_properties_code, properties_calc_parameters, test_wavefunction):\n\tfrom aiida.common.extendeddicts import AttributeDict\n\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation\n\tinputs = AttributeDict()\n\tinputs.metadata = AttributeDict({'options':\n\t\t\t\t\t\t\t\t\t {'resources':\n\t\t\t\t\t\t\t\t\t  {\"num_machines\": 1, \"num_mpiprocs_per_machine\": 1}\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t })\n\tinputs.code = test_properties_code\n\tinputs.parameters = properties_calc_parameters\n\tinputs.wavefunction = test_wavefunction\n\tcalc = PropertiesCalculation(inputs)\n\treturn calc\n\n", "description": null, "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "properties_calc_node", "data": "def properties_calc_node(properties_calc, calc_results):\n\t\"\"\"Returns CalcJobNode corresponding to PropertiesCalc CalcJob\"\"\"\n\tfrom aiida.orm import CalcJobNode\n\tfrom aiida.common.links import LinkType\n\tcomputer = properties_calc.inputs.code.get_remote_computer()\n\tprocess_type = 'aiida.calculations:{}'.format('crystal_dft.properties')\n\n\tdef get_calcnode(files=None):\n\t\tnode = CalcJobNode(computer=computer, process_type=process_type)\n\t\tnode.set_process_label('PropertiesCalculation')\n\t\tnode.set_option('resources', {'num_machines': 1, 'num_mpiprocs_per_machine': 1})\n\t\tnode.set_attribute('input_filename', 'INPUT')\n\t\tnode.set_attribute('output_filename', '_scheduler-stderr.txt')\n\t\tnode.set_attribute('error_filename', '_scheduler-stderr.txt')\n\t\tnode.add_incoming(properties_calc.inputs.code, link_type=LinkType.INPUT_CALC, link_label='code')\n\t\tnode.add_incoming(properties_calc.inputs.parameters, link_type=LinkType.INPUT_CALC, link_label='parameters')\n\t\tnode.add_incoming(properties_calc.inputs.wavefunction, link_type=LinkType.INPUT_CALC, link_label='wavefunction')\n\t\tnode.store()\n\t\tretrieved = calc_results(files)\n\t\tretrieved.add_incoming(node, link_type=LinkType.CREATE, link_label='retrieved')\n\t\tretrieved.store()\n\t\treturn node\n\n\treturn get_calcnode\n\n", "description": "Returns CalcJobNode corresponding to PropertiesCalc CalcJob", "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "crystal_calc_parameters", "data": "def crystal_calc_parameters():\n\tfrom aiida.orm import Dict\n\treturn Dict(dict={\n\t\t\"title\": \"Crystal calc\",\n\t\t\"scf\": {\n\t\t\t\"k_points\": (8, 8),\n\t\t\t# 'dft': {'xc': 'PBE0'}\n\t\t}\n\t})\n\n", "description": null, "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "properties_calc_parameters", "data": "def properties_calc_parameters():\n\tfrom aiida.orm import Dict\n\treturn Dict(dict={\n\t\t\"band\": {\n\t\t\t\"shrink\": 8,\n\t\t\t\"k_points\": 30,\n\t\t\t\"first\": 1,\n\t\t\t\"last\": 14,\n\t\t\t\"bands\": [[[0, 0, 0], [4, 0, 4]],\n\t\t\t\t\t  [[4, 0, 4], [5, 2, 5]],\n\t\t\t\t\t  [[3, 3, 6], [0, 0, 0]],\n\t\t\t\t\t  [[0, 0, 0], [4, 4, 4]],\n\t\t\t\t\t  [[4, 4, 4], [4, 2, 6]],\n\t\t\t\t\t  [[4, 2, 6], [4, 0, 4]]]\n\t\t}\n\t})\n\n", "description": null, "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "test_wavefunction", "data": "def test_wavefunction():\n\tfrom aiida.orm import SinglefileData\n\tfrom aiida_crystal_dft.tests import TEST_DIR\n\tfile_name = os.path.join(TEST_DIR,\n\t\t\t\t\t\t\t 'output_files',\n\t\t\t\t\t\t\t 'mgo_sto3g',\n\t\t\t\t\t\t\t 'fort.9')\n\ttemp_dir = tempfile.gettempdir()\n\texpected = os.path.join(temp_dir, \"fort.9\")\n\tshutil.copy(file_name, expected)\n\twith open(expected, 'rb') as f:\n\t\tyield SinglefileData(file=f)\n\tos.remove(expected)\n\n", "description": null, "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "test_ase_structure", "data": "def test_ase_structure():\n\t# LiCl\n\t# return crystal(\n\t#\t symbols=['Cl', 'Li'],\n\t#\t basis=[[0.3333333333, 0.6666666667, 0.379], [0.3333333333, 0.6666666667, 0.0]],\n\t#\t spacegroup=186,\n\t#\t cellpar=[3.852, 3.852, 6.118, 90.0, 90.0, 120.0])\n\t# MgO\n\treturn crystal(\n\t\tsymbols=[12, 8],\n\t\t# symbols=[26, 8],\n\t\tbasis=[[0, 0, 0], [0.5, 0.5, 0.5]],\n\t\tspacegroup=225,\n\t\tcellpar=[4.21, 4.21, 4.21, 90, 90, 90])\n\n", "description": null, "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "test_mpds_structure", "data": "def test_mpds_structure(aiida_profile):\n\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter\n\tfrom aiida.orm import StructureData\n\timporter = MpdsDbImporter()\n\tquery = {'formulae': 'HgEr', 'sgs': 221}\n\tres = next(importer.find(query))\n\tase_struct = crystal(\n\t\tsymbols=res['els_noneq'],\n\t\tbasis=res['basis_noneq'],\n\t\tspacegroup=res['sg_n'],\n\t\tcellpar=res['cell_abc'])\n\treturn StructureData(ase=ase_struct)\n\n", "description": null, "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "test_magnetic_structure", "data": "def test_magnetic_structure(aiida_profile):\n\tfrom aiida.orm import StructureData\n\tase_struct = crystal(\n\t\tsymbols=[26, 8],\n\t\tbasis=[[0, 0, 0], [0.5, 0.5, 0.5]],\n\t\tspacegroup=225,\n\t\tcellpar=[4.21, 4.21, 4.21, 90, 90, 90])\n\treturn StructureData(ase=ase_struct)\n\n", "description": null, "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "test_structure_data", "data": "def test_structure_data(aiida_profile, test_ase_structure):\n\tfrom aiida.orm import StructureData\n\treturn StructureData(ase=test_ase_structure)\n\n", "description": null, "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}, {"term": "def", "name": "test_structure_issue_30", "data": "def test_structure_issue_30(aiida_profile):\n\tfrom .. import TEST_DIR\n\t# from aiida_crystal_dft.io.f9 import Fort9\n\tfrom aiida_crystal_dft.io.f34 import Fort34\n\tname = os.path.join(TEST_DIR,\n\t\t\t\t\t\t\"input_files\",\n\t\t\t\t\t\t\"issue_30\",\n\t\t\t\t\t\t\"fort.34\")\n\t# parser = Fort9(name)\n\tstruct = Fort34().read(name)\n\tprint(struct.space_group)\n\treturn struct.to_aiida()\n", "description": null, "category": "math", "imports": ["import os", "import shutil", "import tempfile", "import pytest", "from ase.spacegroup import crystal", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida.orm import Bool", "\tfrom aiida_crystal_dft.calculations.serial import CrystalSerialCalculation", "\tfrom aiida.orm import FolderData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.common.extendeddicts import AttributeDict", "\tfrom aiida_crystal_dft.calculations.properties import PropertiesCalculation", "\tfrom aiida.orm import CalcJobNode", "\tfrom aiida.common.links import LinkType", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import Dict", "\tfrom aiida.orm import SinglefileData", "\tfrom aiida_crystal_dft.tests import TEST_DIR", "\tfrom aiida.tools.dbimporters.plugins.mpds import MpdsDbImporter", "\tfrom aiida.orm import StructureData", "\timporter = MpdsDbImporter()", "\tres = next(importer.find(query))", "\tfrom aiida.orm import StructureData", "\tfrom aiida.orm import StructureData", "\tfrom .. import TEST_DIR", "\t# from aiida_crystal_dft.io.f9 import Fort9", "\tfrom aiida_crystal_dft.io.f34 import Fort34"]}], [{"term": "class", "name": "BasicBlock", "data": "class BasicBlock(CombinedOp):\n\texpansion = 1\n\n\tdef __init__(self, name, in_shape, out_channel, stride=1, downsample=None):\n\t\tin_shape = shape2d(in_shape)\n\t\tself.conv1 = conv(name + '.conv1', in_shape, out_channel, 3, stride, 1)\n\t\tself.relu1 = mock(ReLU, name + '.relu1', self.conv1)\n\t\tself.conv2 = conv(name + '.conv2', self.conv1, out_channel, 3, 1, 1)\n\t\tself.relu2 = mock(ReLU, name + '.relu2', self.conv2)\n\t\tself.eltwise_add = mock(ElementwiseAdd, name + '.eltwise_add', self.conv2)\n\t\tself.batch = self.relu2.batch\n\t\tself.out_channel = self.relu2.channel\n\t\tself.out_height = self.relu2.height\n\t\tself.out_width = self.relu2.width\n\t\tself.downsample = downsample\n\t\tself.stride = stride\n\t\tops = [v for v in self.__dict__.values() if isinstance(v, BaseOp)]\n\t\tsuper().__init__(name=name, ops=ops)\n\n\tdef calc(self, x):\n\t\tresidual = x\n\t\tout = self.conv1.calc(x)\n\t\tout = self.relu1.calc(out)\n\t\tout = self.conv2.calc(out)\n\t\tif self.downsample is not None:\n\t\t\tresidual = self.downsample.calc(x)\n\t\tout = self.eltwise_add.calc(out, residual)\n\t\tout = self.relu2.calc(out)\n\t\treturn out\n\n", "description": null, "category": "math", "imports": ["from .utils import *", "from ..op import CombinedOp, SequenceOp, ElementwiseAdd, Linear, ReLU"]}, {"term": "class", "name": "Bottleneck", "data": "class Bottleneck(CombinedOp):\n\texpansion = 4\n\n\tdef __init__(self, name, in_shape, out_channel, stride=1, downsample=None):\n\t\tself.conv1 = conv(name + '.conv1', in_shape, out_channel, 1)\n\t\tself.relu1 = mock(ReLU, name + '.relu1', self.conv1)\n\t\tself.conv2 = conv(name + '.conv2', self.conv1, out_channel, 3, stride, 1)\n\t\tself.relu2 = mock(ReLU, name + '.relu2', self.conv2)\n\t\tself.conv3 = conv(name + '.conv3', self.conv2, out_channel * 4, 1)\n\t\tself.relu3 = mock(ReLU, name + '.relu3', self.conv3)\n\t\tself.eltwise_add = mock(ElementwiseAdd, name + '.eltwise_add', self.conv3)\n\t\tself.batch = self.relu3.batch\n\t\tself.out_channel = self.relu3.channel\n\t\tself.out_height = self.relu3.height\n\t\tself.out_width = self.relu3.width\n\t\tself.downsample = downsample\n\t\tself.stride = stride\n\t\tops = [v for v in self.__dict__.values() if isinstance(v, BaseOp)]\n\t\tsuper().__init__(name=name, ops=ops)\n\n\tdef calc(self, x):\n\t\tresidual = x\n\t\tout = self.conv1.calc(x)\n\t\tout = self.relu1.calc(out)\n\t\tout = self.conv2.calc(out)\n\t\tout = self.relu2.calc(out)\n\t\tout = self.conv3.calc(out)\n\t\tif self.downsample is not None:\n\t\t\tresidual = self.downsample(x)\n\t\tout = self.eltwise_add.calc(out, residual)\n\t\tout = self.relu3.calc(out)\n\t\treturn out\n\n", "description": null, "category": "math", "imports": ["from .utils import *", "from ..op import CombinedOp, SequenceOp, ElementwiseAdd, Linear, ReLU"]}, {"term": "class", "name": "ResNet", "data": "class ResNet(CombinedOp):\n\tdef __init__(self, name, in_shape, block, layers, num_classes=1000, deep_stem=False, avg_down=False):\n\t\tself.inplanes = 64\n\t\tself.deep_stem = deep_stem\n\t\tself.avg_down = avg_down\n\t\tif self.deep_stem:\n\t\t\tconv1 = conv(name + '.stem.conv1', in_shape, 32, 3, 2, 1)\n\t\t\trelu1 = mock(ReLU, name + '.stem.relu1', conv1)\n\t\t\tconv2 = conv(name + '.stem.conv2', conv1, 32, 3, 1, 1)\n\t\t\trelu2 = mock(ReLU, name + '.stem.relu2', conv2)\n\t\t\tconv3 = conv(name + '.stem.conv3', conv2, 64, 3, 1, 1)\n\t\t\tself.conv1 = SequenceOp(name='.stem', ops=[conv1, relu1, conv2, relu2, conv3])\n\t\telse:\n\t\t\tself.conv1 = conv(name + '.conv1', in_shape, 64, 7, 2, 3)\n\t\tself.relu1 = mock(ReLU, name + '.relu1', self.conv1)\n\t\tself.maxpool = pool(name + '.maxpool', self.relu1, 3, 2, 1, 'max')\n\t\tself.layer1 = self._make_layer(name + '.layer1', self.maxpool, block, 64, layers[0])\n\t\tself.layer2 = self._make_layer(name + '.layer2', self.layer1, block, 128, layers[1], stride=2)\n\t\tself.layer3 = self._make_layer(name + '.layer3', self.layer2, block, 256, layers[2], stride=2)\n\t\tself.layer4 = self._make_layer(name + '.layer4', self.layer3, block, 512, layers[3], stride=2)\n\t\tself.avgpool = pool(name + '.avgpool', self.layer4, 7, 1, 0, 'avg')\n\t\tself.flatten = flatten2d(name + '.flatten', self.avgpool)\n\t\tself.fc = Linear(\n\t\t\tbatch=self.flatten.batch, in_channel=512 * block.expansion,\n\t\t\tout_channel=num_classes, biased=True,\n\t\t\tname=name + '.linear'\n\t\t)\n\t\tops = [v for v in self.__dict__.values() if isinstance(v, BaseOp)]\n\t\tsuper().__init__(name=name, ops=ops)\n\n\tdef _make_layer(self, name, prev, block, planes, blocks, stride=1, avg_down=False):\n\t\tdownsample = None\n\t\tif stride != 1 or self.inplanes != planes * block.expansion:\n\t\t\tif self.avg_down:\n\t\t\t\traise NotImplemented\n\t\t\t\t# downsample = nn.Sequential(\n\t\t\t\t#\t nn.AvgPool2d(stride, stride=stride, ceil_mode=True, count_include_pad=False),\n\t\t\t\t#\t nn.Conv2d(self.inplanes, planes * block.expansion,\n\t\t\t\t#\t\t\t   kernel_size=1, stride=1, bias=False),\n\t\t\t\t#\t BN(planes * block.expansion),\n\t\t\t\t# )\n\t\t\telse:\n\t\t\t\tdownsample = conv(name + '.downsample', prev, planes * block.expansion, 1, stride)\n\n\t\tlayers = []\n\t\tlayers.append(block(name + '.' + str(len(layers)), prev, planes, stride, downsample))\n\t\tself.inplanes = planes * block.expansion\n\t\tfor i in range(1, blocks):\n\t\t\tlayers.append(block(name + '.' + str(len(layers)), layers[-1], planes))\n\n\t\treturn SequenceOp(name=name, ops=layers)\n\n\tdef calc(self, x):\n\t\tx = self.conv1.calc(x)\n\t\tx = self.relu1.calc(x)\n\t\tx = self.maxpool.calc(x)\n\t\tx = self.layer1.calc(x)\n\t\tx = self.layer2.calc(x)\n\t\tx = self.layer3.calc(x)\n\t\tx = self.layer4.calc(x)\n\t\tx = self.avgpool.calc(x)\n\t\tx = self.flatten.calc(x)\n\t\tx = self.fc.calc(x)\n\t\treturn x\n\n", "description": null, "category": "math", "imports": ["from .utils import *", "from ..op import CombinedOp, SequenceOp, ElementwiseAdd, Linear, ReLU"]}, {"term": "def", "name": "resnet18", "data": "def resnet18(**kwargs):\n\tmodel = ResNet('resnet18', [1, 3, 224, 224], BasicBlock, [2, 2, 2, 2], **kwargs)\n\treturn model\n", "description": null, "category": "math", "imports": ["from .utils import *", "from ..op import CombinedOp, SequenceOp, ElementwiseAdd, Linear, ReLU"]}], [], [{"term": "def", "name": "op1", "data": "def op1(a, m):\n\ta[1].position += m * np.array([0.1, 0.2, 0.3])\n\treturn a\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase import Atom", "from ase.build import bulk", "from ase.calculators.checkpoint import Checkpoint, CheckpointCalculator", "from ase.calculators.lj import LennardJones", "from ase.lattice.cubic import Diamond"]}, {"term": "def", "name": "op2", "data": "def op2(a, m):\n\ta += Atom('C', m * np.array([0.2, 0.3, 0.1]))\n\treturn a, a.positions[0]\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase import Atom", "from ase.build import bulk", "from ase.calculators.checkpoint import Checkpoint, CheckpointCalculator", "from ase.calculators.lj import LennardJones", "from ase.lattice.cubic import Diamond"]}, {"term": "def", "name": "test_sqlite", "data": "def test_sqlite(testdir):\n\tCP = Checkpoint('checkpoints.db')\n\ta = Diamond('Si', size=[2, 2, 2])\n\ta = CP(op1)(a, 1.0)\n\top1a = a.copy()\n\ta, ra = CP(op2)(a, 2.0)\n\top2a = a.copy()\n\top2ra = ra.copy()\n\n\tCP = Checkpoint('checkpoints.db')\n\ta = Diamond('Si', size=[2, 2, 2])\n\ta = CP(op1)(a, 1.0)\n\tassert a == op1a\n\ta, ra = CP(op2)(a, 2.0)\n\tassert a == op2a\n\tassert(np.abs(ra - op2ra).max() < 1e-5)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase import Atom", "from ase.build import bulk", "from ase.calculators.checkpoint import Checkpoint, CheckpointCalculator", "from ase.calculators.lj import LennardJones", "from ase.lattice.cubic import Diamond"]}, {"term": "def", "name": "rattle_calc", "data": "def rattle_calc(atoms, calc):\n\torig_atoms = atoms.copy()\n\n\t# first do a couple of calculations\n\tnp.random.seed(0)\n\tatoms.rattle()\n\tcp_calc_1 = CheckpointCalculator(calc)\n\tatoms.calc = cp_calc_1\n\te11 = atoms.get_potential_energy()\n\tf11 = atoms.get_forces()\n\tatoms.rattle()\n\te12 = atoms.get_potential_energy()\n\tf12 = atoms.get_forces()\n\n\t# then re-read them from checkpoint file\n\tatoms = orig_atoms\n\tnp.random.seed(0)\n\tatoms.rattle()\n\tcp_calc_2 = CheckpointCalculator(calc)\n\tatoms.calc = cp_calc_2\n\te21 = atoms.get_potential_energy()\n\tf21 = atoms.get_forces()\n\tatoms.rattle()\n\te22 = atoms.get_potential_energy()\n\tf22 = atoms.get_forces()\n\n\tassert e11 == e21\n\tassert e12 == e22\n\tassert(np.abs(f11 - f21).max() < 1e-5)\n\tassert(np.abs(f12 - f22).max() < 1e-5)\n\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase import Atom", "from ase.build import bulk", "from ase.calculators.checkpoint import Checkpoint, CheckpointCalculator", "from ase.calculators.lj import LennardJones", "from ase.lattice.cubic import Diamond"]}, {"term": "def", "name": "test_new_style_interface", "data": "def test_new_style_interface(testdir):\n\tcalc = LennardJones()\n\tatoms = bulk('Cu')\n\trattle_calc(atoms, calc)\n", "description": null, "category": "math", "imports": ["import numpy as np", "from ase import Atom", "from ase.build import bulk", "from ase.calculators.checkpoint import Checkpoint, CheckpointCalculator", "from ase.calculators.lj import LennardJones", "from ase.lattice.cubic import Diamond"]}], [{"term": "def", "name": "test_cacher_calculate_mockup", "data": "def test_cacher_calculate_mockup():\n\tcalc_cacher = make_calculateCacher()\n\tto_mockup = {\n\t\t\"mockup\": True,\n\t\t\"mockuped\": 123,\n\t}\n\tresult = calc_cacher.calculate(to_mockup=to_mockup)\n\tassert result == 123\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "test_cacher_save_mode_json", "data": "def test_cacher_save_mode_json():\n\tcalc_cacher = make_calculateCacher()\n\n\tstart_from = 25\n\tto_calculate = {\n\t\t\"func\": demo_return_num,\n\t\t\"kwargs\": dict(num=start_from),\n\t}\n\n\t# \u0446\u0435\u043b\u044c - \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0432\u043c\u0435\u0441\u0442\u043e pickle json\n\tf_saved = \"in_json\"\n\tf_real = calc_cacher.get_f(f_saved)\n\trmfile(f_real)\n\n\tassert file_exists(f_real) == False\n\n\t_kwargs = {\n\t\t\"to_calculate\": to_calculate,\n\t\t\"save_mode\": \"json\",\n\t\t\"f_to\": f_saved,\n\t}\n\tresult = calc_cacher.calculate(**_kwargs)\n\tassert result == start_from\n\tassert file_exists(f_real) == True\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "test_resave_file", "data": "def test_resave_file():\n\tcalc_cacher = make_calculateCacher()\n\tf = r\"s:\\python2.7\\Lib\\site-packages\\modules_projects\\data\\parse_elements.js\"\n\tf_saved = calc_cacher.resave_file(f)\n\tassert file_exists(f_saved) == True\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "test_resave_to_file", "data": "def test_resave_to_file():\n\tcalc_cacher = make_calculateCacher()\n\thtml = \"\u043f\u0440\u0438\u0432\u0435\u0442! \u0421\u043e\u0445\u0440\u0430\u043d\u0438 \u043c\u0435\u043d\u044f \u043f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430\"\n\tf = \"asdfadfadf/some_special_name_of_file.json\"\n\n\tf_saved = calc_cacher.resave_text_to_file(html, f)\n\tassert file_exists(f_saved) == True\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "test_scenario_calcCacher_releaseVersion_and_debug", "data": "def test_scenario_calcCacher_releaseVersion_and_debug():\n\tstart_from = 25\n\tto_calculate = {\n\t\t\"func\": demo_return_num,\n\t\t\"kwargs\": dict(num=start_from),\n\t}\n\n\t# \u043d\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0435 - \u0432\u0441\u0435 \u0441\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c, \u043d\u0438\u0447\u0435\u0433\u043e \u043d\u0435 \u043a\u0435\u0448\u0438\u0440\u0443\u0435\u043c\n\td_to = r\"s:\\python2.7\\Lib\\site-packages\\modules_projects\\temp\\!cache_calculate_with_cacher\\!typical_bet\"\n\t_kwargs = {\n\t\t\"want_cache\": False,\n\t\t\"want_save_all\": True,\n\t\t\"d_to\": d_to,\n\t}\n\tcalc_cacher = make_calculateCacher(**_kwargs)\n\n\tresult = calc_cacher.calculate(to_calculate)\n\tlogger.debug(\"result=%s\" % result)\n\tassert result == start_from\n\tassert calc_cacher._stats == {\"calculated\": 1}\n\n\t# \u0430 \u0442\u0435\u043f\u0435\u0440\u044c \u0442\u0438\u043f\u0430 \u0434\u0435\u0431\u0430\u0433 - \u044f \u0445\u043e\u0447\u0443 \u043f\u043e\u0434\u0442\u044f\u043d\u0443\u0442\u044c \u0438\u043d\u0444\u0443\n\t_kwargs = {\n\t\t\"want_cache\": True,\n\t\t\"want_save_all\": False,\n\t\t\"d_to\": d_to,\n\t}\n\tcalc_cacher = make_calculateCacher(**_kwargs)\n\n\tresult = calc_cacher.calculate(to_calculate)\n\tlogger.debug(\"result=%s\" % result)\n\tassert result == start_from\n\tassert calc_cacher._stats == {\"cache_file\": 1}\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "test_demo_multifunc", "data": "def test_demo_multifunc(calc_cacher=None):\n\tcalc_cacher = make_calculateCacher(calc_cacher=calc_cacher)\n\n\tstart_from = 25\n\tadding = 10\n\tres1, res2 = demo_multifunc(\n\t\tcalc_cacher=calc_cacher, start_from=start_from, adding=adding\n\t)\n\n\tassert res1 == start_from\n\tassert res2 == start_from + adding\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "test_check_want_cache", "data": "def test_check_want_cache(calc_cacher=None):\n\t\"\"\"\n\t\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0445\u043e\u0442\u0438\u043c \u043a\u0435\u0448 \u0438\u043b\u0438 \u043d\u0435\u0442?\n\t\"\"\"\n\tfun = \"test_check_want_cache\"\n\tcalc_cacher = make_calculateCacher(calc_cacher=calc_cacher)\n\n\tnum = 25\n\tfunc, args, kwargs = demo_return_num, (num,), {}\n\tto_calculate = func_args_kwargs_to_dict(func, args, kwargs)\n\n\t_kwargs = {\n\t\t\"to_calculate\": to_calculate,\n\t\t\"cache_name\": \"to_calculate_step_2\",\n\t}\n\n\tt = 0\n\tt = 1\n\tif t:\n\t\twant_cache, cache_logic = calc_cacher.check_want_cache(**_kwargs)\n\t\tlogger.debug(\n\t\t\t\"want_cache %s, cache_login %s\" % (want_cache, cache_logic)\n\t\t)\n\t\tassert want_cache == True\n\t\tassert cache_logic == \"main want_cache\"\n\n\t# test 2\n\tt = 1\n\tif t:\n\t\tcalc_cacher.demo_return_num = True\n\t\twant_cache, cache_logic = calc_cacher.check_want_cache(**_kwargs)\n\t\tlogger.debug(\n\t\t\t\"want_cache %s, cache_login %s\" % (want_cache, cache_logic)\n\t\t)\n\t\tassert want_cache == True\n\t\tassert cache_logic == \"func_name\"\n\n\t# test 3\n\tt = 1\n\tif t:\n\t\tcalc_cacher.to_calculate_step_2 = True\n\t\twant_cache, cache_logic = calc_cacher.check_want_cache(**_kwargs)\n\t\tlogger.debug(\n\t\t\t\"want_cache %s, cache_login %s\" % (want_cache, cache_logic)\n\t\t)\n\t\tassert want_cache == True\n\t\tassert cache_logic == \"cache_name\"\n\n\t# test 4\n\tt = 1\n\tif t:\n\t\t_kwargs[\"want_cache\"] = False\n\t\tcalc_cacher.to_calculate_step_2 = True\n\t\twant_cache, cache_logic = calc_cacher.check_want_cache(**_kwargs)\n\t\tlogger.debug(\n\t\t\t\"want_cache %s, cache_login %s\" % (want_cache, cache_logic)\n\t\t)\n\t\tassert want_cache == False\n\t\tassert cache_logic == \"in_kwargs\"\n\n", "description": "\n\t\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0445\u043e\u0442\u0438\u043c \u043a\u0435\u0448 \u0438\u043b\u0438 \u043d\u0435\u0442?\n\t", "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "test_cacher_return_saved_with_func", "data": "def test_cacher_return_saved_with_func():\n\tnum = 25\n\tfunc, args, kwargs = demo_return_num, (num,), {}\n\tto_calculate = func_args_kwargs_to_dict(func, args, kwargs)\n\n\tfunc, args, kwargs = demo_return_num_25, (), {}\n\tto_load = func_args_kwargs_to_dict(func, args, kwargs)\n\n\tcalculated = calculate_with_cacher(\n\t\tto_calculate, to_load=to_load, f_to=\"nah\"\n\t)\n\n\tassert calculated == num\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "test_cacher_return_saved_in_file", "data": "def test_cacher_return_saved_in_file():\n\tnum = 26\n\tfunc, args, kwargs = demo_return_num, (num,), {}\n\tto_calculate = func_args_kwargs_to_dict(func, args, kwargs)\n\n\tcalculated = calculate_with_cacher(to_calculate, want_cache=True)\n\n\tassert calculated == num\n\tassert calculated != 1.11\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "test_cacher_calculated", "data": "def test_cacher_calculated():\n\tto_calculate = get_demo_return_args()\n\tfunc, args, kwargs = parse_func_args_kwargs(to_calculate)\n\n\tcalculated = calculate_with_cacher(to_calculate, want_cache=False)\n\n\t# logger.debug('calculated %s' % calculated)\n\tassert calculated == (args, kwargs)\n\tassert calculated != \"some error\"\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "get_demo_return_num", "data": "def get_demo_return_num(num):\n\tfunc = demo_return_num\n\targs = ((num),)\n\tkwargs = {}\n\tr = func_args_kwargs_to_dict(func, args, kwargs)\n\tlogger.debug(\"%s\" % r)\n\treturn r\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "get_demo_return_args", "data": "def get_demo_return_args():\n\tfunc = demo_return_args\n\targs = (1, 2)\n\tkwargs = {\"x\": 1, \"y\": 2}\n\treturn func_args_kwargs_to_dict(func, args, kwargs)\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "demo_return_args", "data": "def demo_return_args(*args, **kwargs):\n\treturn args, kwargs\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "demo_return_num", "data": "def demo_return_num(num=1):\n\treturn num\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "demo_return_num_25", "data": "def demo_return_num_25():\n\treturn 25\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "demo_add", "data": "def demo_add(num, num_2=2):\n\treturn num + num_2\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "demo_multifunc", "data": "def demo_multifunc(calc_cacher=None, start_from=25, adding=10):\n\t\"\"\"\n\t\u0444-\u044f \u0438\u0437 2-\u0445 \u0448\u0430\u0433\u043e\u0432:\n\t\"\"\"\n\tif calc_cacher is None:\n\t\tcalc_cacher = make_calculateCacher()\n\tfunc_calculate = calc_cacher.calculate\n\n\t# func1\n\tto_calculate = {\n\t\t\"func\": demo_return_num,\n\t\t\"kwargs\": dict(num=start_from),\n\t}\n\tres1 = func_calculate(to_calculate)\n\t# logger.debug('%s %s' % (res, expected))\n\n\t# func2\n\tto_calculate = {\n\t\t\"func\": demo_add,\n\t\t# 'args': (res1, adding,),\n\t\t\"kwargs\": dict(num=res1, num_2=adding),\n\t}\n\twant_cache = False\n\tres2 = func_calculate(to_calculate, want_cache=want_cache)\n\t# 25 + 10 == 35\n\n\treturn (res1, res2)\n\n", "description": "\n\t\u0444-\u044f \u0438\u0437 2-\u0445 \u0448\u0430\u0433\u043e\u0432:\n\t", "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}, {"term": "def", "name": "make_calculateCacher", "data": "def make_calculateCacher(calc_cacher=None, *args, **kwargs):\n\tif calc_cacher:\n\t\treturn calc_cacher\n\n\td_to = kwargs.get(\"d_to\")\n\tif not d_to:\n\t\td_to = r\"s:\\python2.7\\Lib\\site-packages\\modules_projects\\temp\\!cache_calculate_with_cacher\\!from_tester\"\n\n\td = {\n\t\t\"want_cache\": True,\n\t\t\"d_to\": d_to,\n\t}\n\tkwargs = add_defaults(kwargs, d)\n\n\tcalc_cacher = CalculateCacher(*args, **kwargs)\n\treturn calc_cacher\n\n", "description": null, "category": "math", "imports": ["from modules import *", "from modules_mega_23.calculation_cacher import *"]}], [{"term": "def", "name": "main", "data": "def main():\n\tprime_list_path=\"/home/mint/Desktop/\"\n\tprime_list_filename=\"primes_upto_100000.csv\"\n\tprimefile=prime_list_path + prime_list_filename\n\tprint(\"primefile currently is: \"+str(primefile))\n\n\t#define prime list\n\t#print('Importing primes from csv file')\n\tprimes = csvfile_store_primes(primefile)\n\t#print('First ten primes are: '+str(primes[0:10]))\n\n\t#print(sys.version_info)\n\n\t#initialise g_values, p_values, and h_values\n\t\n\t#g_values = range(2,3)\n\tg_values = range(2,20)\n\tp_values = primes[0:101]\n\t#p_values = primes[0:1001]\n\t#h_values = range(2,201)\n\n\ttotal_g_values=len(g_values)\n\tprint(\"total_g_values: \"+str(total_g_values))\n\n\ttotal_p_values=len(p_values)\n\tprint(\"total_p_values: \"+str(total_p_values))\n\n\t#total_h_values=len(h_values)\n\t#print(\"total_h_values: \"+str(total_h_values)\n\n\tTotal_values = total_g_values * total_p_values \n\tprint(\"Total_values: \"+str(Total_values))\n\t#Grand_total_values = total_p_values * total_g_values * total_h_values\n\t#print(\"Grand_total_values: \"+str(Grand_total_values)\n\n\t#define counts for different types of results\n\tcount_nosolns=0\n\tcount_x_equals_0=0\n\tcount_normal_soln=0\n\tcount_needlargerprimelist=0\n\tcount_q_e_found=0\n\tcount_q_e_not_found=0\t\n\tcount_notprime=0\n\tcount_calc_xi_no_solns=0\n\tcount_order_not_prime=0\n\tcount_order_prime=0\n\tcount_xi_not_found=0\n\tcount_calc_xi_status_false=0\n\t\n\t#define lists for different types of results\n\tanswers_to_be_checked=[]\n\t#order_false_list=[]\n\tn_prime=[]\n\tq_e_nf_order_p_list=[]\n\n\t#dlp is:  g**x congruent to h mod p, where g, h and p are known, p prime.\n\n\tprint(\"======================================\")\n\n\tprint('Looping through values for g, p, & h..')\n\n\tprevious_calc_g_p=[]\n\tprevious_calc_orders=[]\n\tfor g in g_values:\n\t\tprint(\"g is:\",str(g))\n\t\torder = 0\t\t\n\t\t#h_values_no_solution = False\n\t\tfor p in p_values:\n\t\t\tprint(\"p is:\",str(p))\n\t\t\t#print(\"====================================\"\t\n\t\t\t#print(\"p is: \"+str(p)\t\n\t\t\tif g % p == 0:\n\t\t\t\tcount_nosolns = count_nosolns + len(range(1,p+1))\n\n\t\t\tif g > p:\t\t\t\n\t\t\t\tg_old = g\t\t\t\t\n\t\t\t\tg_new = g % p\n\t\t\t\tprint(\"g:\",g_old,\"> p:\",p,\"- revised g_new is:\",g_new)\n\t\t\t\t\n\t\t\t\t# 2 < order <= p - 1\n\t\t\t\t#no_prim_roots = p - 1 #for F_p this is euler_phi(p) = p-1 since p is prime.\t\t\t\t\t\n\t\t\t\n\t\t\t\tresult = Calc_prop_234(g_new,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false)\n\n\t\t\t\t#return count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\t\t\t\t#x_final=result[0]\n\t\t\t\tcount_nosolns=result[0]\n\t\t\t\tcount_calc_xi_no_solns=result[1]\n\t\t\t\tcount_normal_soln=result[2]\n\t\t\t\t#x_moduli_final=result[4]\n\t\t\t\tanswers_to_be_checked=result[3]\n\t\t\t\tcount_x_equals_0=result[4]\n\t\t\t\tcount_needlargerprimelist=result[5]\n\t\t\t\tcount_notprime=result[6]\n\t\t\t\tq_e_nf_order_p_list=result[7]\n\t\t\t\tcount_xi_not_found=result[8]\n\t\t\t\tcount_calc_xi_status_false=result[9]\n\t\t\t\tprevious_calc_orders=result[10]\n\n\t\t\telif str(g)+\"_\"+str(p) not in previous_calc_g_p:\n\t\t\t\n\t\t\t\tresult = Calc_prop_234(g,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false)\n\n\t\t\t\t#x_final=result[0]\n\t\t\t\tcount_nosolns=result[0]\n\t\t\t\tcount_calc_xi_no_solns=result[1]\n\t\t\t\tcount_normal_soln=result[2]\n\t\t\t\t#x_moduli_final=result[4]\n\t\t\t\tanswers_to_be_checked=result[3]\n\t\t\t\tcount_x_equals_0=result[4]\n\t\t\t\tcount_needlargerprimelist=result[5]\n\t\t\t\tcount_notprime=result[6]\n\t\t\t\tq_e_nf_order_p_list=result[7]\n\t\t\t\tcount_xi_not_found=result[8]\n\t\t\t\tcount_calc_xi_status_false=result[9]\n\t\t\t\tprevious_calc_orders=result[10]\n\n\t#print(\"Grand_total_considered: \"+str(Grand_total_values)+\", total_g_values: \"+str(total_g_values)+\", total_p_values: \"+str(total_p_values)+\", total_h_values: \"+str(total_h_values)+\", number_no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false))\n\n\tprint(\"total_g_values: \"+str(total_g_values)+\", total_p_values: \"+str(total_p_values)+\", number_no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false))\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "Calc_prop_234", "data": "def Calc_prop_234(g,p,count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p, previous_calc_orders, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, count_xi_not_found, count_calc_xi_status_false):\n\n\tprint(\"Running Calc_prop_234(\",g,\",\",p,\")\")\n\n\tif str(g)+\"_\"+str(p) in previous_calc_g_p:\n\t\t#Order for g & p has already been calculated previously\n\t\tprint(\"Order for g_new:\",g,\",p:\",p,\"has already been calculated previously\")\n\t\tinput(\"Waiting for user..\")\n\t\torder=\"\"\n\n\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\n\telif str(g)+\"_\"+str(p) not in previous_calc_g_p:\n\t\tg_p_to_append=[]\n\t\tg_p_to_append.append(str(g)+\"_\"+str(p))\n\t\tprevious_calc_g_p.append(g_p_to_append)\n\n\t\tif g == 1:\n\t\t\t#order = Not found!\n\t\t\tprint(\"order not found - g = 1\")\n\t\t\tcount_nosolns = count_nosolns + 1\n\t\t\tcount_order_not_prime = count_order_not_prime + 1\n\t\t\tcount_q_e_not_found = count_q_e_not_found + 1\n\t\t\torder=\"Not found\"\n\n\t\t\tg_p_order_to_append=[]\n\t\t\tg_p_order_to_append.append(str(g)+\"_\"+str(p))\n\t\t\tg_p_order_to_append.append(str(order))\n\t\t\tprevious_calc_orders.append(g_p_order_to_append)\n\n\t\telse:\n\t\t\tprint(\"previous_calc_orders:\",previous_calc_orders)\n\t\t\t#input(\"waiting for user..\")\n\t\t\tif g_p_to_append in previous_calc_orders:\n\t\t\t\tprint(\"g_p_to_append:\",g_p_to_append,\" is in previous_calc_orders\")\n\t\t\t\tprint(previous_calc_orders.index(g_p_order_to_append))\n\t\t\t\tinput(\"waiting for user..\")\n\n\t\t\telse:\n\t\t\t\t#Calculate order\n\t\t\t\tprint(\"g_p_to_append:\",g_p_to_append,\" is NOT in previous_calc_orders\")\n\t\t\t\tinput(\"waiting for user..\")\t\t\t\t\t\n\t\t\t\torder_result = calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p)\n\n\t\t\t\t#return count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\n\t\t\t\tcount_nosolns = order_result[0]\n\t\t\t\tcount_order_not_prime = order_result[1]\n\t\t\t\tcount_q_e_found = order_result[2]\n\t\t\t\tcount_q_e_not_found = order_result[3]\n\t\t\t\tq_e_nf_order_p_list = order_result[4]\n\t\t\t\tq = order_result[5]\n\t\t\t\te = order_result[6]\n\t\t\t\torder_status = order_result[7]\n\t\t\t\tn_prime = order_result[8]\n\t\t\t\tcount_order_prime = order_result[9]\n\t\t\t\torder = order_result[10]\n\t\t\t\tlhs = order_result[11]\n\t\t\t\tconcat_order_p=str(order)+\"_\"+str(p)\n\n\t\t\t\tg_p_order_to_append=[]\n\t\t\t\tg_p_order_to_append.append(str(g)+\"_\"+str(p))\n\t\t\t\tg_p_order_to_append.append(order)\n\t\t\t\tprevious_calc_orders.append(g_p_order_to_append)\n\t\t\t\t\n\t\t\t\tif str(order)+\"_\"+str(p) in q_e_nf_order_p_list:\n\t\t\t\t\t#print(str(order)+\"_\"+str(p),\"is in q_e_nf_order_p_list\")\n\t\t\t\t\t#elif concat_g_p in order_false_list:\n\t\t\t\t\tcount_nosolns = count_nosolns + len(range(1, p+1))\n\t\t\t\t\t#count_nosolns = count_nosolns + len(h_values)\n\t\t\t\t\t#print(\"Previously calculated - \"+str(concat_order_p)+\" is NOT in form q**e !\"\n\t\t\t\t\tx_final = \"No solns!\"\t\t\t\n\t\t\t\t\t#print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)+\", no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false)\n\t\t\t\telse:\n\t\t\t\t\th_soln_alreadyfound = False\n\t\t\t\t\tfor h in range(1, p+1):\n\t\t\t\t\t#for h in h_values:\t\t\t\t\t\t\t\t\n\t\t\t\t\t#concat_g_h = str(g)+\"_\"+str(h)\n\t\t\t\t\t\t#print(\"-----------------------------------\"\n\t\t\t\t\t\t#print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)\n\t\t\t\t\t\tif h >= p:\n\t\t\t\t\t\t\t#print(\"Setting h_soln_alreadyfound to true..\"\n\t\t\t\t\t\t\th_soln_alreadyfound = True\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\telif g == h:\n\t\t\t\t\t\t\tx_final = 1\n\t\t\t\t\t\t\tx_moduli_final = p - 1\n\t\t\t\t\t\t\tx_to_print = str(x_final)+\" mod \"+str(x_moduli_final)\n\t\n\t\t\t\t\t\t\t#Check answers\n\t\t\t\t\t\t\tif pow(g, x_final, p) != h:\n\t\t\t\t\t\t\t\tprint(\"CHECK x_final! g_new: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli: \"+str(x_moduli))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\telif pow(g, x_final + x_moduli_final, p) != h:\n\t\t\t\t\t\t\t\tprint(\"CHECK x_moduli_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli_final: \"+str(x_moduli_final))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t\t#print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t#print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)+\", no_solns: \"+str(count_nosolns)+\", largerprimelist: \"+str(count_needlargerprimelist)+\", count_q_e_found: \"+str(count_q_e_found)+\", count_q_e_not_found: \"+str(count_q_e_not_found)+\", count_order_prime: \"+str(count_order_prime)+\", count_order_not_prime: \"+str(count_order_not_prime)+\", count_xi_not_found: \"+str(count_xi_not_found)+\", count_calc_xi_status_false: \"+str(count_calc_xi_status_false)\t\t\t\t\t\t\t\n\t\n\t\t\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif order_status == True:\n\t\t\t\t\t\t\t\t#print(\"q is: \"+str(q)+\", e is: \"+str(e) \n\t\t\t\t\t\t\t\t#dlp is:  g**x congruent to h mod p, where g, h and p are known, p prime.\t\n\t\t\t\t\t\t\t\t#print('Running dlp()..')\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t#print(\"-----------------------------------\"\n\t\t\t\t\t\t\t\t#print(\"count_nosolns before dlp(): \"+str(count_nosolns)\n\n\t\t\t\t\t\t\t\tresult = dlp(g, p, h, count_nosolns, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, q_e_nf_order_p_list, primes, q, e, n_prime, count_xi_not_found, count_calc_xi_status_false, lhs)\n\n\t\t\t\t\t\t\t\t#print(\"return back to h_values loop..\"\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\tx_final = result[0]\n\t\t\t\t\t\t\t\tcount_nosolns = result[1]\n\t\t\t\t\t\t\t\tcount_calc_xi_no_solns = result[2]\n\t\t\t\t\t\t\t\tcount_normal_soln = result[3]\n\t\t\t\t\t\t\t\tx_moduli_final = result[4]\n\t\t\t\t\t\t\t\tanswers_to_be_checked.append(result[5])\n\t\t\t\t\t\t\t\tcount_x_equals_0 = result[6]\n\t\t\t\t\t\t\t\tcount_needlargerprimelist = result[7]\n\t\t\t\t\t\t\t\tcount_notprime = result[8]\n\t\t\t\t\t\t\t\tq_e_nf_order_p_list = result[9]\n\t\t\t\t\t\t\t\t#order_false_list = result[9]\n\t\t\t\t\t\t\t\tcount_xi_not_found = result[10]\n\t\t\t\t\t\t\t\tcount_calc_xi_status_false = result[11]\n\n\t\t\t\t\t\t\t\t#print(\"count_nosolns after dlp(): \"+str(count_nosolns)\n\t\t\t\t\t\t\t\t#print(\"x_final is: \"+str(x_final))\n\t\t\t\t\t\t\t\t#print(\"x_moduli_final is: \"+str(x_moduli_final)\n\t\t\t\t\t\t\t\tif x_final != \"No solns!\":\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t#print(\"x_final != No solns!\"\n\t\t\t\t\t\t\t\t\tx_to_print = str(x_final)+\" mod \"+str(x_moduli_final)\n\t\t\t\t\t\t\t\t\t#input(\"Waiting for user..\")\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t#Check answers\n\t\t\t\t\t\t\t\t\tif pow(g, x_final, p) != h:\n\t\t\t\t\t\t\t\t\t\tprint(\"CHECK x_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli: \"+str(x_moduli))\n\t\t\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t\t\telif pow(g, x_final + x_moduli_final, p) != h:\n\t\t\t\t\t\t\t\t\t\tprint(\"CHECK x_moduli_final! g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x_final)+\", x_moduli_final: \"+str(x_moduli_final))\n\t\t\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\n\n\t\t\t\t\t\t\t\t#print(\"g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", x: \"+str(x_final)\n\n\t\t\t\t\t\t\telif order_status != False:\n\t\t\t\t\t\t\t\tprint(\"***ERROR!!!*** order_status is: \"+str(order_status))\n\t\t\t\t\t\t\t\tinput(\"Waiting for user..\")\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t#error=True\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n\telse:\t\t\t\t\n\t\tprint(\"Order for g:\",g,\",p:\",p,\"does not match criteria - not in previous_calc_g_p!\")\n\n\n\t\treturn count_nosolns, count_calc_xi_no_solns, count_normal_soln, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false, previous_calc_orders\n\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "ghp_checks", "data": "def ghp_checks(g,h,p,floor_sqrt_p, count_a_notprime):\t\n\t\n\t#print(\"Running ghp_checks()..\"\n\n\t#Assuming p is prime: \t\tBest case: O(sqrt(n)+5)\t\tWorst case: O(sqrt(n)+8)\n\t#Assuming p is not prime: \tO(sqrt(n)+5)\n\n\tstatus=1\n\t\n\t#Simple Checks for g & h:\n\tif (g==0 or h==0):\t\t\t\t#O(1)\n\t\tprint('One or more numbers entered for g, h and p are 0. Please choose numbers that are not 0.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\telif g==1:\t\t\t\t\t#O(1)\n\t\tprint('g = 1 has trivial solutions for the dlp. Please choose another number.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\telif g<0:\t\t\t\t\t#O(1)\n\t\tprint('Number for g is negative. Please enter another number.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\n\t#Check if g = p:\n\telif g == p:\n\t\tprint('g = p. x is any integer. Please enter other numbers for g and p.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#Check if h < p:\n\telif h >= p:\n\t\tprint('h is >= p. Please enter other numbers for h and p.')\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#Need to check if p is prime\n\t#print('Checking if p is prime ..')\n\ta = isprime(p)\t\t\t\t\t#O(sqrt(n))\t\n\t#True for Prime\n\t#False for not prime\t\n\tif a == False:\t\t\t\t\t#O(1)\t#Best case: O(5)\n\t\tprint('The number entered for p: '+str(p)+' is not prime. Please choose a number that is prime for p.')\t\t\n\t\tstatus=0\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tcount_a_notprime = count_a_notprime + 1\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t#return status, a, b, q\n\treturn status, a\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "isprime", "data": "def isprime(p):\t\t\t#this is O(sqrt(n))\n\t\n\t#print(\"Running isprime(\",p,\")\")\n\t\n\t# www.rookieslab.com/posts/fastest-way-to-check-if-a-number-is-prime-or-not\n\tif p==1:\n\t\treturn False\t\n\t\t\n\ti = 2\n\twhile i*i <= p:\n\t\t#print(\"p is: \"+str(p)+\", i is: \"+str(i)\t\t#\"g = 4\" #\"p is: No exponent found, i is: 2\"\n\t\tif p % i == 0:\n\t\t\treturn False\n\t\ti += 1\n\n\treturn True\t\t\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "dlp", "data": "def dlp(g, p, h, count_nosolns, count_x_equals_0, count_normal_soln, count_needlargerprimelist, answers_to_be_checked, count_calc_xi_no_solns, count_notprime, q_e_nf_order_p_list, primes, q, e, n_prime, count_xi_not_found, count_calc_xi_status_false, lhs):\n\n\t#print(\"-------------------------------------------------\"\n\t#print(\"Running dlp(\"+str(g)+\", \"+str(p)+\", \"+str(h)+\"..)\"\n\n\tfloor_sqrt_p = int(math.floor(math.sqrt(p)))\t\t\t#O(3)\n\t#print('floor_sqrt_p is: '+str(floor_sqrt_p))\n\n\t#Run checks on g, h & p\t\n\t#result=ghp_checks(g,h,p,floor_sqrt_p)\n\t#count_notprime = 0\t\t\t\t\t\t#O(1)\n\t\n\tresult=ghp_checks(g, h, p, floor_sqrt_p, count_notprime) \t#Best case: O(sqrt(n)+5) \tWorst case: O(sqrt(n)+8)\n\t#return status, a\n\t#status=0 for problem and 1 for no problem\n\t#a=True for Prime, a=False for not prime\n\t\n\tstatus_ghp = result[0]\n\tstatus_isprime_a = result[1]\n\n\tif status_isprime_a == False:\t\t\t\t\t#O(1)\n\t\tcount_notprime = count_notprime + 1\t\t\t#O(1)\n\t\tprint(str(p),\" is not prime! Exiting..\")\t\n\t\tsys.exit()\t\t\t\t\t\t\t#O(1)\n\telif status_ghp == 0:\t\t\t\t\t\t#O(1)\n\t\tprint(\"At least one of checks for g, h or p failed! Exiting..\")\t\n\t\tsys.exit()\t\t\t\t\t\t\t#O(1)\n\telse:\n\t\t#store result of p and isprime(p) so later we do not need to run isprime(p) again\t\t\t\t\n\t\tn_prime.append(p)\n\t\t\n\t\t#print(\"n_prime is: \"+str(n_prime)\n\n\t\t#check if sqrt_p > largest element in primes\n\t\t#print('checking if square root of p > largest element in primes...')\n\t\tsqrt_p = math.sqrt(p)\t\t\t\t\t#O(1)\n\t\tlargest_prime = primes[-1]\t\t\t\t#O(???)\n\t\tif sqrt_p > largest_prime:\t\t\t\t#O(1)\t#Subtotal: O(4)\n\t\t\tprint('Square root of p - '+str(sqrt_p)+' is greater than largest prime in list - '+str(largest_prime)+'. Consider using a larger prime list. Exiting..')\n\t\t\tcount_needlargerprimelist = count_needlargerprimelist + 1\n\t\t\tsys.exit()\n\t\telse:\t\t\t\t\t\t\t#O(1)\n\t\t\t#initialise lists\t\n\t\t\tx=[]\t\t\n\t\t\tx_moduli=[]\n\t\t\t\t\t\n\t\t\t################################################\n\t\t\t# Prop_234 Algorithm\n\t\t\t\n\t\t\t#print(\"g: \"+str(g)+\", h: \"+str(h)+\", q: \"+str(q)+\", e: \"+str(e)+\", p: \"+str(p)\n\t\t\t#count_xi_not_found, count_calc_xi_status_false\n\t\t\tresult_prop_234 = prop_234(g, h, q, e, p, count_xi_not_found, count_calc_xi_status_false, lhs)\n\t\t\t#result_prop_234 = prop_234(g, h, q, e, p)\n\t\t\t\n\t\t\t#return x, M, calc_xi_status, xi_found, count_xi_not_found, count_calc_xi_status_false\n\t\t\n\t\t\tx_initial = result_prop_234[0]\n\t\t\tmoduli = result_prop_234[1]\n\t\t\tcalc_xi_status = result_prop_234[2]\t\t\t\t#O(1)\t\t\t\t\n\t\t\txi_found = result_prop_234[3]\t\t\t\t\t#O(1)\t\n\t\t\tcount_xi_not_found = result_prop_234[4]\n\t\t\tcount_calc_xi_status_false = result_prop_234[5]\n\n\t\t\t#print(\"calc_xi_status is: \"+str(calc_xi_status)\n\t\t\tif calc_xi_status == True and xi_found == True:\n\t\t\t\t#Calc_xi method found solutions\n\t\t\t\t#print(\"x_initial is: \"+str(x_initial))\n\t\t\t\tx.append(x_initial)\n\t\t\t\t#print(\"x is: \"+str(x[0]))\n\t\t\t\t#print str(x_initial)+\" appended to x\"\n\t\t\t\tif x_initial == 0:\t\t\n\t\t\t\t\t#print(\"x[0] = 0\")\n\t\t\t\t\tcount_x_equals_0 = count_x_equals_0 + 1 \n\t\t\t\t\tx_moduli.append(moduli)\n\t\t\t\t\tif moduli == 0:\n\t\t\t\t\t\tprint(\"x[0]=0 and x_moduli[0] is 0!\")\n\t\t\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t\telse:\n\t\t\t\t\t\tcount_normal_soln = count_normal_soln + 1\n\n\t\t\t\t\tif pow(g,x[0],p) != h:\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"CHECK ANSWER!!!\"\n\t\t\t\t\t\tprint(\"CHECK FAILED - g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x[0])+\", x_moduli: \"+str(x_moduli[0]))\n\t\t\t\t\t\tanswers_to_be_checked.append(\"g: \"+str(g)+\" h: \"+str(h)+\" p: \"+str(p)+\" x: \"+str(x[0]))\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\n\t\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\n\t\t\t\telse:\n\t\t\t\t\t#print(\"x[0] != 0\"\n\t\t\t\t\tx_moduli.append(moduli)\n\t\t\t\t\t#print str(result_prop_234[1])+\" appended to x_moduli\"\n\t\t\t\t\tif moduli == 0:\n\t\t\t\t\t\tprint(\"x[0] != 0 and moduli is 0!\")\n\t\t\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t\tcount_normal_soln = count_normal_soln + 1\n\t\t\t\t\tif pow(g,x[0],p) != h:\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"CHECK ANSWER!!!\"\n\t\t\t\t\t\tprint(\"CHECK FAILED - g: \"+str(g)+\", h: \"+str(h)+\", p: \"+str(p)+\", x_final: \"+str(x[0])+\", x_moduli: \"+str(x_moduli[0]))\n\t\t\t\t\t\tanswers_to_be_checked.append(str(g)+\"_\"+str(h)+\"_\"+str(p)+\"_\"+str(x[0]))\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\n\t\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, x_moduli[0], answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\n\t\t\telif xi_found == False:\n\t\t\t\t#input(\"xi_found = False ! \")\n\t\t\t\t#Calc_xi method failed to find solutions - an xi was not found !\n\t\t\t\t#print(\"Calc_xi method failed to find solutions - an xi was not found ! \"\n\t\t\t\t#x.append(0)\n\t\t\t\tx.append(\"No solns!\")\n\t\t\t\tcount_calc_xi_no_solns = count_calc_xi_no_solns + 1\n\t\t\t\tcount_nosolns = count_nosolns + 1\t\t\t\t#O(1)\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\t\t\telif calc_xi_status == False:\n\t\t\t\t#input(\"calc_xi_status = False ! \")\n\t\t\t\t#Calc_xi method failed to find solutions - lhs=1 and rhs=1\t\n\t\t\t\t#print(\"Calc_xi method failed to find solutions - calc_xi_status is false ! \"\n\t\t\t\tx.append(\"No solns!\")\n\t\t\t\t#x.append(0)\n\t\t\t\tcount_calc_xi_no_solns = count_calc_xi_no_solns + 1\n\t\t\t\tcount_nosolns = count_nosolns + 1\t\t\t\t#O(1)\n\t\t\t\t#sys.exit()\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n\t\t\telse:\n\t\t\t\tprint(\"calc_xi_status is: \"+str(calc_xi_status))\n\t\t\t\tprint(\"xi_found is: \"+str(calc_xi_status))\n\t\t\t\tinput(\"Waiting for user..\")\n\t\t\t\t#sys.exit()\n\n\t\t\t\treturn x[0], count_nosolns, count_calc_xi_no_solns, count_normal_soln, 0, answers_to_be_checked, count_x_equals_0, count_needlargerprimelist, count_notprime, q_e_nf_order_p_list, count_xi_not_found, count_calc_xi_status_false\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "fcalc_order", "data": "#def calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, order_false_list, primes, n_prime, count_order_prime):\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "fcalc_order", "data": "#def calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime):\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "calc_order", "data": "def calc_order(g, p, count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, primes, n_prime, count_order_prime, previous_calc_g_p):\n\n\t#print(\"Running calc_order(\"+str(g)+\", \"+str(p)+\", ..)\")\n\t#print(\"previous_calc_g_p:\",previous_calc_g_p)\n\t#print(\"Need to calculate & check order for: \"+str(g)+\"_\"+str(p)\n\t#print(\"Need to calculate & check order for: \"+str(concat_g_p)\t\t\t\t\t\n\n\t#use exponent function to get order of g mod p\n\tresult = exponent_g_p(g, p)\t\t\t\t#Worst: O(n + 7)\t#Best: O(8)\n\t#return x, status\n\t#status is False for \"no exponent found\"\t\n\t#status is True for exponent found\n\torder = result[0]\t\t\t\t\t#O(1)\n\tstatus = result[1]\t\t\t\t\t#O(1)\n\t#status = result[1]\t\t\t\t\t\n\n\t#print(\"order is: \"+str(order)\n\t#input(\"Waiting for user..\")\n\n\t#sqrt_order=math.floor(math.sqrt(order))\n\n\t# Now want order = q**e, where q is prime\n\t# obtain q and e \n\tif status == False:\t\t\t\t\t#O(1)\n\t\tq=0\t\t\t\t\t\t\t#O(1)\n\t\te=0\t\t\t\t\t\t\t#O(1)\n\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\tq_e_nf_order_p_list.append(concat_order_p)\t\t#O(1)\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\tcount_nosolns = count_nosolns + 1\t\t\t#O(1)\n\t\torder_status = False\n\t\tlhs = 0\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif order == 1:\t\t\t\t\t#O(1)\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tprint(\"q:\",q,\"e:\",e,\"g:\",g,\"p:\",p,)\n\t\t#input(\"Order is 1! Waiting for user..\")\n\t\t#print(\"order: \"+str(order)\n\t\t#order_false_list.append(str(g)+\"_\"+str(p))\n\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\tcount_nosolns = count_nosolns + 1\t\t\t#O(1)\n\t\t#x_final = \"No solns!\"\n\t\torder_status = False\n\t\t#counts_added = True\n\t\tq = 0\n\t\te = 0\n\t\tlhs = 0\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif order in n_prime:\t\t\t\t\n\t\t#print(\"order: \"+str(order)+\" is prime\"\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tcount_order_prime = count_order_prime + 1\t\t#O(1)\n\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\torder_status = True\n\t\tlhs = pow(g,1,p)\n\t\t#counts_added = True\n\t\t#print(\"q: \"+str(q)+\", e: \"+str(e)\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\telif isprime(order) == True:\t\t\t\t#O(sqrt(n))\n\t\t#True for prime\n\t\t#False for not prime\n\t\t#order is prime\n\t\t#print(\"order: \"+str(order)+\" is prime\"\n\t\tn_prime.append(order)\n\t\tq = order\t\t\t\t\t\t#O(1)\n\t\te = 1\t\t\t\t\t\t\t#O(1)\n\t\tcount_order_prime = count_order_prime + 1\t\t#O(1)\n\t\torder_status=True\n\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\tlhs = pow(g,1,p)\n\t\t#counts_added = True\n\t\t#print(\"q: \"+str(q)+\", e: \"+str(e)\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n\n\telse:\n\t\t#print(\"order is: \"+str(order)+\" - not 1 nor prime!\"\n\t\t#input(\"Waiting for user..\")\n\t\t#order is not 1 nor prime\t\t\n\t\tcount_order_not_prime = count_order_not_prime + 1\t#O(1)\n\n\t\t#now check if order is of form q**e, where q is prime, e>=1. \n\t\t#Need to find q and e.\n\t\t\t\t\t\n\t\tresult = calc_q_e(primes, order, p)\t\t\t#Worst: O(n**2+7n+4)\t#Best: O(12)\n\t\t#return q, e, result\n\n\t\tq=result[0]\t\t\t\t\t\t#O(1)\n\t\te=result[1]\t\t\t\t\t\t#O(1)\n\t\torder_status=result[2]\t\t\t\t\t#O(1)\n\t\t#status=result[2]\t\t\t\t\t\n\t\t#counts_added = False\t\t\t\t\n\t\t#print(\"order_status is: \"+str(order_status)\n\n\t\tif order_status == False:\n\t\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\t\t#order_false_list.append(str(g)+\"_\"+str(p))\t\t#O(1)\n\t\t\tcount_q_e_not_found = count_q_e_not_found + 1\t\t#O(1)\n\t\t\tlhs = 0\n\t\t\t#counts_added = True\n\t\telif order_status == True:\n\t\t\tlhs = pow(g,pow(q,e-1),p)\n\t\t\tcount_q_e_found = count_q_e_found + 1\t\t\t#O(1)\n\t\telse:\n\t\t\tprint(\"order_status is: \"+str(order_status))\n\t\t\tlhs = 0\n\t\t\tinput(\"Waiting for user..\")\n\t\t\tconcat_order_p = str(order)+\"_\"+str(p)\n\t\t\tq_e_nf_order_p_list.append(concat_order_p)\n\t\treturn count_nosolns, count_order_not_prime, count_q_e_found, count_q_e_not_found, q_e_nf_order_p_list, q, e, order_status, n_prime, count_order_prime, order, lhs\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "calc_q_e", "data": "def calc_q_e(primes, order, p):\n\t#print(\"Running calc_q_e()..\"\t\n\t#print(\"Running calc_q_e(primes, \"+str(k)+\", \"+str(p)+\")..\"\n\n\t#Worst: O(n**2+7n+4)\t#Best: O(12)\n\n\t#q needs to be prime, e >= 1 \n\t#p is prime\t\n\n\tresult=False\t\t\t#O(1)\n\tq=0\t\t\t\t#O(1)\n\te=0\t\t\t\t#O(1)\n\tn=1\t\t\t\t#O(1)\n\t#print(\"p is: \"+str(p)\n\t\n\t#***********\n\t#\"What should be used for calculating q & e - pow(prime,n) or pow(prime,n,p)??\")***********\n\n\tfor prime in primes:\t\t#O(n)\t#Worst: O(n**2+7n)\t#Best: O(8)\n\t\t#print(\"==================\"\n\t\tn = 1\t\t\t\t\t\n\t\t#print(\"n is: \"+str(n)+\", order is: \"+str(k) \t\t\n\t\t#print(\"prime is: \"+str(prime)+\", p is: \"+str(prime)\n\t\twhile result is False and prime < p and n <= order and pow(prime,n) <= order:\t#O(n)\t#Worst: O(n+7)\t#Best: O(7)\n\t\t\t#print(\"-----------------\"\n\t\t\t#print(\"n is: \"+str(n)+\", order is: \"+str(order) \n\t\t\t#print(\"prime is: \"+str(prime)+\", p is: \"+str(p)\n\t\t\t#print(\"prime ** n is: \"+str(prime**n)\n\t\t\tif pow(prime,n) == order:\t\t\t\t\t\t\t#O(2)\n\t\t\t\tq = prime\t\t\t\t\t\t#O(1)\n\t\t\t\te = n\t\t\t\t\t\t\t#O(1)\n\t\t\t\tresult = True\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"result is: \"+str(result)\t\t\t\t\n\t\t\t\tbreak\t\t\t\t\t\t\t#O(1)\n\t\t\telse:\n\t\t\t\tn = n + 1\t\t\t\t\t\t#O(1)\n\treturn q, e, result\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "exponent_g_p", "data": "def exponent_g_p(g, p):\n\t#print(\"Running exponent_g_p()..\"\n\n\t#Worst: O(n + 7)\t#Best: O(8)\n\n\tn=1\t\t\t\t\t\t#O(1)\n\tx=0\t\t\t\t\t\t#O(1)\n\tstatus=False\t\t\t\t\t#O(1)\n\twhile n < p:\t\t\t\t\t#O(n)\t#Worst: O(n + 7)\n\t\t#print(\"n is:\"+str(n)\n\t\tif pow(g,n,p) == 1:\t\t#O(2)\t#Worst: O(6)\n\t\t\tx = n\t\t\t\t#O(1)\n\t\t\tstatus=True\t\t\t#O(1)\n\t\t\tbreak\t\t\t\t#O(1)\n\t\telif pow(g,n,p) == -1:\t\t#O(2)\t#Worst: O(6)\n\t\t\tx = 2 * n\t\t\t#O(1)\n\t\t\tstatus=True\t\t\t#O(1)\n\t\t\tbreak\t\t\t\t#O(1)\n\t\tn = n + 1\t\t\t\t#O(1)\n\n\tif x==0:\t\t\t\t\t#O(1)\n\t\tx=\"No exponent found\"\t\t\t#O(1)\n\t\tstatus=False\t\t\t\t#O(1)\n\n\treturn x, status\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "a_exp_x_eq_r", "data": "def a_exp_x_eq_r(a,p,r):\n\t#print(\"Running a_exp_x_eq_r(\"+str(a)+\", \"+str(p)+\", \"+str(r)+\"..)\"\n\tx=1\n\tx_values=[]\n\tcount=0\n\tdiff=0\n\tfor x in range(0,2*p):\n\t\t#print(\"count is: \"+str(count)\t\t\n\t\tif pow(a,x,p) == r:\n\t\t\t#print(\"a**x % p is: \"+str(r)\n\t\t\tx_values.append(x)\n\t\t\t#print str(x)+\" appended to x_values\"\n\t\t\tcount=count+1\n\t\t\tif count==2:\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#print str(x)+\" appended to x_values\n\t\t\t\tdiff = x_values[1] - x_values[0]\t\t\t\t\n\t\t\t\t#print(\"diff is: \"+str(diff)\n\t\t\t\tbreak\n\t\t#x = x + 1\n\treturn diff\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "prop_234", "data": "def prop_234(g, h, qi, ei, p, count_xi_not_found, count_calc_xi_status_false, lhs):\n\t#print(\"-----------------------------------\"\n\t#print(\"Running prop_234(\"+str(g)+\", \"+str(h)+\", \"+str(qi)+\", \"+str(ei)+\", \"+str(p)+\"..) to solve for x...\"\n\t\n\t#g[var], h[var], qi[var], ei[var], p\n\t#let x = x_0 +x_1*(q)+x_2*(q**2)+...+x_{e-1}q^(e-1), with 0 <= x_i < q, and determine successively x_0, x_1, x_2, ...\n\n\t#print(\"qi is: \"+str(qi)\n\t#print(\"ei is: \"+str(ei)\n\n\t# constuct list of q_powers from 0 to e-1\n\tq_powers=[]\t\t\t\t\t\t#O(1)\n\n\t#when ei > 0: #worst: O(n+3)\t#best: O(3)\n\t#when ei = 0: O(3)\t\n\t#when ei not > 0 nor = 0: O(4)\n\n\t#first q_power will always be 1 (for k=0)\n\tif ei > 0:\t\t\t\t\t\t#O(1)\t#worst: O(n+3)\t#best: O(1)\n\t\tfor k in range(0,ei):\t\t\t\t\t#O(n)\n\t\t\tq_powers.append(pow(qi,k))\t\t\t#O(2)\n\t\t\t#q_powers.append(qi**k)\n\telif ei==0:\t\t\t\t\t\t#O(1)\t#worst: O(3)\n\t\tprint(\"ei = 0!\")\t\t\t\t\t\n\t\tsys.exit()\t\t\t\t\t#O(1)\n\n\telse:\t\t\t\t\t\t\t#O(1)\t#worst: O(4)\n\t\tprint(\"ei is: \",str(ei))\n\t\tsys.exit()\t\t\t\t\t#O(1)\n\n\t#print(\"q_powers are: \"+str(q_powers)\n\n\t#now want to calculate xi using function\t\n\tresult = calc_xi(q_powers, g, p, h, qi, ei, lhs)\n\t#return xi, calc_xi_status, xi_found\t\n\txi = result[0]\n\tcalc_xi_status = result[1]\n\txi_found = result[2]\n\n\t#Subtotal - Worst: O(n**2 + 7n + 3), Best: O(3) when calc_xi_status == False\n\tif calc_xi_status == False:\n\t\tcount_calc_xi_status_false = count_calc_xi_status_false + 1\n\t\t#print(\"Calc_xi_status is false! - g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", qi: \"+str(qi)+\", ei: \"+str(ei)\n\t\tx=0 \t\t\t\t\t\t#O(1)\n\t\tM=0\t\t\t\t\t\t#O(1)\n\t\t#input(\"Calc_xi method failed (lhs=rhs=1). Waiting for user..\")\n\telif xi_found == False:\t\t\t\t#O(1)\n\t\tcount_xi_not_found = count_xi_not_found + 1\n\t\t#print(\"An xi was not found! - g: \"+str(g)+\", p: \"+str(p)+\", h: \"+str(h)+\", qi: \"+str(qi)+\", ei: \"+str(ei)\n\t\tx=0 \t\t\t\t\t\t#O(1)\n\t\tM=0\t\t\t\t\t\t#O(1)\n\t\t#input(\"Calc_xi method failed (lhs=rhs=1). Waiting for user..\")\n\telif calc_xi_status == True and xi_found == True:\t\t#O(1)\t#Subtotal - Worst: O(n**2 + 7n + 2), Best: O(n+5) when only 1 as q_power\n\t\t#print(\"xi are: \"+str(xi)\n\n\t\t#print(\"---------------------------\"\n\t\n\t\t#print(\"q_powers are: \"+str(q_powers)\t\n\t\tfor q_power in q_powers: \t\t\t#O(n)\t#Worst: O(n**2 + 7n)\t#Best: O(n+4) - when only 1 as q_power\n\t\t\t#print(\"q_power is: \"+str(q_power)\n\t\t\t#print(\"index of q_power is: \"+str(q_powers.index(q_power))\n\t\t\t#print(\"xi[(q_powers.index(q_power))] is: \"+str(xi[(q_powers.index(q_power))])\t\t\n\t\t\ta=xi[q_powers.index(q_power)] \t\t\t\t\t\t\t#O(n+1)\n\t\t\tif q_power==1: \t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Adding \"+str(xi[q_powers.index(q_power)])+\" to x\"\n\t\t\t\tx = a\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#x = xi[q_powers.index(q_power)]\n\t\t\t\n\t\t\telse:\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Adding \"+str(xi[(q_powers.index(q_power))])+\"*\"+str(q_power)+\" to x, and reducing mod \"+str(qi**ei)\n\t\t\t\tx = (x + a * q_power) % pow(qi,ei)\t\t\t\t\t#O(4)\n\t\t\t\t#x = (x + xi[q_powers.index(q_power)]*q_power) % (pow(qi,ei))\t\n\t\t\t\n\t\tM = pow(qi,ei)\t\t\t\t\t#O(1)\n\t\t#print(\"x is: \"+str(x)+\" mod \"+str(M))\t\t\n\telse:\n\t\tprint(\"calc_xi_status is: \"+str(calc_xi_status))\n\t\tprint(\"xi_found are: \"+str(xi_found))\n\t\tinput(\"Waiting for user..\")\n\n\treturn x, M, calc_xi_status, xi_found, count_xi_not_found, count_calc_xi_status_false\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "calc_xi", "data": "def calc_xi(q_powers, g, p, h, qi, ei, lhs):\n\t#print(\"---------------------------\"\t\t\t\n\t#print(\"Running calc_xi(\"+str(q_powers)+\", \"+str(g)+\", \"+str(h)+\", \"+str(qi)+\", \"+str(ei)+\", \"+str(p)+\") ..\"\t\t\t\t\n\n\t#initialise xi, cumul_q_powers, cumul_xi_q_powers\n\txi = len(q_powers) * [0]\t\t\t\t#O(len(q_powers))\n\tcumul_q_powers=[]\t\t\t\t\t#O(1)\n\tcumul_xi_q_powers=[]\t\t\t\t\t#O(1)\n\tcalc_xi_status=True\t\t\t\t\t#O(1)\n\n\t#Loop through each q_power until xi are calculated\n\tfor q_power in q_powers:\n\t\t#print(\"q_power is: \"+str(q_power)\t\t\n\t\tif calc_xi_status == True:\n\t\t\tif q_power==1:\t\t\t\t\t\t\t#total (incl top lev if) = \n\t\t\t\t#solving for x_0\t\t\n\t\t\t\t#print(\"---------------------------\")\t\t\t\n\t\t\t\txi_found = False\n\t\t\t\t#print(\"Solving for xi[0] ..\")\t\t\t\t\n\t\t\t\t#print(\"q_power is: \"+str(q_power))\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t#lhs= pow(g,pow(qi,ei-1),p)\t\t\t\t#O(2)\n\t\t\t\t#lhs= (g**qi**(ei-1)) % p\t\t\t\t\n\t\t\t\t#print(\"lhs is: \"+str(lhs)) \t\t# lhs=76\t\n\t\t\t\t\t\n\t\t\t\trhs= pow(h,pow(qi,ei-1),p)\t\t\t\t#O(2)\n\t\t\t\t#rhs= (h**qi**(ei-1)) % p\t\t\t\t\n\t\t\t\t#print(\"rhs is: \"+str(rhs)) \t\t# rhs=1\t\t\n\t\t\t\n\t\t\t\tif lhs ==1 and rhs ==1:\t\t\t\t\t#O(1)\t\t#subtotal: O(2)\t#section= O(2n+6)\t\t\t\t\n\t\t\t\t\t#This method seems to fail for this instance. Try p-1/q method?? brute force search instead??\t\t\t\t\n\t\t\t\t\tcalc_xi_status=False\t\t\t\t#O(1)\n\n\t\t\t\telse:\t\t\t\t\t\t\t#O(1)\t\t#Worst: O(4n+1)\t#best: O(6)\n\t\t\t\t\tfor t in range(0, qi):\t\t\t\t#O(n)\t\t#Worst: O(4n)\t#best: O(5)\n\t\t\t\t\t\tif pow(lhs,t,p) == rhs:\t\t\t#O(2)\t\t#Worst: O(4)\t#best: O(4)\n\t\t\t\t\t\t#if lhs**t % p ==rhs:\t\t\t\t\t\n\t\t\t\t\t\t\txi[0]=t  # xi[0]=\t\t#O(1)\n\t\t\t\t\t\t\txi_found = True\n\t\t\t\t\t\t\t#print(\"xi[0] is: \"+str(t)\t\n\t\t\t\t\t\t\tbreak\t\t\t\t\n\n\t\t\t\tif calc_xi_status == True:\t\t\t\t#O(1)\t\t#subtotal= O(3)\n\t\t\t\t\tcumul_xi_q_powers.append(xi[0])\t\t\t#O(1)\n\t\t\t\t\tcumul_q_powers.append(1)\t\t\t#O(1)\n\t\t\t\t\t#print(\"cumul_xi_q_powers after append: \"+str(cumul_xi_q_powers)\n\t\t\t\t\t#print(\"cumul_q_powers after append: \"+str(cumul_q_powers)\n\t\t\telse:\t\t\t\t\t\t\t\t#O(1)\t\t#total (incl top lev if) = \n\t\t\t\t#solving for x_n (n!=0)\n\t\t\t\t#print(\"---------------------------\")\t\t\t\n\t\t\t\txi_found = False\n\t\t\t\t#print(\"solving for x_n (n!=0)..\"\t\t\t\n\t\t\t\t#print(\"q_power is: \"+str(q_power))\t\t\t\n\t\t\t\txi_number = q_powers.index(q_power)\t\t\t#O(n)\n\t\t\t\t#print(\"Solving for xi[\"+str(xi_number)+\"] ..\")\n\t\t\t\t#print(\"cumul_xi_q_powers before append: \"+str(cumul_xi_q_powers)\n\t\t\t\t#print(\"cumul_q_powers before append: \"+str(cumul_q_powers)\n\t\t\t\n\t\t\t\t#print(\"g is: \"+str(g) # g=\n\t\t\t\t#print(\"h is: \"+str(h) # h=\n\t\t\t\ta = xi_number-1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"xi[\"+str(a)+\"] is: \"+str(xi[a])) # xi[0]=0\t\n\t\t\t\n\t\t\t\t#print(\"qi is: \"+str(qi))\t#qi = \n\t\t\t\t#print(\"ei is: \"+str(ei))\t#ei = \n\t\t\t\n\t\t\t\t#print(\"cumul_xi_q_powers is: \"+str(cumul_xi_q_powers)\t\n\t\t\t\t#print(\"cumul_q_powers is: \"+str(cumul_q_powers)\t\t\n\t\t\t\n\t\t\t\tz=0\n\t\t\t\tfor cumul_xi_q_power in cumul_xi_q_powers:\t\t#O(n+1)\n\t\t\t\t\tz = z + cumul_xi_q_power\n\t\t\t\t\n\t\t\t\t#print(\"sum_cumul_xi_q_power is now: \"+str(z)\t\t\n\n\t\t\t\tif xi[xi_number-1] >= 0:\n\t\t\t\t\t#need to work out what g**-[x_0+x_1*q_power+x_2*q_power**2 + ...], mod p is!!!\n\t\t\t\t\t#print(\"xi[\"+str(xi_number-1)+\"] >= 0\")\n\t\t\t\t\t#print(\"Calculating modular inverse of \"+str(g)+\"**\"+str(-z)+\", mod \"+str(p))\t\t\t\n\t\t\t\t\t#print(\"Calculating modular inverse of \"+str(g)+\"**\"+str(-xi[xi_number-1])+\", mod \"+str(p))\t\t\t\t\n\t\t\t\t\tb = calc_modinverse(g, z, p)\t\t\t\t\t\t\t\t\t#O(n+5)\n\t\t\t\t\t#b = calc_modinverse(g, xi[xi_number-1], p) #b = \n\t\t\t\t\t#print(\"inverse is: \"+str(b)) #b = \t\t\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t#(ei - xi_number - 1)\n\n\t\t\t\t\t#print(\"(h * b)**qi**(ei - xi_number - 1) % p is: \"+str((h * b)**qi**(ei - xi_number - 1) % p)\n\t\t\t\t\trhs = pow(h * b,pow(qi,ei - xi_number - 1),p)\n\t\t\t\t\t#rhs = (h * b)**qi**(ei - xi_number - 1) % p\t\t\t\t\t\t#O(2n+2)\t\t\t\n\n\t\t\t\t\t#print(\"rhs is: \"+str(rhs))\t\t\t\t\t\t\t\t\n\n\t\t\t\t\tif lhs == 1 and rhs == 1:\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(4)\n\t\t\t\t\t\tprint(\"lhs == 1 and rhs == 1\")\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t#print(\"xi[\"+str(xi_number-1)+\"] >= 0, lhs=1, rhs=1, g: \"+str(g)+\" p: \"+str(p)+\" h: \"+str(h))\t\t\t\n\t\t\t\t\t\tcalc_xi_status=False\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\tprint(\"Calc_xi method failed. h is \"+str(h)+\", p is \"+str(p)+\", qi is \"+str(qi)+\", ei is \"+str(ei)+\", xi_number is \"+str(xi_number))\t\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\tsys.exit()\n\t\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(n**2+5n+1)\n\t\t\t\t\t\tfor t in range(0, qi):\t\t\t\t\t\t\t\t\t#O(n)\n\t\t\t\t\t\t\t#print(\"t is now: \"+str(t)\t\t\t\t\t\n\t\t\t\t\t\t\t#print(str(lhs)+\"**\"+str(t)+\" % \"+str(p)+\" is: \"+str(lhs**t % p))\n\t\t\t\t\t\t\tif lhs**t % p == rhs:\t\t\t\t\t\t\t\t#O(n+2)\n\t\t\t\t\t\t\t\txi[xi_number]=t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\t\t\txi_found = True\n\t\t\t\t\t\t\t\t#print(\"xi[\"+str(xi_number)+\"] is: \"+str(t)\t\t\t\t\t\n\t\t\t\t\t\t\t\tbreak\t\t\t\t\t\t\t\t\t\t#O(1)\n\n\t\t\t\t\tif calc_xi_status == True:\t\t\t\t\t\t\t\t\t#O(1)\t#Subtotal O(n**2+5n+1)\n\t\t\t\t\t\tcumul_xi_q_powers.append(q_power * xi[xi_number])\t\t\t\t\t\t#O(3)\n\t\t\t\t\t\t#print(\"Appended \"+str(q_power * xi_number)+\" to cumul_xi_q_powers\")\n\t\t\t\t\t\tcumul_q_powers.append(q_power)\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\t\t#print(\"Appended \"+str(q_power)+\" to cumul_q_powers\")\n\t\t\t\t\t\t#print(\"xi[\"+str(xi_number)+\"] is: \"+str(xi[xi_number]))\n\t\t\t\t\t\t#print(\"xi are now:\"+str(xi)\n\t\t\t\t\t\t#print(\"cumul_xi_q_powers after append: \"+str(cumul_xi_q_powers)\n\t\t\t\t\t\t#print(\"cumul_q_powers after append: \"+str(cumul_q_powers)\n\t\t\t\telse:\t\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\tprint(\"xi[\"+str(xi_number-1)+\"] is negative !!! CHECK\")\t\t\t\t\t\t\t\n\t\t\t\t\t#input(\"Waiting for user..\")\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\t\t\tsys.exit()\t\t\t\t\t\t\t\t\t\t\t\t#O(1)\n\t\t\n\t\t\t\t#print(\"lhs is: \"+str(lhs)\n\t\t\t\t#print(\"rhs is: \"+str(rhs)\n\n\t\t\t\t#print(\"rhs is: \"+str(rhs))\n\t\t\t\t#print(\"qi is: \"+str(qi)\n\treturn xi, calc_xi_status, xi_found\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "calc_modinverse", "data": "def calc_modinverse(g, power, p):\n\t#print(\"----------------\"\n\t#print(\"Running calc_modinverse()..\"\t\t\t\t\t#O(1)\n\t#print(\"g is: \"+str(g)\n\t#print(\"power is: \"+str(power)\n\t\n\tfloor_sqrt_p = math.floor(math.sqrt(p))\t\t\t\t\t#O(2)\n\n\t#this only works for p being prime!\t\n\tif isprime(p) == True:\t\t\t\t\t\t\t#O(1)\t#Subtotal O(2n+4)\n\t#if isprime(p,floor_sqrt_p) == 0:\t\n\t\tresult=g**(p-2)% p\t\t\t\t\t\t#O(n+2)\t#Subtotal O(2n+3)\n\t\t#print str(g)+\"**(-1) mod \"+str(p)+\" is: \"+str(result)\n\t\tc = result**power % p\t\t\t\t\t\t#O(n+1)\n\t\t#print(\"c is: \"+str(c)\t\n\t\t#print str(g)+\"**(-\"+str(power)+\") mod \"+str(p)+\" is: \"+str(c)\n\telse:\n\t\t#p is not prime!\n\t\t#print(\"p: \"+str(p)+\" is not prime!\"\n\t\tc = modinv(g, p)\t\t\t\t\t\t#O(n)\n\t\t#return x % m\n\t\t#print(\"inverse is: \"+str(c)\t\t\n\n\t\t#input(\"Waiting for user..\")\t\n\treturn c\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "calc_powers", "data": "def calc_powers(factors):\n\t#Worst: O(n+13)\t#Best: O(18)\n\n\t#print(\"Running calc_powers..\"\n\t#Now want to find max powers m for each factor in factors.\n\t#can do this by counting unique factors\t\t\t\n\tprime_factors=[]\t\t\t\t\t#O(1)\n\tpowers = []\t\t\t\t\t\t#O(1)\n\tfac_list = []\t\t\t\t\t\t#O(1)\n\tcount = 0\t\t\t\t\t\t#O(1)\n\tc_primefactors_powers = 0\t\t\t\t#O(1)\n\ts_before_calc_powers = time.clock()\t\t\t#O(1)\n\tfor factor in factors:\t\t\t\t\t#O(n)\t#Worst: O(n**2 + 2n)\t#Best: O(???)\n\t\t#print(\"------------------\"\t\n\t\t#print(\"factor is: \"+str(factor)\t\t\n\t\tif fac_list:\t\t\t\t\t\t#O(1)\t#Worst: O(n+2)\t#Best: O(4)\n\t\t\t#temp factor list for comparisons has values\n\t\t\tif factor in fac_list:\t\t\t\t\t#O(n)\t#Worst: O(n+1)\t#Best: O(6)\n\t\t\t\t#print str(factor)+\" is in fac_list\"\n\t\t\t\tcount += 1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#temp_factor, temp_count = factor, count\n\t\t\t\t#print temp_factor, temp_count\n\t\t\telse:\t\t\t\t\t\t\t#O(1)\n\t\t\t\t#factor is not in fac_list\n\t\t\t\t#add factor to prime_factors\n\t\t\t\tprime_factors.append(factor)\t\t\t\t#O(1)\n\t\t\t\t#print(\"Added \"+str(factor)+\" to prime_factors\"\n\t\t\t\t#print(\"prime_factors is: \"+str(prime_factors)\n\t\t\t\t#add current count to powers for previous factor\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\tpowers.append(count)\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"Added \"+str(count)+\" to powers for previous factor\"\n\t\t\t\t#count = 0\n\t\t\t\t#print str(factor)+\" is NOT in fac_list\"\n\t\t\t\t#append it\t\t\t\t\n\t\t\t\tfac_list.append(factor)\t\t\t\t\t#O(1)\n\t\t\t\t#count += 1\n\t\t\t\tcount = 1\t\t\t\t\t\t#O(1)\n\t\t\t\t#print(\"count is: \"+str(count)\n\t\t\t\t#print(\"fac_list is: \"+str(fac_list)\n\t\t\t\t\n\t\telse:\t\t\t\t\t\t\t\t#O(1)\t#Subtotal: O(4)\n\t\t\t#temp factor list for comparisons is empty\n\t\t\t#store 1st factor\n\t\t\t#print(\"fac_list is empty\"\n\t\t\tfac_list.append(factor)\t\t\t\t\t\t#O(1)\n\t\t\t#print str(factor)+\" added to fac_list\"\n\t\t\tprime_factors.append(factor)\t\t\t\t\t#O(1)\n\t\t\t#print(\"Added \"+str(factor)+\" to prime_factors\"\n\t\t\t#print(\"prime_factors is: \"+str(prime_factors)\t\t\t\n\t\t\tcount += 1\t\t\t\t\t\t\t#O(1)\n\t\t\t#print(\"count is: \"+str(count)\t\n\n\t#add count to powers for the last factor and the last factor\n\tpowers.append(count)\n\t#print(\"Added \"+str(count)+\" to powers for previous factor\"\n\t\n\t#print(\"prime_factors are: \"+str(prime_factors)\n\t#print(\"powers are: \"+str(powers)\n\n\tc_calc_powers = time.clock() - s_before_calc_powers\n\n\treturn prime_factors, powers, c_calc_powers\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "csvfile_store_primes", "data": "def csvfile_store_primes(csv_filename_var):\t\t### Assumming O(n+len(z1)+1) ### \n\t\t\n\twith open(csv_filename_var,'r') as csvfile:\n\t\t# Strip quotes, eol chars etc, and convert strings to integers\n\t\t#Use generator to get number of primes to use in prime file..\n\t\tz1=(int(x) for row in csv.reader(csvfile) for x in row)\t\t\t#O(n) - Potentially y rows and x items in each row, \n\t\t\t\t\t\t\t\t\t\t\t# however only 1 row in csvfile being used. Hence x*y=x items to store\n\t\tprimes=list(z1)\t\t\t\t\t\t\t\t#O(len(z1))\n\t\tcsvfile.close()\t\t\t\t\t\t\t\t#O(1 ???)\n\treturn primes\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "factorise", "data": "def factorise(N):\t\t\n\t#based on code on https://stackoverflow.com/questions/16996217/prime-factorization-list/\n\t#Author states this is is O(sqrt(n))) and 2 to 3 times faster than trial division in practice\n\t#Wheel factorization, which uses a cyclic set of gaps between potential primes to greatly\n\t#reduce the number of trial divisions.\n\t#uses a 2,3,5-wheel\n\n\t#print(\"Running factorise(\"+str(N)+\")..\"\t\n\n\t#Create lists to hold prime factors of N and corresponding powers\n\tfactors = []\t\t\t\t\t#O(1)\n\n\t#print(\"Calculating prime factors and powers\"\n\ts_before_factorisations = time.clock()\t\t\n\t\t\n\tgaps=[1,2,2,4,2,4,2,4,6,2,6]\t\t\t#O(1)\n\tlength, cycle = 11,3\t\t\t\t#O(1)\n\tf, factors, next = 2, [], 0\t\t\t#O(1)\n\twhile f*f <= N:\t\t\t\t\t#O(n)\n\t\twhile N % f == 0:\t\t\t\t#O(n)\n\t\t\t#f is a factor. Add factor f to fs\n\t\t\tfactors.append(f)\t\t\t\t#O(1)\n\t\t\tN /= f\t\t\t\t\t\t#O(1)\n\t\tf += gaps[next]\t\t\t\t#O(1)\n\t\tnext += 1\t\t\t\t#O(1)\n\t\tif next == length:\t\t\t#O(1)\n\t\t\tnext = cycle\t\t\t\t#O(1)\n\tif N > 1: factors.append(N)\n\t\t\n\tc_factorisations = time.clock() - s_before_factorisations\t#O(1)\n\n\treturn factors, c_factorisations\t\t#O(1)\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "size_input_check", "data": "def size_input_check(input_number):\n\n\t#if size of number >= 2*10^8 then return message about memory & exit\n\tif input_number>2*(10**8):\n\t\tprint('Number to attempt to factorise is too large for this program. Try a number <= 2x10^8. Exiting to avoid memory issues..')\n\t\tsys.exit()\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "egcd", "data": "def egcd(a, b):\t\t\t\t\t\t\t#O(n)\n\t#print(\"Running egcd(\"+str(a)+\",\"+str(b)+\")\")\n\t#print(\"a is: \"+str(a)\n\t#print(\"b is: \"+str(b)\t\n\tif a == 0:\t\t\t\t\t\t#O(1)\t#Subtotal: O(2)\n\t\treturn (b, 0, a)\t\t\t\t#O(1)\n\tg, y, x = egcd(b % a, a)\t\t\t\t\n\t#print(\"egcd(\"+str(a)+\",\"+str(b)+\") is: \"+str(g)+\" \"+str(x - (b//a) * y)+\" \"+str(y))\n\treturn (g, x - (b//a) * y, y)\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}, {"term": "def", "name": "modinv", "data": "def modinv(a, m):\t\t\t\t\t\t#### O(n+5) ###\n\t#print(\"Running modinv(\"+str(a)+\",\"+str(m)+\")\")\t\t\n\t#print(\"a is: \"+str(a)\n\t#print(\"m is: \"+str(m)\t\n\t#egcd(a, m)\n\tg, x, y = egcd(a, m)\t\t\t\t\t#O(n)\n\tif g != 1:\t\t\t\t\t\t\t#O(1)\t#Subtotal: O(2)\n\t\traise Exception('No Modular Inverse') \t\t\t#O(1)\n\t#print(str(a)+\"**(-1) mod \"+str(m)+\" is: \"+str(x % m))\t\n\treturn x % m\t\t\t\t\t\t#O(1)\n\n", "description": null, "category": "math", "imports": ["import sys", "import math", "\tfrom math import gcd as bltin_gcd", "\tfrom fractions import gcd", "import os", "import itertools", "import csv", "import time"]}], [{"term": "class", "name": "Relocation", "data": "class Relocation(object):\n\t\"\"\" Relocation object - representing a single relocation entry. Allows\n\t\tdictionary-like access to the entry's fields.\n\n\t\tCan be either a REL or RELA relocation.\n\t\"\"\"\n\tdef __init__(self, entry, elffile):\n\t\tself.entry = entry\n\t\tself.elffile = elffile\n\t\t\n\tdef is_RELA(self):\n\t\t\"\"\" Is this a RELA relocation? If not, it's REL.\n\t\t\"\"\"\n\t\treturn 'r_addend' in self.entry\n\t\t\n\tdef __getitem__(self, name):\n\t\t\"\"\" Dict-like access to entries\n\t\t\"\"\"\n\t\treturn self.entry[name]\n\n\tdef __repr__(self):\n\t\treturn '' % (\n\t\t\t\t'RELA' if self.is_RELA() else 'REL',\n\t\t\t\tself.entry)\n\n\tdef __str__(self):\n\t\treturn self.__repr__()\n\n", "description": " Relocation object - representing a single relocation entry. Allows\n\t\tdictionary-like access to the entry's fields.\n\n\t\tCan be either a REL or RELA relocation.\n\t", "category": "math", "imports": ["from collections import namedtuple", "from ..common.exceptions import ELFRelocationError", "from ..common.utils import elf_assert, struct_parse", "from .sections import Section", "from .enums import ENUM_RELOC_TYPE_i386, ENUM_RELOC_TYPE_x64"]}, {"term": "class", "name": "RelocationSection", "data": "class RelocationSection(Section):\n\t\"\"\" ELF relocation section. Serves as a collection of Relocation entries.\n\t\"\"\"\n\tdef __init__(self, header, name, stream, elffile):\n\t\tsuper(RelocationSection, self).__init__(header, name, stream)\n\t\tself.elffile = elffile\n\t\tself.elfstructs = self.elffile.structs\n\t\tif self.header['sh_type'] == 'SHT_REL':\n\t\t\texpected_size = self.elfstructs.Elf_Rel.sizeof()\n\t\t\tself.entry_struct = self.elfstructs.Elf_Rel\n\t\telif self.header['sh_type'] == 'SHT_RELA':\n\t\t\texpected_size = self.elfstructs.Elf_Rela.sizeof()\n\t\t\tself.entry_struct = self.elfstructs.Elf_Rela\n\t\telse:\n\t\t\telf_assert(False, 'Unknown relocation type section')\n\n\t\telf_assert(\n\t\t\tself.header['sh_entsize'] == expected_size,\n\t\t\t'Expected sh_entsize of SHT_REL section to be %s' % expected_size)\n\n\tdef is_RELA(self):\n\t\t\"\"\" Is this a RELA relocation section? If not, it's REL.\n\t\t\"\"\"\n\t\treturn self.header['sh_type'] == 'SHT_RELA'\n\n\tdef num_relocations(self):\n\t\t\"\"\" Number of relocations in the section\n\t\t\"\"\"\n\t\treturn self['sh_size'] // self['sh_entsize']\n\n\tdef get_relocation(self, n):\n\t\t\"\"\" Get the relocation at index #n from the section (Relocation object)\n\t\t\"\"\"\n\t\tentry_offset = self['sh_offset'] + n * self['sh_entsize']\n\t\tentry = struct_parse(\n\t\t\tself.entry_struct,\n\t\t\tself.stream,\n\t\t\tstream_pos=entry_offset)\n\t\treturn Relocation(entry, self.elffile)\n\n\tdef iter_relocations(self):\n\t\t\"\"\" Yield all the relocations in the section\n\t\t\"\"\"\n\t\tfor i in range(self.num_relocations()):\n\t\t\tyield self.get_relocation(i)\n\n", "description": " ELF relocation section. Serves as a collection of Relocation entries.\n\t", "category": "math", "imports": ["from collections import namedtuple", "from ..common.exceptions import ELFRelocationError", "from ..common.utils import elf_assert, struct_parse", "from .sections import Section", "from .enums import ENUM_RELOC_TYPE_i386, ENUM_RELOC_TYPE_x64"]}, {"term": "class", "name": "RelocationHandler", "data": "class RelocationHandler(object):\n\t\"\"\" Handles the logic of relocations in ELF files.\n\t\"\"\"\n\tdef __init__(self, elffile):\n\t\tself.elffile = elffile\n\n\tdef find_relocations_for_section(self, section):\n\t\t\"\"\" Given a section, find the relocation section for it in the ELF\n\t\t\tfile. Return a RelocationSection object, or None if none was\n\t\t\tfound.\n\t\t\"\"\"\n\t\treloc_section_names = (\n\t\t\t\tb'.rel' + section.name,\n\t\t\t\tb'.rela' + section.name)\n\t\t# Find the relocation section aimed at this one. Currently assume\n\t\t# that either .rel or .rela section exists for this section, but\n\t\t# not both.\n\t\tfor relsection in self.elffile.iter_sections():\n\t\t\tif (\tisinstance(relsection, RelocationSection) and\n\t\t\t\t\trelsection.name in reloc_section_names):\n\t\t\t\treturn relsection\n\t\treturn None\n\t\t\n\tdef apply_section_relocations(self, stream, reloc_section):\n\t\t\"\"\" Apply all relocations in reloc_section (a RelocationSection object)\n\t\t\tto the given stream, that contains the data of the section that is\n\t\t\tbeing relocated. The stream is modified as a result.\n\t\t\"\"\"\n\t\t# The symbol table associated with this relocation section\n\t\tsymtab = self.elffile.get_section(reloc_section['sh_link'])\n\t\tfor reloc in reloc_section.iter_relocations():\n\t\t\tself._do_apply_relocation(stream, reloc, symtab)\n\n\tdef _do_apply_relocation(self, stream, reloc, symtab):\n\t\t# Preparations for performing the relocation: obtain the value of\n\t\t# the symbol mentioned in the relocation, as well as the relocation\n\t\t# recipe which tells us how to actually perform it.\n\t\t# All peppered with some sanity checking.\n\t\tif reloc['r_info_sym'] >= symtab.num_symbols():\n\t\t\traise ELFRelocationError(\n\t\t\t\t'Invalid symbol reference in relocation: index %s' % (\n\t\t\t\t\treloc['r_info_sym']))\n\t\tsym_value = symtab.get_symbol(reloc['r_info_sym'])['st_value']\n\n\t\treloc_type = reloc['r_info_type']\n\t\trecipe = None\n\n\t\tif self.elffile.get_machine_arch() == 'x86':\n\t\t\tif reloc.is_RELA():\n\t\t\t\traise ELFRelocationError(\n\t\t\t\t\t'Unexpected RELA relocation for x86: %s' % reloc)\n\t\t\trecipe = self._RELOCATION_RECIPES_X86.get(reloc_type, None)\n\t\telif self.elffile.get_machine_arch() == 'x64':\n\t\t\tif not reloc.is_RELA():\n\t\t\t\traise ELFRelocationError(\n\t\t\t\t\t'Unexpected REL relocation for x64: %s' % reloc)\n\t\t\trecipe = self._RELOCATION_RECIPES_X64.get(reloc_type, None)\n\n\t\tif recipe is None:\n\t\t\traise ELFRelocationError(\n\t\t\t\t\t'Unsupported relocation type: %s' % reloc_type)\n\n\t\t# So now we have everything we need to actually perform the relocation.\n\t\t# Let's get to it:\n\n\t\t# 0. Find out which struct we're going to be using to read this value\n\t\t#\tfrom the stream and write it back.\n\t\tif recipe.bytesize == 4:\n\t\t\tvalue_struct = self.elffile.structs.Elf_word('')\n\t\telif recipe.bytesize == 8:\n\t\t\tvalue_struct = self.elffile.structs.Elf_word64('')\n\t\telse:\n\t\t\traise ELFRelocationError('Invalid bytesize %s for relocation' % \n\t\t\t\t\trecipe_bytesize)\n\n\t\t# 1. Read the value from the stream (with correct size and endianness)\n\t\toriginal_value = struct_parse(\n\t\t\tvalue_struct,\n\t\t\tstream,\n\t\t\tstream_pos=reloc['r_offset'])\n\t\t# 2. Apply the relocation to the value, acting according to the recipe\n\t\trelocated_value = recipe.calc_func(\n\t\t\tvalue=original_value,\n\t\t\tsym_value=sym_value,\n\t\t\toffset=reloc['r_offset'],\n\t\t\taddend=reloc['r_addend'] if recipe.has_addend else 0)\n\t\t# 3. Write the relocated value back into the stream\n\t\tstream.seek(reloc['r_offset'])\n\t\tvalue_struct.build_stream(relocated_value, stream)\n\n\t# Relocations are represented by \"recipes\". Each recipe specifies:\n\t#  bytesize: The number of bytes to read (and write back) to the section.\n\t#\t\t\tThis is the unit of data on which relocation is performed.\n\t#  has_addend: Does this relocation have an extra addend?\n\t#  calc_func: A function that performs the relocation on an extracted\n\t#\t\t\t value, and returns the updated value.\n\t#\n\t_RELOCATION_RECIPE_TYPE = namedtuple('_RELOCATION_RECIPE_TYPE',\n\t\t'bytesize has_addend calc_func')\n\n\tdef _reloc_calc_identity(value, sym_value, offset, addend=0):\n\t\treturn value\n\n\tdef _reloc_calc_sym_plus_value(value, sym_value, offset, addend=0):\n\t\treturn sym_value + value\n\n\tdef _reloc_calc_sym_plus_value_pcrel(value, sym_value, offset, addend=0):\n\t\treturn sym_value + value - offset\n\t\t\n\tdef _reloc_calc_sym_plus_addend(value, sym_value, offset, addend=0):\n\t\treturn sym_value + addend\n\t\t\n\t_RELOCATION_RECIPES_X86 = {\n\t\tENUM_RELOC_TYPE_i386['R_386_NONE']: _RELOCATION_RECIPE_TYPE(\n\t\t\tbytesize=4, has_addend=False, calc_func=_reloc_calc_identity),\n\t\tENUM_RELOC_TYPE_i386['R_386_32']: _RELOCATION_RECIPE_TYPE(\n\t\t\tbytesize=4, has_addend=False,\n\t\t\tcalc_func=_reloc_calc_sym_plus_value),\n\t\tENUM_RELOC_TYPE_i386['R_386_PC32']: _RELOCATION_RECIPE_TYPE(\n\t\t\tbytesize=4, has_addend=False,\n\t\t\tcalc_func=_reloc_calc_sym_plus_value_pcrel),\n\t}\n\t\n\t_RELOCATION_RECIPES_X64 = {\n\t\tENUM_RELOC_TYPE_x64['R_X86_64_NONE']: _RELOCATION_RECIPE_TYPE(\n\t\t\tbytesize=8, has_addend=True, calc_func=_reloc_calc_identity),\n\t\tENUM_RELOC_TYPE_x64['R_X86_64_64']: _RELOCATION_RECIPE_TYPE(\n\t\t\tbytesize=8, has_addend=True, calc_func=_reloc_calc_sym_plus_addend),\n\t\tENUM_RELOC_TYPE_x64['R_X86_64_32']: _RELOCATION_RECIPE_TYPE(\n\t\t\tbytesize=4, has_addend=True, calc_func=_reloc_calc_sym_plus_addend),\n\t\tENUM_RELOC_TYPE_x64['R_X86_64_32S']: _RELOCATION_RECIPE_TYPE(\n\t\t\tbytesize=4, has_addend=True, calc_func=_reloc_calc_sym_plus_addend),\n\t}\n\n\n", "description": " Handles the logic of relocations in ELF files.\n\t", "category": "math", "imports": ["from collections import namedtuple", "from ..common.exceptions import ELFRelocationError", "from ..common.utils import elf_assert, struct_parse", "from .sections import Section", "from .enums import ENUM_RELOC_TYPE_i386, ENUM_RELOC_TYPE_x64"]}], [], [{"term": "class", "name": "WorkbookProperties", "data": "class WorkbookProperties(Serialisable):\n\ttagname: str\n\tdate1904: Any\n\tdateCompatibility: Any\n\tshowObjects: Any\n\tshowBorderUnselectedTables: Any\n\tfilterPrivacy: Any\n\tpromptedSolutions: Any\n\tshowInkAnnotation: Any\n\tbackupFile: Any\n\tsaveExternalLinkValues: Any\n\tupdateLinks: Any\n\tcodeName: Any\n\thidePivotFieldList: Any\n\tshowPivotChartFilter: Any\n\tallowRefreshQuery: Any\n\tpublishItems: Any\n\tcheckCompatibility: Any\n\tautoCompressPictures: Any\n\trefreshAllConnections: Any\n\tdefaultThemeVersion: Any\n\tdef __init__(\n\t\tself,\n\t\tdate1904: Any | None = ...,\n\t\tdateCompatibility: Any | None = ...,\n\t\tshowObjects: Any | None = ...,\n\t\tshowBorderUnselectedTables: Any | None = ...,\n\t\tfilterPrivacy: Any | None = ...,\n\t\tpromptedSolutions: Any | None = ...,\n\t\tshowInkAnnotation: Any | None = ...,\n\t\tbackupFile: Any | None = ...,\n\t\tsaveExternalLinkValues: Any | None = ...,\n\t\tupdateLinks: Any | None = ...,\n\t\tcodeName: Any | None = ...,\n\t\thidePivotFieldList: Any | None = ...,\n\t\tshowPivotChartFilter: Any | None = ...,\n\t\tallowRefreshQuery: Any | None = ...,\n\t\tpublishItems: Any | None = ...,\n\t\tcheckCompatibility: Any | None = ...,\n\t\tautoCompressPictures: Any | None = ...,\n\t\trefreshAllConnections: Any | None = ...,\n\t\tdefaultThemeVersion: Any | None = ...,\n\t) -> None: ...\n", "description": null, "category": "math", "imports": ["from typing import Any", "from openpyxl.descriptors.serialisable import Serialisable"]}, {"term": "class", "name": "CalcProperties", "data": "class CalcProperties(Serialisable):\n\ttagname: str\n\tcalcId: Any\n\tcalcMode: Any\n\tfullCalcOnLoad: Any\n\trefMode: Any\n\titerate: Any\n\titerateCount: Any\n\titerateDelta: Any\n\tfullPrecision: Any\n\tcalcCompleted: Any\n\tcalcOnSave: Any\n\tconcurrentCalc: Any\n\tconcurrentManualCount: Any\n\tforceFullCalc: Any\n\tdef __init__(\n\t\tself,\n\t\tcalcId: int = ...,\n\t\tcalcMode: Any | None = ...,\n\t\tfullCalcOnLoad: bool = ...,\n\t\trefMode: Any | None = ...,\n\t\titerate: Any | None = ...,\n\t\titerateCount: Any | None = ...,\n\t\titerateDelta: Any | None = ...,\n\t\tfullPrecision: Any | None = ...,\n\t\tcalcCompleted: Any | None = ...,\n\t\tcalcOnSave: Any | None = ...,\n\t\tconcurrentCalc: Any | None = ...,\n\t\tconcurrentManualCount: Any | None = ...,\n\t\tforceFullCalc: Any | None = ...,\n\t) -> None: ...\n", "description": null, "category": "math", "imports": ["from typing import Any", "from openpyxl.descriptors.serialisable import Serialisable"]}, {"term": "class", "name": "FileVersion", "data": "class FileVersion(Serialisable):\n\ttagname: str\n\tappName: Any\n\tlastEdited: Any\n\tlowestEdited: Any\n\trupBuild: Any\n\tcodeName: Any\n\tdef __init__(\n\t\tself,\n\t\tappName: Any | None = ...,\n\t\tlastEdited: Any | None = ...,\n\t\tlowestEdited: Any | None = ...,\n\t\trupBuild: Any | None = ...,\n\t\tcodeName: Any | None = ...,\n\t) -> None: ...\n", "description": null, "category": "math", "imports": ["from typing import Any", "from openpyxl.descriptors.serialisable import Serialisable"]}]]