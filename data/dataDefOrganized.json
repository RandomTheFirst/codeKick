[[{"term": "def", "name": "dump_packet", "data": "def dump_packet(data): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional, Type", "from .charset import MBLENGTH as MBLENGTH, charset_by_name as charset_by_name, charset_by_id as charset_by_id", "from .cursors import Cursor as Cursor", "from .constants import FIELD_TYPE as FIELD_TYPE, FLAG as FLAG", "from .constants import SERVER_STATUS as SERVER_STATUS", "from .constants import CLIENT as CLIENT", "from .constants import COMMAND as COMMAND", "from .util import join_bytes as join_bytes, byte2int as byte2int, int2byte as int2byte", "from .converters import escape_item as escape_item, encoders as encoders, decoders as decoders", "from .err import raise_mysql_exception as raise_mysql_exception, Warning as Warning, Error as Error, InterfaceError as InterfaceError, DataError as DataError, DatabaseError as DatabaseError, OperationalError as OperationalError, IntegrityError as IntegrityError, InternalError as InternalError, NotSupportedError as NotSupportedError, ProgrammingError as ProgrammingError"]}, {"term": "class", "name": "classRandStruct_323:", "data": "class RandStruct_323:\n\tmax_value: Any\n\tseed1: Any\n\tseed2: Any\n\tdef __init__(self, seed1, seed2): ...\n\tdef my_rnd(self): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional, Type", "from .charset import MBLENGTH as MBLENGTH, charset_by_name as charset_by_name, charset_by_id as charset_by_id", "from .cursors import Cursor as Cursor", "from .constants import FIELD_TYPE as FIELD_TYPE, FLAG as FLAG", "from .constants import SERVER_STATUS as SERVER_STATUS", "from .constants import CLIENT as CLIENT", "from .constants import COMMAND as COMMAND", "from .util import join_bytes as join_bytes, byte2int as byte2int, int2byte as int2byte", "from .converters import escape_item as escape_item, encoders as encoders, decoders as decoders", "from .err import raise_mysql_exception as raise_mysql_exception, Warning as Warning, Error as Error, InterfaceError as InterfaceError, DataError as DataError, DatabaseError as DatabaseError, OperationalError as OperationalError, IntegrityError as IntegrityError, InternalError as InternalError, NotSupportedError as NotSupportedError, ProgrammingError as ProgrammingError"]}, {"term": "def", "name": "defaulterrorhandler", "data": "def defaulterrorhandler(connection, cursor, errorclass, errorvalue): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional, Type", "from .charset import MBLENGTH as MBLENGTH, charset_by_name as charset_by_name, charset_by_id as charset_by_id", "from .cursors import Cursor as Cursor", "from .constants import FIELD_TYPE as FIELD_TYPE, FLAG as FLAG", "from .constants import SERVER_STATUS as SERVER_STATUS", "from .constants import CLIENT as CLIENT", "from .constants import COMMAND as COMMAND", "from .util import join_bytes as join_bytes, byte2int as byte2int, int2byte as int2byte", "from .converters import escape_item as escape_item, encoders as encoders, decoders as decoders", "from .err import raise_mysql_exception as raise_mysql_exception, Warning as Warning, Error as Error, InterfaceError as InterfaceError, DataError as DataError, DatabaseError as DatabaseError, OperationalError as OperationalError, IntegrityError as IntegrityError, InternalError as InternalError, NotSupportedError as NotSupportedError, ProgrammingError as ProgrammingError"]}, {"term": "class", "name": "classMysqlPacket:", "data": "class MysqlPacket:\n\tconnection: Any\n\tdef __init__(self, connection): ...\n\tdef packet_number(self): ...\n\tdef get_all_data(self): ...\n\tdef read(self, size): ...\n\tdef read_all(self): ...\n\tdef advance(self, length): ...\n\tdef rewind(self, position: int = ...): ...\n\tdef peek(self, size): ...\n\tdef get_bytes(self, position, length: int = ...): ...\n\tdef read_length_coded_binary(self): ...\n\tdef read_length_coded_string(self): ...\n\tdef is_ok_packet(self): ...\n\tdef is_eof_packet(self): ...\n\tdef is_resultset_packet(self): ...\n\tdef is_error_packet(self): ...\n\tdef check_error(self): ...\n\tdef dump(self): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional, Type", "from .charset import MBLENGTH as MBLENGTH, charset_by_name as charset_by_name, charset_by_id as charset_by_id", "from .cursors import Cursor as Cursor", "from .constants import FIELD_TYPE as FIELD_TYPE, FLAG as FLAG", "from .constants import SERVER_STATUS as SERVER_STATUS", "from .constants import CLIENT as CLIENT", "from .constants import COMMAND as COMMAND", "from .util import join_bytes as join_bytes, byte2int as byte2int, int2byte as int2byte", "from .converters import escape_item as escape_item, encoders as encoders, decoders as decoders", "from .err import raise_mysql_exception as raise_mysql_exception, Warning as Warning, Error as Error, InterfaceError as InterfaceError, DataError as DataError, DatabaseError as DatabaseError, OperationalError as OperationalError, IntegrityError as IntegrityError, InternalError as InternalError, NotSupportedError as NotSupportedError, ProgrammingError as ProgrammingError"]}, {"term": "class", "name": "FieldDescriptorPacket", "data": "class FieldDescriptorPacket(MysqlPacket):\n\tdef __init__(self, *args): ...\n\tdef description(self): ...\n\tdef get_column_length(self): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional, Type", "from .charset import MBLENGTH as MBLENGTH, charset_by_name as charset_by_name, charset_by_id as charset_by_id", "from .cursors import Cursor as Cursor", "from .constants import FIELD_TYPE as FIELD_TYPE, FLAG as FLAG", "from .constants import SERVER_STATUS as SERVER_STATUS", "from .constants import CLIENT as CLIENT", "from .constants import COMMAND as COMMAND", "from .util import join_bytes as join_bytes, byte2int as byte2int, int2byte as int2byte", "from .converters import escape_item as escape_item, encoders as encoders, decoders as decoders", "from .err import raise_mysql_exception as raise_mysql_exception, Warning as Warning, Error as Error, InterfaceError as InterfaceError, DataError as DataError, DatabaseError as DatabaseError, OperationalError as OperationalError, IntegrityError as IntegrityError, InternalError as InternalError, NotSupportedError as NotSupportedError, ProgrammingError as ProgrammingError"]}, {"term": "class", "name": "classConnection:", "data": "class Connection:\n\terrorhandler: Any\n\tssl: Any\n\thost: Any\n\tport: Any\n\tuser: Any\n\tpassword: Any\n\tdb: Any\n\tunix_socket: Any\n\tcharset: Any\n\tuse_unicode: Any\n\tclient_flag: Any\n\tcursorclass: Any\n\tconnect_timeout: Any\n\tmessages: Any\n\tencoders: Any\n\tdecoders: Any\n\thost_info: Any\n\tdef __init__(self, host: str = ..., user: Optional[Any] = ..., passwd: str = ..., db: Optional[Any] = ...,\n\t\t\t\t port: int = ..., unix_socket: Optional[Any] = ..., charset: str = ..., sql_mode: Optional[Any] = ...,\n\t\t\t\t read_default_file: Optional[Any] = ..., conv=..., use_unicode: Optional[Any] = ..., client_flag: int = ...,\n\t\t\t\t cursorclass=..., init_command: Optional[Any] = ..., connect_timeout: Optional[Any] = ...,\n\t\t\t\t ssl: Optional[Any] = ..., read_default_group: Optional[Any] = ..., compress: Optional[Any] = ...,\n\t\t\t\t named_pipe: Optional[Any] = ...): ...\n\tsocket: Any\n\trfile: Any\n\twfile: Any\n\tdef close(self): ...\n\tdef autocommit(self, value): ...\n\tdef commit(self): ...\n\tdef begin(self) -> None: ...\n\tdef rollback(self): ...\n\tdef escape(self, obj): ...\n\tdef literal(self, obj): ...\n\tdef cursor(self, cursor: Optional[Type[Cursor]] = ...): ...\n\tdef __enter__(self): ...\n\tdef __exit__(self, exc, value, traceback): ...\n\tdef query(self, sql): ...\n\tdef next_result(self, unbuffered: bool = ...): ...\n\tdef affected_rows(self): ...\n\tdef kill(self, thread_id): ...\n\tdef ping(self, reconnect: bool = ...): ...\n\tdef set_charset(self, charset): ...\n\tdef read_packet(self, packet_type=...): ...\n\tdef insert_id(self): ...\n\tdef thread_id(self): ...\n\tdef character_set_name(self): ...\n\tdef get_host_info(self): ...\n\tdef get_proto_info(self): ...\n\tdef get_server_info(self): ...\n\tdef show_warnings(self): ...\n\tWarning: Any\n\tError: Any\n\tInterfaceError: Any\n\tDatabaseError: Any\n\tDataError: Any\n\tOperationalError: Any\n\tIntegrityError: Any\n\tInternalError: Any\n\tProgrammingError: Any\n\tNotSupportedError: Any\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional, Type", "from .charset import MBLENGTH as MBLENGTH, charset_by_name as charset_by_name, charset_by_id as charset_by_id", "from .cursors import Cursor as Cursor", "from .constants import FIELD_TYPE as FIELD_TYPE, FLAG as FLAG", "from .constants import SERVER_STATUS as SERVER_STATUS", "from .constants import CLIENT as CLIENT", "from .constants import COMMAND as COMMAND", "from .util import join_bytes as join_bytes, byte2int as byte2int, int2byte as int2byte", "from .converters import escape_item as escape_item, encoders as encoders, decoders as decoders", "from .err import raise_mysql_exception as raise_mysql_exception, Warning as Warning, Error as Error, InterfaceError as InterfaceError, DataError as DataError, DatabaseError as DatabaseError, OperationalError as OperationalError, IntegrityError as IntegrityError, InternalError as InternalError, NotSupportedError as NotSupportedError, ProgrammingError as ProgrammingError"]}, {"term": "class", "name": "classMySQLResult:", "data": "class MySQLResult:\n\tconnection: Any\n\taffected_rows: Any\n\tinsert_id: Any\n\tserver_status: Any\n\twarning_count: Any\n\tmessage: Any\n\tfield_count: Any\n\tdescription: Any\n\trows: Any\n\thas_next: Any\n\tdef __init__(self, connection): ...\n\tfirst_packet: Any\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional, Type", "from .charset import MBLENGTH as MBLENGTH, charset_by_name as charset_by_name, charset_by_id as charset_by_id", "from .cursors import Cursor as Cursor", "from .constants import FIELD_TYPE as FIELD_TYPE, FLAG as FLAG", "from .constants import SERVER_STATUS as SERVER_STATUS", "from .constants import CLIENT as CLIENT", "from .constants import COMMAND as COMMAND", "from .util import join_bytes as join_bytes, byte2int as byte2int, int2byte as int2byte", "from .converters import escape_item as escape_item, encoders as encoders, decoders as decoders", "from .err import raise_mysql_exception as raise_mysql_exception, Warning as Warning, Error as Error, InterfaceError as InterfaceError, DataError as DataError, DatabaseError as DatabaseError, OperationalError as OperationalError, IntegrityError as IntegrityError, InternalError as InternalError, NotSupportedError as NotSupportedError, ProgrammingError as ProgrammingError"]}], [{"term": "class", "name": "Random", "data": "class Random(_random.Random):\n\tdef __init__(self, x: Any = ...) -> None: ...\n\tdef seed(self, a: Any = ..., version: int = ...) -> None: ...\n\tdef getstate(self) -> tuple: ...\n\tdef setstate(self, state: tuple) -> None: ...\n\tdef getrandbits(self, k: int) -> int: ...\n\tdef randrange(self, start: int, stop: Union[int, None] = ..., step: int = ...) -> int: ...\n\tdef randint(self, a: int, b: int) -> int: ...\n\tdef choice(self, seq: Sequence[_T]) -> _T: ...\n\tif sys.version_info >= (3, 6):\n\t\tdef choices(self, population: Sequence[_T], weights: Optional[Sequence[float]] = ..., *, cum_weights: Optional[Sequence[float]] = ..., k: int = ...) -> List[_T]: ...\n\tdef shuffle(self, x: List[Any], random: Union[Callable[[], float], None] = ...) -> None: ...\n\tdef sample(self, population: Union[Sequence[_T], AbstractSet[_T]], k: int) -> List[_T]: ...\n\tdef random(self) -> float: ...\n\tdef uniform(self, a: float, b: float) -> float: ...\n\tdef triangular(self, low: float = ..., high: float = ..., mode: float = ...) -> float: ...\n\tdef betavariate(self, alpha: float, beta: float) -> float: ...\n\tdef expovariate(self, lambd: float) -> float: ...\n\tdef gammavariate(self, alpha: float, beta: float) -> float: ...\n\tdef gauss(self, mu: float, sigma: float) -> float: ...\n\tdef lognormvariate(self, mu: float, sigma: float) -> float: ...\n\tdef normalvariate(self, mu: float, sigma: float) -> float: ...\n\tdef vonmisesvariate(self, mu: float, kappa: float) -> float: ...\n\tdef paretovariate(self, alpha: float) -> float: ...\n\tdef weibullvariate(self, alpha: float, beta: float) -> float: ...\n", "description": null, "category": "def", "imports": ["import _random", "import sys", "from typing import ("]}, {"term": "class", "name": "SystemRandom", "data": "class SystemRandom(Random):\n\t...\n", "description": null, "category": "def", "imports": ["import _random", "import sys", "from typing import ("]}, {"term": "def", "name": "triangular", "data": "def triangular(low: float = ..., high: float = ...,\n", "description": null, "category": "def", "imports": ["import _random", "import sys", "from typing import ("]}], [{"term": "def", "name": "namedtuple", "data": "def namedtuple(typename: Union[str, unicode], field_names: Union[str, unicode, Iterable[Union[str, unicode]]],\n\t\t\t   verbose: bool = ..., rename: bool = ...) -> Type[tuple]: ...\n", "description": null, "category": "def", "imports": ["from typing import Dict, Generic, TypeVar, Tuple, overload, Type, Optional, List, Union, Reversible", "from typing import ("]}, {"term": "class", "name": "deque", "data": "class deque(Sized, Iterable[_T], Reversible[_T], Generic[_T]):\n\tdef __init__(self, iterable: Iterable[_T] = ...,\n\t\t\t\t maxlen: int = ...) -> None: ...\n\t@property\n\tdef maxlen(self) -> Optional[int]: ...\n\tdef append(self, x: _T) -> None: ...\n\tdef appendleft(self, x: _T) -> None: ...\n\tdef clear(self) -> None: ...\n\tdef count(self, x: _T) -> int: ...\n\tdef extend(self, iterable: Iterable[_T]) -> None: ...\n\tdef extendleft(self, iterable: Iterable[_T]) -> None: ...\n\tdef pop(self) -> _T: ...\n\tdef popleft(self) -> _T: ...\n\tdef remove(self, value: _T) -> None: ...\n\tdef reverse(self) -> None: ...\n\tdef rotate(self, n: int) -> None: ...\n\tdef __len__(self) -> int: ...\n\tdef __iter__(self) -> Iterator[_T]: ...\n\tdef __str__(self) -> str: ...\n\tdef __hash__(self) -> int: ...\n\tdef __getitem__(self, i: int) -> _T: ...\n\tdef __setitem__(self, i: int, x: _T) -> None: ...\n\tdef __contains__(self, o: _T) -> bool: ...\n\tdef __reversed__(self) -> Iterator[_T]: ...\n\tdef __iadd__(self: _S, iterable: Iterable[_T]) -> _S: ...\n", "description": null, "category": "def", "imports": ["from typing import Dict, Generic, TypeVar, Tuple, overload, Type, Optional, List, Union, Reversible", "from typing import ("]}, {"term": "class", "name": "Counter", "data": "class Counter(Dict[_T, int], Generic[_T]):\n\t@overload\n\tdef __init__(self, **kwargs: int) -> None: ...\n\t@overload\n\tdef __init__(self, mapping: Mapping[_T, int]) -> None: ...\n\t@overload\n\tdef __init__(self, iterable: Iterable[_T]) -> None: ...\n\tdef copy(self: _CounterT) -> _CounterT: ...\n\tdef elements(self) -> Iterator[_T]: ...\n\tdef most_common(self, n: Optional[int] = ...) -> List[Tuple[_T, int]]: ...\n\t@overload\n\tdef subtract(self, __mapping: Mapping[_T, int]) -> None: ...\n\t@overload\n\tdef subtract(self, iterable: Iterable[_T]) -> None: ...\n\t# The Iterable[Tuple[...]] argument type is not actually desirable\n\t# (the tuples will be added as keys, breaking type safety) but\n\t# it's included so that the signature is compatible with\n\t# Dict.update. Not sure if we should use '# type: ignore' instead\n\t# and omit the type from the union.\n\t@overload\n\tdef update(self, __m: Mapping[_T, int], **kwargs: int) -> None: ...\n\t@overload\n\tdef update(self, __m: Union[Iterable[_T], Iterable[Tuple[_T, int]]], **kwargs: int) -> None: ...\n\t@overload\n\tdef update(self, **kwargs: int) -> None: ...\n\n\tdef __add__(self, other: Counter[_T]) -> Counter[_T]: ...\n\tdef __sub__(self, other: Counter[_T]) -> Counter[_T]: ...\n\tdef __and__(self, other: Counter[_T]) -> Counter[_T]: ...\n\tdef __or__(self, other: Counter[_T]) -> Counter[_T]: ...\n\tdef __iadd__(self, other: Counter[_T]) -> Counter[_T]: ...\n\tdef __isub__(self, other: Counter[_T]) -> Counter[_T]: ...\n\tdef __iand__(self, other: Counter[_T]) -> Counter[_T]: ...\n\tdef __ior__(self, other: Counter[_T]) -> Counter[_T]: ...\n", "description": null, "category": "def", "imports": ["from typing import Dict, Generic, TypeVar, Tuple, overload, Type, Optional, List, Union, Reversible", "from typing import ("]}, {"term": "class", "name": "OrderedDict", "data": "class OrderedDict(Dict[_KT, _VT], Reversible[_KT], Generic[_KT, _VT]):\n\tdef popitem(self, last: bool = ...) -> Tuple[_KT, _VT]: ...\n\tdef copy(self: _OrderedDictT) -> _OrderedDictT: ...\n\tdef __reversed__(self) -> Iterator[_KT]: ...\n", "description": null, "category": "def", "imports": ["from typing import Dict, Generic, TypeVar, Tuple, overload, Type, Optional, List, Union, Reversible", "from typing import ("]}, {"term": "class", "name": "defaultdict", "data": "class defaultdict(Dict[_KT, _VT], Generic[_KT, _VT]):\n\tdefault_factory: Callable[[], _VT]\n\t@overload\n\tdef __init__(self, **kwargs: _VT) -> None: ...\n\t@overload\n\tdef __init__(self, default_factory: Optional[Callable[[], _VT]]) -> None: ...\n\t@overload\n\tdef __init__(self, default_factory: Optional[Callable[[], _VT]], **kwargs: _VT) -> None: ...\n\t@overload\n\tdef __init__(self, default_factory: Optional[Callable[[], _VT]],\n\t\t\t\t map: Mapping[_KT, _VT]) -> None: ...\n\t@overload\n\tdef __init__(self, default_factory: Optional[Callable[[], _VT]],\n\t\t\t\t map: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n\t@overload\n\tdef __init__(self, default_factory: Optional[Callable[[], _VT]],\n\t\t\t\t iterable: Iterable[Tuple[_KT, _VT]]) -> None: ...\n\t@overload\n\tdef __init__(self, default_factory: Optional[Callable[[], _VT]],\n\t\t\t\t iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n\tdef __missing__(self, key: _KT) -> _VT: ...\n", "description": null, "category": "def", "imports": ["from typing import Dict, Generic, TypeVar, Tuple, overload, Type, Optional, List, Union, Reversible", "from typing import ("]}], [{"term": "class", "name": "classS3WebsiteEndpointTranslate:", "data": "class S3WebsiteEndpointTranslate:\n\ttrans_region: Dict[str, str]\n\t@classmethod\n\tdef translate_region(self, reg: Text) -> str: ...\n", "description": null, "category": "def", "imports": ["from .bucketlistresultset import BucketListResultSet", "from .connection import S3Connection", "from .key import Key", "from typing import Any, Dict, Optional, Text, Type, List"]}, {"term": "class", "name": "classBucket:", "data": "class Bucket:\n\tLoggingGroup: str\n\tBucketPaymentBody: str\n\tVersioningBody: str\n\tVersionRE: str\n\tMFADeleteRE: str\n\tname: Text\n\tconnection: S3Connection\n\tkey_class: Type[Key]\n\tdef __init__(self, connection: Optional[S3Connection] = ..., name: Optional[Text] = ..., key_class: Type[Key] = ...) -> None: ...\n\tdef __iter__(self): ...\n\tdef __contains__(self, key_name) -> bool: ...\n\tdef startElement(self, name, attrs, connection): ...\n\tcreation_date: Any\n\tdef endElement(self, name, value, connection): ...\n\tdef set_key_class(self, key_class): ...\n\tdef lookup(self, key_name, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_key(self, key_name, headers: Optional[Dict[Text, Text]] = ..., version_id: Optional[Any] = ..., response_headers: Optional[Dict[Text, Text]] = ..., validate: bool = ...) -> Key: ...\n\tdef list(self, prefix: Text = ..., delimiter: Text = ..., marker: Text = ..., headers: Optional[Dict[Text, Text]] = ..., encoding_type: Optional[Any] = ...) -> BucketListResultSet: ...\n\tdef list_versions(self, prefix: str = ..., delimiter: str = ..., key_marker: str = ..., version_id_marker: str = ..., headers: Optional[Dict[Text, Text]] = ..., encoding_type: Optional[Text] = ...) -> BucketListResultSet: ...\n\tdef list_multipart_uploads(self, key_marker: str = ..., upload_id_marker: str = ..., headers: Optional[Dict[Text, Text]] = ..., encoding_type: Optional[Any] = ...): ...\n\tdef validate_kwarg_names(self, kwargs, names): ...\n\tdef get_all_keys(self, headers: Optional[Dict[Text, Text]] = ..., **params): ...\n\tdef get_all_versions(self, headers: Optional[Dict[Text, Text]] = ..., **params): ...\n\tdef validate_get_all_versions_params(self, params): ...\n\tdef get_all_multipart_uploads(self, headers: Optional[Dict[Text, Text]] = ..., **params): ...\n\tdef new_key(self, key_name: Optional[Any] = ...): ...\n\tdef generate_url(self, expires_in, method: str = ..., headers: Optional[Dict[Text, Text]] = ..., force_http: bool = ..., response_headers: Optional[Dict[Text, Text]] = ..., expires_in_absolute: bool = ...): ...\n\tdef delete_keys(self, keys, quiet: bool = ..., mfa_token: Optional[Any] = ..., headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef delete_key(self, key_name, headers: Optional[Dict[Text, Text]] = ..., version_id: Optional[Any] = ..., mfa_token: Optional[Any] = ...): ...\n\tdef copy_key(self, new_key_name, src_bucket_name, src_key_name, metadata: Optional[Any] = ..., src_version_id: Optional[Any] = ..., storage_class: str = ..., preserve_acl: bool = ..., encrypt_key: bool = ..., headers: Optional[Dict[Text, Text]] = ..., query_args: Optional[Any] = ...): ...\n\tdef set_canned_acl(self, acl_str, key_name: str = ..., headers: Optional[Dict[Text, Text]] = ..., version_id: Optional[Any] = ...): ...\n\tdef get_xml_acl(self, key_name: str = ..., headers: Optional[Dict[Text, Text]] = ..., version_id: Optional[Any] = ...): ...\n\tdef set_xml_acl(self, acl_str, key_name: str = ..., headers: Optional[Dict[Text, Text]] = ..., version_id: Optional[Any] = ..., query_args: str = ...): ...\n\tdef set_acl(self, acl_or_str, key_name: str = ..., headers: Optional[Dict[Text, Text]] = ..., version_id: Optional[Any] = ...): ...\n\tdef get_acl(self, key_name: str = ..., headers: Optional[Dict[Text, Text]] = ..., version_id: Optional[Any] = ...): ...\n\tdef set_subresource(self, subresource, value, key_name: str = ..., headers: Optional[Dict[Text, Text]] = ..., version_id: Optional[Any] = ...): ...\n\tdef get_subresource(self, subresource, key_name: str = ..., headers: Optional[Dict[Text, Text]] = ..., version_id: Optional[Any] = ...): ...\n\tdef make_public(self, recursive: bool = ..., headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef add_email_grant(self, permission, email_address, recursive: bool = ..., headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef add_user_grant(self, permission, user_id, recursive: bool = ..., headers: Optional[Dict[Text, Text]] = ..., display_name: Optional[Any] = ...): ...\n\tdef list_grants(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_location(self): ...\n\tdef set_xml_logging(self, logging_str, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef enable_logging(self, target_bucket, target_prefix: str = ..., grants: Optional[Any] = ..., headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef disable_logging(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_logging_status(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef set_as_logging_target(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_request_payment(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef set_request_payment(self, payer: str = ..., headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef configure_versioning(self, versioning, mfa_delete: bool = ..., mfa_token: Optional[Any] = ..., headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_versioning_status(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef configure_lifecycle(self, lifecycle_config, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_lifecycle_config(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef delete_lifecycle_configuration(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef configure_website(self, suffix: Optional[Any] = ..., error_key: Optional[Any] = ..., redirect_all_requests_to: Optional[Any] = ..., routing_rules: Optional[Any] = ..., headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef set_website_configuration(self, config, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef set_website_configuration_xml(self, xml, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_website_configuration(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_website_configuration_obj(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_website_configuration_with_xml(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_website_configuration_xml(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef delete_website_configuration(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_website_endpoint(self): ...\n\tdef get_policy(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef set_policy(self, policy, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef delete_policy(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef set_cors_xml(self, cors_xml, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef set_cors(self, cors_config, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_cors_xml(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_cors(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef delete_cors(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef initiate_multipart_upload(self, key_name, headers: Optional[Dict[Text, Text]] = ..., reduced_redundancy: bool = ..., metadata: Optional[Any] = ..., encrypt_key: bool = ..., policy: Optional[Any] = ...): ...\n\tdef complete_multipart_upload(self, key_name, upload_id, xml_body, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef cancel_multipart_upload(self, key_name, upload_id, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef delete(self, headers: Optional[Dict[Text, Text]] = ...): ...\n\tdef get_tags(self): ...\n\tdef get_xml_tags(self): ...\n\tdef set_xml_tags(self, tag_str, headers: Optional[Dict[Text, Text]] = ..., query_args: str = ...): ...\n\tdef set_tags(self, tags, headers: Optional[Dict[Text, Text]] = ...): ...\n", "description": null, "category": "def", "imports": ["from .bucketlistresultset import BucketListResultSet", "from .connection import S3Connection", "from .key import Key", "from typing import Any, Dict, Optional, Text, Type, List"]}], [{"term": "class", "name": "classGpioData:", "data": "class GpioData:\n\t_count = 0\n\t_modNum = 8\n\t_specMap = {}\n\t_freqMap = {}\n\t_mapList = []\n\t_modeMap = {}\n\t_smtMap = {}\n\t_map_table = {}\n\n\tdef __init__(self):\n\t\tself.__defMode = 0\n\t\tself.__eintMode = False\n\t\tself.__modeVec = ['0', '0', '0', '0', '0', '0', '0', '0']\n\t\tself.__inPullEn = True\n\t\tself.__inPullSelHigh = False\n\t\tself.__defDirInt = 0\n\t\tself.__defDir = 'IN'\n\t\tself.__inEn = True\n\t\tself.__outEn = False\n\t\tself.__outHigh = False\n\t\tself.__varNames = []\n\t\tself.__smtNum = -1\n\t\tself.__smtEn = False\n\t\tself.__iesEn = True\n\t\tself.__drvCur = \"\"\n\n\n\tdef get_defMode(self):\n\t\treturn self.__defMode\n\n\tdef set_defMode(self, mode):\n\t\tself.__defMode = mode\n\n\tdef get_eintMode(self):\n\t\treturn self.__eintMode\n\n\tdef set_eintMode(self, flag):\n\t\tself.__eintMode = flag\n\n\tdef get_modeVec(self):\n\t\treturn self.__modeVec\n\n\tdef set_modeVec(self, vec):\n\t\tself.__modeVec = vec\n\n\tdef get_inPullEn(self):\n\t\treturn self.__inPullEn\n\n\tdef set_inpullEn(self, flag):\n\t\tself.__inPullEn = flag\n\n\tdef get_inPullSelHigh(self):\n\t\treturn self.__inPullSelHigh\n\n\tdef set_inpullSelHigh(self, flag):\n\t\tself.__inPullSelHigh = flag\n\n\tdef get_defDir(self):\n\t\treturn self.__defDir\n\n\tdef set_defDir(self, dir):\n\t\tself.__defDir = dir\n\n\tdef get_inEn(self):\n\t\treturn self.__inEn\n\n\tdef set_inEn(self, flag):\n\t\tself.__inEn = flag\n\n\tdef get_outEn(self):\n\t\treturn self.__outEn\n\n\tdef set_outEn(self, flag):\n\t\tself.__outEn = flag\n\n\tdef get_outHigh(self):\n\t\treturn self.__outHigh\n\n\tdef set_outHigh(self, outHigh):\n\t\tself.__outHigh = outHigh\n\n\tdef get_varNames(self):\n\t\treturn self.__varNames\n\n\tdef set_varNames(self, names):\n\t\tself.__varNames = names\n\n\tdef set_smtEn(self, flag):\n\t\tself.__smtEn = flag\n\n\tdef get_smtEn(self):\n\t\treturn self.__smtEn\n\n\tdef get_iesEn(self):\n\t\treturn self.__iesEn\n\n\tdef set_iesEn(self, flag):\n\t\tself.__iesEn = flag\n\n\tdef set_drvCur(self, val):\n\t\tself.__drvCur = val\n\n\tdef get_drvCur(self):\n\t\treturn self.__drvCur\n\n\tdef set_smtNum(self, num):\n\t\tself.__smtNum = num\n\n\tdef get_smtNum(self):\n\t\treturn self.__smtNum\n\n\tdef ge_defDirInt(self):\n\t\tif self.__defDir == 'IN':\n\t\t\treturn 0\n\t\telse:\n\t\t\treturn 1\n\n\t@staticmethod\n\tdef set_eint_map_table(map_table):\n\t\tGpioData._map_table = map_table\n\n\t@staticmethod\n\tdef get_modeName(key, idx):\n\t\tif key in GpioData._modeMap.keys():\n\t\t\tvalue = GpioData._modeMap[key]\n", "description": null, "category": "def", "imports": []}], [{"term": "class", "name": "AugAssignTest", "data": "class AugAssignTest(unittest.TestCase):\n\tdef testBasic(self):\n\t\tx = 2\n\t\tx += 1\n\t\tx *= 2\n\t\tx **= 2\n\t\tx -= 8\n\t\tx //= 5\n\t\tx %= 3\n\t\tx &= 2\n\t\tx |= 5\n\t\tx ^= 1\n\t\tx /= 2\n\t\tself.assertEqual(x, 3.0)\n\n\tdef test_with_unpacking(self):\n\t\tself.assertRaises(SyntaxError, compile, \"x, b += 3\", \"<test>\", \"exec\")\n\n\tdef testInList(self):\n\t\tx = [2]\n\t\tx[0] += 1\n\t\tx[0] *= 2\n\t\tx[0] **= 2\n\t\tx[0] -= 8\n\t\tx[0] //= 5\n\t\tx[0] %= 3\n\t\tx[0] &= 2\n\t\tx[0] |= 5\n\t\tx[0] ^= 1\n\t\tx[0] /= 2\n\t\tself.assertEqual(x[0], 3.0)\n\n\tdef testInDict(self):\n\t\tx = {0: 2}\n\t\tx[0] += 1\n\t\tx[0] *= 2\n\t\tx[0] **= 2\n\t\tx[0] -= 8\n\t\tx[0] //= 5\n\t\tx[0] %= 3\n\t\tx[0] &= 2\n\t\tx[0] |= 5\n\t\tx[0] ^= 1\n\t\tx[0] /= 2\n\t\tself.assertEqual(x[0], 3.0)\n\n\tdef testSequences(self):\n\t\tx = [1,2]\n\t\tx += [3,4]\n\t\tx *= 2\n\n\t\tself.assertEqual(x, [1, 2, 3, 4, 1, 2, 3, 4])\n\n\t\tx = [1, 2, 3]\n\t\ty = x\n\t\tx[1:2] *= 2\n\t\ty[1:2] += [1]\n\n\t\tself.assertEqual(x, [1, 2, 1, 2, 3])\n\t\tself.assertTrue(x is y)\n\n\tdef testCustomMethods1(self):\n\n\t\tclass aug_test:\n\t\t\tdef __init__(self, value):\n\t\t\t\tself.val = value\n\t\t\tdef __radd__(self, val):\n\t\t\t\treturn self.val + val\n\t\t\tdef __add__(self, val):\n\t\t\t\treturn aug_test(self.val + val)\n\n\t\tclass aug_test2(aug_test):\n\t\t\tdef __iadd__(self, val):\n\t\t\t\tself.val = self.val + val\n\t\t\t\treturn self\n\n\t\tclass aug_test3(aug_test):\n\t\t\tdef __iadd__(self, val):\n\t\t\t\treturn aug_test3(self.val + val)\n\n\t\tclass aug_test4(aug_test3):\n\t\t\t\"\"\"Blocks inheritance, and fallback to __add__\"\"\"\n\t\t\t__iadd__ = None\n\n\t\tx = aug_test(1)\n\t\ty = x\n\t\tx += 10\n\n\t\tself.assertIsInstance(x, aug_test)\n\t\tself.assertTrue(y is not x)\n\t\tself.assertEqual(x.val, 11)\n\n\t\tx = aug_test2(2)\n\t\ty = x\n\t\tx += 10\n\n\t\tself.assertTrue(y is x)\n\t\tself.assertEqual(x.val, 12)\n\n\t\tx = aug_test3(3)\n\t\ty = x\n\t\tx += 10\n\n\t\tself.assertIsInstance(x, aug_test3)\n\t\tself.assertTrue(y is not x)\n\t\tself.assertEqual(x.val, 13)\n\n\t\tx = aug_test4(4)\n\t\twith self.assertRaises(TypeError):\n\t\t\tx += 10\n\n\n\tdef testCustomMethods2(test_self):\n\t\toutput = []\n\n\t\tclass testall:\n\t\t\tdef __add__(self, val):\n\t\t\t\toutput.append(\"__add__ called\")\n\t\t\tdef __radd__(self, val):\n\t\t\t\toutput.append(\"__radd__ called\")\n\t\t\tdef __iadd__(self, val):\n\t\t\t\toutput.append(\"__iadd__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __sub__(self, val):\n\t\t\t\toutput.append(\"__sub__ called\")\n\t\t\tdef __rsub__(self, val):\n\t\t\t\toutput.append(\"__rsub__ called\")\n\t\t\tdef __isub__(self, val):\n\t\t\t\toutput.append(\"__isub__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __mul__(self, val):\n\t\t\t\toutput.append(\"__mul__ called\")\n\t\t\tdef __rmul__(self, val):\n\t\t\t\toutput.append(\"__rmul__ called\")\n\t\t\tdef __imul__(self, val):\n\t\t\t\toutput.append(\"__imul__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __matmul__(self, val):\n\t\t\t\toutput.append(\"__matmul__ called\")\n\t\t\tdef __rmatmul__(self, val):\n\t\t\t\toutput.append(\"__rmatmul__ called\")\n\t\t\tdef __imatmul__(self, val):\n\t\t\t\toutput.append(\"__imatmul__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __floordiv__(self, val):\n\t\t\t\toutput.append(\"__floordiv__ called\")\n\t\t\t\treturn self\n\t\t\tdef __ifloordiv__(self, val):\n\t\t\t\toutput.append(\"__ifloordiv__ called\")\n\t\t\t\treturn self\n\t\t\tdef __rfloordiv__(self, val):\n\t\t\t\toutput.append(\"__rfloordiv__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __truediv__(self, val):\n\t\t\t\toutput.append(\"__truediv__ called\")\n\t\t\t\treturn self\n\t\t\tdef __rtruediv__(self, val):\n\t\t\t\toutput.append(\"__rtruediv__ called\")\n\t\t\t\treturn self\n\t\t\tdef __itruediv__(self, val):\n\t\t\t\toutput.append(\"__itruediv__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __mod__(self, val):\n\t\t\t\toutput.append(\"__mod__ called\")\n\t\t\tdef __rmod__(self, val):\n\t\t\t\toutput.append(\"__rmod__ called\")\n\t\t\tdef __imod__(self, val):\n\t\t\t\toutput.append(\"__imod__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __pow__(self, val):\n\t\t\t\toutput.append(\"__pow__ called\")\n\t\t\tdef __rpow__(self, val):\n\t\t\t\toutput.append(\"__rpow__ called\")\n\t\t\tdef __ipow__(self, val):\n\t\t\t\toutput.append(\"__ipow__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __or__(self, val):\n\t\t\t\toutput.append(\"__or__ called\")\n\t\t\tdef __ror__(self, val):\n\t\t\t\toutput.append(\"__ror__ called\")\n\t\t\tdef __ior__(self, val):\n\t\t\t\toutput.append(\"__ior__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __and__(self, val):\n\t\t\t\toutput.append(\"__and__ called\")\n\t\t\tdef __rand__(self, val):\n\t\t\t\toutput.append(\"__rand__ called\")\n\t\t\tdef __iand__(self, val):\n\t\t\t\toutput.append(\"__iand__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __xor__(self, val):\n\t\t\t\toutput.append(\"__xor__ called\")\n\t\t\tdef __rxor__(self, val):\n\t\t\t\toutput.append(\"__rxor__ called\")\n\t\t\tdef __ixor__(self, val):\n\t\t\t\toutput.append(\"__ixor__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __rshift__(self, val):\n\t\t\t\toutput.append(\"__rshift__ called\")\n\t\t\tdef __rrshift__(self, val):\n\t\t\t\toutput.append(\"__rrshift__ called\")\n\t\t\tdef __irshift__(self, val):\n\t\t\t\toutput.append(\"__irshift__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __lshift__(self, val):\n\t\t\t\toutput.append(\"__lshift__ called\")\n\t\t\tdef __rlshift__(self, val):\n\t\t\t\toutput.append(\"__rlshift__ called\")\n\t\t\tdef __ilshift__(self, val):\n\t\t\t\toutput.append(\"__ilshift__ called\")\n\t\t\t\treturn self\n\n\t\tx = testall()\n\t\tx + 1\n\t\t1 + x\n\t\tx += 1\n\n\t\tx - 1\n\t\t1 - x\n\t\tx -= 1\n\n\t\tx * 1\n\t\t1 * x\n\t\tx *= 1\n\n\t\tx @ 1\n\t\t1 @ x\n\t\tx @= 1\n\n\t\tx / 1\n\t\t1 / x\n\t\tx /= 1\n\n\t\tx // 1\n\t\t1 // x\n\t\tx //= 1\n\n\t\tx % 1\n\t\t1 % x\n\t\tx %= 1\n\n\t\tx ** 1\n\t\t1 ** x\n\t\tx **= 1\n\n\t\tx | 1\n\t\t1 | x\n\t\tx |= 1\n\n\t\tx & 1\n\t\t1 & x\n\t\tx &= 1\n\n\t\tx ^ 1\n\t\t1 ^ x\n\t\tx ^= 1\n\n\t\tx >> 1\n\t\t1 >> x\n\t\tx >>= 1\n\n\t\tx << 1\n\t\t1 << x\n\t\tx <<= 1\n\n", "description": "Blocks inheritance, and fallback to __add__", "category": "def", "imports": ["import unittest"]}], [{"term": "class", "name": "ForeignEnum", "data": "class ForeignEnum(int):\n\t@classmethod\n\tdef Name(cls, number: int) -> bytes: ...\n\n\t@classmethod\n\tdef Value(cls, name: bytes) -> ForeignEnum: ...\n\n\t@classmethod\n\tdef keys(cls) -> List[bytes]: ...\n\n\t@classmethod\n\tdef values(cls) -> List[ForeignEnum]: ...\n\n\t@classmethod\n\tdef items(cls) -> List[Tuple[bytes, ForeignEnum]]: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestEnumWithDupValue", "data": "class TestEnumWithDupValue(int):\n\t@classmethod\n\tdef Name(cls, number: int) -> bytes: ...\n\n\t@classmethod\n\tdef Value(cls, name: bytes) -> TestEnumWithDupValue: ...\n\n\t@classmethod\n\tdef keys(cls) -> List[bytes]: ...\n\n\t@classmethod\n\tdef values(cls) -> List[TestEnumWithDupValue]: ...\n\n\t@classmethod\n\tdef items(cls) -> List[Tuple[bytes, TestEnumWithDupValue]]: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestSparseEnum", "data": "class TestSparseEnum(int):\n\t@classmethod\n\tdef Name(cls, number: int) -> bytes: ...\n\n\t@classmethod\n\tdef Value(cls, name: bytes) -> TestSparseEnum: ...\n\n\t@classmethod\n\tdef keys(cls) -> List[bytes]: ...\n\n\t@classmethod\n\tdef values(cls) -> List[TestSparseEnum]: ...\n\n\t@classmethod\n\tdef items(cls) -> List[Tuple[bytes, TestSparseEnum]]: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestAllTypes", "data": "class TestAllTypes(Message):\n\tclass NestedEnum(int):\n\t\t@classmethod\n\t\tdef Name(cls, number: int) -> bytes: ...\n\n\t\t@classmethod\n\t\tdef Value(cls, name: bytes) -> TestAllTypes.NestedEnum: ...\n\n\t\t@classmethod\n\t\tdef keys(cls) -> List[bytes]: ...\n\n\t\t@classmethod\n\t\tdef values(cls) -> List[TestAllTypes.NestedEnum]: ...\n\n\t\t@classmethod\n\t\tdef items(cls) -> List[Tuple[bytes, TestAllTypes.NestedEnum]]: ...\n\tFOO: TestAllTypes.NestedEnum\n\tBAR: TestAllTypes.NestedEnum\n\tBAZ: TestAllTypes.NestedEnum\n\tNEG: TestAllTypes.NestedEnum\n\n\tclass NestedMessage(Message):\n\t\tbb: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t bb: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestAllTypes.NestedMessage: ...\n\n\tclass OptionalGroup(Message):\n\t\ta: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestAllTypes.OptionalGroup: ...\n\n\tclass RepeatedGroup(Message):\n\t\ta: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestAllTypes.RepeatedGroup: ...\n\toptional_int32: int\n\toptional_int64: int\n\toptional_uint32: int\n\toptional_uint64: int\n\toptional_sint32: int\n\toptional_sint64: int\n\toptional_fixed32: int\n\toptional_fixed64: int\n\toptional_sfixed32: int\n\toptional_sfixed64: int\n\toptional_float: float\n\toptional_double: float\n\toptional_bool: bool\n\toptional_string: Text\n\toptional_bytes: bytes\n\toptional_nested_enum: TestAllTypes.NestedEnum\n\toptional_foreign_enum: ForeignEnum\n\toptional_import_enum: ImportEnum\n\toptional_string_piece: Text\n\toptional_cord: Text\n\trepeated_int32: RepeatedScalarFieldContainer[int]\n\trepeated_int64: RepeatedScalarFieldContainer[int]\n\trepeated_uint32: RepeatedScalarFieldContainer[int]\n\trepeated_uint64: RepeatedScalarFieldContainer[int]\n\trepeated_sint32: RepeatedScalarFieldContainer[int]\n\trepeated_sint64: RepeatedScalarFieldContainer[int]\n\trepeated_fixed32: RepeatedScalarFieldContainer[int]\n\trepeated_fixed64: RepeatedScalarFieldContainer[int]\n\trepeated_sfixed32: RepeatedScalarFieldContainer[int]\n\trepeated_sfixed64: RepeatedScalarFieldContainer[int]\n\trepeated_float: RepeatedScalarFieldContainer[float]\n\trepeated_double: RepeatedScalarFieldContainer[float]\n\trepeated_bool: RepeatedScalarFieldContainer[bool]\n\trepeated_string: RepeatedScalarFieldContainer[Text]\n\trepeated_bytes: RepeatedScalarFieldContainer[bytes]\n\trepeated_nested_enum: RepeatedScalarFieldContainer[TestAllTypes.NestedEnum]\n\trepeated_foreign_enum: RepeatedScalarFieldContainer[ForeignEnum]\n\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]\n\trepeated_string_piece: RepeatedScalarFieldContainer[Text]\n\trepeated_cord: RepeatedScalarFieldContainer[Text]\n\tdefault_int32: int\n\tdefault_int64: int\n\tdefault_uint32: int\n\tdefault_uint64: int\n\tdefault_sint32: int\n\tdefault_sint64: int\n\tdefault_fixed32: int\n\tdefault_fixed64: int\n\tdefault_sfixed32: int\n\tdefault_sfixed64: int\n\tdefault_float: float\n\tdefault_double: float\n\tdefault_bool: bool\n\tdefault_string: Text\n\tdefault_bytes: bytes\n\tdefault_nested_enum: TestAllTypes.NestedEnum\n\tdefault_foreign_enum: ForeignEnum\n\tdefault_import_enum: ImportEnum\n\tdefault_string_piece: Text\n\tdefault_cord: Text\n\toneof_uint32: int\n\toneof_string: Text\n\toneof_bytes: bytes\n\n\t@property\n\tdef optionalgroup(self) -> TestAllTypes.OptionalGroup: ...\n\n\t@property\n\tdef optional_nested_message(self) -> TestAllTypes.NestedMessage: ...\n\n\t@property\n\tdef optional_foreign_message(self) -> ForeignMessage: ...\n\n\t@property\n\tdef optional_import_message(self) -> ImportMessage: ...\n\n\t@property\n\tdef optional_public_import_message(self) -> PublicImportMessage: ...\n\n\t@property\n\tdef optional_lazy_message(self) -> TestAllTypes.NestedMessage: ...\n\n\t@property\n\tdef repeatedgroup(\n\t\tself) -> RepeatedCompositeFieldContainer[TestAllTypes.RepeatedGroup]: ...\n\n\t@property\n\tdef repeated_nested_message(\n\t\tself) -> RepeatedCompositeFieldContainer[TestAllTypes.NestedMessage]: ...\n\n\t@property\n\tdef repeated_foreign_message(\n\t\tself) -> RepeatedCompositeFieldContainer[ForeignMessage]: ...\n\n\t@property\n\tdef repeated_import_message(\n\t\tself) -> RepeatedCompositeFieldContainer[ImportMessage]: ...\n\n\t@property\n\tdef repeated_lazy_message(\n\t\tself) -> RepeatedCompositeFieldContainer[TestAllTypes.NestedMessage]: ...\n\n\t@property\n\tdef oneof_nested_message(self) -> TestAllTypes.NestedMessage: ...\n\n\tdef __init__(self,\n\t\t\t\t optional_int32: Optional[int] = ...,\n\t\t\t\t optional_int64: Optional[int] = ...,\n\t\t\t\t optional_uint32: Optional[int] = ...,\n\t\t\t\t optional_uint64: Optional[int] = ...,\n\t\t\t\t optional_sint32: Optional[int] = ...,\n\t\t\t\t optional_sint64: Optional[int] = ...,\n\t\t\t\t optional_fixed32: Optional[int] = ...,\n\t\t\t\t optional_fixed64: Optional[int] = ...,\n\t\t\t\t optional_sfixed32: Optional[int] = ...,\n\t\t\t\t optional_sfixed64: Optional[int] = ...,\n\t\t\t\t optional_float: Optional[float] = ...,\n\t\t\t\t optional_double: Optional[float] = ...,\n\t\t\t\t optional_bool: Optional[bool] = ...,\n\t\t\t\t optional_string: Optional[Text] = ...,\n\t\t\t\t optional_bytes: Optional[bytes] = ...,\n\t\t\t\t optionalgroup: Optional[TestAllTypes.OptionalGroup] = ...,\n\t\t\t\t optional_nested_message: Optional[TestAllTypes.NestedMessage] = ...,\n\t\t\t\t optional_foreign_message: Optional[ForeignMessage] = ...,\n\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,\n\t\t\t\t optional_nested_enum: Optional[TestAllTypes.NestedEnum] = ...,\n\t\t\t\t optional_foreign_enum: Optional[ForeignEnum] = ...,\n\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,\n\t\t\t\t optional_string_piece: Optional[Text] = ...,\n\t\t\t\t optional_cord: Optional[Text] = ...,\n\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,\n\t\t\t\t optional_lazy_message: Optional[TestAllTypes.NestedMessage] = ...,\n\t\t\t\t repeated_int32: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_int64: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_uint32: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_uint64: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_sint32: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_sint64: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_fixed32: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_fixed64: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_sfixed32: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_sfixed64: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_float: Optional[Iterable[float]] = ...,\n\t\t\t\t repeated_double: Optional[Iterable[float]] = ...,\n\t\t\t\t repeated_bool: Optional[Iterable[bool]] = ...,\n\t\t\t\t repeated_string: Optional[Iterable[Text]] = ...,\n\t\t\t\t repeated_bytes: Optional[Iterable[bytes]] = ...,\n\t\t\t\t repeatedgroup: Optional[Iterable[TestAllTypes.RepeatedGroup]] = ...,\n\t\t\t\t repeated_nested_message: Optional[Iterable[TestAllTypes.NestedMessage]] = ...,\n\t\t\t\t repeated_foreign_message: Optional[Iterable[ForeignMessage]] = ...,\n\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,\n\t\t\t\t repeated_nested_enum: Optional[Iterable[TestAllTypes.NestedEnum]] = ...,\n\t\t\t\t repeated_foreign_enum: Optional[Iterable[ForeignEnum]] = ...,\n\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,\n\t\t\t\t repeated_string_piece: Optional[Iterable[Text]] = ...,\n\t\t\t\t repeated_cord: Optional[Iterable[Text]] = ...,\n\t\t\t\t repeated_lazy_message: Optional[Iterable[TestAllTypes.NestedMessage]] = ...,\n\t\t\t\t default_int32: Optional[int] = ...,\n\t\t\t\t default_int64: Optional[int] = ...,\n\t\t\t\t default_uint32: Optional[int] = ...,\n\t\t\t\t default_uint64: Optional[int] = ...,\n\t\t\t\t default_sint32: Optional[int] = ...,\n\t\t\t\t default_sint64: Optional[int] = ...,\n\t\t\t\t default_fixed32: Optional[int] = ...,\n\t\t\t\t default_fixed64: Optional[int] = ...,\n\t\t\t\t default_sfixed32: Optional[int] = ...,\n\t\t\t\t default_sfixed64: Optional[int] = ...,\n\t\t\t\t default_float: Optional[float] = ...,\n\t\t\t\t default_double: Optional[float] = ...,\n\t\t\t\t default_bool: Optional[bool] = ...,\n\t\t\t\t default_string: Optional[Text] = ...,\n\t\t\t\t default_bytes: Optional[bytes] = ...,\n\t\t\t\t default_nested_enum: Optional[TestAllTypes.NestedEnum] = ...,\n\t\t\t\t default_foreign_enum: Optional[ForeignEnum] = ...,\n\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,\n\t\t\t\t default_string_piece: Optional[Text] = ...,\n\t\t\t\t default_cord: Optional[Text] = ...,\n\t\t\t\t oneof_uint32: Optional[int] = ...,\n\t\t\t\t oneof_nested_message: Optional[TestAllTypes.NestedMessage] = ...,\n\t\t\t\t oneof_string: Optional[Text] = ...,\n\t\t\t\t oneof_bytes: Optional[bytes] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestAllTypes: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "NestedTestAllTypes", "data": "class NestedTestAllTypes(Message):\n\n\t@property\n\tdef child(self) -> NestedTestAllTypes: ...\n\n\t@property\n\tdef payload(self) -> TestAllTypes: ...\n\n\t@property\n\tdef repeated_child(\n\t\tself) -> RepeatedCompositeFieldContainer[NestedTestAllTypes]: ...\n\n\tdef __init__(self,\n\t\t\t\t child: Optional[NestedTestAllTypes] = ...,\n\t\t\t\t payload: Optional[TestAllTypes] = ...,\n\t\t\t\t repeated_child: Optional[Iterable[NestedTestAllTypes]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> NestedTestAllTypes: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestDeprecatedFields", "data": "class TestDeprecatedFields(Message):\n\tdeprecated_int32: int\n\tdeprecated_int32_in_oneof: int\n\n\tdef __init__(self,\n\t\t\t\t deprecated_int32: Optional[int] = ...,\n\t\t\t\t deprecated_int32_in_oneof: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestDeprecatedFields: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestDeprecatedMessage", "data": "class TestDeprecatedMessage(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestDeprecatedMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "ForeignMessage", "data": "class ForeignMessage(Message):\n\tc: int\n\td: int\n\n\tdef __init__(self,\n\t\t\t\t c: Optional[int] = ...,\n\t\t\t\t d: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> ForeignMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestReservedFields", "data": "class TestReservedFields(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestReservedFields: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestAllExtensions", "data": "class TestAllExtensions(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestAllExtensions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "OptionalGroup_extension", "data": "class OptionalGroup_extension(Message):\n\ta: int\n\n\tdef __init__(self,\n\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> OptionalGroup_extension: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "RepeatedGroup_extension", "data": "class RepeatedGroup_extension(Message):\n\ta: int\n\n\tdef __init__(self,\n\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> RepeatedGroup_extension: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestGroup", "data": "class TestGroup(Message):\n\tclass OptionalGroup(Message):\n\t\ta: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestGroup.OptionalGroup: ...\n\toptional_foreign_enum: ForeignEnum\n\n\t@property\n\tdef optionalgroup(self) -> TestGroup.OptionalGroup: ...\n\n\tdef __init__(self,\n\t\t\t\t optionalgroup: Optional[TestGroup.OptionalGroup] = ...,\n\t\t\t\t optional_foreign_enum: Optional[ForeignEnum] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestGroup: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestGroupExtension", "data": "class TestGroupExtension(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestGroupExtension: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestNestedExtension", "data": "class TestNestedExtension(Message):\n\tclass OptionalGroup_extension(Message):\n\t\ta: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(\n\t\t\tcls, s: bytes) -> TestNestedExtension.OptionalGroup_extension: ...\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestNestedExtension: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestRequired", "data": "class TestRequired(Message):\n\ta: int\n\tdummy2: int\n\tb: int\n\tdummy4: int\n\tdummy5: int\n\tdummy6: int\n\tdummy7: int\n\tdummy8: int\n\tdummy9: int\n\tdummy10: int\n\tdummy11: int\n\tdummy12: int\n\tdummy13: int\n\tdummy14: int\n\tdummy15: int\n\tdummy16: int\n\tdummy17: int\n\tdummy18: int\n\tdummy19: int\n\tdummy20: int\n\tdummy21: int\n\tdummy22: int\n\tdummy23: int\n\tdummy24: int\n\tdummy25: int\n\tdummy26: int\n\tdummy27: int\n\tdummy28: int\n\tdummy29: int\n\tdummy30: int\n\tdummy31: int\n\tdummy32: int\n\tc: int\n\n\tdef __init__(self,\n\t\t\t\t a: int,\n\t\t\t\t b: int,\n\t\t\t\t c: int,\n\t\t\t\t dummy2: Optional[int] = ...,\n\t\t\t\t dummy4: Optional[int] = ...,\n\t\t\t\t dummy5: Optional[int] = ...,\n\t\t\t\t dummy6: Optional[int] = ...,\n\t\t\t\t dummy7: Optional[int] = ...,\n\t\t\t\t dummy8: Optional[int] = ...,\n\t\t\t\t dummy9: Optional[int] = ...,\n\t\t\t\t dummy10: Optional[int] = ...,\n\t\t\t\t dummy11: Optional[int] = ...,\n\t\t\t\t dummy12: Optional[int] = ...,\n\t\t\t\t dummy13: Optional[int] = ...,\n\t\t\t\t dummy14: Optional[int] = ...,\n\t\t\t\t dummy15: Optional[int] = ...,\n\t\t\t\t dummy16: Optional[int] = ...,\n\t\t\t\t dummy17: Optional[int] = ...,\n\t\t\t\t dummy18: Optional[int] = ...,\n\t\t\t\t dummy19: Optional[int] = ...,\n\t\t\t\t dummy20: Optional[int] = ...,\n\t\t\t\t dummy21: Optional[int] = ...,\n\t\t\t\t dummy22: Optional[int] = ...,\n\t\t\t\t dummy23: Optional[int] = ...,\n\t\t\t\t dummy24: Optional[int] = ...,\n\t\t\t\t dummy25: Optional[int] = ...,\n\t\t\t\t dummy26: Optional[int] = ...,\n\t\t\t\t dummy27: Optional[int] = ...,\n\t\t\t\t dummy28: Optional[int] = ...,\n\t\t\t\t dummy29: Optional[int] = ...,\n\t\t\t\t dummy30: Optional[int] = ...,\n\t\t\t\t dummy31: Optional[int] = ...,\n\t\t\t\t dummy32: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestRequired: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestRequiredForeign", "data": "class TestRequiredForeign(Message):\n\tdummy: int\n\n\t@property\n\tdef optional_message(self) -> TestRequired: ...\n\n\t@property\n\tdef repeated_message(\n\t\tself) -> RepeatedCompositeFieldContainer[TestRequired]: ...\n\n\tdef __init__(self,\n\t\t\t\t optional_message: Optional[TestRequired] = ...,\n\t\t\t\t repeated_message: Optional[Iterable[TestRequired]] = ...,\n\t\t\t\t dummy: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestRequiredForeign: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestRequiredMessage", "data": "class TestRequiredMessage(Message):\n\n\t@property\n\tdef optional_message(self) -> TestRequired: ...\n\n\t@property\n\tdef repeated_message(\n\t\tself) -> RepeatedCompositeFieldContainer[TestRequired]: ...\n\n\t@property\n\tdef required_message(self) -> TestRequired: ...\n\n\tdef __init__(self,\n\t\t\t\t required_message: TestRequired,\n\t\t\t\t optional_message: Optional[TestRequired] = ...,\n\t\t\t\t repeated_message: Optional[Iterable[TestRequired]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestRequiredMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestForeignNested", "data": "class TestForeignNested(Message):\n\n\t@property\n\tdef foreign_nested(self) -> TestAllTypes.NestedMessage: ...\n\n\tdef __init__(self,\n\t\t\t\t foreign_nested: Optional[TestAllTypes.NestedMessage] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestForeignNested: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestEmptyMessage", "data": "class TestEmptyMessage(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestEmptyMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestEmptyMessageWithExtensions", "data": "class TestEmptyMessageWithExtensions(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestEmptyMessageWithExtensions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestMultipleExtensionRanges", "data": "class TestMultipleExtensionRanges(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestMultipleExtensionRanges: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestReallyLargeTagNumber", "data": "class TestReallyLargeTagNumber(Message):\n\ta: int\n\tbb: int\n\n\tdef __init__(self,\n\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t bb: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestReallyLargeTagNumber: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestRecursiveMessage", "data": "class TestRecursiveMessage(Message):\n\ti: int\n\n\t@property\n\tdef a(self) -> TestRecursiveMessage: ...\n\n\tdef __init__(self,\n\t\t\t\t a: Optional[TestRecursiveMessage] = ...,\n\t\t\t\t i: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestRecursiveMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestMutualRecursionA", "data": "class TestMutualRecursionA(Message):\n\tclass SubMessage(Message):\n\n\t\t@property\n\t\tdef b(self) -> TestMutualRecursionB: ...\n\n\t\tdef __init__(self,\n\t\t\t\t\t b: Optional[TestMutualRecursionB] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestMutualRecursionA.SubMessage: ...\n\n\tclass SubGroup(Message):\n\n\t\t@property\n\t\tdef sub_message(self) -> TestMutualRecursionA.SubMessage: ...\n\n\t\t@property\n\t\tdef not_in_this_scc(self) -> TestAllTypes: ...\n\n\t\tdef __init__(self,\n\t\t\t\t\t sub_message: Optional[TestMutualRecursionA.SubMessage] = ...,\n\t\t\t\t\t not_in_this_scc: Optional[TestAllTypes] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestMutualRecursionA.SubGroup: ...\n\n\t@property\n\tdef bb(self) -> TestMutualRecursionB: ...\n\n\t@property\n\tdef subgroup(self) -> TestMutualRecursionA.SubGroup: ...\n\n\tdef __init__(self,\n\t\t\t\t bb: Optional[TestMutualRecursionB] = ...,\n\t\t\t\t subgroup: Optional[TestMutualRecursionA.SubGroup] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestMutualRecursionA: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestMutualRecursionB", "data": "class TestMutualRecursionB(Message):\n\toptional_int32: int\n\n\t@property\n\tdef a(self) -> TestMutualRecursionA: ...\n\n\tdef __init__(self,\n\t\t\t\t a: Optional[TestMutualRecursionA] = ...,\n\t\t\t\t optional_int32: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestMutualRecursionB: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestIsInitialized", "data": "class TestIsInitialized(Message):\n\tclass SubMessage(Message):\n\t\tclass SubGroup(Message):\n\t\t\ti: int\n\n\t\t\tdef __init__(self,\n\t\t\t\t\t\t i: int,\n\t\t\t\t\t\t ) -> None: ...\n\n\t\t\t@classmethod\n\t\t\tdef FromString(\n\t\t\t\tcls, s: bytes) -> TestIsInitialized.SubMessage.SubGroup: ...\n\n\t\t@property\n\t\tdef subgroup(self) -> TestIsInitialized.SubMessage.SubGroup: ...\n\n\t\tdef __init__(self,\n\t\t\t\t\t subgroup: Optional[TestIsInitialized.SubMessage.SubGroup] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestIsInitialized.SubMessage: ...\n\n\t@property\n\tdef sub_message(self) -> TestIsInitialized.SubMessage: ...\n\n\tdef __init__(self,\n\t\t\t\t sub_message: Optional[TestIsInitialized.SubMessage] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestIsInitialized: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestDupFieldNumber", "data": "class TestDupFieldNumber(Message):\n\tclass Foo(Message):\n\t\ta: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestDupFieldNumber.Foo: ...\n\n\tclass Bar(Message):\n\t\ta: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestDupFieldNumber.Bar: ...\n\ta: int\n\n\t@property\n\tdef foo(self) -> TestDupFieldNumber.Foo: ...\n\n\t@property\n\tdef bar(self) -> TestDupFieldNumber.Bar: ...\n\n\tdef __init__(self,\n\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t foo: Optional[TestDupFieldNumber.Foo] = ...,\n\t\t\t\t bar: Optional[TestDupFieldNumber.Bar] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestDupFieldNumber: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestEagerMessage", "data": "class TestEagerMessage(Message):\n\n\t@property\n\tdef sub_message(self) -> TestAllTypes: ...\n\n\tdef __init__(self,\n\t\t\t\t sub_message: Optional[TestAllTypes] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestEagerMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestLazyMessage", "data": "class TestLazyMessage(Message):\n\n\t@property\n\tdef sub_message(self) -> TestAllTypes: ...\n\n\tdef __init__(self,\n\t\t\t\t sub_message: Optional[TestAllTypes] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestLazyMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestNestedMessageHasBits", "data": "class TestNestedMessageHasBits(Message):\n\tclass NestedMessage(Message):\n\t\tnestedmessage_repeated_int32: RepeatedScalarFieldContainer[int]\n\n\t\t@property\n\t\tdef nestedmessage_repeated_foreignmessage(\n\t\t\tself) -> RepeatedCompositeFieldContainer[ForeignMessage]: ...\n\n\t\tdef __init__(self,\n\t\t\t\t\t nestedmessage_repeated_int32: Optional[Iterable[int]] = ...,\n\t\t\t\t\t nestedmessage_repeated_foreignmessage: Optional[Iterable[ForeignMessage]] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(\n\t\t\tcls, s: bytes) -> TestNestedMessageHasBits.NestedMessage: ...\n\n\t@property\n\tdef optional_nested_message(\n\t\tself) -> TestNestedMessageHasBits.NestedMessage: ...\n\n\tdef __init__(self,\n\t\t\t\t optional_nested_message: Optional[TestNestedMessageHasBits.NestedMessage] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestNestedMessageHasBits: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestCamelCaseFieldNames", "data": "class TestCamelCaseFieldNames(Message):\n\tPrimitiveField: int\n\tStringField: Text\n\tEnumField: ForeignEnum\n\tStringPieceField: Text\n\tCordField: Text\n\tRepeatedPrimitiveField: RepeatedScalarFieldContainer[int]\n\tRepeatedStringField: RepeatedScalarFieldContainer[Text]\n\tRepeatedEnumField: RepeatedScalarFieldContainer[ForeignEnum]\n\tRepeatedStringPieceField: RepeatedScalarFieldContainer[Text]\n\tRepeatedCordField: RepeatedScalarFieldContainer[Text]\n\n\t@property\n\tdef MessageField(self) -> ForeignMessage: ...\n\n\t@property\n\tdef RepeatedMessageField(\n\t\tself) -> RepeatedCompositeFieldContainer[ForeignMessage]: ...\n\n\tdef __init__(self,\n\t\t\t\t PrimitiveField: Optional[int] = ...,\n\t\t\t\t StringField: Optional[Text] = ...,\n\t\t\t\t EnumField: Optional[ForeignEnum] = ...,\n\t\t\t\t MessageField: Optional[ForeignMessage] = ...,\n\t\t\t\t StringPieceField: Optional[Text] = ...,\n\t\t\t\t CordField: Optional[Text] = ...,\n\t\t\t\t RepeatedPrimitiveField: Optional[Iterable[int]] = ...,\n\t\t\t\t RepeatedStringField: Optional[Iterable[Text]] = ...,\n\t\t\t\t RepeatedEnumField: Optional[Iterable[ForeignEnum]] = ...,\n\t\t\t\t RepeatedMessageField: Optional[Iterable[ForeignMessage]] = ...,\n\t\t\t\t RepeatedStringPieceField: Optional[Iterable[Text]] = ...,\n\t\t\t\t RepeatedCordField: Optional[Iterable[Text]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestCamelCaseFieldNames: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestFieldOrderings", "data": "class TestFieldOrderings(Message):\n\tclass NestedMessage(Message):\n\t\too: int\n\t\tbb: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t oo: Optional[int] = ...,\n\t\t\t\t\t bb: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestFieldOrderings.NestedMessage: ...\n\tmy_string: Text\n\tmy_int: int\n\tmy_float: float\n\n\t@property\n\tdef optional_nested_message(self) -> TestFieldOrderings.NestedMessage: ...\n\n\tdef __init__(self,\n\t\t\t\t my_string: Optional[Text] = ...,\n\t\t\t\t my_int: Optional[int] = ...,\n\t\t\t\t my_float: Optional[float] = ...,\n\t\t\t\t optional_nested_message: Optional[TestFieldOrderings.NestedMessage] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestFieldOrderings: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestExtensionOrderings1", "data": "class TestExtensionOrderings1(Message):\n\tmy_string: Text\n\n\tdef __init__(self,\n\t\t\t\t my_string: Optional[Text] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestExtensionOrderings1: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestExtensionOrderings2", "data": "class TestExtensionOrderings2(Message):\n\tclass TestExtensionOrderings3(Message):\n\t\tmy_string: Text\n\n\t\tdef __init__(self,\n\t\t\t\t\t my_string: Optional[Text] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(\n\t\t\tcls, s: bytes) -> TestExtensionOrderings2.TestExtensionOrderings3: ...\n\tmy_string: Text\n\n\tdef __init__(self,\n\t\t\t\t my_string: Optional[Text] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestExtensionOrderings2: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestExtremeDefaultValues", "data": "class TestExtremeDefaultValues(Message):\n\tescaped_bytes: bytes\n\tlarge_uint32: int\n\tlarge_uint64: int\n\tsmall_int32: int\n\tsmall_int64: int\n\treally_small_int32: int\n\treally_small_int64: int\n\tutf8_string: Text\n\tzero_float: float\n\tone_float: float\n\tsmall_float: float\n\tnegative_one_float: float\n\tnegative_float: float\n\tlarge_float: float\n\tsmall_negative_float: float\n\tinf_double: float\n\tneg_inf_double: float\n\tnan_double: float\n\tinf_float: float\n\tneg_inf_float: float\n\tnan_float: float\n\tcpp_trigraph: Text\n\tstring_with_zero: Text\n\tbytes_with_zero: bytes\n\tstring_piece_with_zero: Text\n\tcord_with_zero: Text\n\treplacement_string: Text\n\n\tdef __init__(self,\n\t\t\t\t escaped_bytes: Optional[bytes] = ...,\n\t\t\t\t large_uint32: Optional[int] = ...,\n\t\t\t\t large_uint64: Optional[int] = ...,\n\t\t\t\t small_int32: Optional[int] = ...,\n\t\t\t\t small_int64: Optional[int] = ...,\n\t\t\t\t really_small_int32: Optional[int] = ...,\n\t\t\t\t really_small_int64: Optional[int] = ...,\n\t\t\t\t utf8_string: Optional[Text] = ...,\n\t\t\t\t zero_float: Optional[float] = ...,\n\t\t\t\t one_float: Optional[float] = ...,\n\t\t\t\t small_float: Optional[float] = ...,\n\t\t\t\t negative_one_float: Optional[float] = ...,\n\t\t\t\t negative_float: Optional[float] = ...,\n\t\t\t\t large_float: Optional[float] = ...,\n\t\t\t\t small_negative_float: Optional[float] = ...,\n\t\t\t\t inf_double: Optional[float] = ...,\n\t\t\t\t neg_inf_double: Optional[float] = ...,\n\t\t\t\t nan_double: Optional[float] = ...,\n\t\t\t\t inf_float: Optional[float] = ...,\n\t\t\t\t neg_inf_float: Optional[float] = ...,\n\t\t\t\t nan_float: Optional[float] = ...,\n\t\t\t\t cpp_trigraph: Optional[Text] = ...,\n\t\t\t\t string_with_zero: Optional[Text] = ...,\n\t\t\t\t bytes_with_zero: Optional[bytes] = ...,\n\t\t\t\t string_piece_with_zero: Optional[Text] = ...,\n\t\t\t\t cord_with_zero: Optional[Text] = ...,\n\t\t\t\t replacement_string: Optional[Text] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestExtremeDefaultValues: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "SparseEnumMessage", "data": "class SparseEnumMessage(Message):\n\tsparse_enum: TestSparseEnum\n\n\tdef __init__(self,\n\t\t\t\t sparse_enum: Optional[TestSparseEnum] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> SparseEnumMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "OneString", "data": "class OneString(Message):\n\tdata: Text\n\n\tdef __init__(self,\n\t\t\t\t data: Optional[Text] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> OneString: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "MoreString", "data": "class MoreString(Message):\n\tdata: RepeatedScalarFieldContainer[Text]\n\n\tdef __init__(self,\n\t\t\t\t data: Optional[Iterable[Text]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> MoreString: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "OneBytes", "data": "class OneBytes(Message):\n\tdata: bytes\n\n\tdef __init__(self,\n\t\t\t\t data: Optional[bytes] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> OneBytes: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "MoreBytes", "data": "class MoreBytes(Message):\n\tdata: RepeatedScalarFieldContainer[bytes]\n\n\tdef __init__(self,\n\t\t\t\t data: Optional[Iterable[bytes]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> MoreBytes: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "Int32Message", "data": "class Int32Message(Message):\n\tdata: int\n\n\tdef __init__(self,\n\t\t\t\t data: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> Int32Message: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "Uint32Message", "data": "class Uint32Message(Message):\n\tdata: int\n\n\tdef __init__(self,\n\t\t\t\t data: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> Uint32Message: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "Int64Message", "data": "class Int64Message(Message):\n\tdata: int\n\n\tdef __init__(self,\n\t\t\t\t data: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> Int64Message: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "Uint64Message", "data": "class Uint64Message(Message):\n\tdata: int\n\n\tdef __init__(self,\n\t\t\t\t data: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> Uint64Message: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "BoolMessage", "data": "class BoolMessage(Message):\n\tdata: bool\n\n\tdef __init__(self,\n\t\t\t\t data: Optional[bool] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> BoolMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestOneof", "data": "class TestOneof(Message):\n\tclass FooGroup(Message):\n\t\ta: int\n\t\tb: Text\n\n\t\tdef __init__(self,\n\t\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t\t b: Optional[Text] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestOneof.FooGroup: ...\n\tfoo_int: int\n\tfoo_string: Text\n\n\t@property\n\tdef foo_message(self) -> TestAllTypes: ...\n\n\t@property\n\tdef foogroup(self) -> TestOneof.FooGroup: ...\n\n\tdef __init__(self,\n\t\t\t\t foo_int: Optional[int] = ...,\n\t\t\t\t foo_string: Optional[Text] = ...,\n\t\t\t\t foo_message: Optional[TestAllTypes] = ...,\n\t\t\t\t foogroup: Optional[TestOneof.FooGroup] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestOneof: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestOneofBackwardsCompatible", "data": "class TestOneofBackwardsCompatible(Message):\n\tclass FooGroup(Message):\n\t\ta: int\n\t\tb: Text\n\n\t\tdef __init__(self,\n\t\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t\t b: Optional[Text] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(\n\t\t\tcls, s: bytes) -> TestOneofBackwardsCompatible.FooGroup: ...\n\tfoo_int: int\n\tfoo_string: Text\n\n\t@property\n\tdef foo_message(self) -> TestAllTypes: ...\n\n\t@property\n\tdef foogroup(self) -> TestOneofBackwardsCompatible.FooGroup: ...\n\n\tdef __init__(self,\n\t\t\t\t foo_int: Optional[int] = ...,\n\t\t\t\t foo_string: Optional[Text] = ...,\n\t\t\t\t foo_message: Optional[TestAllTypes] = ...,\n\t\t\t\t foogroup: Optional[TestOneofBackwardsCompatible.FooGroup] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestOneofBackwardsCompatible: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestOneof2", "data": "class TestOneof2(Message):\n\tclass NestedEnum(int):\n\t\t@classmethod\n\t\tdef Name(cls, number: int) -> bytes: ...\n\n\t\t@classmethod\n\t\tdef Value(cls, name: bytes) -> TestOneof2.NestedEnum: ...\n\n\t\t@classmethod\n\t\tdef keys(cls) -> List[bytes]: ...\n\n\t\t@classmethod\n\t\tdef values(cls) -> List[TestOneof2.NestedEnum]: ...\n\n\t\t@classmethod\n\t\tdef items(cls) -> List[Tuple[bytes, TestOneof2.NestedEnum]]: ...\n\tFOO: TestOneof2.NestedEnum\n\tBAR: TestOneof2.NestedEnum\n\tBAZ: TestOneof2.NestedEnum\n\n\tclass FooGroup(Message):\n\t\ta: int\n\t\tb: Text\n\n\t\tdef __init__(self,\n\t\t\t\t\t a: Optional[int] = ...,\n\t\t\t\t\t b: Optional[Text] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestOneof2.FooGroup: ...\n\n\tclass NestedMessage(Message):\n\t\tqux_int: int\n\t\tcorge_int: RepeatedScalarFieldContainer[int]\n\n\t\tdef __init__(self,\n\t\t\t\t\t qux_int: Optional[int] = ...,\n\t\t\t\t\t corge_int: Optional[Iterable[int]] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestOneof2.NestedMessage: ...\n\tfoo_int: int\n\tfoo_string: Text\n\tfoo_cord: Text\n\tfoo_string_piece: Text\n\tfoo_bytes: bytes\n\tfoo_enum: TestOneof2.NestedEnum\n\tbar_int: int\n\tbar_string: Text\n\tbar_cord: Text\n\tbar_string_piece: Text\n\tbar_bytes: bytes\n\tbar_enum: TestOneof2.NestedEnum\n\tbaz_int: int\n\tbaz_string: Text\n\n\t@property\n\tdef foo_message(self) -> TestOneof2.NestedMessage: ...\n\n\t@property\n\tdef foogroup(self) -> TestOneof2.FooGroup: ...\n\n\t@property\n\tdef foo_lazy_message(self) -> TestOneof2.NestedMessage: ...\n\n\tdef __init__(self,\n\t\t\t\t foo_int: Optional[int] = ...,\n\t\t\t\t foo_string: Optional[Text] = ...,\n\t\t\t\t foo_cord: Optional[Text] = ...,\n\t\t\t\t foo_string_piece: Optional[Text] = ...,\n\t\t\t\t foo_bytes: Optional[bytes] = ...,\n\t\t\t\t foo_enum: Optional[TestOneof2.NestedEnum] = ...,\n\t\t\t\t foo_message: Optional[TestOneof2.NestedMessage] = ...,\n\t\t\t\t foogroup: Optional[TestOneof2.FooGroup] = ...,\n\t\t\t\t foo_lazy_message: Optional[TestOneof2.NestedMessage] = ...,\n\t\t\t\t bar_int: Optional[int] = ...,\n\t\t\t\t bar_string: Optional[Text] = ...,\n\t\t\t\t bar_cord: Optional[Text] = ...,\n\t\t\t\t bar_string_piece: Optional[Text] = ...,\n\t\t\t\t bar_bytes: Optional[bytes] = ...,\n\t\t\t\t bar_enum: Optional[TestOneof2.NestedEnum] = ...,\n\t\t\t\t baz_int: Optional[int] = ...,\n\t\t\t\t baz_string: Optional[Text] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestOneof2: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestRequiredOneof", "data": "class TestRequiredOneof(Message):\n\tclass NestedMessage(Message):\n\t\trequired_double: float\n\n\t\tdef __init__(self,\n\t\t\t\t\t required_double: float,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestRequiredOneof.NestedMessage: ...\n\tfoo_int: int\n\tfoo_string: Text\n\n\t@property\n\tdef foo_message(self) -> TestRequiredOneof.NestedMessage: ...\n\n\tdef __init__(self,\n\t\t\t\t foo_int: Optional[int] = ...,\n\t\t\t\t foo_string: Optional[Text] = ...,\n\t\t\t\t foo_message: Optional[TestRequiredOneof.NestedMessage] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestRequiredOneof: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestPackedTypes", "data": "class TestPackedTypes(Message):\n\tpacked_int32: RepeatedScalarFieldContainer[int]\n\tpacked_int64: RepeatedScalarFieldContainer[int]\n\tpacked_uint32: RepeatedScalarFieldContainer[int]\n\tpacked_uint64: RepeatedScalarFieldContainer[int]\n\tpacked_sint32: RepeatedScalarFieldContainer[int]\n\tpacked_sint64: RepeatedScalarFieldContainer[int]\n\tpacked_fixed32: RepeatedScalarFieldContainer[int]\n\tpacked_fixed64: RepeatedScalarFieldContainer[int]\n\tpacked_sfixed32: RepeatedScalarFieldContainer[int]\n\tpacked_sfixed64: RepeatedScalarFieldContainer[int]\n\tpacked_float: RepeatedScalarFieldContainer[float]\n\tpacked_double: RepeatedScalarFieldContainer[float]\n\tpacked_bool: RepeatedScalarFieldContainer[bool]\n\tpacked_enum: RepeatedScalarFieldContainer[ForeignEnum]\n\n\tdef __init__(self,\n\t\t\t\t packed_int32: Optional[Iterable[int]] = ...,\n\t\t\t\t packed_int64: Optional[Iterable[int]] = ...,\n\t\t\t\t packed_uint32: Optional[Iterable[int]] = ...,\n\t\t\t\t packed_uint64: Optional[Iterable[int]] = ...,\n\t\t\t\t packed_sint32: Optional[Iterable[int]] = ...,\n\t\t\t\t packed_sint64: Optional[Iterable[int]] = ...,\n\t\t\t\t packed_fixed32: Optional[Iterable[int]] = ...,\n\t\t\t\t packed_fixed64: Optional[Iterable[int]] = ...,\n\t\t\t\t packed_sfixed32: Optional[Iterable[int]] = ...,\n\t\t\t\t packed_sfixed64: Optional[Iterable[int]] = ...,\n\t\t\t\t packed_float: Optional[Iterable[float]] = ...,\n\t\t\t\t packed_double: Optional[Iterable[float]] = ...,\n\t\t\t\t packed_bool: Optional[Iterable[bool]] = ...,\n\t\t\t\t packed_enum: Optional[Iterable[ForeignEnum]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestPackedTypes: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestUnpackedTypes", "data": "class TestUnpackedTypes(Message):\n\tunpacked_int32: RepeatedScalarFieldContainer[int]\n\tunpacked_int64: RepeatedScalarFieldContainer[int]\n\tunpacked_uint32: RepeatedScalarFieldContainer[int]\n\tunpacked_uint64: RepeatedScalarFieldContainer[int]\n\tunpacked_sint32: RepeatedScalarFieldContainer[int]\n\tunpacked_sint64: RepeatedScalarFieldContainer[int]\n\tunpacked_fixed32: RepeatedScalarFieldContainer[int]\n\tunpacked_fixed64: RepeatedScalarFieldContainer[int]\n\tunpacked_sfixed32: RepeatedScalarFieldContainer[int]\n\tunpacked_sfixed64: RepeatedScalarFieldContainer[int]\n\tunpacked_float: RepeatedScalarFieldContainer[float]\n\tunpacked_double: RepeatedScalarFieldContainer[float]\n\tunpacked_bool: RepeatedScalarFieldContainer[bool]\n\tunpacked_enum: RepeatedScalarFieldContainer[ForeignEnum]\n\n\tdef __init__(self,\n\t\t\t\t unpacked_int32: Optional[Iterable[int]] = ...,\n\t\t\t\t unpacked_int64: Optional[Iterable[int]] = ...,\n\t\t\t\t unpacked_uint32: Optional[Iterable[int]] = ...,\n\t\t\t\t unpacked_uint64: Optional[Iterable[int]] = ...,\n\t\t\t\t unpacked_sint32: Optional[Iterable[int]] = ...,\n\t\t\t\t unpacked_sint64: Optional[Iterable[int]] = ...,\n\t\t\t\t unpacked_fixed32: Optional[Iterable[int]] = ...,\n\t\t\t\t unpacked_fixed64: Optional[Iterable[int]] = ...,\n\t\t\t\t unpacked_sfixed32: Optional[Iterable[int]] = ...,\n\t\t\t\t unpacked_sfixed64: Optional[Iterable[int]] = ...,\n\t\t\t\t unpacked_float: Optional[Iterable[float]] = ...,\n\t\t\t\t unpacked_double: Optional[Iterable[float]] = ...,\n\t\t\t\t unpacked_bool: Optional[Iterable[bool]] = ...,\n\t\t\t\t unpacked_enum: Optional[Iterable[ForeignEnum]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestUnpackedTypes: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestPackedExtensions", "data": "class TestPackedExtensions(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestPackedExtensions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestUnpackedExtensions", "data": "class TestUnpackedExtensions(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestUnpackedExtensions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestDynamicExtensions", "data": "class TestDynamicExtensions(Message):\n\tclass DynamicEnumType(int):\n\t\t@classmethod\n\t\tdef Name(cls, number: int) -> bytes: ...\n\n\t\t@classmethod\n\t\tdef Value(cls, name: bytes) -> TestDynamicExtensions.DynamicEnumType: ...\n\n\t\t@classmethod\n\t\tdef keys(cls) -> List[bytes]: ...\n\n\t\t@classmethod\n\t\tdef values(cls) -> List[TestDynamicExtensions.DynamicEnumType]: ...\n\n\t\t@classmethod\n\t\tdef items(cls) -> List[Tuple[bytes,\n\t\t\t\t\t\t\t\t\t TestDynamicExtensions.DynamicEnumType]]: ...\n\tDYNAMIC_FOO: TestDynamicExtensions.DynamicEnumType\n\tDYNAMIC_BAR: TestDynamicExtensions.DynamicEnumType\n\tDYNAMIC_BAZ: TestDynamicExtensions.DynamicEnumType\n\n\tclass DynamicMessageType(Message):\n\t\tdynamic_field: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t dynamic_field: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(\n\t\t\tcls, s: bytes) -> TestDynamicExtensions.DynamicMessageType: ...\n\tscalar_extension: int\n\tenum_extension: ForeignEnum\n\tdynamic_enum_extension: TestDynamicExtensions.DynamicEnumType\n\trepeated_extension: RepeatedScalarFieldContainer[Text]\n\tpacked_extension: RepeatedScalarFieldContainer[int]\n\n\t@property\n\tdef message_extension(self) -> ForeignMessage: ...\n\n\t@property\n\tdef dynamic_message_extension(\n\t\tself) -> TestDynamicExtensions.DynamicMessageType: ...\n\n\tdef __init__(self,\n\t\t\t\t scalar_extension: Optional[int] = ...,\n\t\t\t\t enum_extension: Optional[ForeignEnum] = ...,\n\t\t\t\t dynamic_enum_extension: Optional[TestDynamicExtensions.DynamicEnumType] = ...,\n\t\t\t\t message_extension: Optional[ForeignMessage] = ...,\n\t\t\t\t dynamic_message_extension: Optional[TestDynamicExtensions.DynamicMessageType] = ...,\n\t\t\t\t repeated_extension: Optional[Iterable[Text]] = ...,\n\t\t\t\t packed_extension: Optional[Iterable[int]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestDynamicExtensions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestRepeatedScalarDifferentTagSizes", "data": "class TestRepeatedScalarDifferentTagSizes(Message):\n\trepeated_fixed32: RepeatedScalarFieldContainer[int]\n\trepeated_int32: RepeatedScalarFieldContainer[int]\n\trepeated_fixed64: RepeatedScalarFieldContainer[int]\n\trepeated_int64: RepeatedScalarFieldContainer[int]\n\trepeated_float: RepeatedScalarFieldContainer[float]\n\trepeated_uint64: RepeatedScalarFieldContainer[int]\n\n\tdef __init__(self,\n\t\t\t\t repeated_fixed32: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_int32: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_fixed64: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_int64: Optional[Iterable[int]] = ...,\n\t\t\t\t repeated_float: Optional[Iterable[float]] = ...,\n\t\t\t\t repeated_uint64: Optional[Iterable[int]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestRepeatedScalarDifferentTagSizes: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestParsingMerge", "data": "class TestParsingMerge(Message):\n\tclass RepeatedFieldsGenerator(Message):\n\t\tclass Group1(Message):\n\n\t\t\t@property\n\t\t\tdef field1(self) -> TestAllTypes: ...\n\n\t\t\tdef __init__(self,\n\t\t\t\t\t\t field1: Optional[TestAllTypes] = ...,\n\t\t\t\t\t\t ) -> None: ...\n\n\t\t\t@classmethod\n\t\t\tdef FromString(\n\t\t\t\tcls, s: bytes) -> TestParsingMerge.RepeatedFieldsGenerator.Group1: ...\n\n\t\tclass Group2(Message):\n\n\t\t\t@property\n\t\t\tdef field1(self) -> TestAllTypes: ...\n\n\t\t\tdef __init__(self,\n\t\t\t\t\t\t field1: Optional[TestAllTypes] = ...,\n\t\t\t\t\t\t ) -> None: ...\n\n\t\t\t@classmethod\n\t\t\tdef FromString(\n\t\t\t\tcls, s: bytes) -> TestParsingMerge.RepeatedFieldsGenerator.Group2: ...\n\n\t\t@property\n\t\tdef field1(self) -> RepeatedCompositeFieldContainer[TestAllTypes]: ...\n\n\t\t@property\n\t\tdef field2(self) -> RepeatedCompositeFieldContainer[TestAllTypes]: ...\n\n\t\t@property\n\t\tdef field3(self) -> RepeatedCompositeFieldContainer[TestAllTypes]: ...\n\n\t\t@property\n\t\tdef group1(\n\t\t\tself) -> RepeatedCompositeFieldContainer[TestParsingMerge.RepeatedFieldsGenerator.Group1]: ...\n\n\t\t@property\n\t\tdef group2(\n\t\t\tself) -> RepeatedCompositeFieldContainer[TestParsingMerge.RepeatedFieldsGenerator.Group2]: ...\n\n\t\t@property\n\t\tdef ext1(self) -> RepeatedCompositeFieldContainer[TestAllTypes]: ...\n\n\t\t@property\n\t\tdef ext2(self) -> RepeatedCompositeFieldContainer[TestAllTypes]: ...\n\n\t\tdef __init__(self,\n\t\t\t\t\t field1: Optional[Iterable[TestAllTypes]] = ...,\n\t\t\t\t\t field2: Optional[Iterable[TestAllTypes]] = ...,\n\t\t\t\t\t field3: Optional[Iterable[TestAllTypes]] = ...,\n\t\t\t\t\t group1: Optional[Iterable[TestParsingMerge.RepeatedFieldsGenerator.Group1]] = ...,\n\t\t\t\t\t group2: Optional[Iterable[TestParsingMerge.RepeatedFieldsGenerator.Group2]] = ...,\n\t\t\t\t\t ext1: Optional[Iterable[TestAllTypes]] = ...,\n\t\t\t\t\t ext2: Optional[Iterable[TestAllTypes]] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(\n\t\t\tcls, s: bytes) -> TestParsingMerge.RepeatedFieldsGenerator: ...\n\n\tclass OptionalGroup(Message):\n\n\t\t@property\n\t\tdef optional_group_all_types(self) -> TestAllTypes: ...\n\n\t\tdef __init__(self,\n\t\t\t\t\t optional_group_all_types: Optional[TestAllTypes] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestParsingMerge.OptionalGroup: ...\n\n\tclass RepeatedGroup(Message):\n\n\t\t@property\n\t\tdef repeated_group_all_types(self) -> TestAllTypes: ...\n\n\t\tdef __init__(self,\n\t\t\t\t\t repeated_group_all_types: Optional[TestAllTypes] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestParsingMerge.RepeatedGroup: ...\n\n\t@property\n\tdef required_all_types(self) -> TestAllTypes: ...\n\n\t@property\n\tdef optional_all_types(self) -> TestAllTypes: ...\n\n\t@property\n\tdef repeated_all_types(\n\t\tself) -> RepeatedCompositeFieldContainer[TestAllTypes]: ...\n\n\t@property\n\tdef optionalgroup(self) -> TestParsingMerge.OptionalGroup: ...\n\n\t@property\n\tdef repeatedgroup(\n\t\tself) -> RepeatedCompositeFieldContainer[TestParsingMerge.RepeatedGroup]: ...\n\n\tdef __init__(self,\n\t\t\t\t required_all_types: TestAllTypes,\n\t\t\t\t optional_all_types: Optional[TestAllTypes] = ...,\n\t\t\t\t repeated_all_types: Optional[Iterable[TestAllTypes]] = ...,\n\t\t\t\t optionalgroup: Optional[TestParsingMerge.OptionalGroup] = ...,\n\t\t\t\t repeatedgroup: Optional[Iterable[TestParsingMerge.RepeatedGroup]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestParsingMerge: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestCommentInjectionMessage", "data": "class TestCommentInjectionMessage(Message):\n\ta: Text\n\n\tdef __init__(self,\n\t\t\t\t a: Optional[Text] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestCommentInjectionMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "FooRequest", "data": "class FooRequest(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> FooRequest: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "FooResponse", "data": "class FooResponse(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> FooResponse: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "FooClientMessage", "data": "class FooClientMessage(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> FooClientMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "FooServerMessage", "data": "class FooServerMessage(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> FooServerMessage: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "BarRequest", "data": "class BarRequest(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> BarRequest: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "BarResponse", "data": "class BarResponse(Message):\n\n\tdef __init__(self,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> BarResponse: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestJsonName", "data": "class TestJsonName(Message):\n\tfield_name1: int\n\tfieldName2: int\n\tFieldName3: int\n\t_field_name4: int\n\tFIELD_NAME5: int\n\tfield_name6: int\n\n\tdef __init__(self,\n\t\t\t\t field_name1: Optional[int] = ...,\n\t\t\t\t fieldName2: Optional[int] = ...,\n\t\t\t\t FieldName3: Optional[int] = ...,\n\t\t\t\t _field_name4: Optional[int] = ...,\n\t\t\t\t FIELD_NAME5: Optional[int] = ...,\n\t\t\t\t field_name6: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestJsonName: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestHugeFieldNumbers", "data": "class TestHugeFieldNumbers(Message):\n\tclass OptionalGroup(Message):\n\t\tgroup_a: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t group_a: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> TestHugeFieldNumbers.OptionalGroup: ...\n\n\tclass StringStringMapEntry(Message):\n\t\tkey: Text\n\t\tvalue: Text\n\n\t\tdef __init__(self,\n\t\t\t\t\t key: Optional[Text] = ...,\n\t\t\t\t\t value: Optional[Text] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(\n\t\t\tcls, s: bytes) -> TestHugeFieldNumbers.StringStringMapEntry: ...\n\toptional_int32: int\n\tfixed_32: int\n\trepeated_int32: RepeatedScalarFieldContainer[int]\n\tpacked_int32: RepeatedScalarFieldContainer[int]\n\toptional_enum: ForeignEnum\n\toptional_string: Text\n\toptional_bytes: bytes\n\toneof_uint32: int\n\toneof_string: Text\n\toneof_bytes: bytes\n\n\t@property\n\tdef optional_message(self) -> ForeignMessage: ...\n\n\t@property\n\tdef optionalgroup(self) -> TestHugeFieldNumbers.OptionalGroup: ...\n\n\t@property\n\tdef string_string_map(self) -> MutableMapping[Text, Text]: ...\n\n\t@property\n\tdef oneof_test_all_types(self) -> TestAllTypes: ...\n\n\tdef __init__(self,\n\t\t\t\t optional_int32: Optional[int] = ...,\n\t\t\t\t fixed_32: Optional[int] = ...,\n\t\t\t\t repeated_int32: Optional[Iterable[int]] = ...,\n\t\t\t\t packed_int32: Optional[Iterable[int]] = ...,\n\t\t\t\t optional_enum: Optional[ForeignEnum] = ...,\n\t\t\t\t optional_string: Optional[Text] = ...,\n\t\t\t\t optional_bytes: Optional[bytes] = ...,\n\t\t\t\t optional_message: Optional[ForeignMessage] = ...,\n\t\t\t\t optionalgroup: Optional[TestHugeFieldNumbers.OptionalGroup] = ...,\n\t\t\t\t string_string_map: Optional[Mapping[Text, Text]] = ...,\n\t\t\t\t oneof_uint32: Optional[int] = ...,\n\t\t\t\t oneof_test_all_types: Optional[TestAllTypes] = ...,\n\t\t\t\t oneof_string: Optional[Text] = ...,\n\t\t\t\t oneof_bytes: Optional[bytes] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> TestHugeFieldNumbers: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}, {"term": "class", "name": "TestExtensionInsideTable", "data": "class TestExtensionInsideTable(Message):\n\tfield1: int\n\tfield2: int\n\tfield3: int\n\tfield4: int\n\tfield6: int\n\tfield7: int\n\tfield8: int\n\tfield9: int\n\tfield10: int\n\n\tdef __init__(self,\n\t\t\t\t field1: Optional[int] = ...,\n\t\t\t\t field2: Optional[int] = ...,\n\t\t\t\t field3: Optional[int] = ...,\n\t\t\t\t field4: Optional[int] = ...,\n\t\t\t\t field6: Optional[int] = ...,\n\t\t\t\t field7: Optional[int] = ...,\n\t\t\t\t field8: Optional[int] = ...,\n\t\t\t\t field9: Optional[int] = ...,\n\t\t\t\t field10: Optional[int] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from google.protobuf.unittest_import_pb2 import (", "from google.protobuf.unittest_import_public_pb2 import (", "from typing import (", "\toptional_import_enum: ImportEnum", "\trepeated_import_enum: RepeatedScalarFieldContainer[ImportEnum]", "\tdefault_import_enum: ImportEnum", "\tdef optional_import_message(self) -> ImportMessage: ...", "\tdef optional_public_import_message(self) -> PublicImportMessage: ...", "\tdef repeated_import_message(", "\t\t\t\t optional_import_message: Optional[ImportMessage] = ...,", "\t\t\t\t optional_import_enum: Optional[ImportEnum] = ...,", "\t\t\t\t optional_public_import_message: Optional[PublicImportMessage] = ...,", "\t\t\t\t repeated_import_message: Optional[Iterable[ImportMessage]] = ...,", "\t\t\t\t repeated_import_enum: Optional[Iterable[ImportEnum]] = ...,", "\t\t\t\t default_import_enum: Optional[ImportEnum] = ...,"]}], [{"term": "def", "name": "fdoModuleCleanups", "data": "\tdef doModuleCleanups() -> None: ...\n", "description": null, "category": "def", "imports": ["import datetime", "import logging", "import sys", "import unittest.result", "from types import TracebackType", "from typing import ("]}, {"term": "def", "name": "skipUnless", "data": "def skipUnless(condition: object, reason: str) -> Callable[[_FT], _FT]: ...\n\n", "description": null, "category": "def", "imports": ["import datetime", "import logging", "import sys", "import unittest.result", "from types import TracebackType", "from typing import ("]}, {"term": "class", "name": "SkipTest", "data": "class SkipTest(Exception):\n\tdef __init__(self, reason: str) -> None: ...\n\n", "description": null, "category": "def", "imports": ["import datetime", "import logging", "import sys", "import unittest.result", "from types import TracebackType", "from typing import ("]}, {"term": "class", "name": "classTestCase:", "data": "class TestCase:\n\tfailureException: Type[BaseException]\n\tlongMessage: bool\n\tmaxDiff: Optional[int]\n\t# undocumented\n\t_testMethodName: str\n\t# undocumented\n\t_testMethodDoc: str\n\tdef __init__(self, methodName: str = ...) -> None: ...\n\tdef setUp(self) -> None: ...\n\tdef tearDown(self) -> None: ...\n\t@classmethod\n\tdef setUpClass(cls) -> None: ...\n\t@classmethod\n\tdef tearDownClass(cls) -> None: ...\n\tdef run(self, result: Optional[unittest.result.TestResult] = ...) -> Optional[unittest.result.TestResult]: ...\n\tdef __call__(self, result: Optional[unittest.result.TestResult] = ...) -> Optional[unittest.result.TestResult]: ...\n\tdef skipTest(self, reason: Any) -> None: ...\n\tdef subTest(self, msg: Any = ..., **params: Any) -> ContextManager[None]: ...\n\tdef debug(self) -> None: ...\n\tdef _addSkip(\n\t\tself, result: unittest.result.TestResult, test_case: unittest.case.TestCase, reason: str\n\t) -> None: ...\n\tdef assertEqual(self, first: Any, second: Any, msg: Any = ...) -> None: ...\n\tdef assertNotEqual(self, first: Any, second: Any,\n\t\t\t\t\t   msg: Any = ...) -> None: ...\n\tdef assertTrue(self, expr: Any, msg: Any = ...) -> None: ...\n\tdef assertFalse(self, expr: Any, msg: Any = ...) -> None: ...\n\tdef assertIs(self, expr1: Any, expr2: Any, msg: Any = ...) -> None: ...\n\tdef assertIsNot(self, expr1: Any, expr2: Any, msg: Any = ...) -> None: ...\n\tdef assertIsNone(self, obj: Any, msg: Any = ...) -> None: ...\n\tdef assertIsNotNone(self, obj: Any, msg: Any = ...) -> None: ...\n\tdef assertIn(self, member: Any,\n\t\t\t\t container: Union[Iterable[Any], Container[Any]],\n\t\t\t\t msg: Any = ...) -> None: ...\n\tdef assertNotIn(self, member: Any,\n\t\t\t\t\tcontainer: Union[Iterable[Any], Container[Any]],\n\t\t\t\t\tmsg: Any = ...) -> None: ...\n\tdef assertIsInstance(self, obj: Any,\n\t\t\t\t\t\t cls: Union[type, Tuple[type, ...]],\n\t\t\t\t\t\t msg: Any = ...) -> None: ...\n\tdef assertNotIsInstance(self, obj: Any,\n\t\t\t\t\t\t\tcls: Union[type, Tuple[type, ...]],\n\t\t\t\t\t\t\tmsg: Any = ...) -> None: ...\n\tdef assertGreater(self, a: Any, b: Any, msg: Any = ...) -> None: ...\n\tdef assertGreaterEqual(self, a: Any, b: Any, msg: Any = ...) -> None: ...\n\tdef assertLess(self, a: Any, b: Any, msg: Any = ...) -> None: ...\n\tdef assertLessEqual(self, a: Any, b: Any, msg: Any = ...) -> None: ...\n\t@overload\n\tdef assertRaises(self,  # type: ignore\n\t\t\t\t\t expected_exception: Union[Type[BaseException], Tuple[Type[BaseException], ...]],\n\t\t\t\t\t callable: Callable[..., Any],\n\t\t\t\t\t *args: Any, **kwargs: Any) -> None: ...\n\t@overload\n\tdef assertRaises(self,\n\t\t\t\t\t expected_exception: Union[Type[_E], Tuple[Type[_E], ...]],\n\t\t\t\t\t msg: Any = ...) -> _AssertRaisesContext[_E]: ...\n\t@overload\n\tdef assertRaisesRegex(self,  # type: ignore\n\t\t\t\t\t\t  expected_exception: Union[Type[BaseException], Tuple[Type[BaseException], ...]],\n\t\t\t\t\t\t  expected_regex: Union[str, bytes, Pattern[str], Pattern[bytes]],\n\t\t\t\t\t\t  callable: Callable[..., Any],\n\t\t\t\t\t\t  *args: Any, **kwargs: Any) -> None: ...\n\t@overload\n\tdef assertRaisesRegex(self,\n\t\t\t\t\t\t  expected_exception: Union[Type[_E], Tuple[Type[_E], ...]],\n\t\t\t\t\t\t  expected_regex: Union[str, bytes, Pattern[str], Pattern[bytes]],\n\t\t\t\t\t\t  msg: Any = ...) -> _AssertRaisesContext[_E]: ...\n\t@overload\n\tdef assertWarns(self,  # type: ignore\n\t\t\t\t\texpected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]],\n\t\t\t\t\tcallable: Callable[..., Any],\n\t\t\t\t\t*args: Any, **kwargs: Any) -> None: ...\n\t@overload\n\tdef assertWarns(self,\n\t\t\t\t\texpected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]],\n\t\t\t\t\tmsg: Any = ...) -> _AssertWarnsContext: ...\n\t@overload\n\tdef assertWarnsRegex(self,  # type: ignore\n\t\t\t\t\t\t expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]],\n\t\t\t\t\t\t expected_regex: Union[str, bytes, Pattern[str], Pattern[bytes]],\n\t\t\t\t\t\t callable: Callable[..., Any],\n\t\t\t\t\t\t *args: Any, **kwargs: Any) -> None: ...\n\t@overload\n\tdef assertWarnsRegex(self,\n\t\t\t\t\t\t expected_warning: Union[Type[Warning], Tuple[Type[Warning], ...]],\n\t\t\t\t\t\t expected_regex: Union[str, bytes, Pattern[str], Pattern[bytes]],\n\t\t\t\t\t\t msg: Any = ...) -> _AssertWarnsContext: ...\n\tdef assertLogs(\n\t\tself, logger: Optional[Union[str, logging.Logger]] = ...,\n\t\tlevel: Union[int, str, None] = ...\n\t) -> _AssertLogsContext: ...\n\t@overload\n\tdef assertAlmostEqual(self, first: float, second: float, places: int = ...,\n\t\t\t\t\t\t  msg: Any = ..., delta: float = ...) -> None: ...\n\t@overload\n\tdef assertAlmostEqual(self, first: datetime.datetime, second: datetime.datetime,\n\t\t\t\t\t\t  places: int = ..., msg: Any = ...,\n\t\t\t\t\t\t  delta: datetime.timedelta = ...) -> None: ...\n\t@overload\n\tdef assertNotAlmostEqual(self, first: float, second: float, *,\n\t\t\t\t\t\t\t msg: Any = ...) -> None: ...\n\t@overload\n\tdef assertNotAlmostEqual(self, first: float, second: float,\n\t\t\t\t\t\t\t places: int = ..., msg: Any = ...) -> None: ...\n\t@overload\n\tdef assertNotAlmostEqual(self, first: float, second: float, *,\n\t\t\t\t\t\t\t msg: Any = ..., delta: float = ...) -> None: ...\n\t@overload\n\tdef assertNotAlmostEqual(self, first: datetime.datetime, second: datetime.datetime,\n\t\t\t\t\t\t\t places: int = ..., msg: Any = ...,\n\t\t\t\t\t\t\t delta: datetime.timedelta = ...) -> None: ...\n\tdef assertRegex(self, text: AnyStr, expected_regex: Union[AnyStr, Pattern[AnyStr]],\n\t\t\t\t\tmsg: Any = ...) -> None: ...\n\tdef assertNotRegex(self, text: AnyStr, unexpected_regex: Union[AnyStr, Pattern[AnyStr]],\n\t\t\t\t\t   msg: Any = ...) -> None: ...\n\tdef assertCountEqual(self, first: Iterable[Any], second: Iterable[Any],\n\t\t\t\t\t\t msg: Any = ...) -> None: ...\n\tdef addTypeEqualityFunc(self, typeobj: Type[Any],\n\t\t\t\t\t\t\tfunction: Callable[..., None]) -> None: ...\n\tdef assertMultiLineEqual(self, first: str, second: str,\n\t\t\t\t\t\t\t msg: Any = ...) -> None: ...\n\tdef assertSequenceEqual(self, seq1: Sequence[Any], seq2: Sequence[Any],\n\t\t\t\t\t\t\tmsg: Any = ...,\n\t\t\t\t\t\t\tseq_type: Type[Sequence[Any]] = ...) -> None: ...\n\tdef assertListEqual(self, list1: List[Any], list2: List[Any],\n\t\t\t\t\t\tmsg: Any = ...) -> None: ...\n\tdef assertTupleEqual(self, tuple1: Tuple[Any, ...], tuple2: Tuple[Any, ...],\n\t\t\t\t\t\t msg: Any = ...) -> None: ...\n\tdef assertSetEqual(self, set1: Union[Set[Any], FrozenSet[Any]],\n\t\t\t\t\t   set2: Union[Set[Any], FrozenSet[Any]], msg: Any = ...) -> None: ...\n\tdef assertDictEqual(self, d1: Dict[Any, Any], d2: Dict[Any, Any],\n\t\t\t\t\t\tmsg: Any = ...) -> None: ...\n\tdef fail(self, msg: Any = ...) -> NoReturn: ...\n\tdef countTestCases(self) -> int: ...\n\tdef defaultTestResult(self) -> unittest.result.TestResult: ...\n\tdef id(self) -> str: ...\n\tdef shortDescription(self) -> Optional[str]: ...\n\tdef addCleanup(self, function: Callable[..., Any], *args: Any,\n\t\t\t\t   **kwargs: Any) -> None: ...\n\tdef doCleanups(self) -> None: ...\n\tif sys.version_info >= (3, 8):\n\t\t@classmethod\n\t\tdef addClassCleanup(cls, __function: Callable[..., Any], *args: Any, **kwargs: Any) -> None: ...\n\t\t@classmethod\n\t\tdef doClassCleanups(cls) -> None: ...\n\tdef _formatMessage(self, msg: Optional[str], standardMsg: str) -> str: ...  # undocumented\n\tdef _getAssertEqualityFunc(self, first: Any, second: Any) -> Callable[..., None]: ...  # undocumented\n\t# below is deprecated\n\tdef failUnlessEqual(self, first: Any, second: Any,\n\t\t\t\t\t\tmsg: Any = ...) -> None: ...\n\tdef assertEquals(self, first: Any, second: Any, msg: Any = ...) -> None: ...\n\tdef failIfEqual(self, first: Any, second: Any, msg: Any = ...) -> None: ...\n\tdef assertNotEquals(self, first: Any, second: Any,\n\t\t\t\t\t\tmsg: Any = ...) -> None: ...\n\tdef failUnless(self, expr: bool, msg: Any = ...) -> None: ...\n\tdef assert_(self, expr: bool, msg: Any = ...) -> None: ...\n\tdef failIf(self, expr: bool, msg: Any = ...) -> None: ...\n\t@overload\n\tdef failUnlessRaises(self,  # type: ignore\n\t\t\t\t\t\t exception: Union[Type[BaseException], Tuple[Type[BaseException], ...]],\n\t\t\t\t\t\t callable: Callable[..., Any] = ...,\n\t\t\t\t\t\t *args: Any, **kwargs: Any) -> None: ...\n\t@overload\n\tdef failUnlessRaises(self,\n\t\t\t\t\t\t exception: Union[Type[_E], Tuple[Type[_E], ...]],\n\t\t\t\t\t\t msg: Any = ...) -> _AssertRaisesContext[_E]: ...\n\tdef failUnlessAlmostEqual(self, first: float, second: float,\n\t\t\t\t\t\t\t  places: int = ..., msg: Any = ...) -> None: ...\n\tdef assertAlmostEquals(self, first: float, second: float, places: int = ...,\n\t\t\t\t\t\t   msg: Any = ..., delta: float = ...) -> None: ...\n\tdef failIfAlmostEqual(self, first: float, second: float, places: int = ...,\n\t\t\t\t\t\t  msg: Any = ...) -> None: ...\n\tdef assertNotAlmostEquals(self, first: float, second: float,\n\t\t\t\t\t\t\t  places: int = ..., msg: Any = ...,\n\t\t\t\t\t\t\t  delta: float = ...) -> None: ...\n\tdef assertRegexpMatches(self, text: AnyStr, regex: Union[AnyStr, Pattern[AnyStr]],\n\t\t\t\t\t\t\tmsg: Any = ...) -> None: ...\n\t@overload\n\tdef assertRaisesRegexp(self,  # type: ignore\n\t\t\t\t\t\t   exception: Union[Type[BaseException], Tuple[Type[BaseException], ...]],\n\t\t\t\t\t\t   expected_regex: Union[str, bytes, Pattern[str], Pattern[bytes]],\n\t\t\t\t\t\t   callable: Callable[..., Any],\n\t\t\t\t\t\t   *args: Any, **kwargs: Any) -> None: ...\n\t@overload\n\tdef assertRaisesRegexp(self,\n\t\t\t\t\t\t   exception: Union[Type[_E], Tuple[Type[_E], ...]],\n\t\t\t\t\t\t   expected_regex: Union[str, bytes, Pattern[str], Pattern[bytes]],\n\t\t\t\t\t\t   msg: Any = ...) -> _AssertRaisesContext[_E]: ...\n\tdef assertDictContainsSubset(self,\n\t\t\t\t\t\t\t\t expected: Mapping[Any, Any],\n\t\t\t\t\t\t\t\t actual: Mapping[Any, Any],\n\t\t\t\t\t\t\t\t msg: object = ...) -> None: ...\n", "description": null, "category": "def", "imports": ["import datetime", "import logging", "import sys", "import unittest.result", "from types import TracebackType", "from typing import ("]}, {"term": "class", "name": "FunctionTestCase", "data": "class FunctionTestCase(TestCase):\n\tdef __init__(self, testFunc: Callable[[], None],\n\t\t\t\t setUp: Optional[Callable[[], None]] = ...,\n\t\t\t\t tearDown: Optional[Callable[[], None]] = ...,\n\t\t\t\t description: Optional[str] = ...) -> None: ...\n", "description": null, "category": "def", "imports": ["import datetime", "import logging", "import sys", "import unittest.result", "from types import TracebackType", "from typing import ("]}, {"term": "class", "name": "_AssertRaisesContext", "data": "class _AssertRaisesContext(Generic[_E]):\n\texception: _E\n\tdef __enter__(self) -> _AssertRaisesContext[_E]: ...\n\tdef __exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException],\n\t\t\t\t exc_tb: Optional[TracebackType]) -> bool: ...\n", "description": null, "category": "def", "imports": ["import datetime", "import logging", "import sys", "import unittest.result", "from types import TracebackType", "from typing import ("]}, {"term": "class", "name": "class_AssertWarnsContext:", "data": "class _AssertWarnsContext:\n\twarning: Warning\n\tfilename: str\n\tlineno: int\n\tdef __enter__(self) -> _AssertWarnsContext: ...\n\tdef __exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException],\n\t\t\t\t exc_tb: Optional[TracebackType]) -> None: ...\n", "description": null, "category": "def", "imports": ["import datetime", "import logging", "import sys", "import unittest.result", "from types import TracebackType", "from typing import ("]}, {"term": "class", "name": "class_AssertLogsContext:", "data": "class _AssertLogsContext:\n\trecords: List[logging.LogRecord]\n\toutput: List[str]\n\tdef __enter__(self) -> _AssertLogsContext: ...\n\tdef __exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException],\n", "description": null, "category": "def", "imports": ["import datetime", "import logging", "import sys", "import unittest.result", "from types import TracebackType", "from typing import ("]}], [{"term": "class", "name": "FileDescriptorSet", "data": "class FileDescriptorSet(Message):\n\n\t@property\n\tdef file(self) -> RepeatedCompositeFieldContainer[FileDescriptorProto]: ...\n\n\tdef __init__(self,\n\t\t\t\t file: Optional[Iterable[FileDescriptorProto]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> FileDescriptorSet: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "FileDescriptorProto", "data": "class FileDescriptorProto(Message):\n\tname: Text\n\tpackage: Text\n\tdependency: RepeatedScalarFieldContainer[Text]\n\tpublic_dependency: RepeatedScalarFieldContainer[int]\n\tweak_dependency: RepeatedScalarFieldContainer[int]\n\tsyntax: Text\n\n\t@property\n\tdef message_type(\n\t\tself) -> RepeatedCompositeFieldContainer[DescriptorProto]: ...\n\n\t@property\n\tdef enum_type(\n\t\tself) -> RepeatedCompositeFieldContainer[EnumDescriptorProto]: ...\n\n\t@property\n\tdef service(\n\t\tself) -> RepeatedCompositeFieldContainer[ServiceDescriptorProto]: ...\n\n\t@property\n\tdef extension(\n\t\tself) -> RepeatedCompositeFieldContainer[FieldDescriptorProto]: ...\n\n\t@property\n\tdef options(self) -> FileOptions: ...\n\n\t@property\n\tdef source_code_info(self) -> SourceCodeInfo: ...\n\n\tdef __init__(self,\n\t\t\t\t name: Optional[Text] = ...,\n\t\t\t\t package: Optional[Text] = ...,\n\t\t\t\t dependency: Optional[Iterable[Text]] = ...,\n\t\t\t\t public_dependency: Optional[Iterable[int]] = ...,\n\t\t\t\t weak_dependency: Optional[Iterable[int]] = ...,\n\t\t\t\t message_type: Optional[Iterable[DescriptorProto]] = ...,\n\t\t\t\t enum_type: Optional[Iterable[EnumDescriptorProto]] = ...,\n\t\t\t\t service: Optional[Iterable[ServiceDescriptorProto]] = ...,\n\t\t\t\t extension: Optional[Iterable[FieldDescriptorProto]] = ...,\n\t\t\t\t options: Optional[FileOptions] = ...,\n\t\t\t\t source_code_info: Optional[SourceCodeInfo] = ...,\n\t\t\t\t syntax: Optional[Text] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> FileDescriptorProto: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "DescriptorProto", "data": "class DescriptorProto(Message):\n\n\tclass ExtensionRange(Message):\n\t\tstart: int\n\t\tend: int\n\n\t\t@property\n\t\tdef options(self) -> ExtensionRangeOptions: ...\n\n\t\tdef __init__(self,\n\t\t\t\t\t start: Optional[int] = ...,\n\t\t\t\t\t end: Optional[int] = ...,\n\t\t\t\t\t options: Optional[ExtensionRangeOptions] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> DescriptorProto.ExtensionRange: ...\n\n\tclass ReservedRange(Message):\n\t\tstart: int\n\t\tend: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t start: Optional[int] = ...,\n\t\t\t\t\t end: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> DescriptorProto.ReservedRange: ...\n\tname: Text\n\treserved_name: RepeatedScalarFieldContainer[Text]\n\n\t@property\n\tdef field(\n\t\tself) -> RepeatedCompositeFieldContainer[FieldDescriptorProto]: ...\n\n\t@property\n\tdef extension(\n\t\tself) -> RepeatedCompositeFieldContainer[FieldDescriptorProto]: ...\n\n\t@property\n\tdef nested_type(\n\t\tself) -> RepeatedCompositeFieldContainer[DescriptorProto]: ...\n\n\t@property\n\tdef enum_type(\n\t\tself) -> RepeatedCompositeFieldContainer[EnumDescriptorProto]: ...\n\n\t@property\n\tdef extension_range(\n\t\tself) -> RepeatedCompositeFieldContainer[DescriptorProto.ExtensionRange]: ...\n\n\t@property\n\tdef oneof_decl(\n\t\tself) -> RepeatedCompositeFieldContainer[OneofDescriptorProto]: ...\n\n\t@property\n\tdef options(self) -> MessageOptions: ...\n\n\t@property\n\tdef reserved_range(\n\t\tself) -> RepeatedCompositeFieldContainer[DescriptorProto.ReservedRange]: ...\n\n\tdef __init__(self,\n\t\t\t\t name: Optional[Text] = ...,\n\t\t\t\t field: Optional[Iterable[FieldDescriptorProto]] = ...,\n\t\t\t\t extension: Optional[Iterable[FieldDescriptorProto]] = ...,\n\t\t\t\t nested_type: Optional[Iterable[DescriptorProto]] = ...,\n\t\t\t\t enum_type: Optional[Iterable[EnumDescriptorProto]] = ...,\n\t\t\t\t extension_range: Optional[Iterable[DescriptorProto.ExtensionRange]] = ...,\n\t\t\t\t oneof_decl: Optional[Iterable[OneofDescriptorProto]] = ...,\n\t\t\t\t options: Optional[MessageOptions] = ...,\n\t\t\t\t reserved_range: Optional[Iterable[DescriptorProto.ReservedRange]] = ...,\n\t\t\t\t reserved_name: Optional[Iterable[Text]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> DescriptorProto: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "ExtensionRangeOptions", "data": "class ExtensionRangeOptions(Message):\n\n\t@property\n\tdef uninterpreted_option(\n\t\tself) -> RepeatedCompositeFieldContainer[UninterpretedOption]: ...\n\n\tdef __init__(self,\n\t\t\t\t uninterpreted_option: Optional[Iterable[UninterpretedOption]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> ExtensionRangeOptions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "FieldDescriptorProto", "data": "class FieldDescriptorProto(Message):\n\n\tclass Type(int):\n\n\t\t@classmethod\n\t\tdef Name(cls, number: int) -> bytes: ...\n\n\t\t@classmethod\n\t\tdef Value(cls, name: bytes) -> FieldDescriptorProto.Type: ...\n\n\t\t@classmethod\n\t\tdef keys(cls) -> List[bytes]: ...\n\n\t\t@classmethod\n\t\tdef values(cls) -> List[FieldDescriptorProto.Type]: ...\n\n\t\t@classmethod\n\t\tdef items(cls) -> List[Tuple[bytes, FieldDescriptorProto.Type]]: ...\n\tTYPE_DOUBLE: FieldDescriptorProto.Type\n\tTYPE_FLOAT: FieldDescriptorProto.Type\n\tTYPE_INT64: FieldDescriptorProto.Type\n\tTYPE_UINT64: FieldDescriptorProto.Type\n\tTYPE_INT32: FieldDescriptorProto.Type\n\tTYPE_FIXED64: FieldDescriptorProto.Type\n\tTYPE_FIXED32: FieldDescriptorProto.Type\n\tTYPE_BOOL: FieldDescriptorProto.Type\n\tTYPE_STRING: FieldDescriptorProto.Type\n\tTYPE_GROUP: FieldDescriptorProto.Type\n\tTYPE_MESSAGE: FieldDescriptorProto.Type\n\tTYPE_BYTES: FieldDescriptorProto.Type\n\tTYPE_UINT32: FieldDescriptorProto.Type\n\tTYPE_ENUM: FieldDescriptorProto.Type\n\tTYPE_SFIXED32: FieldDescriptorProto.Type\n\tTYPE_SFIXED64: FieldDescriptorProto.Type\n\tTYPE_SINT32: FieldDescriptorProto.Type\n\tTYPE_SINT64: FieldDescriptorProto.Type\n\n\tclass Label(int):\n\n\t\t@classmethod\n\t\tdef Name(cls, number: int) -> bytes: ...\n\n\t\t@classmethod\n\t\tdef Value(cls, name: bytes) -> FieldDescriptorProto.Label: ...\n\n\t\t@classmethod\n\t\tdef keys(cls) -> List[bytes]: ...\n\n\t\t@classmethod\n\t\tdef values(cls) -> List[FieldDescriptorProto.Label]: ...\n\n\t\t@classmethod\n\t\tdef items(cls) -> List[Tuple[bytes, FieldDescriptorProto.Label]]: ...\n\tLABEL_OPTIONAL: FieldDescriptorProto.Label\n\tLABEL_REQUIRED: FieldDescriptorProto.Label\n\tLABEL_REPEATED: FieldDescriptorProto.Label\n\tname: Text\n\tnumber: int\n\tlabel: FieldDescriptorProto.Label\n\ttype: FieldDescriptorProto.Type\n\ttype_name: Text\n\textendee: Text\n\tdefault_value: Text\n\toneof_index: int\n\tjson_name: Text\n\n\t@property\n\tdef options(self) -> FieldOptions: ...\n\n\tdef __init__(self,\n\t\t\t\t name: Optional[Text] = ...,\n\t\t\t\t number: Optional[int] = ...,\n\t\t\t\t label: Optional[FieldDescriptorProto.Label] = ...,\n\t\t\t\t type: Optional[FieldDescriptorProto.Type] = ...,\n\t\t\t\t type_name: Optional[Text] = ...,\n\t\t\t\t extendee: Optional[Text] = ...,\n\t\t\t\t default_value: Optional[Text] = ...,\n\t\t\t\t oneof_index: Optional[int] = ...,\n\t\t\t\t json_name: Optional[Text] = ...,\n\t\t\t\t options: Optional[FieldOptions] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> FieldDescriptorProto: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "OneofDescriptorProto", "data": "class OneofDescriptorProto(Message):\n\tname: Text\n\n\t@property\n\tdef options(self) -> OneofOptions: ...\n\n\tdef __init__(self,\n\t\t\t\t name: Optional[Text] = ...,\n\t\t\t\t options: Optional[OneofOptions] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> OneofDescriptorProto: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "EnumDescriptorProto", "data": "class EnumDescriptorProto(Message):\n\n\tclass EnumReservedRange(Message):\n\t\tstart: int\n\t\tend: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t start: Optional[int] = ...,\n\t\t\t\t\t end: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(\n\t\t\tcls, s: bytes) -> EnumDescriptorProto.EnumReservedRange: ...\n\tname: Text\n\treserved_name: RepeatedScalarFieldContainer[Text]\n\n\t@property\n\tdef value(\n\t\tself) -> RepeatedCompositeFieldContainer[EnumValueDescriptorProto]: ...\n\n\t@property\n\tdef options(self) -> EnumOptions: ...\n\n\t@property\n\tdef reserved_range(\n\t\tself) -> RepeatedCompositeFieldContainer[EnumDescriptorProto.EnumReservedRange]: ...\n\n\tdef __init__(self,\n\t\t\t\t name: Optional[Text] = ...,\n\t\t\t\t value: Optional[Iterable[EnumValueDescriptorProto]] = ...,\n\t\t\t\t options: Optional[EnumOptions] = ...,\n\t\t\t\t reserved_range: Optional[Iterable[EnumDescriptorProto.EnumReservedRange]] = ...,\n\t\t\t\t reserved_name: Optional[Iterable[Text]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> EnumDescriptorProto: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "EnumValueDescriptorProto", "data": "class EnumValueDescriptorProto(Message):\n\tname: Text\n\tnumber: int\n\n\t@property\n\tdef options(self) -> EnumValueOptions: ...\n\n\tdef __init__(self,\n\t\t\t\t name: Optional[Text] = ...,\n\t\t\t\t number: Optional[int] = ...,\n\t\t\t\t options: Optional[EnumValueOptions] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> EnumValueDescriptorProto: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "ServiceDescriptorProto", "data": "class ServiceDescriptorProto(Message):\n\tname: Text\n\n\t@property\n\tdef method(\n\t\tself) -> RepeatedCompositeFieldContainer[MethodDescriptorProto]: ...\n\n\t@property\n\tdef options(self) -> ServiceOptions: ...\n\n\tdef __init__(self,\n\t\t\t\t name: Optional[Text] = ...,\n\t\t\t\t method: Optional[Iterable[MethodDescriptorProto]] = ...,\n\t\t\t\t options: Optional[ServiceOptions] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> ServiceDescriptorProto: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "MethodDescriptorProto", "data": "class MethodDescriptorProto(Message):\n\tname: Text\n\tinput_type: Text\n\toutput_type: Text\n\tclient_streaming: bool\n\tserver_streaming: bool\n\n\t@property\n\tdef options(self) -> MethodOptions: ...\n\n\tdef __init__(self,\n\t\t\t\t name: Optional[Text] = ...,\n\t\t\t\t input_type: Optional[Text] = ...,\n\t\t\t\t output_type: Optional[Text] = ...,\n\t\t\t\t options: Optional[MethodOptions] = ...,\n\t\t\t\t client_streaming: Optional[bool] = ...,\n\t\t\t\t server_streaming: Optional[bool] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> MethodDescriptorProto: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "FileOptions", "data": "class FileOptions(Message):\n\n\tclass OptimizeMode(int):\n\n\t\t@classmethod\n\t\tdef Name(cls, number: int) -> bytes: ...\n\n\t\t@classmethod\n\t\tdef Value(cls, name: bytes) -> FileOptions.OptimizeMode: ...\n\n\t\t@classmethod\n\t\tdef keys(cls) -> List[bytes]: ...\n\n\t\t@classmethod\n\t\tdef values(cls) -> List[FileOptions.OptimizeMode]: ...\n\n\t\t@classmethod\n\t\tdef items(cls) -> List[Tuple[bytes, FileOptions.OptimizeMode]]: ...\n\tSPEED: FileOptions.OptimizeMode\n\tCODE_SIZE: FileOptions.OptimizeMode\n\tLITE_RUNTIME: FileOptions.OptimizeMode\n\tjava_package: Text\n\tjava_outer_classname: Text\n\tjava_multiple_files: bool\n\tjava_generate_equals_and_hash: bool\n\tjava_string_check_utf8: bool\n\toptimize_for: FileOptions.OptimizeMode\n\tgo_package: Text\n\tcc_generic_services: bool\n\tjava_generic_services: bool\n\tpy_generic_services: bool\n\tphp_generic_services: bool\n\tdeprecated: bool\n\tcc_enable_arenas: bool\n\tobjc_class_prefix: Text\n\tcsharp_namespace: Text\n\tswift_prefix: Text\n\tphp_class_prefix: Text\n\tphp_namespace: Text\n\n\t@property\n\tdef uninterpreted_option(\n\t\tself) -> RepeatedCompositeFieldContainer[UninterpretedOption]: ...\n\n\tdef __init__(self,\n\t\t\t\t java_package: Optional[Text] = ...,\n\t\t\t\t java_outer_classname: Optional[Text] = ...,\n\t\t\t\t java_multiple_files: Optional[bool] = ...,\n\t\t\t\t java_generate_equals_and_hash: Optional[bool] = ...,\n\t\t\t\t java_string_check_utf8: Optional[bool] = ...,\n\t\t\t\t optimize_for: Optional[FileOptions.OptimizeMode] = ...,\n\t\t\t\t go_package: Optional[Text] = ...,\n\t\t\t\t cc_generic_services: Optional[bool] = ...,\n\t\t\t\t java_generic_services: Optional[bool] = ...,\n\t\t\t\t py_generic_services: Optional[bool] = ...,\n\t\t\t\t php_generic_services: Optional[bool] = ...,\n\t\t\t\t deprecated: Optional[bool] = ...,\n\t\t\t\t cc_enable_arenas: Optional[bool] = ...,\n\t\t\t\t objc_class_prefix: Optional[Text] = ...,\n\t\t\t\t csharp_namespace: Optional[Text] = ...,\n\t\t\t\t swift_prefix: Optional[Text] = ...,\n\t\t\t\t php_class_prefix: Optional[Text] = ...,\n\t\t\t\t php_namespace: Optional[Text] = ...,\n\t\t\t\t uninterpreted_option: Optional[Iterable[UninterpretedOption]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> FileOptions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "MessageOptions", "data": "class MessageOptions(Message):\n\tmessage_set_wire_format: bool\n\tno_standard_descriptor_accessor: bool\n\tdeprecated: bool\n\tmap_entry: bool\n\n\t@property\n\tdef uninterpreted_option(\n\t\tself) -> RepeatedCompositeFieldContainer[UninterpretedOption]: ...\n\n\tdef __init__(self,\n\t\t\t\t message_set_wire_format: Optional[bool] = ...,\n\t\t\t\t no_standard_descriptor_accessor: Optional[bool] = ...,\n\t\t\t\t deprecated: Optional[bool] = ...,\n\t\t\t\t map_entry: Optional[bool] = ...,\n\t\t\t\t uninterpreted_option: Optional[Iterable[UninterpretedOption]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> MessageOptions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "FieldOptions", "data": "class FieldOptions(Message):\n\n\tclass CType(int):\n\n\t\t@classmethod\n\t\tdef Name(cls, number: int) -> bytes: ...\n\n\t\t@classmethod\n\t\tdef Value(cls, name: bytes) -> FieldOptions.CType: ...\n\n\t\t@classmethod\n\t\tdef keys(cls) -> List[bytes]: ...\n\n\t\t@classmethod\n\t\tdef values(cls) -> List[FieldOptions.CType]: ...\n\n\t\t@classmethod\n\t\tdef items(cls) -> List[Tuple[bytes, FieldOptions.CType]]: ...\n\tSTRING: FieldOptions.CType\n\tCORD: FieldOptions.CType\n\tSTRING_PIECE: FieldOptions.CType\n\n\tclass JSType(int):\n\n\t\t@classmethod\n\t\tdef Name(cls, number: int) -> bytes: ...\n\n\t\t@classmethod\n\t\tdef Value(cls, name: bytes) -> FieldOptions.JSType: ...\n\n\t\t@classmethod\n\t\tdef keys(cls) -> List[bytes]: ...\n\n\t\t@classmethod\n\t\tdef values(cls) -> List[FieldOptions.JSType]: ...\n\n\t\t@classmethod\n\t\tdef items(cls) -> List[Tuple[bytes, FieldOptions.JSType]]: ...\n\tJS_NORMAL: FieldOptions.JSType\n\tJS_STRING: FieldOptions.JSType\n\tJS_NUMBER: FieldOptions.JSType\n\tctype: FieldOptions.CType\n\tpacked: bool\n\tjstype: FieldOptions.JSType\n\tlazy: bool\n\tdeprecated: bool\n\tweak: bool\n\n\t@property\n\tdef uninterpreted_option(\n\t\tself) -> RepeatedCompositeFieldContainer[UninterpretedOption]: ...\n\n\tdef __init__(self,\n\t\t\t\t ctype: Optional[FieldOptions.CType] = ...,\n\t\t\t\t packed: Optional[bool] = ...,\n\t\t\t\t jstype: Optional[FieldOptions.JSType] = ...,\n\t\t\t\t lazy: Optional[bool] = ...,\n\t\t\t\t deprecated: Optional[bool] = ...,\n\t\t\t\t weak: Optional[bool] = ...,\n\t\t\t\t uninterpreted_option: Optional[Iterable[UninterpretedOption]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> FieldOptions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "OneofOptions", "data": "class OneofOptions(Message):\n\n\t@property\n\tdef uninterpreted_option(\n\t\tself) -> RepeatedCompositeFieldContainer[UninterpretedOption]: ...\n\n\tdef __init__(self,\n\t\t\t\t uninterpreted_option: Optional[Iterable[UninterpretedOption]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> OneofOptions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "EnumOptions", "data": "class EnumOptions(Message):\n\tallow_alias: bool\n\tdeprecated: bool\n\n\t@property\n\tdef uninterpreted_option(\n\t\tself) -> RepeatedCompositeFieldContainer[UninterpretedOption]: ...\n\n\tdef __init__(self,\n\t\t\t\t allow_alias: Optional[bool] = ...,\n\t\t\t\t deprecated: Optional[bool] = ...,\n\t\t\t\t uninterpreted_option: Optional[Iterable[UninterpretedOption]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> EnumOptions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "EnumValueOptions", "data": "class EnumValueOptions(Message):\n\tdeprecated: bool\n\n\t@property\n\tdef uninterpreted_option(\n\t\tself) -> RepeatedCompositeFieldContainer[UninterpretedOption]: ...\n\n\tdef __init__(self,\n\t\t\t\t deprecated: Optional[bool] = ...,\n\t\t\t\t uninterpreted_option: Optional[Iterable[UninterpretedOption]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> EnumValueOptions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "ServiceOptions", "data": "class ServiceOptions(Message):\n\tdeprecated: bool\n\n\t@property\n\tdef uninterpreted_option(\n\t\tself) -> RepeatedCompositeFieldContainer[UninterpretedOption]: ...\n\n\tdef __init__(self,\n\t\t\t\t deprecated: Optional[bool] = ...,\n\t\t\t\t uninterpreted_option: Optional[Iterable[UninterpretedOption]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> ServiceOptions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "MethodOptions", "data": "class MethodOptions(Message):\n\n\tclass IdempotencyLevel(int):\n\n\t\t@classmethod\n\t\tdef Name(cls, number: int) -> bytes: ...\n\n\t\t@classmethod\n\t\tdef Value(cls, name: bytes) -> MethodOptions.IdempotencyLevel: ...\n\n\t\t@classmethod\n\t\tdef keys(cls) -> List[bytes]: ...\n\n\t\t@classmethod\n\t\tdef values(cls) -> List[MethodOptions.IdempotencyLevel]: ...\n\n\t\t@classmethod\n\t\tdef items(cls) -> List[Tuple[bytes, MethodOptions.IdempotencyLevel]]: ...\n\tIDEMPOTENCY_UNKNOWN: MethodOptions.IdempotencyLevel\n\tNO_SIDE_EFFECTS: MethodOptions.IdempotencyLevel\n\tIDEMPOTENT: MethodOptions.IdempotencyLevel\n\tdeprecated: bool\n\tidempotency_level: MethodOptions.IdempotencyLevel\n\n\t@property\n\tdef uninterpreted_option(\n\t\tself) -> RepeatedCompositeFieldContainer[UninterpretedOption]: ...\n\n\tdef __init__(self,\n\t\t\t\t deprecated: Optional[bool] = ...,\n\t\t\t\t idempotency_level: Optional[MethodOptions.IdempotencyLevel] = ...,\n\t\t\t\t uninterpreted_option: Optional[Iterable[UninterpretedOption]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> MethodOptions: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "UninterpretedOption", "data": "class UninterpretedOption(Message):\n\n\tclass NamePart(Message):\n\t\tname_part: Text\n\t\tis_extension: bool\n\n\t\tdef __init__(self,\n\t\t\t\t\t name_part: Text,\n\t\t\t\t\t is_extension: bool,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> UninterpretedOption.NamePart: ...\n\tidentifier_value: Text\n\tpositive_int_value: int\n\tnegative_int_value: int\n\tdouble_value: float\n\tstring_value: bytes\n\taggregate_value: Text\n\n\t@property\n\tdef name(\n\t\tself) -> RepeatedCompositeFieldContainer[UninterpretedOption.NamePart]: ...\n\n\tdef __init__(self,\n\t\t\t\t name: Optional[Iterable[UninterpretedOption.NamePart]] = ...,\n\t\t\t\t identifier_value: Optional[Text] = ...,\n\t\t\t\t positive_int_value: Optional[int] = ...,\n\t\t\t\t negative_int_value: Optional[int] = ...,\n\t\t\t\t double_value: Optional[float] = ...,\n\t\t\t\t string_value: Optional[bytes] = ...,\n\t\t\t\t aggregate_value: Optional[Text] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> UninterpretedOption: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "SourceCodeInfo", "data": "class SourceCodeInfo(Message):\n\n\tclass Location(Message):\n\t\tpath: RepeatedScalarFieldContainer[int]\n\t\tspan: RepeatedScalarFieldContainer[int]\n\t\tleading_comments: Text\n\t\ttrailing_comments: Text\n\t\tleading_detached_comments: RepeatedScalarFieldContainer[Text]\n\n\t\tdef __init__(self,\n\t\t\t\t\t path: Optional[Iterable[int]] = ...,\n\t\t\t\t\t span: Optional[Iterable[int]] = ...,\n\t\t\t\t\t leading_comments: Optional[Text] = ...,\n\t\t\t\t\t trailing_comments: Optional[Text] = ...,\n\t\t\t\t\t leading_detached_comments: Optional[Iterable[Text]] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> SourceCodeInfo.Location: ...\n\n\t@property\n\tdef location(\n\t\tself) -> RepeatedCompositeFieldContainer[SourceCodeInfo.Location]: ...\n\n\tdef __init__(self,\n\t\t\t\t location: Optional[Iterable[SourceCodeInfo.Location]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n\tdef FromString(cls, s: bytes) -> SourceCodeInfo: ...\n\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}, {"term": "class", "name": "GeneratedCodeInfo", "data": "class GeneratedCodeInfo(Message):\n\n\tclass Annotation(Message):\n\t\tpath: RepeatedScalarFieldContainer[int]\n\t\tsource_file: Text\n\t\tbegin: int\n\t\tend: int\n\n\t\tdef __init__(self,\n\t\t\t\t\t path: Optional[Iterable[int]] = ...,\n\t\t\t\t\t source_file: Optional[Text] = ...,\n\t\t\t\t\t begin: Optional[int] = ...,\n\t\t\t\t\t end: Optional[int] = ...,\n\t\t\t\t\t ) -> None: ...\n\n\t\t@classmethod\n\t\tdef FromString(cls, s: bytes) -> GeneratedCodeInfo.Annotation: ...\n\n\t@property\n\tdef annotation(\n\t\tself) -> RepeatedCompositeFieldContainer[GeneratedCodeInfo.Annotation]: ...\n\n\tdef __init__(self,\n\t\t\t\t annotation: Optional[Iterable[GeneratedCodeInfo.Annotation]] = ...,\n\t\t\t\t ) -> None: ...\n\n\t@classmethod\n", "description": null, "category": "def", "imports": ["from google.protobuf.internal.containers import (", "from google.protobuf.message import (", "from typing import ("]}], [{"term": "class", "name": "classsemantic_unit:", "data": "class semantic_unit:\n\tdef __init__(self,info_dict={}, children = []):\n\t\tself.info_dict = info_dict\n\t\tself.children = children\n\n\tdef get_word(self):\n\t\tif 'word' in self.info_dict:\n\t\t\treturn self.info_dict['word']\n\t\telse:\n\t\t\treturn None\n\tdef get_lemma(self):\n\t\tif 'lemma' in self.info_dict:\n\t\t\treturn self.info_dict['lemma']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_position(self):\n\t\tif 'position' in self.info_dict:\n\t\t\treturn self.info_dict['position']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_start_position(self):\n\t\tif 'start_position' in self.info_dict:\n\t\t\treturn self.info_dict['start_position']\n\t\telse:\n\t\t\treturn None\n\tdef get_end_position(self):\n\t\tif 'end_position' in self.info_dict:\n\t\t\treturn self.info_dict['end_position']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_pos(self):\n\t\tif 'pos' in self.info_dict:\n\t\t\treturn self.info_dict['pos']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_deps(self):\n\t\tif 'deps' in self.info_dict:\n\t\t\treturn self.info_dict['deps']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_added_subj_flag(self):\n\t\tif 'added_subj_flag' in self.info_dict:\n\t\t\treturn self.info_dict['added_subj_flag']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_semantic_role(self):\n\t\tif 'semantic_role' in self.info_dict:\n\t\t\treturn self.info_dict['semantic_role']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_root_flag(self):\n\t\tif 'root_flag' in self.info_dict:\n\t\t\treturn self.info_dict['root_flag']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_is_subclass_of(self):\n\t\tif 'is_subclass_of' in self.info_dict:\n\t\t\treturn self.info_dict['is_subclass_of']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_refer_to(self):\n\t\tif 'refer_to' in self.info_dict:\n\t\t\treturn self.info_dict['refer_to']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_ner(self):\n\t\tif 'ner' in self.info_dict:\n\t\t\treturn self.info_dict['ner']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_match_clue(self):\n\t\tif 'match_clue' in self.info_dict:\n\t\t\treturn self.info_dict['match_clue']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_merge_clue(self):\n\t\tif 'merge_clue' in self.info_dict:\n\t\t\treturn self.info_dict['merge_clue']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_buddy(self):\n\t\tif 'buddy' in self.info_dict:\n\t\t\treturn self.info_dict['buddy']\n\t\telse:\n\t\t\treturn None\n\tdef get_start_index(self):\n\t\tif 'start_index' in self.info_dict:\n\t\t\treturn self.info_dict['start_index']\n\t\telse:\n\t\t\treturn None\n\tdef get_end_index(self):\n\t\tif 'end_index' in self.info_dict:\n\t\t\treturn self.info_dict['end_index']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_children_position_list(self):\n\t\tif 'children_position_list' in self.info_dict:\n\t\t\treturn self.info_dict['children_position_list']\n\t\telse:\n\t\t\treturn None\n\n\n\tdef add_word(self, word):\n\t\tself.info_dict['word'] = word\n\n\tdef add_lemma(self, lemma):\n\t\tself.info_dict['lemma'] = lemma\n\n\tdef add_position(self, position):\n\t\tself.info_dict['position'] = position\n\n\tdef add_start_position(self, start_position):\n\t\tself.info_dict['start_position'] = start_position\n\n\tdef add_end_position(self, end_position):\n\t\tself.info_dict['end_position'] = end_position\n\n\tdef add_pos(self, pos):\n\t\tself.info_dict['pos'] = pos\n\n\tdef add_deps(self, deps):\n\t\tself.info_dict['deps'] = deps\n\n\tdef add_added_subj_flag(self, added_subj_flag):\n\t\tself.info_dict['added_subj_flag'] = added_subj_flag\n\n\tdef add_semantic_role(self, semantic_role):\n\t\tself.info_dict['semantic_role'] = semantic_role\n\n\tdef add_root_flag(self, root_flag):\n\t\tself.info_dict['root_flag'] = root_flag\n\n\tdef add_is_subclass_of(self, is_subclass_of):\n\t\tself.info_dict['is_subclass_of'] = is_subclass_of\n\n\tdef add_refer_to(self, refer_to):\n\t\tself.info_dict['refer_to'] = refer_to\n\n\tdef add_ner(self, ner):\n\t\tself.info_dict['ner'] = ner\n\n\tdef add_match_clue(self, match_clue):\n\t\tself.info_dict['match_clue'] = match_clue\n\n\tdef add_merge_clue(self, merge_clue):\n\t\tself.info_dict['merge_clue'] = merge_clue\n\n\tdef add_buddy(self, buddy):\n\t\tself.info_dict['buddy'] = buddy\n\n\tdef add_start_index(self, start_index):\n\t\tself.info_dict['start_index'] = start_index\n\n\tdef add_end_index(self, end_index):\n\t\tself.info_dict['end_index'] = end_index\n\n\tdef add_children(self, children):\n\t\tself.children.append(children)\n\n\tdef add_children_list(self, children_list):\n\t\tself.children = children_list\n\n\tdef add_children_position_list(self, children_position_list):\n\t\tself.info_dict['children_position_list'] = children_position_list\n\n\n\n\n\n\n\n", "description": null, "category": "def", "imports": ["from collections import defaultdict"]}, {"term": "class", "name": "classmotion_event:", "data": "class motion_event:\n\tdef __init__(self,info_dict={}):\n\t\tself.info_dict = info_dict\n\n\tdef get_action(self):\n\t\tif 'action' in self.info_dict:\n\t\t\treturn self.info_dict['action']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_relation(self):\n\t\tif 'relation' in self.info_dict:\n\t\t\treturn self.info_dict['relation']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_figure(self):\n\t\tif 'figure' in self.info_dict:\n\t\t\treturn self.info_dict['figure']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_ground(self):\n\t\tif 'ground' in self.info_dict:\n\t\t\treturn self.info_dict['ground']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_agent(self):\n\t\tif 'agent' in self.info_dict:\n\t\t\treturn self.info_dict['agent']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_recipient(self):\n\t\tif 'recipient' in self.info_dict:\n\t\t\treturn self.info_dict['recipient']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_source(self):\n\t\tif 'source' in self.info_dict:\n\t\t\treturn self.info_dict['source']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_path(self):\n\t\tif 'path' in self.info_dict:\n\t\t\treturn self.info_dict['path']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_goal(self):\n\t\tif 'goal' in self.info_dict:\n\t\t\treturn self.info_dict['goal']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_via(self):\n\t\tif 'via' in self.info_dict:\n\t\t\treturn self.info_dict['via']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_toward(self):\n\t\tif 'toward' in self.info_dict:\n\t\t\treturn self.info_dict['toward']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_away_from(self):\n\t\tif 'away from' in self.info_dict:\n\t\t\treturn self.info_dict['away from']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_manner(self):\n\t\tif 'manner' in self.info_dict:\n\t\t\treturn self.info_dict['manner']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_direction(self):\n\t\tif 'direction' in self.info_dict:\n\t\t\treturn self.info_dict['direction']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_speed(self):\n\t\tif 'speed' in self.info_dict:\n\t\t\treturn self.info_dict['speed']\n\t\telse:\n\t\t\treturn None\n\n\tdef add_action(self, action):\n\t\tself.info_dict['action'] = action\n\n\tdef add_relation(self, relation):\n\t\tself.info_dict['relation'] = relation\n\n\tdef add_figure(self, figure):\n\t\tself.info_dict['figure'] = figure\n\n\tdef add_ground(self, ground):\n\t\tself.info_dict['ground'] = ground\n\n\tdef add_agent(self, agent):\n\t\tself.info_dict['agent'] = agent\n\n\tdef add_recipient(self, recipient):\n\t\tself.info_dict['recipient'] = recipient\n\n\tdef add_source(self, source):\n\t\tself.info_dict['source'] = source\n\n\tdef add_path(self, path):\n\t\tself.info_dict['path'] = path\n\n\tdef add_goal(self, goal):\n\t\tself.info_dict['goal'] = goal\n\n\tdef add_via(self, via):\n\t\tself.info_dict['via'] = via\n\n\tdef add_toward(self, toward):\n\t\tself.info_dict['toward'] = toward\n\n\tdef add_away_from(self, away_from):\n\t\tself.info_dict['away from'] = away_from\n\n\tdef add_manner(self, manner):\n\t\tself.info_dict['manner'] = manner\n\n\tdef add_direction(self, direction):\n\t\tself.info_dict['direction'] = direction\n\n\tdef add_speed(self, speed):\n\t\tself.info_dict['speed'] = speed\n", "description": null, "category": "def", "imports": ["from collections import defaultdict"]}, {"term": "class", "name": "classlocative:", "data": "class locative:\n\tdef __init__(self,info_dict={}):\n\t\tself.info_dict = info_dict\n\n\tdef get_figure(self):\n\t\tif 'figure' in self.info_dict:\n\t\t\treturn self.info_dict['figure']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_ground(self):\n\t\tif 'ground' in self.info_dict:\n\t\t\treturn self.info_dict['ground']\n\t\telse:\n\t\t\treturn None\n\n\tdef get_relation(self):\n\t\tif 'relation' in self.info_dict:\n\t\t\treturn self.info_dict['relation']\n\t\telse:\n\t\t\treturn None\n\n\tdef add_figure(self, figure):\n\t\tself.info_dict['figure'] = figure\n\n\tdef add_ground(self, ground):\n\t\tself.info_dict['ground'] = ground\n\n\tdef add_relation(self, relation):\n", "description": null, "category": "def", "imports": ["from collections import defaultdict"]}], [{"term": "class", "name": "#It'sbesttousetheTkinter.Canvasclassdirectly.", "data": "# It's best to use the Tkinter.Canvas class directly.\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}, {"term": "class", "name": "classCanvasItem:", "data": "class CanvasItem:\n\tdef __init__(self, canvas, itemType, *args, **kw):\n\t\tself.canvas = canvas\n\t\tself.id = canvas._create(itemType, args, kw)\n\t\tif not hasattr(canvas, 'items'):\n\t\t\tcanvas.items = {}\n\t\tcanvas.items[self.id] = self\n\tdef __str__(self):\n\t\treturn str(self.id)\n\tdef __repr__(self):\n\t\treturn '<%s, id=%d>' % (self.__class__.__name__, self.id)\n\tdef delete(self):\n\t\tdel self.canvas.items[self.id]\n\t\tself.canvas.delete(self.id)\n\tdef __getitem__(self, key):\n\t\tv = self.canvas.tk.split(self.canvas.tk.call(\n\t\t\t\tself.canvas._w, 'itemconfigure',\n\t\t\t\tself.id, '-' + key))\n\t\treturn v[4]\n\tcget = __getitem__\n\tdef __setitem__(self, key, value):\n\t\tself.canvas.itemconfig(self.id, {key: value})\n\tdef keys(self):\n\t\tif not hasattr(self, '_keys'):\n\t\t\tself._keys = map(lambda x, tk=self.canvas.tk:\n\t\t\t\t\t\t\t tk.splitlist(x)[0][1:],\n\t\t\t\t\t\t\t self.canvas.tk.splitlist(\n\t\t\t\t\t\t\t\t\t self.canvas._do(\n\t\t\t\t\t\t\t\t\t\t\t 'itemconfigure',\n\t\t\t\t\t\t\t\t\t\t\t (self.id,))))\n\t\treturn self._keys\n\tdef has_key(self, key):\n\t\treturn key in self.keys()\n\tdef __contains__(self, key):\n\t\treturn key in self.keys()\n\tdef addtag(self, tag, option='withtag'):\n\t\tself.canvas.addtag(tag, option, self.id)\n\tdef bbox(self):\n\t\tx1, y1, x2, y2 = self.canvas.bbox(self.id)\n\t\treturn (x1, y1), (x2, y2)\n\tdef bind(self, sequence=None, command=None, add=None):\n\t\treturn self.canvas.tag_bind(self.id, sequence, command, add)\n\tdef unbind(self, sequence, funcid=None):\n\t\tself.canvas.tag_unbind(self.id, sequence, funcid)\n\tdef config(self, cnf={}, **kw):\n\t\treturn self.canvas.itemconfig(self.id, _cnfmerge((cnf, kw)))\n\tdef coords(self, pts = ()):\n\t\tflat = ()\n\t\tfor x, y in pts: flat = flat + (x, y)\n\t\treturn self.canvas.coords(self.id, *flat)\n\tdef dchars(self, first, last=None):\n\t\tself.canvas.dchars(self.id, first, last)\n\tdef dtag(self, ttd):\n\t\tself.canvas.dtag(self.id, ttd)\n\tdef focus(self):\n\t\tself.canvas.focus(self.id)\n\tdef gettags(self):\n\t\treturn self.canvas.gettags(self.id)\n\tdef icursor(self, index):\n\t\tself.canvas.icursor(self.id, index)\n\tdef index(self, index):\n\t\treturn self.canvas.index(self.id, index)\n\tdef insert(self, beforethis, string):\n\t\tself.canvas.insert(self.id, beforethis, string)\n\tdef lower(self, belowthis=None):\n\t\tself.canvas.tag_lower(self.id, belowthis)\n\tdef move(self, xamount, yamount):\n\t\tself.canvas.move(self.id, xamount, yamount)\n\tdef tkraise(self, abovethis=None):\n\t\tself.canvas.tag_raise(self.id, abovethis)\n\traise_ = tkraise # BW compat\n\tdef scale(self, xorigin, yorigin, xscale, yscale):\n\t\tself.canvas.scale(self.id, xorigin, yorigin, xscale, yscale)\n\tdef type(self):\n\t\treturn self.canvas.type(self.id)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}, {"term": "class", "name": "Arc", "data": "class Arc(CanvasItem):\n\tdef __init__(self, canvas, *args, **kw):\n\t\tCanvasItem.__init__(self, canvas, 'arc', *args, **kw)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}, {"term": "class", "name": "Bitmap", "data": "class Bitmap(CanvasItem):\n\tdef __init__(self, canvas, *args, **kw):\n\t\tCanvasItem.__init__(self, canvas, 'bitmap', *args, **kw)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}, {"term": "class", "name": "ImageItem", "data": "class ImageItem(CanvasItem):\n\tdef __init__(self, canvas, *args, **kw):\n\t\tCanvasItem.__init__(self, canvas, 'image', *args, **kw)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}, {"term": "class", "name": "Line", "data": "class Line(CanvasItem):\n\tdef __init__(self, canvas, *args, **kw):\n\t\tCanvasItem.__init__(self, canvas, 'line', *args, **kw)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}, {"term": "class", "name": "Oval", "data": "class Oval(CanvasItem):\n\tdef __init__(self, canvas, *args, **kw):\n\t\tCanvasItem.__init__(self, canvas, 'oval', *args, **kw)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}, {"term": "class", "name": "Polygon", "data": "class Polygon(CanvasItem):\n\tdef __init__(self, canvas, *args, **kw):\n\t\tCanvasItem.__init__(self, canvas, 'polygon', *args, **kw)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}, {"term": "class", "name": "Rectangle", "data": "class Rectangle(CanvasItem):\n\tdef __init__(self, canvas, *args, **kw):\n\t\tCanvasItem.__init__(self, canvas, 'rectangle', *args, **kw)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}, {"term": "class", "name": "CanvasText", "data": "class CanvasText(CanvasItem):\n\tdef __init__(self, canvas, *args, **kw):\n\t\tCanvasItem.__init__(self, canvas, 'text', *args, **kw)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}, {"term": "class", "name": "Window", "data": "class Window(CanvasItem):\n\tdef __init__(self, canvas, *args, **kw):\n\t\tCanvasItem.__init__(self, canvas, 'window', *args, **kw)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}, {"term": "class", "name": "classGroup:", "data": "class Group:\n\tdef __init__(self, canvas, tag=None):\n\t\tif not tag:\n\t\t\ttag = 'Group%d' % id(self)\n\t\tself.tag = self.id = tag\n\t\tself.canvas = canvas\n\t\tself.canvas.dtag(self.tag)\n\tdef str(self):\n\t\treturn self.tag\n\t__str__ = str\n\tdef _do(self, cmd, *args):\n\t\treturn self.canvas._do(cmd, (self.tag,) + _flatten(args))\n\tdef addtag_above(self, tagOrId):\n\t\tself._do('addtag', 'above', tagOrId)\n\tdef addtag_all(self):\n\t\tself._do('addtag', 'all')\n\tdef addtag_below(self, tagOrId):\n\t\tself._do('addtag', 'below', tagOrId)\n\tdef addtag_closest(self, x, y, halo=None, start=None):\n\t\tself._do('addtag', 'closest', x, y, halo, start)\n\tdef addtag_enclosed(self, x1, y1, x2, y2):\n\t\tself._do('addtag', 'enclosed', x1, y1, x2, y2)\n\tdef addtag_overlapping(self, x1, y1, x2, y2):\n\t\tself._do('addtag', 'overlapping', x1, y1, x2, y2)\n\tdef addtag_withtag(self, tagOrId):\n\t\tself._do('addtag', 'withtag', tagOrId)\n\tdef bbox(self):\n\t\treturn self.canvas._getints(self._do('bbox'))\n\tdef bind(self, sequence=None, command=None, add=None):\n\t\treturn self.canvas.tag_bind(self.id, sequence, command, add)\n\tdef unbind(self, sequence, funcid=None):\n\t\tself.canvas.tag_unbind(self.id, sequence, funcid)\n\tdef coords(self, *pts):\n\t\treturn self._do('coords', pts)\n\tdef dchars(self, first, last=None):\n\t\tself._do('dchars', first, last)\n\tdef delete(self):\n\t\tself._do('delete')\n\tdef dtag(self, tagToDelete=None):\n\t\tself._do('dtag', tagToDelete)\n\tdef focus(self):\n\t\tself._do('focus')\n\tdef gettags(self):\n\t\treturn self.canvas.tk.splitlist(self._do('gettags', self.tag))\n\tdef icursor(self, index):\n\t\treturn self._do('icursor', index)\n\tdef index(self, index):\n\t\treturn self.canvas.tk.getint(self._do('index', index))\n\tdef insert(self, beforeThis, string):\n\t\tself._do('insert', beforeThis, string)\n\tdef config(self, cnf={}, **kw):\n\t\treturn self.canvas.itemconfigure(self.tag, _cnfmerge((cnf,kw)))\n\tdef lower(self, belowThis=None):\n\t\tself._do('lower', belowThis)\n\tdef move(self, xAmount, yAmount):\n\t\tself._do('move', xAmount, yAmount)\n\tdef tkraise(self, aboveThis=None):\n\t\tself._do('raise', aboveThis)\n\tlift = tkraise\n\tdef scale(self, xOrigin, yOrigin, xScale, yScale):\n\t\tself._do('scale', xOrigin, yOrigin, xScale, yScale)\n\tdef select_adjust(self, index):\n\t\tself.canvas._do('select', ('adjust', self.tag, index))\n\tdef select_from(self, index):\n\t\tself.canvas._do('select', ('from', self.tag, index))\n\tdef select_to(self, index):\n\t\tself.canvas._do('select', ('to', self.tag, index))\n\tdef type(self):\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Tkinter import Canvas, _cnfmerge, _flatten"]}], [{"term": "def", "name": "pack", "data": "def pack(*args, **kwargs):\n\tfrom aepack import pack\n\treturn pack( *args, **kwargs)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "nice", "data": "def nice(s):\n\t\"\"\"'nice' representation of an object\"\"\"\n\tif type(s) is StringType: return repr(s)\n\telse: return str(s)\n", "description": "'nice' representation of an object", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classUnknown:", "data": "class Unknown:\n\t\"\"\"An uninterpreted AE object\"\"\"\n\n\tdef __init__(self, type, data):\n\t\tself.type = type\n\t\tself.data = data\n\n\tdef __repr__(self):\n\t\treturn \"Unknown(%r, %r)\" % (self.type, self.data)\n\n\tdef __aepack__(self):\n\t\treturn pack(self.data, self.type)\n", "description": "An uninterpreted AE object", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classEnum:", "data": "class Enum:\n\t\"\"\"An AE enumeration value\"\"\"\n\n\tdef __init__(self, enum):\n\t\tself.enum = \"%-4.4s\" % str(enum)\n\n\tdef __repr__(self):\n\t\treturn \"Enum(%r)\" % (self.enum,)\n\n\tdef __str__(self):\n\t\treturn string.strip(self.enum)\n\n\tdef __aepack__(self):\n\t\treturn pack(self.enum, typeEnumeration)\n", "description": "An AE enumeration value", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsEnum", "data": "def IsEnum(x):\n\treturn isinstance(x, Enum)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "mkenum", "data": "def mkenum(enum):\n\tif IsEnum(enum): return enum\n\treturn Enum(enum)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classInsertionLoc:", "data": "class InsertionLoc:\n\tdef __init__(self, of, pos):\n\t\tself.of = of\n\t\tself.pos = pos\n\n\tdef __repr__(self):\n\t\treturn \"InsertionLoc(%r, %r)\" % (self.of, self.pos)\n\n\tdef __aepack__(self):\n\t\trec = {'kobj': self.of, 'kpos': self.pos}\n\t\treturn pack(rec, forcetype='insl')\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "beginning", "data": "def beginning(of):\n\treturn InsertionLoc(of, Enum('bgng'))\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "end", "data": "def end(of):\n\treturn InsertionLoc(of, Enum('end '))\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classBoolean:", "data": "class Boolean:\n\t\"\"\"An AE boolean value\"\"\"\n\n\tdef __init__(self, bool):\n\t\tself.bool = (not not bool)\n\n\tdef __repr__(self):\n\t\treturn \"Boolean(%r)\" % (self.bool,)\n\n\tdef __str__(self):\n\t\tif self.bool:\n\t\t\treturn \"True\"\n\t\telse:\n\t\t\treturn \"False\"\n\n\tdef __aepack__(self):\n\t\treturn pack(struct.pack('b', self.bool), 'bool')\n", "description": "An AE boolean value", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsBoolean", "data": "def IsBoolean(x):\n\treturn isinstance(x, Boolean)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "mkboolean", "data": "def mkboolean(bool):\n\tif IsBoolean(bool): return bool\n\treturn Boolean(bool)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classType:", "data": "class Type:\n\t\"\"\"An AE 4-char typename object\"\"\"\n\n\tdef __init__(self, type):\n\t\tself.type = \"%-4.4s\" % str(type)\n\n\tdef __repr__(self):\n\t\treturn \"Type(%r)\" % (self.type,)\n\n\tdef __str__(self):\n\t\treturn string.strip(self.type)\n\n\tdef __aepack__(self):\n\t\treturn pack(self.type, typeType)\n", "description": "An AE 4-char typename object", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsType", "data": "def IsType(x):\n\treturn isinstance(x, Type)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "mktype", "data": "def mktype(type):\n\tif IsType(type): return type\n\treturn Type(type)\n\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classKeyword:", "data": "class Keyword:\n\t\"\"\"An AE 4-char keyword object\"\"\"\n\n\tdef __init__(self, keyword):\n\t\tself.keyword = \"%-4.4s\" % str(keyword)\n\n\tdef __repr__(self):\n\t\treturn \"Keyword(%r)\" % repr(self.keyword)\n\n\tdef __str__(self):\n\t\treturn string.strip(self.keyword)\n\n\tdef __aepack__(self):\n\t\treturn pack(self.keyword, typeKeyword)\n", "description": "An AE 4-char keyword object", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsKeyword", "data": "def IsKeyword(x):\n\treturn isinstance(x, Keyword)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classRange:", "data": "class Range:\n\t\"\"\"An AE range object\"\"\"\n\n\tdef __init__(self, start, stop):\n\t\tself.start = start\n\t\tself.stop = stop\n\n\tdef __repr__(self):\n\t\treturn \"Range(%r, %r)\" % (self.start, self.stop)\n\n\tdef __str__(self):\n\t\treturn \"%s thru %s\" % (nice(self.start), nice(self.stop))\n\n\tdef __aepack__(self):\n\t\treturn pack({'star': self.start, 'stop': self.stop}, 'rang')\n", "description": "An AE range object", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsRange", "data": "def IsRange(x):\n\treturn isinstance(x, Range)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classComparison:", "data": "class Comparison:\n\t\"\"\"An AE Comparison\"\"\"\n\n\tdef __init__(self, obj1, relo, obj2):\n\t\tself.obj1 = obj1\n\t\tself.relo = \"%-4.4s\" % str(relo)\n\t\tself.obj2 = obj2\n\n\tdef __repr__(self):\n\t\treturn \"Comparison(%r, %r, %r)\" % (self.obj1, self.relo, self.obj2)\n\n\tdef __str__(self):\n\t\treturn \"%s %s %s\" % (nice(self.obj1), string.strip(self.relo), nice(self.obj2))\n\n\tdef __aepack__(self):\n\t\treturn pack({'obj1': self.obj1,\n\t\t\t\t 'relo': mkenum(self.relo),\n\t\t\t\t 'obj2': self.obj2},\n\t\t\t\t'cmpd')\n", "description": "An AE Comparison", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsComparison", "data": "def IsComparison(x):\n\treturn isinstance(x, Comparison)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "NComparison", "data": "class NComparison(Comparison):\n\t# The class attribute 'relo' must be set in a subclass\n\n\tdef __init__(self, obj1, obj2):\n\t\tComparison.__init__(obj1, self.relo, obj2)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classOrdinal:", "data": "class Ordinal:\n\t\"\"\"An AE Ordinal\"\"\"\n\n", "description": "An AE Ordinal", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "f__repr__", "data": "\tdef __repr__(self):\n\t\treturn \"Ordinal(%r)\" % (self.abso,)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "f__str__", "data": "\tdef __str__(self):\n\t\treturn \"%s\" % (string.strip(self.abso))\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "f__aepack__", "data": "\tdef __aepack__(self):\n\t\treturn pack(self.abso, 'abso')\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsOrdinal", "data": "def IsOrdinal(x):\n\treturn isinstance(x, Ordinal)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "NOrdinal", "data": "class NOrdinal(Ordinal):\n\t# The class attribute 'abso' must be set in a subclass\n\n\tdef __init__(self):\n\t\tOrdinal.__init__(self, self.abso)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classLogical:", "data": "class Logical:\n\t\"\"\"An AE logical expression object\"\"\"\n\n\tdef __init__(self, logc, term):\n\t\tself.logc = \"%-4.4s\" % str(logc)\n\t\tself.term = term\n\n\tdef __repr__(self):\n\t\treturn \"Logical(%r, %r)\" % (self.logc, self.term)\n\n\tdef __str__(self):\n\t\tif type(self.term) == ListType and len(self.term) == 2:\n\t\t\treturn \"%s %s %s\" % (nice(self.term[0]),\n\t\t\t\t\t\t\t\t string.strip(self.logc),\n\t\t\t\t\t\t\t\t nice(self.term[1]))\n\t\telse:\n\t\t\treturn \"%s(%s)\" % (string.strip(self.logc), nice(self.term))\n\n\tdef __aepack__(self):\n\t\treturn pack({'logc': mkenum(self.logc), 'term': self.term}, 'logi')\n", "description": "An AE logical expression object", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsLogical", "data": "def IsLogical(x):\n\treturn isinstance(x, Logical)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classStyledText:", "data": "class StyledText:\n\t\"\"\"An AE object respresenting text in a certain style\"\"\"\n\n\tdef __init__(self, style, text):\n\t\tself.style = style\n\t\tself.text = text\n\n\tdef __repr__(self):\n\t\treturn \"StyledText(%r, %r)\" % (self.style, self.text)\n\n\tdef __str__(self):\n\t\treturn self.text\n\n\tdef __aepack__(self):\n\t\treturn pack({'ksty': self.style, 'ktxt': self.text}, 'STXT')\n", "description": "An AE object respresenting text in a certain style", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsStyledText", "data": "def IsStyledText(x):\n\treturn isinstance(x, StyledText)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classAEText:", "data": "class AEText:\n\t\"\"\"An AE text object with style, script and language specified\"\"\"\n\n\tdef __init__(self, script, style, text):\n\t\tself.script = script\n\t\tself.style = style\n\t\tself.text = text\n\n\tdef __repr__(self):\n\t\treturn \"AEText(%r, %r, %r)\" % (self.script, self.style, self.text)\n\n\tdef __str__(self):\n\t\treturn self.text\n\n\tdef __aepack__(self):\n\t\treturn pack({keyAEScriptTag: self.script, keyAEStyles: self.style,\n\t\t\t\t keyAEText: self.text}, typeAEText)\n", "description": "An AE text object with style, script and language specified", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsAEText", "data": "def IsAEText(x):\n\treturn isinstance(x, AEText)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classIntlText:", "data": "class IntlText:\n\t\"\"\"A text object with script and language specified\"\"\"\n\n\tdef __init__(self, script, language, text):\n\t\tself.script = script\n\t\tself.language = language\n\t\tself.text = text\n\n\tdef __repr__(self):\n\t\treturn \"IntlText(%r, %r, %r)\" % (self.script, self.language, self.text)\n\n\tdef __str__(self):\n\t\treturn self.text\n\n\tdef __aepack__(self):\n\t\treturn pack(struct.pack('hh', self.script, self.language)+self.text,\n\t\t\ttypeIntlText)\n", "description": "A text object with script and language specified", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsIntlText", "data": "def IsIntlText(x):\n\treturn isinstance(x, IntlText)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classIntlWritingCode:", "data": "class IntlWritingCode:\n\t\"\"\"An object representing script and language\"\"\"\n\n\tdef __init__(self, script, language):\n\t\tself.script = script\n\t\tself.language = language\n\n\tdef __repr__(self):\n\t\treturn \"IntlWritingCode(%r, %r)\" % (self.script, self.language)\n\n\tdef __str__(self):\n\t\treturn \"script system %d, language %d\"%(self.script, self.language)\n\n\tdef __aepack__(self):\n\t\treturn pack(struct.pack('hh', self.script, self.language),\n\t\t\ttypeIntlWritingCode)\n", "description": "An object representing script and language", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsIntlWritingCode", "data": "def IsIntlWritingCode(x):\n\treturn isinstance(x, IntlWritingCode)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classQDPoint:", "data": "class QDPoint:\n\t\"\"\"A point\"\"\"\n\n\tdef __init__(self, v, h):\n\t\tself.v = v\n\t\tself.h = h\n\n\tdef __repr__(self):\n\t\treturn \"QDPoint(%r, %r)\" % (self.v, self.h)\n\n\tdef __str__(self):\n\t\treturn \"(%d, %d)\"%(self.v, self.h)\n\n\tdef __aepack__(self):\n\t\treturn pack(struct.pack('hh', self.v, self.h),\n\t\t\ttypeQDPoint)\n", "description": "A point", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsQDPoint", "data": "def IsQDPoint(x):\n\treturn isinstance(x, QDPoint)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classQDRectangle:", "data": "class QDRectangle:\n\t\"\"\"A rectangle\"\"\"\n\n\tdef __init__(self, v0, h0, v1, h1):\n\t\tself.v0 = v0\n\t\tself.h0 = h0\n\t\tself.v1 = v1\n\t\tself.h1 = h1\n\n\tdef __repr__(self):\n\t\treturn \"QDRectangle(%r, %r, %r, %r)\" % (self.v0, self.h0, self.v1, self.h1)\n\n\tdef __str__(self):\n\t\treturn \"(%d, %d)-(%d, %d)\"%(self.v0, self.h0, self.v1, self.h1)\n\n\tdef __aepack__(self):\n\t\treturn pack(struct.pack('hhhh', self.v0, self.h0, self.v1, self.h1),\n\t\t\ttypeQDRectangle)\n", "description": "A rectangle", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsQDRectangle", "data": "def IsQDRectangle(x):\n\treturn isinstance(x, QDRectangle)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classRGBColor:", "data": "class RGBColor:\n\t\"\"\"An RGB color\"\"\"\n\n\tdef __init__(self, r, g, b):\n\t\tself.r = r\n\t\tself.g = g\n\t\tself.b = b\n\n\tdef __repr__(self):\n\t\treturn \"RGBColor(%r, %r, %r)\" % (self.r, self.g, self.b)\n\n\tdef __str__(self):\n\t\treturn \"0x%x red, 0x%x green, 0x%x blue\"% (self.r, self.g, self.b)\n\n\tdef __aepack__(self):\n\t\treturn pack(struct.pack('hhh', self.r, self.g, self.b),\n\t\t\ttypeRGBColor)\n", "description": "An RGB color", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsRGBColor", "data": "def IsRGBColor(x):\n\treturn isinstance(x, RGBColor)\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classObjectSpecifier:", "data": "class ObjectSpecifier:\n\n\t\"\"\"A class for constructing and manipulation AE object specifiers in python.\n\n\tAn object specifier is actually a record with four fields:\n\n\tkey type\tdescription\n\t--- ----\t-----------\n\n\t'want'  type\t4-char class code of thing we want,\n\t\t\te.g. word, paragraph or property\n\n\t'form'  enum\thow we specify which 'want' thing(s) we want,\n\t\t\te.g. by index, by range, by name, or by property specifier\n\n\t'seld'  any which thing(s) we want,\n\t\t\te.g. its index, its name, or its property specifier\n\n\t'from'  object  the object in which it is contained,\n\t\t\tor null, meaning look for it in the application\n\n\tNote that we don't call this class plain \"Object\", since that name\n\tis likely to be used by the application.\n\t\"\"\"\n\n\tdef __init__(self, want, form, seld, fr = None):\n\t\tself.want = want\n\t\tself.form = form\n\t\tself.seld = seld\n\t\tself.fr = fr\n\n\tdef __repr__(self):\n\t\ts = \"ObjectSpecifier(%r, %r, %r\" % (self.want, self.form, self.seld)\n\t\tif self.fr:\n\t\t\ts = s + \", %r)\" % (self.fr,)\n\t\telse:\n\t\t\ts = s + \")\"\n\t\treturn s\n\n\tdef __aepack__(self):\n\t\treturn pack({'want': mktype(self.want),\n\t\t\t\t 'form': mkenum(self.form),\n\t\t\t\t 'seld': self.seld,\n\t\t\t\t 'from': self.fr},\n\t\t\t\t'obj ')\n", "description": "A class for constructing and manipulation AE object specifiers in python.\n\n\tAn object specifier is actually a record with four fields:\n\n\tkey type\tdescription\n\t--- ----\t-----------\n\n\t'want'  type\t4-char class code of thing we want,\n\t\t\te.g. word, paragraph or property\n\n\t'form'  enum\thow we specify which 'want' thing(s) we want,\n\t\t\te.g. by index, by range, by name, or by property specifier\n\n\t'seld'  any which thing(s) we want,\n\t\t\te.g. its index, its name, or its property specifier\n\n\t'from'  object  the object in which it is contained,\n\t\t\tor null, meaning look for it in the application\n\n\tNote that we don't call this class plain \"Object\", since that name\n\tis likely to be used by the application.\n\t", "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "def", "name": "IsObjectSpecifier", "data": "def IsObjectSpecifier(x):\n\treturn isinstance(x, ObjectSpecifier)\n\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "Property", "data": "class Property(ObjectSpecifier):\n\n\tdef __init__(self, which, fr = None, want='prop'):\n\t\tObjectSpecifier.__init__(self, want, 'prop', mktype(which), fr)\n\n\tdef __repr__(self):\n\t\tif self.fr:\n\t\t\treturn \"Property(%r, %r)\" % (self.seld.type, self.fr)\n\t\telse:\n\t\t\treturn \"Property(%r)\" % (self.seld.type,)\n\n\tdef __str__(self):\n\t\tif self.fr:\n\t\t\treturn \"Property %s of %s\" % (str(self.seld), str(self.fr))\n\t\telse:\n\t\t\treturn \"Property %s\" % str(self.seld)\n\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "NProperty", "data": "class NProperty(ObjectSpecifier):\n\t# Subclasses *must* self baseclass attributes:\n\t# want is the type of this property\n\t# which is the property name of this property\n\n\tdef __init__(self, fr = None):\n\t\t#try:\n\t\t#   dummy = self.want\n\t\t#except:\n\t\t#   self.want = 'prop'\n\t\tself.want = 'prop'\n\t\tObjectSpecifier.__init__(self, self.want, 'prop',\n\t\t\t\t\tmktype(self.which), fr)\n\n\tdef __repr__(self):\n\t\trv = \"Property(%r\" % (self.seld.type,)\n\t\tif self.fr:\n\t\t\trv = rv + \", fr=%r\" % (self.fr,)\n\t\tif self.want != 'prop':\n\t\t\trv = rv + \", want=%r\" % (self.want,)\n\t\treturn rv + \")\"\n\n\tdef __str__(self):\n\t\tif self.fr:\n\t\t\treturn \"Property %s of %s\" % (str(self.seld), str(self.fr))\n\t\telse:\n\t\t\treturn \"Property %s\" % str(self.seld)\n\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "SelectableItem", "data": "class SelectableItem(ObjectSpecifier):\n\n\tdef __init__(self, want, seld, fr = None):\n\t\tt = type(seld)\n\t\tif t == StringType:\n\t\t\tform = 'name'\n\t\telif IsRange(seld):\n\t\t\tform = 'rang'\n\t\telif IsComparison(seld) or IsLogical(seld):\n\t\t\tform = 'test'\n\t\telif t == TupleType:\n\t\t\t# Breakout: specify both form and seld in a tuple\n\t\t\t# (if you want ID or rele or somesuch)\n\t\t\tform, seld = seld\n\t\telse:\n\t\t\tform = 'indx'\n\t\tObjectSpecifier.__init__(self, want, form, seld, fr)\n\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "ComponentItem", "data": "class ComponentItem(SelectableItem):\n\t# Derived classes *must* set the *class attribute* 'want' to some constant\n\t# Also, dictionaries _propdict and _elemdict must be set to map property\n\t# and element names to the correct classes\n\n\t_propdict = {}\n\t_elemdict = {}\n\tdef __init__(self, which, fr = None):\n\t\tSelectableItem.__init__(self, self.want, which, fr)\n\n\tdef __repr__(self):\n\t\tif not self.fr:\n\t\t\treturn \"%s(%r)\" % (self.__class__.__name__, self.seld)\n\t\treturn \"%s(%r, %r)\" % (self.__class__.__name__, self.seld, self.fr)\n\n\tdef __str__(self):\n\t\tseld = self.seld\n\t\tif type(seld) == StringType:\n\t\t\tss = repr(seld)\n\t\telif IsRange(seld):\n\t\t\tstart, stop = seld.start, seld.stop\n\t\t\tif type(start) == InstanceType == type(stop) and \\\n\t\t\t   start.__class__ == self.__class__ == stop.__class__:\n\t\t\t\tss = str(start.seld) + \" thru \" + str(stop.seld)\n\t\t\telse:\n\t\t\t\tss = str(seld)\n\t\telse:\n\t\t\tss = str(seld)\n\t\ts = \"%s %s\" % (self.__class__.__name__, ss)\n\t\tif self.fr: s = s + \" of %s\" % str(self.fr)\n\t\treturn s\n\n\tdef __getattr__(self, name):\n\t\tif name in self._elemdict:\n\t\t\tcls = self._elemdict[name]\n\t\t\treturn DelayedComponentItem(cls, self)\n\t\tif name in self._propdict:\n\t\t\tcls = self._propdict[name]\n\t\t\treturn cls(self)\n\t\traise AttributeError, name\n\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}, {"term": "class", "name": "classDelayedComponentItem:", "data": "class DelayedComponentItem:\n\tdef __init__(self, compclass, fr):\n\t\tself.compclass = compclass\n\t\tself.fr = fr\n\n\tdef __call__(self, which):\n\t\treturn self.compclass(which, self.fr)\n\n\tdef __repr__(self):\n\t\treturn \"%s(???, %r)\" % (self.__class__.__name__, self.fr)\n\n\tdef __str__(self):\n\t\treturn \"selector for element %s of %s\"%(self.__class__.__name__, str(self.fr))\n", "description": null, "category": "def", "imports": ["from warnings import warnpy3k", "from Carbon.AppleEvents import *", "import struct", "from types import *", "import string", "\tfrom aepack import pack"]}], [{"term": "class", "name": "AugAssignTest", "data": "class AugAssignTest(unittest.TestCase):\n\tdef testBasic(self):\n\t\tx = 2\n\t\tx += 1\n\t\tx *= 2\n\t\tx **= 2\n\t\tx -= 8\n\t\tx //= 5\n\t\tx %= 3\n\t\tx &= 2\n\t\tx |= 5\n\t\tx ^= 1\n\t\tx /= 2\n\t\tif 1/2 == 0:\n\t\t\t# classic division\n\t\t\tself.assertEqual(x, 3)\n\t\telse:\n\t\t\t# new-style division (with -Qnew)\n\t\t\tself.assertEqual(x, 3.0)\n\n\tdef test_with_unpacking(self):\n\t\tself.assertRaises(SyntaxError, compile, \"x, b += 3\", \"<test>\", \"exec\")\n\n\tdef testInList(self):\n\t\tx = [2]\n\t\tx[0] += 1\n\t\tx[0] *= 2\n\t\tx[0] **= 2\n\t\tx[0] -= 8\n\t\tx[0] //= 5\n\t\tx[0] %= 3\n\t\tx[0] &= 2\n\t\tx[0] |= 5\n\t\tx[0] ^= 1\n\t\tx[0] /= 2\n\t\tif 1/2 == 0:\n\t\t\tself.assertEqual(x[0], 3)\n\t\telse:\n\t\t\tself.assertEqual(x[0], 3.0)\n\n\tdef testInDict(self):\n\t\tx = {0: 2}\n\t\tx[0] += 1\n\t\tx[0] *= 2\n\t\tx[0] **= 2\n\t\tx[0] -= 8\n\t\tx[0] //= 5\n\t\tx[0] %= 3\n\t\tx[0] &= 2\n\t\tx[0] |= 5\n\t\tx[0] ^= 1\n\t\tx[0] /= 2\n\t\tif 1/2 == 0:\n\t\t\tself.assertEqual(x[0], 3)\n\t\telse:\n\t\t\tself.assertEqual(x[0], 3.0)\n\n\tdef testSequences(self):\n\t\tx = [1,2]\n\t\tx += [3,4]\n\t\tx *= 2\n\n\t\tself.assertEqual(x, [1, 2, 3, 4, 1, 2, 3, 4])\n\n\t\tx = [1, 2, 3]\n\t\ty = x\n\t\tx[1:2] *= 2\n\t\ty[1:2] += [1]\n\n\t\tself.assertEqual(x, [1, 2, 1, 2, 3])\n\t\tself.assertTrue(x is y)\n\n\tdef testCustomMethods1(self):\n\n\t\tclass aug_test:\n\t\t\tdef __init__(self, value):\n\t\t\t\tself.val = value\n\t\t\tdef __radd__(self, val):\n\t\t\t\treturn self.val + val\n\t\t\tdef __add__(self, val):\n\t\t\t\treturn aug_test(self.val + val)\n\n\t\tclass aug_test2(aug_test):\n\t\t\tdef __iadd__(self, val):\n\t\t\t\tself.val = self.val + val\n\t\t\t\treturn self\n\n\t\tclass aug_test3(aug_test):\n\t\t\tdef __iadd__(self, val):\n\t\t\t\treturn aug_test3(self.val + val)\n\n\t\tx = aug_test(1)\n\t\ty = x\n\t\tx += 10\n\n\t\tself.assertIsInstance(x, aug_test)\n\t\tself.assertTrue(y is not x)\n\t\tself.assertEqual(x.val, 11)\n\n\t\tx = aug_test2(2)\n\t\ty = x\n\t\tx += 10\n\n\t\tself.assertTrue(y is x)\n\t\tself.assertEqual(x.val, 12)\n\n\t\tx = aug_test3(3)\n\t\ty = x\n\t\tx += 10\n\n\t\tself.assertIsInstance(x, aug_test3)\n\t\tself.assertTrue(y is not x)\n\t\tself.assertEqual(x.val, 13)\n\n\n\tdef testCustomMethods2(test_self):\n\t\toutput = []\n\n\t\tclass testall:\n\t\t\tdef __add__(self, val):\n\t\t\t\toutput.append(\"__add__ called\")\n\t\t\tdef __radd__(self, val):\n\t\t\t\toutput.append(\"__radd__ called\")\n\t\t\tdef __iadd__(self, val):\n\t\t\t\toutput.append(\"__iadd__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __sub__(self, val):\n\t\t\t\toutput.append(\"__sub__ called\")\n\t\t\tdef __rsub__(self, val):\n\t\t\t\toutput.append(\"__rsub__ called\")\n\t\t\tdef __isub__(self, val):\n\t\t\t\toutput.append(\"__isub__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __mul__(self, val):\n\t\t\t\toutput.append(\"__mul__ called\")\n\t\t\tdef __rmul__(self, val):\n\t\t\t\toutput.append(\"__rmul__ called\")\n\t\t\tdef __imul__(self, val):\n\t\t\t\toutput.append(\"__imul__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __div__(self, val):\n\t\t\t\toutput.append(\"__div__ called\")\n\t\t\tdef __rdiv__(self, val):\n\t\t\t\toutput.append(\"__rdiv__ called\")\n\t\t\tdef __idiv__(self, val):\n\t\t\t\toutput.append(\"__idiv__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __floordiv__(self, val):\n\t\t\t\toutput.append(\"__floordiv__ called\")\n\t\t\t\treturn self\n\t\t\tdef __ifloordiv__(self, val):\n\t\t\t\toutput.append(\"__ifloordiv__ called\")\n\t\t\t\treturn self\n\t\t\tdef __rfloordiv__(self, val):\n\t\t\t\toutput.append(\"__rfloordiv__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __truediv__(self, val):\n\t\t\t\toutput.append(\"__truediv__ called\")\n\t\t\t\treturn self\n\t\t\tdef __itruediv__(self, val):\n\t\t\t\toutput.append(\"__itruediv__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __mod__(self, val):\n\t\t\t\toutput.append(\"__mod__ called\")\n\t\t\tdef __rmod__(self, val):\n\t\t\t\toutput.append(\"__rmod__ called\")\n\t\t\tdef __imod__(self, val):\n\t\t\t\toutput.append(\"__imod__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __pow__(self, val):\n\t\t\t\toutput.append(\"__pow__ called\")\n\t\t\tdef __rpow__(self, val):\n\t\t\t\toutput.append(\"__rpow__ called\")\n\t\t\tdef __ipow__(self, val):\n\t\t\t\toutput.append(\"__ipow__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __or__(self, val):\n\t\t\t\toutput.append(\"__or__ called\")\n\t\t\tdef __ror__(self, val):\n\t\t\t\toutput.append(\"__ror__ called\")\n\t\t\tdef __ior__(self, val):\n\t\t\t\toutput.append(\"__ior__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __and__(self, val):\n\t\t\t\toutput.append(\"__and__ called\")\n\t\t\tdef __rand__(self, val):\n\t\t\t\toutput.append(\"__rand__ called\")\n\t\t\tdef __iand__(self, val):\n\t\t\t\toutput.append(\"__iand__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __xor__(self, val):\n\t\t\t\toutput.append(\"__xor__ called\")\n\t\t\tdef __rxor__(self, val):\n\t\t\t\toutput.append(\"__rxor__ called\")\n\t\t\tdef __ixor__(self, val):\n\t\t\t\toutput.append(\"__ixor__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __rshift__(self, val):\n\t\t\t\toutput.append(\"__rshift__ called\")\n\t\t\tdef __rrshift__(self, val):\n\t\t\t\toutput.append(\"__rrshift__ called\")\n\t\t\tdef __irshift__(self, val):\n\t\t\t\toutput.append(\"__irshift__ called\")\n\t\t\t\treturn self\n\n\t\t\tdef __lshift__(self, val):\n\t\t\t\toutput.append(\"__lshift__ called\")\n\t\t\tdef __rlshift__(self, val):\n\t\t\t\toutput.append(\"__rlshift__ called\")\n\t\t\tdef __ilshift__(self, val):\n\t\t\t\toutput.append(\"__ilshift__ called\")\n\t\t\t\treturn self\n\n\t\tx = testall()\n\t\tx + 1\n\t\t1 + x\n\t\tx += 1\n\n\t\tx - 1\n\t\t1 - x\n\t\tx -= 1\n\n\t\tx * 1\n\t\t1 * x\n\t\tx *= 1\n\n\t\tif 1/2 == 0:\n\t\t\tx / 1\n\t\t\t1 / x\n\t\t\tx /= 1\n\t\telse:\n\t\t\t# True division is in effect, so \"/\" doesn't map to __div__ etc;\n\t\t\t# but the canned expected-output file requires that those get called.\n\t\t\tx.__div__(1)\n\t\t\tx.__rdiv__(1)\n\t\t\tx.__idiv__(1)\n\n\t\tx // 1\n\t\t1 // x\n\t\tx //= 1\n\n\t\tx % 1\n\t\t1 % x\n\t\tx %= 1\n\n\t\tx ** 1\n\t\t1 ** x\n\t\tx **= 1\n\n\t\tx | 1\n\t\t1 | x\n\t\tx |= 1\n\n\t\tx & 1\n\t\t1 & x\n\t\tx &= 1\n\n\t\tx ^ 1\n\t\t1 ^ x\n\t\tx ^= 1\n\n\t\tx >> 1\n\t\t1 >> x\n\t\tx >>= 1\n\n\t\tx << 1\n\t\t1 << x\n\t\tx <<= 1\n\n", "description": null, "category": "def", "imports": ["from test.test_support import run_unittest, check_py3k_warnings", "import unittest"]}, {"term": "def", "name": "test_main", "data": "def test_main():\n\twith check_py3k_warnings((\"classic int division\", DeprecationWarning)):\n\t\trun_unittest(AugAssignTest)\n", "description": null, "category": "def", "imports": ["from test.test_support import run_unittest, check_py3k_warnings", "import unittest"]}], [{"term": "class", "name": "AST", "data": "class AST(object):\n\t# no doc\n\tdef __delattr__(self, *args, **kwargs): # real signature unknown\n\t\t\"\"\" Implement delattr(self, name). \"\"\"\n\t\tpass\n\n\tdef __getattribute__(self, *args, **kwargs): # real signature unknown\n\t\t\"\"\" Return getattr(self, name). \"\"\"\n\t\tpass\n\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t@staticmethod # known case of __new__\n\tdef __new__(*args, **kwargs): # real signature unknown\n\t\t\"\"\" Create and return a new object.  See help(type) for accurate signature. \"\"\"\n\t\tpass\n\n\tdef __reduce__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\tdef __setattr__(self, *args, **kwargs): # real signature unknown\n\t\t\"\"\" Implement setattr(self, name, value). \"\"\"\n\t\tpass\n\n\t_attributes = ()\n\t_fields = ()\n\t__dict__ = None # (!) real value is ''\n\n", "description": " Implement delattr(self, name). ", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "operator", "data": "class operator(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = ()\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Add", "data": "class Add(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "alias", "data": "class alias(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = (\n\t\t'name',\n\t\t'asname',\n\t)\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "boolop", "data": "class boolop(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = ()\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "And", "data": "class And(boolop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "arg", "data": "class arg(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = (\n\t\t'lineno',\n\t\t'col_offset',\n\t)\n\t_fields = (\n\t\t'arg',\n\t\t'annotation',\n\t)\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "arguments", "data": "class arguments(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = (\n\t\t'args',\n\t\t'vararg',\n\t\t'kwonlyargs',\n\t\t'kw_defaults',\n\t\t'kwarg',\n\t\t'defaults',\n\t)\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "stmt", "data": "class stmt(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = (\n\t\t'lineno',\n\t\t'col_offset',\n\t)\n\t_fields = ()\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Assert", "data": "class Assert(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'test',\n\t\t'msg',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Assign", "data": "class Assign(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'targets',\n\t\t'value',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "AsyncFor", "data": "class AsyncFor(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'target',\n\t\t'iter',\n\t\t'body',\n\t\t'orelse',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "AsyncFunctionDef", "data": "class AsyncFunctionDef(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'name',\n\t\t'args',\n\t\t'body',\n\t\t'decorator_list',\n\t\t'returns',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "AsyncWith", "data": "class AsyncWith(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'items',\n\t\t'body',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "expr", "data": "class expr(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = (\n\t\t'lineno',\n\t\t'col_offset',\n\t)\n\t_fields = ()\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Attribute", "data": "class Attribute(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'value',\n\t\t'attr',\n\t\t'ctx',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "AugAssign", "data": "class AugAssign(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'target',\n\t\t'op',\n\t\t'value',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "expr_context", "data": "class expr_context(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = ()\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "AugLoad", "data": "class AugLoad(expr_context):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "AugStore", "data": "class AugStore(expr_context):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Await", "data": "class Await(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'value',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "BinOp", "data": "class BinOp(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'left',\n\t\t'op',\n\t\t'right',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "BitAnd", "data": "class BitAnd(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "BitOr", "data": "class BitOr(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "BitXor", "data": "class BitXor(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "BoolOp", "data": "class BoolOp(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'op',\n\t\t'values',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Break", "data": "class Break(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Bytes", "data": "class Bytes(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t's',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Call", "data": "class Call(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'func',\n\t\t'args',\n\t\t'keywords',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "ClassDef", "data": "class ClassDef(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'name',\n\t\t'bases',\n\t\t'keywords',\n\t\t'body',\n\t\t'decorator_list',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "cmpop", "data": "class cmpop(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = ()\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Compare", "data": "class Compare(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'left',\n\t\t'ops',\n\t\t'comparators',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "comprehension", "data": "class comprehension(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = (\n\t\t'target',\n\t\t'iter',\n\t\t'ifs',\n\t)\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Continue", "data": "class Continue(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Del", "data": "class Del(expr_context):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Delete", "data": "class Delete(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'targets',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Dict", "data": "class Dict(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'keys',\n\t\t'values',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "DictComp", "data": "class DictComp(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'key',\n\t\t'value',\n\t\t'generators',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Div", "data": "class Div(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Ellipsis", "data": "class Ellipsis(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Eq", "data": "class Eq(cmpop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "excepthandler", "data": "class excepthandler(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = (\n\t\t'lineno',\n\t\t'col_offset',\n\t)\n\t_fields = ()\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "ExceptHandler", "data": "class ExceptHandler(excepthandler):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'type',\n\t\t'name',\n\t\t'body',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Expr", "data": "class Expr(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'value',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "mod", "data": "class mod(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = ()\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Expression", "data": "class Expression(mod):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'body',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "slice", "data": "class slice(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = ()\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "ExtSlice", "data": "class ExtSlice(slice):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'dims',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "FloorDiv", "data": "class FloorDiv(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "For", "data": "class For(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'target',\n\t\t'iter',\n\t\t'body',\n\t\t'orelse',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "FunctionDef", "data": "class FunctionDef(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'name',\n\t\t'args',\n\t\t'body',\n\t\t'decorator_list',\n\t\t'returns',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "GeneratorExp", "data": "class GeneratorExp(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'elt',\n\t\t'generators',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Global", "data": "class Global(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'names',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Gt", "data": "class Gt(cmpop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "GtE", "data": "class GtE(cmpop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "If", "data": "class If(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'test',\n\t\t'body',\n\t\t'orelse',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "IfExp", "data": "class IfExp(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'test',\n\t\t'body',\n\t\t'orelse',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Import", "data": "class Import(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'names',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "ImportFrom", "data": "class ImportFrom(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'module',\n\t\t'names',\n\t\t'level',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "In", "data": "class In(cmpop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Index", "data": "class Index(slice):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'value',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Interactive", "data": "class Interactive(mod):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'body',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "unaryop", "data": "class unaryop(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = ()\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Invert", "data": "class Invert(unaryop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Is", "data": "class Is(cmpop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "IsNot", "data": "class IsNot(cmpop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "keyword", "data": "class keyword(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = (\n\t\t'arg',\n\t\t'value',\n\t)\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Lambda", "data": "class Lambda(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'args',\n\t\t'body',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "List", "data": "class List(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'elts',\n\t\t'ctx',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "ListComp", "data": "class ListComp(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'elt',\n\t\t'generators',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Load", "data": "class Load(expr_context):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "LShift", "data": "class LShift(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Lt", "data": "class Lt(cmpop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "LtE", "data": "class LtE(cmpop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "MatMult", "data": "class MatMult(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Mod", "data": "class Mod(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Module", "data": "class Module(mod):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'body',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Mult", "data": "class Mult(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Name", "data": "class Name(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'id',\n\t\t'ctx',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "NameConstant", "data": "class NameConstant(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'value',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Nonlocal", "data": "class Nonlocal(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'names',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Not", "data": "class Not(unaryop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "NotEq", "data": "class NotEq(cmpop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "NotIn", "data": "class NotIn(cmpop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Num", "data": "class Num(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'n',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Or", "data": "class Or(boolop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Param", "data": "class Param(expr_context):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Pass", "data": "class Pass(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Pow", "data": "class Pow(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Raise", "data": "class Raise(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'exc',\n\t\t'cause',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Return", "data": "class Return(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'value',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "RShift", "data": "class RShift(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Set", "data": "class Set(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'elts',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "SetComp", "data": "class SetComp(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'elt',\n\t\t'generators',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Slice", "data": "class Slice(slice):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'lower',\n\t\t'upper',\n\t\t'step',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Starred", "data": "class Starred(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'value',\n\t\t'ctx',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Store", "data": "class Store(expr_context):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Str", "data": "class Str(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t's',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Sub", "data": "class Sub(operator):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Subscript", "data": "class Subscript(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'value',\n\t\t'slice',\n\t\t'ctx',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Suite", "data": "class Suite(mod):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'body',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Try", "data": "class Try(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'body',\n\t\t'handlers',\n\t\t'orelse',\n\t\t'finalbody',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Tuple", "data": "class Tuple(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'elts',\n\t\t'ctx',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "UAdd", "data": "class UAdd(unaryop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "UnaryOp", "data": "class UnaryOp(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'op',\n\t\t'operand',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "USub", "data": "class USub(unaryop):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = ()\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "While", "data": "class While(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'test',\n\t\t'body',\n\t\t'orelse',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "With", "data": "class With(stmt):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'items',\n\t\t'body',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "withitem", "data": "class withitem(AST):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t_attributes = ()\n\t_fields = (\n\t\t'context_expr',\n\t\t'optional_vars',\n\t)\n\n", "description": "list of weak references to the object (if defined)", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "Yield", "data": "class Yield(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'value',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "YieldFrom", "data": "class YieldFrom(expr):\n\t# no doc\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t_fields = (\n\t\t'value',\n\t)\n\n", "description": null, "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}, {"term": "class", "name": "__loader__", "data": "class __loader__(object):\n\t\"\"\"\n\tMeta path import for built-in modules.\n\t\n\t\tAll methods are either class or static methods to avoid the need to\n\t\tinstantiate the class.\n\t\"\"\"\n\t@classmethod\n\tdef create_module(cls, *args, **kwargs): # real signature unknown\n\t\t\"\"\" Create a built-in module \"\"\"\n\t\tpass\n\n\t@classmethod\n\tdef exec_module(cls, *args, **kwargs): # real signature unknown\n\t\t\"\"\" Exec a built-in module \"\"\"\n\t\tpass\n\n\t@classmethod\n\tdef find_module(cls, *args, **kwargs): # real signature unknown\n\t\t\"\"\"\n\t\tFind the built-in module.\n\t\t\n\t\t\t\tIf 'path' is ever specified then the search is considered a failure.\n\t\t\n\t\t\t\tThis method is deprecated.  Use find_spec() instead.\n\t\t\"\"\"\n\t\tpass\n\n\t@classmethod\n\tdef find_spec(cls, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t@classmethod\n\tdef get_code(cls, *args, **kwargs): # real signature unknown\n\t\t\"\"\" Return None as built-in modules do not have code objects. \"\"\"\n\t\tpass\n\n\t@classmethod\n\tdef get_source(cls, *args, **kwargs): # real signature unknown\n\t\t\"\"\" Return None as built-in modules do not have source code. \"\"\"\n\t\tpass\n\n\t@classmethod\n\tdef is_package(cls, *args, **kwargs): # real signature unknown\n\t\t\"\"\" Return False as built-in modules are never packages. \"\"\"\n\t\tpass\n\n\t@classmethod\n\tdef load_module(cls, *args, **kwargs): # real signature unknown\n\t\t\"\"\"\n\t\tLoad the specified module into sys.modules and return it.\n\t\t\n\t\t\tThis method is deprecated.  Use loader.exec_module instead.\n\t\t\"\"\"\n\t\tpass\n\n\tdef module_repr(module): # reliably restored by inspect\n\t\t\"\"\"\n\t\tReturn repr for the module.\n\t\t\n\t\t\t\tThe method is deprecated.  The import machinery does the job itself.\n\t\t\"\"\"\n\t\tpass\n\n\tdef __init__(self, *args, **kwargs): # real signature unknown\n\t\tpass\n\n\t__weakref__ = property(lambda self: object(), lambda self, v: None, lambda self: None)  # default\n\t\"\"\"list of weak references to the object (if defined)\"\"\"\n\n\n\t__dict__ = None # (!) real value is ''\n\n", "description": "\n\tMeta path import for built-in modules.\n\t\n\t\tAll methods are either class or static methods to avoid the need to\n\t\tinstantiate the class.\n\t", "category": "def", "imports": ["# no imports", "\tMeta path import for built-in modules.", "\t\t\t\tThe method is deprecated.  The import machinery does the job itself."]}], [{"term": "class", "name": "ParserError", "data": "class ParserError(MarkedYAMLError): ...\n", "description": null, "category": "def", "imports": ["from typing import Any", "from yaml.error import MarkedYAMLError"]}, {"term": "class", "name": "classParser:", "data": "class Parser:\n\tDEFAULT_TAGS: Any\n\tcurrent_event: Any\n\tyaml_version: Any\n\ttag_handles: Any\n\tstates: Any\n\tmarks: Any\n\tstate: Any\n\tdef __init__(self) -> None: ...\n\tdef dispose(self): ...\n\tdef check_event(self, *choices): ...\n\tdef peek_event(self): ...\n\tdef get_event(self): ...\n\tdef parse_stream_start(self): ...\n\tdef parse_implicit_document_start(self): ...\n\tdef parse_document_start(self): ...\n\tdef parse_document_end(self): ...\n\tdef parse_document_content(self): ...\n\tdef process_directives(self): ...\n\tdef parse_block_node(self): ...\n\tdef parse_flow_node(self): ...\n\tdef parse_block_node_or_indentless_sequence(self): ...\n\tdef parse_node(self, block=..., indentless_sequence=...): ...\n\tdef parse_block_sequence_first_entry(self): ...\n\tdef parse_block_sequence_entry(self): ...\n\tdef parse_indentless_sequence_entry(self): ...\n\tdef parse_block_mapping_first_key(self): ...\n\tdef parse_block_mapping_key(self): ...\n\tdef parse_block_mapping_value(self): ...\n\tdef parse_flow_sequence_first_entry(self): ...\n\tdef parse_flow_sequence_entry(self, first=...): ...\n\tdef parse_flow_sequence_entry_mapping_key(self): ...\n\tdef parse_flow_sequence_entry_mapping_value(self): ...\n\tdef parse_flow_sequence_entry_mapping_end(self): ...\n\tdef parse_flow_mapping_first_key(self): ...\n\tdef parse_flow_mapping_key(self, first=...): ...\n\tdef parse_flow_mapping_value(self): ...\n\tdef parse_flow_mapping_empty_value(self): ...\n", "description": null, "category": "def", "imports": ["from typing import Any", "from yaml.error import MarkedYAMLError"]}], [{"term": "class", "name": "Angle", "data": "class Angle(object):\n\n\tdef __init__(self, deg):\n\t\tself.deg = deg\n\t\tself.normalize()\n\n\tdef normalize(self):\n\t\tself.deg = self.deg % 360\n\t\twhile self.deg < 0:\n\t\t\tself.deg += 360\n\n\t# addition\n\tdef addF(self, d):\n\t\treturn Angle(self.deg + d)\n\tdef iaddF(self, d):\n\t\tself.deg += d\n\t\tself.normalize()\n\t\treturn self\n\tdef addA(self, a):\n\t\treturn self.addF(a.deg)\n\tdef iaddA(self, a):\n\t\treturn self.iaddF(a.deg)\n\n\t# subtraction\n\tdef subF(self, d):\n\t\treturn Angle(self.deg - d)\n\tdef isubF(self, d):\n\t\tself.deg -= d\n\t\tself.normalize()\n\t\treturn self\n\tdef subA(self, a):\n\t\treturn self.subF(a.deg)\n\tdef isubA(self, a):\n\t\treturn self.isubF(a.deg)\n\n\t# negate\n\tdef neg(self):\n\t\treturn Angle(360 - self.deg)\n\n\t# multiplication\n\tdef mulF(self, d):\n\t\treturn Angle(self.deg * d)\n\tdef imulF(self, d):\n\t\tself.deg *= d\n\t\tself.normalize()\n\t\treturn self\n\tdef mulA(self, a):\n\t\treturn self.mulF(a.deg)\n\tdef imulA(self, a):\n\t\treturn self.imulF(a.deg)\n\n\t# division\n\tdef divF(self, d): # /\n\t\treturn Angle(self.deg / d)\n\tdef idivF(self, d): # /=\n\t\tself.deg /= d\n\t\tself.normalize()\n\t\treturn self\n\tdef divA(self, a):\n\t\treturn self.divF(a.deg)\n\tdef idivA(self, a):\n\t\treturn self.idivF(a.deg)\n\n\t# comparison\n\tdef ltF(self, d): # <\n\t\treturn self.deg < d\n\tdef lteF(self, d): # <=\n\t\treturn self.deg <= d\n\tdef ltA(self, a):\n\t\treturn self.ltF(a.deg)\n\tdef lteA(self, a):\n\t\treturn self.lteF(a.deg)\n\n\tdef gtF(self, d): # >\n\t\treturn self.deg > d\n\tdef gteF(self, d): # >=\n\t\treturn self.deg >= d\n\tdef gtA(self, a):\n\t\treturn self.gtF(a.deg)\n\tdef gteA(self, a):\n\t\treturn self.gteF(a.deg)\n\n\tdef __str__(self):\n\t\treturn \"A:{}\".format(self.deg)\n\n\tdef getCos(self):\n\t\treturn math.cos(self.toRadians())\n\tdef getSin(self):\n\t\treturn math.sin(self.toRadians())\n\tdef getTan(self):\n\t\treturn math.tan(self.toRadians())\n\tdef getSigned(self):\n\t\tif self.deg > 180:\n\t\t\treturn self.deg - 360\n\t\treturn self.deg\n\n\tdef new(self):\n\t\treturn Angle(self.deg)\n\n\tdef toVector(self):\n\t\trad = self.deg * math.pi / 180\n\t\treturn math.cos(rad), math.sin(rad)\n\tdef toRadians(self):\n\t\treturn self.deg * math.pi / 180\n\n\tdef fromRadians(radians):\n", "description": null, "category": "def", "imports": ["import math"]}], [{"term": "class", "name": "Cud", "data": "class Cud():\n\n\tdef __init__(self):\n\t\tprint(\"__init__ called\")\n\n\tdef __repr__(self):\n\t\tprint(\"__repr__ called\")\n\t\treturn \"\"\n\n\tdef __lt__(self, other):\n\t\tprint(\"__lt__ called\")\n\n\tdef __le__(self, other):\n\t\tprint(\"__le__ called\")\n\n\tdef __eq__(self, other):\n\t\tprint(\"__eq__ called\")\n\n\tdef __ne__(self, other):\n\t\tprint(\"__ne__ called\")\n\n\tdef __ge__(self, other):\n\t\tprint(\"__ge__ called\")\n\n\tdef __gt__(self, other):\n\t\tprint(\"__gt__ called\")\n\n\tdef __abs__(self):\n\t\tprint(\"__abs__ called\")\n\n\tdef __add__(self, other):\n\t\tprint(\"__add__ called\")\n\n\tdef __and__(self, other):\n\t\tprint(\"__and__ called\")\n\n\tdef __floordiv__(self, other):\n\t\tprint(\"__floordiv__ called\")\n\n\tdef __index__(self, other):\n\t\tprint(\"__index__ called\")\n\n\tdef __inv__(self):\n\t\tprint(\"__inv__ called\")\n\n\tdef __invert__(self):\n\t\tprint(\"__invert__ called\")\n\n\tdef __lshift__(self, val):\n\t\tprint(\"__lshift__ called\")\n\n\tdef __mod__(self, val):\n\t\tprint(\"__mod__ called\")\n\n\tdef __mul__(self, other):\n\t\tprint(\"__mul__ called\")\n\n\tdef __matmul__(self, other):\n\t\tprint(\"__matmul__ called\")\n\n\tdef __neg__(self):\n\t\tprint(\"__neg__ called\")\n\n\tdef __or__(self, other):\n\t\tprint(\"__or__ called\")\n\n\tdef __pos__(self):\n\t\tprint(\"__pos__ called\")\n\n\tdef __pow__(self, val):\n\t\tprint(\"__pow__ called\")\n\n\tdef __rshift__(self, val):\n\t\tprint(\"__rshift__ called\")\n\n\tdef __sub__(self, other):\n\t\tprint(\"__sub__ called\")\n\n\tdef __truediv__(self, other):\n\t\tprint(\"__truediv__ called\")\n\n\tdef __div__(self, other):\n\t\tprint(\"__div__ called\")\n\n\tdef __xor__(self, other):\n\t\tprint(\"__xor__ called\")\n\n\tdef __iadd__(self, other):\n\t\tprint(\"__iadd__ called\")\n\t\treturn self\n\n\tdef __isub__(self, other):\n\t\tprint(\"__isub__ called\")\n\t\treturn self\n\n\tdef __int__(self):\n\t\treturn 42\n", "description": null, "category": "def", "imports": []}, {"term": "class", "name": "classBadInt:", "data": "class BadInt:\n\tdef __int__(self):\n\t\tprint(\"__int__ called\")\n\t\treturn None\n", "description": null, "category": "def", "imports": []}], [{"term": "class", "name": "MeetupTest", "data": "class MeetupTest(unittest.TestCase):\n\tdef test_monteenth_of_may_2013(self):\n\t\tself.assertEqual(meetup(2013, 5, \"teenth\", \"Monday\"), date(2013, 5, 13))\n\n\tdef test_monteenth_of_august_2013(self):\n\t\tself.assertEqual(meetup(2013, 8, \"teenth\", \"Monday\"), date(2013, 8, 19))\n\n\tdef test_monteenth_of_september_2013(self):\n\t\tself.assertEqual(meetup(2013, 9, \"teenth\", \"Monday\"), date(2013, 9, 16))\n\n\tdef test_tuesteenth_of_march_2013(self):\n\t\tself.assertEqual(meetup(2013, 3, \"teenth\", \"Tuesday\"), date(2013, 3, 19))\n\n\tdef test_tuesteenth_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"teenth\", \"Tuesday\"), date(2013, 4, 16))\n\n\tdef test_tuesteenth_of_august_2013(self):\n\t\tself.assertEqual(meetup(2013, 8, \"teenth\", \"Tuesday\"), date(2013, 8, 13))\n\n\tdef test_wednesteenth_of_january_2013(self):\n\t\tself.assertEqual(meetup(2013, 1, \"teenth\", \"Wednesday\"), date(2013, 1, 16))\n\n\tdef test_wednesteenth_of_february_2013(self):\n\t\tself.assertEqual(meetup(2013, 2, \"teenth\", \"Wednesday\"), date(2013, 2, 13))\n\n\tdef test_wednesteenth_of_june_2013(self):\n\t\tself.assertEqual(meetup(2013, 6, \"teenth\", \"Wednesday\"), date(2013, 6, 19))\n\n\tdef test_thursteenth_of_may_2013(self):\n\t\tself.assertEqual(meetup(2013, 5, \"teenth\", \"Thursday\"), date(2013, 5, 16))\n\n\tdef test_thursteenth_of_june_2013(self):\n\t\tself.assertEqual(meetup(2013, 6, \"teenth\", \"Thursday\"), date(2013, 6, 13))\n\n\tdef test_thursteenth_of_september_2013(self):\n\t\tself.assertEqual(meetup(2013, 9, \"teenth\", \"Thursday\"), date(2013, 9, 19))\n\n\tdef test_friteenth_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"teenth\", \"Friday\"), date(2013, 4, 19))\n\n\tdef test_friteenth_of_august_2013(self):\n\t\tself.assertEqual(meetup(2013, 8, \"teenth\", \"Friday\"), date(2013, 8, 16))\n\n\tdef test_friteenth_of_september_2013(self):\n\t\tself.assertEqual(meetup(2013, 9, \"teenth\", \"Friday\"), date(2013, 9, 13))\n\n\tdef test_saturteenth_of_february_2013(self):\n\t\tself.assertEqual(meetup(2013, 2, \"teenth\", \"Saturday\"), date(2013, 2, 16))\n\n\tdef test_saturteenth_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"teenth\", \"Saturday\"), date(2013, 4, 13))\n\n\tdef test_saturteenth_of_october_2013(self):\n\t\tself.assertEqual(meetup(2013, 10, \"teenth\", \"Saturday\"), date(2013, 10, 19))\n\n\tdef test_sunteenth_of_may_2013(self):\n\t\tself.assertEqual(meetup(2013, 5, \"teenth\", \"Sunday\"), date(2013, 5, 19))\n\n\tdef test_sunteenth_of_june_2013(self):\n\t\tself.assertEqual(meetup(2013, 6, \"teenth\", \"Sunday\"), date(2013, 6, 16))\n\n\tdef test_sunteenth_of_october_2013(self):\n\t\tself.assertEqual(meetup(2013, 10, \"teenth\", \"Sunday\"), date(2013, 10, 13))\n\n\tdef test_first_monday_of_march_2013(self):\n\t\tself.assertEqual(meetup(2013, 3, \"1st\", \"Monday\"), date(2013, 3, 4))\n\n\tdef test_first_monday_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"1st\", \"Monday\"), date(2013, 4, 1))\n\n\tdef test_first_tuesday_of_may_2013(self):\n\t\tself.assertEqual(meetup(2013, 5, \"1st\", \"Tuesday\"), date(2013, 5, 7))\n\n\tdef test_first_tuesday_of_june_2013(self):\n\t\tself.assertEqual(meetup(2013, 6, \"1st\", \"Tuesday\"), date(2013, 6, 4))\n\n\tdef test_first_wednesday_of_july_2013(self):\n\t\tself.assertEqual(meetup(2013, 7, \"1st\", \"Wednesday\"), date(2013, 7, 3))\n\n\tdef test_first_wednesday_of_august_2013(self):\n\t\tself.assertEqual(meetup(2013, 8, \"1st\", \"Wednesday\"), date(2013, 8, 7))\n\n\tdef test_first_thursday_of_september_2013(self):\n\t\tself.assertEqual(meetup(2013, 9, \"1st\", \"Thursday\"), date(2013, 9, 5))\n\n\tdef test_first_thursday_of_october_2013(self):\n\t\tself.assertEqual(meetup(2013, 10, \"1st\", \"Thursday\"), date(2013, 10, 3))\n\n\tdef test_first_friday_of_november_2013(self):\n\t\tself.assertEqual(meetup(2013, 11, \"1st\", \"Friday\"), date(2013, 11, 1))\n\n\tdef test_first_friday_of_december_2013(self):\n\t\tself.assertEqual(meetup(2013, 12, \"1st\", \"Friday\"), date(2013, 12, 6))\n\n\tdef test_first_saturday_of_january_2013(self):\n\t\tself.assertEqual(meetup(2013, 1, \"1st\", \"Saturday\"), date(2013, 1, 5))\n\n\tdef test_first_saturday_of_february_2013(self):\n\t\tself.assertEqual(meetup(2013, 2, \"1st\", \"Saturday\"), date(2013, 2, 2))\n\n\tdef test_first_sunday_of_march_2013(self):\n\t\tself.assertEqual(meetup(2013, 3, \"1st\", \"Sunday\"), date(2013, 3, 3))\n\n\tdef test_first_sunday_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"1st\", \"Sunday\"), date(2013, 4, 7))\n\n\tdef test_second_monday_of_march_2013(self):\n\t\tself.assertEqual(meetup(2013, 3, \"2nd\", \"Monday\"), date(2013, 3, 11))\n\n\tdef test_second_monday_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"2nd\", \"Monday\"), date(2013, 4, 8))\n\n\tdef test_second_tuesday_of_may_2013(self):\n\t\tself.assertEqual(meetup(2013, 5, \"2nd\", \"Tuesday\"), date(2013, 5, 14))\n\n\tdef test_second_tuesday_of_june_2013(self):\n\t\tself.assertEqual(meetup(2013, 6, \"2nd\", \"Tuesday\"), date(2013, 6, 11))\n\n\tdef test_second_wednesday_of_july_2013(self):\n\t\tself.assertEqual(meetup(2013, 7, \"2nd\", \"Wednesday\"), date(2013, 7, 10))\n\n\tdef test_second_wednesday_of_august_2013(self):\n\t\tself.assertEqual(meetup(2013, 8, \"2nd\", \"Wednesday\"), date(2013, 8, 14))\n\n\tdef test_second_thursday_of_september_2013(self):\n\t\tself.assertEqual(meetup(2013, 9, \"2nd\", \"Thursday\"), date(2013, 9, 12))\n\n\tdef test_second_thursday_of_october_2013(self):\n\t\tself.assertEqual(meetup(2013, 10, \"2nd\", \"Thursday\"), date(2013, 10, 10))\n\n\tdef test_second_friday_of_november_2013(self):\n\t\tself.assertEqual(meetup(2013, 11, \"2nd\", \"Friday\"), date(2013, 11, 8))\n\n\tdef test_second_friday_of_december_2013(self):\n\t\tself.assertEqual(meetup(2013, 12, \"2nd\", \"Friday\"), date(2013, 12, 13))\n\n\tdef test_second_saturday_of_january_2013(self):\n\t\tself.assertEqual(meetup(2013, 1, \"2nd\", \"Saturday\"), date(2013, 1, 12))\n\n\tdef test_second_saturday_of_february_2013(self):\n\t\tself.assertEqual(meetup(2013, 2, \"2nd\", \"Saturday\"), date(2013, 2, 9))\n\n\tdef test_second_sunday_of_march_2013(self):\n\t\tself.assertEqual(meetup(2013, 3, \"2nd\", \"Sunday\"), date(2013, 3, 10))\n\n\tdef test_second_sunday_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"2nd\", \"Sunday\"), date(2013, 4, 14))\n\n\tdef test_third_monday_of_march_2013(self):\n\t\tself.assertEqual(meetup(2013, 3, \"3rd\", \"Monday\"), date(2013, 3, 18))\n\n\tdef test_third_monday_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"3rd\", \"Monday\"), date(2013, 4, 15))\n\n\tdef test_third_tuesday_of_may_2013(self):\n\t\tself.assertEqual(meetup(2013, 5, \"3rd\", \"Tuesday\"), date(2013, 5, 21))\n\n\tdef test_third_tuesday_of_june_2013(self):\n\t\tself.assertEqual(meetup(2013, 6, \"3rd\", \"Tuesday\"), date(2013, 6, 18))\n\n\tdef test_third_wednesday_of_july_2013(self):\n\t\tself.assertEqual(meetup(2013, 7, \"3rd\", \"Wednesday\"), date(2013, 7, 17))\n\n\tdef test_third_wednesday_of_august_2013(self):\n\t\tself.assertEqual(meetup(2013, 8, \"3rd\", \"Wednesday\"), date(2013, 8, 21))\n\n\tdef test_third_thursday_of_september_2013(self):\n\t\tself.assertEqual(meetup(2013, 9, \"3rd\", \"Thursday\"), date(2013, 9, 19))\n\n\tdef test_third_thursday_of_october_2013(self):\n\t\tself.assertEqual(meetup(2013, 10, \"3rd\", \"Thursday\"), date(2013, 10, 17))\n\n\tdef test_third_friday_of_november_2013(self):\n\t\tself.assertEqual(meetup(2013, 11, \"3rd\", \"Friday\"), date(2013, 11, 15))\n\n\tdef test_third_friday_of_december_2013(self):\n\t\tself.assertEqual(meetup(2013, 12, \"3rd\", \"Friday\"), date(2013, 12, 20))\n\n\tdef test_third_saturday_of_january_2013(self):\n\t\tself.assertEqual(meetup(2013, 1, \"3rd\", \"Saturday\"), date(2013, 1, 19))\n\n\tdef test_third_saturday_of_february_2013(self):\n\t\tself.assertEqual(meetup(2013, 2, \"3rd\", \"Saturday\"), date(2013, 2, 16))\n\n\tdef test_third_sunday_of_march_2013(self):\n\t\tself.assertEqual(meetup(2013, 3, \"3rd\", \"Sunday\"), date(2013, 3, 17))\n\n\tdef test_third_sunday_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"3rd\", \"Sunday\"), date(2013, 4, 21))\n\n\tdef test_fourth_monday_of_march_2013(self):\n\t\tself.assertEqual(meetup(2013, 3, \"4th\", \"Monday\"), date(2013, 3, 25))\n\n\tdef test_fourth_monday_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"4th\", \"Monday\"), date(2013, 4, 22))\n\n\tdef test_fourth_tuesday_of_may_2013(self):\n\t\tself.assertEqual(meetup(2013, 5, \"4th\", \"Tuesday\"), date(2013, 5, 28))\n\n\tdef test_fourth_tuesday_of_june_2013(self):\n\t\tself.assertEqual(meetup(2013, 6, \"4th\", \"Tuesday\"), date(2013, 6, 25))\n\n\tdef test_fourth_wednesday_of_july_2013(self):\n\t\tself.assertEqual(meetup(2013, 7, \"4th\", \"Wednesday\"), date(2013, 7, 24))\n\n\tdef test_fourth_wednesday_of_august_2013(self):\n\t\tself.assertEqual(meetup(2013, 8, \"4th\", \"Wednesday\"), date(2013, 8, 28))\n\n\tdef test_fourth_thursday_of_september_2013(self):\n\t\tself.assertEqual(meetup(2013, 9, \"4th\", \"Thursday\"), date(2013, 9, 26))\n\n\tdef test_fourth_thursday_of_october_2013(self):\n\t\tself.assertEqual(meetup(2013, 10, \"4th\", \"Thursday\"), date(2013, 10, 24))\n\n\tdef test_fourth_friday_of_november_2013(self):\n\t\tself.assertEqual(meetup(2013, 11, \"4th\", \"Friday\"), date(2013, 11, 22))\n\n\tdef test_fourth_friday_of_december_2013(self):\n\t\tself.assertEqual(meetup(2013, 12, \"4th\", \"Friday\"), date(2013, 12, 27))\n\n\tdef test_fourth_saturday_of_january_2013(self):\n\t\tself.assertEqual(meetup(2013, 1, \"4th\", \"Saturday\"), date(2013, 1, 26))\n\n\tdef test_fourth_saturday_of_february_2013(self):\n\t\tself.assertEqual(meetup(2013, 2, \"4th\", \"Saturday\"), date(2013, 2, 23))\n\n\tdef test_fourth_sunday_of_march_2013(self):\n\t\tself.assertEqual(meetup(2013, 3, \"4th\", \"Sunday\"), date(2013, 3, 24))\n\n\tdef test_fourth_sunday_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"4th\", \"Sunday\"), date(2013, 4, 28))\n\n\tdef test_last_monday_of_march_2013(self):\n\t\tself.assertEqual(meetup(2013, 3, \"last\", \"Monday\"), date(2013, 3, 25))\n\n\tdef test_last_monday_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"last\", \"Monday\"), date(2013, 4, 29))\n\n\tdef test_last_tuesday_of_may_2013(self):\n\t\tself.assertEqual(meetup(2013, 5, \"last\", \"Tuesday\"), date(2013, 5, 28))\n\n\tdef test_last_tuesday_of_june_2013(self):\n\t\tself.assertEqual(meetup(2013, 6, \"last\", \"Tuesday\"), date(2013, 6, 25))\n\n\tdef test_last_wednesday_of_july_2013(self):\n\t\tself.assertEqual(meetup(2013, 7, \"last\", \"Wednesday\"), date(2013, 7, 31))\n\n\tdef test_last_wednesday_of_august_2013(self):\n\t\tself.assertEqual(meetup(2013, 8, \"last\", \"Wednesday\"), date(2013, 8, 28))\n\n\tdef test_last_thursday_of_september_2013(self):\n\t\tself.assertEqual(meetup(2013, 9, \"last\", \"Thursday\"), date(2013, 9, 26))\n\n\tdef test_last_thursday_of_october_2013(self):\n\t\tself.assertEqual(meetup(2013, 10, \"last\", \"Thursday\"), date(2013, 10, 31))\n\n\tdef test_last_friday_of_november_2013(self):\n\t\tself.assertEqual(meetup(2013, 11, \"last\", \"Friday\"), date(2013, 11, 29))\n\n\tdef test_last_friday_of_december_2013(self):\n\t\tself.assertEqual(meetup(2013, 12, \"last\", \"Friday\"), date(2013, 12, 27))\n\n\tdef test_last_saturday_of_january_2013(self):\n\t\tself.assertEqual(meetup(2013, 1, \"last\", \"Saturday\"), date(2013, 1, 26))\n\n\tdef test_last_saturday_of_february_2013(self):\n\t\tself.assertEqual(meetup(2013, 2, \"last\", \"Saturday\"), date(2013, 2, 23))\n\n\tdef test_last_sunday_of_march_2013(self):\n\t\tself.assertEqual(meetup(2013, 3, \"last\", \"Sunday\"), date(2013, 3, 31))\n\n\tdef test_last_sunday_of_april_2013(self):\n\t\tself.assertEqual(meetup(2013, 4, \"last\", \"Sunday\"), date(2013, 4, 28))\n\n\tdef test_last_wednesday_of_february_2012(self):\n\t\tself.assertEqual(meetup(2012, 2, \"last\", \"Wednesday\"), date(2012, 2, 29))\n\n\tdef test_last_wednesday_of_december_2014(self):\n\t\tself.assertEqual(meetup(2014, 12, \"last\", \"Wednesday\"), date(2014, 12, 31))\n\n\tdef test_last_sunday_of_february_2015(self):\n\t\tself.assertEqual(meetup(2015, 2, \"last\", \"Sunday\"), date(2015, 2, 22))\n\n\tdef test_first_friday_of_december_2012(self):\n\t\tself.assertEqual(meetup(2012, 12, \"1st\", \"Friday\"), date(2012, 12, 7))\n\n\t# Additional tests for this track\n\n\tdef test_fifth_monday_of_march_2015(self):\n\t\tself.assertEqual(meetup(2015, 3, \"5th\", \"Monday\"), date(2015, 3, 30))\n\n\tdef test_nonexistent_fifth_monday_of_february_2015(self):\n\t\twith self.assertRaisesWithMessage(MeetupDayException):\n\t\t\tmeetup(2015, 2, \"5th\", \"Monday\")\n\n\t# Utility functions\n\tdef assertRaisesWithMessage(self, exception):\n\t\treturn self.assertRaisesRegex(exception, r\".+\")\n\n", "description": null, "category": "def", "imports": ["from datetime import date", "import unittest", "from meetup import meetup, MeetupDayException"]}], [{"term": "def", "name": "lt", "data": "def lt(a, b):\n\t\"Same as a < b.\"\n\treturn a < b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "le", "data": "def le(a, b):\n\t\"Same as a <= b.\"\n\treturn a <= b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "eq", "data": "def eq(a, b):\n\t\"Same as a == b.\"\n\treturn a == b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "ne", "data": "def ne(a, b):\n\t\"Same as a != b.\"\n\treturn a != b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "ge", "data": "def ge(a, b):\n\t\"Same as a >= b.\"\n\treturn a >= b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "gt", "data": "def gt(a, b):\n\t\"Same as a > b.\"\n\treturn a > b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "not_", "data": "def not_(a):\n\t\"Same as not a.\"\n\treturn not a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "truth", "data": "def truth(a):\n\t\"Return True if a is true, False otherwise.\"\n\treturn True if a else False\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "is_", "data": "def is_(a, b):\n\t\"Same as a is b.\"\n\treturn a is b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "is_not", "data": "def is_not(a, b):\n\t\"Same as a is not b.\"\n\treturn a is not b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "abs", "data": "def abs(a):\n\t\"Same as abs(a).\"\n\treturn _abs(a)\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "add", "data": "def add(a, b):\n\t\"Same as a + b.\"\n\treturn a + b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "and_", "data": "def and_(a, b):\n\t\"Same as a & b.\"\n\treturn a & b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "floordiv", "data": "def floordiv(a, b):\n\t\"Same as a // b.\"\n\treturn a // b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "index", "data": "def index(a):\n\t\"Same as a.__index__().\"\n\treturn a.__index__()\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "inv", "data": "def inv(a):\n\t\"Same as ~a.\"\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "lshift", "data": "def lshift(a, b):\n\t\"Same as a << b.\"\n\treturn a << b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "mod", "data": "def mod(a, b):\n\t\"Same as a % b.\"\n\treturn a % b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "mul", "data": "def mul(a, b):\n\t\"Same as a * b.\"\n\treturn a * b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "matmul", "data": "def matmul(a, b):\n\t\"Same as a @ b.\"\n\treturn a @ b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "neg", "data": "def neg(a):\n\t\"Same as -a.\"\n\treturn -a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "or_", "data": "def or_(a, b):\n\t\"Same as a | b.\"\n\treturn a | b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "pos", "data": "def pos(a):\n\t\"Same as +a.\"\n\treturn +a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "pow", "data": "def pow(a, b):\n\t\"Same as a ** b.\"\n\treturn a ** b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "rshift", "data": "def rshift(a, b):\n\t\"Same as a >> b.\"\n\treturn a >> b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "sub", "data": "def sub(a, b):\n\t\"Same as a - b.\"\n\treturn a - b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "truediv", "data": "def truediv(a, b):\n\t\"Same as a / b.\"\n\treturn a / b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "xor", "data": "def xor(a, b):\n\t\"Same as a ^ b.\"\n\treturn a ^ b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "concat", "data": "def concat(a, b):\n\t\"Same as a + b, for a and b sequences.\"\n\tif not hasattr(a, '__getitem__'):\n\t\tmsg = \"'%s' object can't be concatenated\" % type(a).__name__\n\t\traise TypeError(msg)\n\treturn a + b\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "contains", "data": "def contains(a, b):\n\t\"Same as b in a (note reversed operands).\"\n\treturn b in a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "countOf", "data": "def countOf(a, b):\n\t\"Return the number of times b occurs in a.\"\n\tcount = 0\n\tfor i in a:\n\t\tif i == b:\n\t\t\tcount += 1\n\treturn count\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "delitem", "data": "def delitem(a, b):\n\t\"Same as del a[b].\"\n\tdel a[b]\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "getitem", "data": "def getitem(a, b):\n\t\"Same as a[b].\"\n\treturn a[b]\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "indexOf", "data": "def indexOf(a, b):\n\t\"Return the first index of b in a.\"\n\tfor i, j in enumerate(a):\n\t\tif j == b:\n\t\t\treturn i\n\telse:\n\t\traise ValueError('sequence.index(x): x not in sequence')\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "setitem", "data": "def setitem(a, b, c):\n\t\"Same as a[b] = c.\"\n\ta[b] = c\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "length_hint", "data": "def length_hint(obj, default=0):\n\t\"\"\"\n\tReturn an estimate of the number of items in obj.\n\tThis is useful for presizing containers when building from an iterable.\n\n\tIf the object supports len(), the result will be exact. Otherwise, it may\n\tover- or under-estimate by an arbitrary amount. The result will be an\n\tinteger >= 0.\n\t\"\"\"\n\tif not isinstance(default, int):\n\t\tmsg = (\"'%s' object cannot be interpreted as an integer\" %\n\t\t\t   type(default).__name__)\n\t\traise TypeError(msg)\n\n\ttry:\n\t\treturn len(obj)\n\texcept TypeError:\n\t\tpass\n\n\ttry:\n\t\thint = type(obj).__length_hint__\n\texcept AttributeError:\n\t\treturn default\n\n\ttry:\n\t\tval = hint(obj)\n\texcept TypeError:\n\t\treturn default\n\tif val is NotImplemented:\n\t\treturn default\n\tif not isinstance(val, int):\n\t\tmsg = ('__length_hint__ must be integer, not %s' %\n\t\t\t   type(val).__name__)\n\t\traise TypeError(msg)\n\tif val < 0:\n\t\tmsg = '__length_hint__() should return >= 0'\n\t\traise ValueError(msg)\n\treturn val\n", "description": "\n\tReturn an estimate of the number of items in obj.\n\tThis is useful for presizing containers when building from an iterable.\n\n\tIf the object supports len(), the result will be exact. Otherwise, it may\n\tover- or under-estimate by an arbitrary amount. The result will be an\n\tinteger >= 0.\n\t", "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "class", "name": "classattrgetter:", "data": "class attrgetter:\n\t\"\"\"\n\tReturn a callable object that fetches the given attribute(s) from its operand.\n\tAfter f = attrgetter('name'), the call f(r) returns r.name.\n\tAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\n\tAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\n\t(r.name.first, r.name.last).\n\t\"\"\"\n\t__slots__ = ('_attrs', '_call')\n\n\tdef __init__(self, attr, *attrs):\n\t\tif not attrs:\n\t\t\tif not isinstance(attr, str):\n\t\t\t\traise TypeError('attribute name must be a string')\n\t\t\tself._attrs = (attr,)\n\t\t\tnames = attr.split('.')\n\t\t\tdef func(obj):\n\t\t\t\tfor name in names:\n\t\t\t\t\tobj = getattr(obj, name)\n\t\t\t\treturn obj\n\t\t\tself._call = func\n\t\telse:\n\t\t\tself._attrs = (attr,) + attrs\n\t\t\tgetters = tuple(map(attrgetter, self._attrs))\n\t\t\tdef func(obj):\n\t\t\t\treturn tuple(getter(obj) for getter in getters)\n\t\t\tself._call = func\n\n\tdef __call__(self, obj):\n\t\treturn self._call(obj)\n\n\tdef __repr__(self):\n\t\treturn '%s.%s(%s)' % (self.__class__.__module__,\n\t\t\t\t\t\t\t  self.__class__.__qualname__,\n\t\t\t\t\t\t\t  ', '.join(map(repr, self._attrs)))\n\n\tdef __reduce__(self):\n\t\treturn self.__class__, self._attrs\n", "description": "\n\tReturn a callable object that fetches the given attribute(s) from its operand.\n\tAfter f = attrgetter('name'), the call f(r) returns r.name.\n\tAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\n\tAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\n\t(r.name.first, r.name.last).\n\t", "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "class", "name": "classitemgetter:", "data": "class itemgetter:\n\t\"\"\"\n\tReturn a callable object that fetches the given item(s) from its operand.\n\tAfter f = itemgetter(2), the call f(r) returns r[2].\n\tAfter g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\n\t\"\"\"\n\t__slots__ = ('_items', '_call')\n\n\tdef __init__(self, item, *items):\n\t\tif not items:\n\t\t\tself._items = (item,)\n\t\t\tdef func(obj):\n\t\t\t\treturn obj[item]\n\t\t\tself._call = func\n\t\telse:\n\t\t\tself._items = items = (item,) + items\n\t\t\tdef func(obj):\n\t\t\t\treturn tuple(obj[i] for i in items)\n\t\t\tself._call = func\n\n\tdef __call__(self, obj):\n\t\treturn self._call(obj)\n\n\tdef __repr__(self):\n\t\treturn '%s.%s(%s)' % (self.__class__.__module__,\n\t\t\t\t\t\t\t  self.__class__.__name__,\n\t\t\t\t\t\t\t  ', '.join(map(repr, self._items)))\n\n\tdef __reduce__(self):\n\t\treturn self.__class__, self._items\n", "description": "\n\tReturn a callable object that fetches the given item(s) from its operand.\n\tAfter f = itemgetter(2), the call f(r) returns r[2].\n\tAfter g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\n\t", "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "class", "name": "classmethodcaller:", "data": "class methodcaller:\n\t\"\"\"\n\tReturn a callable object that calls the given method on its operand.\n\tAfter f = methodcaller('name'), the call f(r) returns r.name().\n\tAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\n\tr.name('date', foo=1).\n\t\"\"\"\n\t__slots__ = ('_name', '_args', '_kwargs')\n\n\tdef __init__(*args, **kwargs):\n\t\tif len(args) < 2:\n\t\t\tmsg = \"methodcaller needs at least one argument, the method name\"\n\t\t\traise TypeError(msg)\n\t\tself = args[0]\n\t\tself._name = args[1]\n\t\tif not isinstance(self._name, str):\n\t\t\traise TypeError('method name must be a string')\n\t\tself._args = args[2:]\n\t\tself._kwargs = kwargs\n\n\tdef __call__(self, obj):\n\t\treturn getattr(obj, self._name)(*self._args, **self._kwargs)\n\n\tdef __repr__(self):\n\t\targs = [repr(self._name)]\n\t\targs.extend(map(repr, self._args))\n\t\targs.extend('%s=%r' % (k, v) for k, v in self._kwargs.items())\n\t\treturn '%s.%s(%s)' % (self.__class__.__module__,\n\t\t\t\t\t\t\t  self.__class__.__name__,\n\t\t\t\t\t\t\t  ', '.join(args))\n\n\tdef __reduce__(self):\n\t\tif not self._kwargs:\n\t\t\treturn self.__class__, (self._name,) + self._args\n\t\telse:\n\t\t\tfrom functools import partial\n\t\t\treturn partial(self.__class__, self._name, **self._kwargs), self._args\n\n", "description": "\n\tReturn a callable object that calls the given method on its operand.\n\tAfter f = methodcaller('name'), the call f(r) returns r.name().\n\tAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\n\tr.name('date', foo=1).\n\t", "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "iadd", "data": "def iadd(a, b):\n\t\"Same as a += b.\"\n\ta += b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "iand", "data": "def iand(a, b):\n\t\"Same as a &= b.\"\n\ta &= b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "iconcat", "data": "def iconcat(a, b):\n\t\"Same as a += b, for a and b sequences.\"\n\tif not hasattr(a, '__getitem__'):\n\t\tmsg = \"'%s' object can't be concatenated\" % type(a).__name__\n\t\traise TypeError(msg)\n\ta += b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "ifloordiv", "data": "def ifloordiv(a, b):\n\t\"Same as a //= b.\"\n\ta //= b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "ilshift", "data": "def ilshift(a, b):\n\t\"Same as a <<= b.\"\n\ta <<= b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "imod", "data": "def imod(a, b):\n\t\"Same as a %= b.\"\n\ta %= b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "imul", "data": "def imul(a, b):\n\t\"Same as a *= b.\"\n\ta *= b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "imatmul", "data": "def imatmul(a, b):\n\t\"Same as a @= b.\"\n\ta @= b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "ior", "data": "def ior(a, b):\n\t\"Same as a |= b.\"\n\ta |= b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "ipow", "data": "def ipow(a, b):\n\t\"Same as a **= b.\"\n\ta **=b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "irshift", "data": "def irshift(a, b):\n\t\"Same as a >>= b.\"\n\ta >>= b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "isub", "data": "def isub(a, b):\n\t\"Same as a -= b.\"\n\ta -= b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "itruediv", "data": "def itruediv(a, b):\n\t\"Same as a /= b.\"\n\ta /= b\n\treturn a\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}, {"term": "def", "name": "ixor", "data": "def ixor(a, b):\n\t\"Same as a ^= b.\"\n\ta ^= b\n\treturn a\n\n", "description": null, "category": "def", "imports": ["from builtins import abs as _abs", "\t\t\tfrom functools import partial", "\tfrom _operator import *", "\tfrom _operator import __doc__", "# All of these \"__func__ = func\" assignments have to happen after importing"]}], [{"term": "class", "name": "TimeoutError", "data": "class TimeoutError(Error): ...\n", "description": null, "category": "def", "imports": ["import threading", "from logging import Logger", "from typing import TypeVar, Generic, Any, Iterable, Iterator, Callable, Tuple, Optional, Set, List", "from types import TracebackType", "import sys"]}, {"term": "class", "name": "sBrokenExecutor", "data": "\tclass BrokenExecutor(RuntimeError): ...\n", "description": null, "category": "def", "imports": ["import threading", "from logging import Logger", "from typing import TypeVar, Generic, Any, Iterable, Iterator, Callable, Tuple, Optional, Set, List", "from types import TracebackType", "import sys"]}, {"term": "class", "name": "Future", "data": "class Future(Generic[_T]):\n\tdef __init__(self) -> None: ...\n\tdef cancel(self) -> bool: ...\n\tdef cancelled(self) -> bool: ...\n\tdef running(self) -> bool: ...\n\tdef done(self) -> bool: ...\n\tdef add_done_callback(self, fn: Callable[[Future[_T]], Any]) -> None: ...\n\tdef result(self, timeout: Optional[float] = ...) -> _T: ...\n\tdef set_running_or_notify_cancel(self) -> bool: ...\n\tdef set_result(self, result: _T) -> None: ...\n\n\tif sys.version_info >= (3,):\n\t\tdef exception(self, timeout: Optional[float] = ...) -> Optional[BaseException]: ...\n\t\tdef set_exception(self, exception: Optional[BaseException]) -> None: ...\n\telse:\n\t\tdef exception(self, timeout: Optional[float] = ...) -> Any: ...\n\t\tdef exception_info(self, timeout: Optional[float] = ...) -> Tuple[Any, Optional[TracebackType]]: ...\n\t\tdef set_exception(self, exception: Any) -> None: ...\n\t\tdef set_exception_info(self, exception: Any, traceback: Optional[TracebackType]) -> None: ...\n\n", "description": null, "category": "def", "imports": ["import threading", "from logging import Logger", "from typing import TypeVar, Generic, Any, Iterable, Iterator, Callable, Tuple, Optional, Set, List", "from types import TracebackType", "import sys"]}, {"term": "class", "name": "classExecutor:", "data": "class Executor:\n\tdef submit(self, fn: Callable[..., _T], *args: Any, **kwargs: Any) -> Future[_T]: ...\n\tif sys.version_info >= (3, 5):\n\t\tdef map(self, func: Callable[..., _T], *iterables: Iterable[Any], timeout: Optional[float] = ...,\n\t\t\t\tchunksize: int = ...) -> Iterator[_T]: ...\n\telse:\n\t\tdef map(self, func: Callable[..., _T], *iterables: Iterable[Any], timeout: Optional[float] = ...,) -> Iterator[_T]: ...\n\tdef shutdown(self, wait: bool = ...) -> None: ...\n\tdef __enter__(self: _T) -> _T: ...\n\tdef __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> Optional[bool]: ...\n", "description": null, "category": "def", "imports": ["import threading", "from logging import Logger", "from typing import TypeVar, Generic, Any, Iterable, Iterator, Callable, Tuple, Optional, Set, List", "from types import TracebackType", "import sys"]}, {"term": "def", "name": "as_completed", "data": "def as_completed(fs: Iterable[Future[_T]], timeout: Optional[float] = ...) -> Iterator[Future[_T]]: ...\n", "description": null, "category": "def", "imports": ["import threading", "from logging import Logger", "from typing import TypeVar, Generic, Any, Iterable, Iterator, Callable, Tuple, Optional, Set, List", "from types import TracebackType", "import sys"]}, {"term": "def", "name": "wait", "data": "def wait(fs: Iterable[Future[_T]], timeout: Optional[float] = ..., return_when: str = ...) -> Tuple[Set[Future[_T]],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSet[Future[_T]]]: ...\n", "description": null, "category": "def", "imports": ["import threading", "from logging import Logger", "from typing import TypeVar, Generic, Any, Iterable, Iterator, Callable, Tuple, Optional, Set, List", "from types import TracebackType", "import sys"]}, {"term": "class", "name": "class_Waiter:", "data": "class _Waiter:\n\tevent: threading.Event\n\tfinished_futures: List[Future[Any]]\n\tdef __init__(self) -> None: ...\n\tdef add_result(self, future: Future[Any]) -> None: ...\n\tdef add_exception(self, future: Future[Any]) -> None: ...\n\tdef add_cancelled(self, future: Future[Any]) -> None: ...\n\n", "description": null, "category": "def", "imports": ["import threading", "from logging import Logger", "from typing import TypeVar, Generic, Any, Iterable, Iterator, Callable, Tuple, Optional, Set, List", "from types import TracebackType", "import sys"]}, {"term": "class", "name": "_AsCompletedWaiter", "data": "class _AsCompletedWaiter(_Waiter):\n\tlock: threading.Lock\n\tdef __init__(self) -> None: ...\n\tdef add_result(self, future: Future[Any]) -> None: ...\n\tdef add_exception(self, future: Future[Any]) -> None: ...\n\tdef add_cancelled(self, future: Future[Any]) -> None: ...\n\n", "description": null, "category": "def", "imports": ["import threading", "from logging import Logger", "from typing import TypeVar, Generic, Any, Iterable, Iterator, Callable, Tuple, Optional, Set, List", "from types import TracebackType", "import sys"]}, {"term": "class", "name": "_FirstCompletedWaiter", "data": "class _FirstCompletedWaiter(_Waiter):\n\tdef add_result(self, future: Future[Any]) -> None: ...\n\tdef add_exception(self, future: Future[Any]) -> None: ...\n\tdef add_cancelled(self, future: Future[Any]) -> None: ...\n\n", "description": null, "category": "def", "imports": ["import threading", "from logging import Logger", "from typing import TypeVar, Generic, Any, Iterable, Iterator, Callable, Tuple, Optional, Set, List", "from types import TracebackType", "import sys"]}, {"term": "class", "name": "_AllCompletedWaiter", "data": "class _AllCompletedWaiter(_Waiter):\n\tnum_pending_calls: int\n\tstop_on_exception: bool\n\tlock: threading.Lock\n\tdef __init__(self, num_pending_calls: int, stop_on_exception: bool) -> None: ...\n\tdef add_result(self, future: Future[Any]) -> None: ...\n\tdef add_exception(self, future: Future[Any]) -> None: ...\n\tdef add_cancelled(self, future: Future[Any]) -> None: ...\n\n", "description": null, "category": "def", "imports": ["import threading", "from logging import Logger", "from typing import TypeVar, Generic, Any, Iterable, Iterator, Callable, Tuple, Optional, Set, List", "from types import TracebackType", "import sys"]}, {"term": "class", "name": "class_AcquireFutures:", "data": "class _AcquireFutures:\n\tfutures: Iterable[Future[Any]]\n\tdef __init__(self, futures: Iterable[Future[Any]]) -> None: ...\n\tdef __enter__(self) -> None: ...\n", "description": null, "category": "def", "imports": ["import threading", "from logging import Logger", "from typing import TypeVar, Generic, Any, Iterable, Iterator, Callable, Tuple, Optional, Set, List", "from types import TracebackType", "import sys"]}], [{"term": "def", "name": "quote", "data": "def quote(str): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional"]}, {"term": "class", "name": "classAddrlistClass:", "data": "class AddrlistClass:\n\tspecials: Any\n\tpos: Any\n\tLWS: Any\n\tCR: Any\n\tFWS: Any\n\tatomends: Any\n\tphraseends: Any\n\tfield: Any\n\tcommentlist: Any\n\tdef __init__(self, field): ...\n\tdef gotonext(self): ...\n\tdef getaddrlist(self): ...\n\tdef getaddress(self): ...\n\tdef getrouteaddr(self): ...\n\tdef getaddrspec(self): ...\n\tdef getdomain(self): ...\n\tdef getdelimited(self, beginchar, endchars, allowcomments: bool = ...): ...\n\tdef getquote(self): ...\n\tdef getcomment(self): ...\n\tdef getdomainliteral(self): ...\n\tdef getatom(self, atomends: Optional[Any] = ...): ...\n\tdef getphraselist(self): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional"]}, {"term": "class", "name": "AddressList", "data": "class AddressList(AddrlistClass):\n\taddresslist: Any\n\tdef __init__(self, field): ...\n\tdef __len__(self): ...\n\tdef __add__(self, other): ...\n\tdef __iadd__(self, other): ...\n\tdef __sub__(self, other): ...\n\tdef __isub__(self, other): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional"]}], [{"term": "class", "name": "BaseMultiIndexCodesEngine", "data": "class BaseMultiIndexCodesEngine(_mod_builtins.object):\n\t'\\n\tBase class for MultiIndexUIntEngine and MultiIndexPyIntEngine, which\\n\trepresent each label in a MultiIndex as an integer, by juxtaposing the bits\\n\tencoding each level, with appropriate offsets.\\n\\n\tFor instance: if 3 levels have respectively 3, 6 and 1 possible values,\\n\tthen their labels can be represented using respectively 2, 3 and 1 bits,\\n\tas follows:\\n\t _ _ _ _____ _ __ __ __\\n\t|0|0|0| ... |0| 0|a1|a0| -> offset 0 (first level)\\n\t \u2014 \u2014 \u2014 \u2014\u2014\u2014\u2014\u2014 \u2014 \u2014\u2014 \u2014\u2014 \u2014\u2014\\n\t|0|0|0| ... |0|b2|b1|b0| -> offset 2 (bits required for first level)\\n\t \u2014 \u2014 \u2014 \u2014\u2014\u2014\u2014\u2014 \u2014 \u2014\u2014 \u2014\u2014 \u2014\u2014\\n\t|0|0|0| ... |0| 0| 0|c0| -> offset 5 (bits required for first two levels)\\n\t \u203e \u203e \u203e \u203e\u203e\u203e\u203e\u203e \u203e \u203e\u203e \u203e\u203e \u203e\u203e\\n\tand the resulting unsigned integer representation will be:\\n\t _ _ _ _____ _ __ __ __ __ __ __\\n\t|0|0|0| ... |0|c0|b2|b1|b0|a1|a0|\\n\t \u203e \u203e \u203e \u203e\u203e\u203e\u203e\u203e \u203e \u203e\u203e \u203e\u203e \u203e\u203e \u203e\u203e \u203e\u203e \u203e\u203e\\n\\n\tOffsets are calculated at initialization, labels are transformed by method\\n\t_codes_to_ints.\\n\\n\tKeys are located by first locating each component against the respective\\n\tlevel, then locating (the integer representation of) codes.\\n\t'\n\t__class__ = BaseMultiIndexCodesEngine\n\tdef __contains__(self, key):\n\t\t'Return key in self.'\n\t\treturn False\n\t\n\tdef __init__(self):\n\t\t'\\n\t\tParameters\\n\t\t----------\\n\t\tlevels : list-like of numpy arrays\\n\t\t\tLevels of the MultiIndex.\\n\t\tlabels : list-like of numpy arrays of integer dtype\\n\t\t\tLabels of the MultiIndex.\\n\t\toffsets : numpy array of uint64 dtype\\n\t\t\tPre-calculated offsets, one for each level of the index.\\n\t\t'\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n\tdef _extract_level_codes(self):\n\t\t'\\n\t\tMap the requested list of (tuple) keys to their integer representations\\n\t\tfor searching in the underlying integer index.\\n\\n\t\tParameters\\n\t\t----------\\n\t\ttarget : list-like of keys\\n\t\t\tEach key is a tuple, with a label for each level of the index.\\n\\n\t\tReturns\\n\t\t------\\n\t\tint_keys : 1-dimensional array of dtype uint64 or object\\n\t\t\tIntegers representing one combination each\\n\t\t'\n\t\tpass\n\t\n\tdef get_indexer(self):\n\t\tpass\n\t\n\tdef get_indexer_non_unique(self):\n\t\tpass\n\t\n\tdef get_loc(self):\n\t\tpass\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "DatetimeEngine", "data": "class DatetimeEngine(Int64Engine):\n\t__class__ = DatetimeEngine\n\tdef __contains__(self, key):\n\t\t'Return key in self.'\n\t\treturn False\n\t\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n\tdef get_backfill_indexer(self):\n\t\tpass\n\t\n\tdef get_indexer(self):\n\t\tpass\n\t\n\tdef get_loc(self):\n\t\tpass\n\t\n\tdef get_pad_indexer(self):\n\t\tpass\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "Float32Engine", "data": "class Float32Engine(IndexEngine):\n\t__class__ = Float32Engine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "Float64Engine", "data": "class Float64Engine(IndexEngine):\n\t__class__ = Float64Engine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "IndexEngine", "data": "class IndexEngine(_mod_builtins.object):\n\t__class__ = IndexEngine\n\tdef __contains__(self, key):\n\t\t'Return key in self.'\n\t\treturn False\n\t\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\tdef __sizeof__(self):\n\t\treturn 0\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n\tdef clear_mapping(self):\n\t\tpass\n\t\n\tdef get_backfill_indexer(self):\n\t\tpass\n\t\n\tdef get_indexer(self):\n\t\tpass\n\t\n\tdef get_indexer_non_unique(self):\n\t\t'\\n\t\tReturn an indexer suitable for taking from a non unique index\\n\t\treturn the labels in the same order ast the target\\n\t\tand a missing indexer into the targets (which correspond\\n\t\tto the -1 indices in the results\\n\t\t'\n\t\tpass\n\t\n\tdef get_loc(self):\n\t\tpass\n\t\n\tdef get_pad_indexer(self):\n\t\tpass\n\t\n\tdef get_value(self):\n\t\t'\\n\t\tParameters\\n\t\t----------\\n\t\tarr : 1-dimensional ndarray\\n\t\t'\n\t\tpass\n\t\n\t@property\n\tdef is_mapping_populated(self):\n\t\tpass\n\t\n\t@property\n\tdef is_monotonic_decreasing(self):\n\t\tpass\n\t\n\t@property\n\tdef is_monotonic_increasing(self):\n\t\tpass\n\t\n\t@property\n\tdef is_unique(self):\n\t\tpass\n\t\n\t@property\n\tdef mapping(self):\n\t\tpass\n\t\n\t@property\n\tdef over_size_threshold(self):\n\t\tpass\n\t\n\tdef set_value(self):\n\t\t'\\n\t\tParameters\\n\t\t----------\\n\t\tarr : 1-dimensional ndarray\\n\t\t'\n\t\tpass\n\t\n\tdef sizeof(self):\n\t\t' return the sizeof our mapping '\n\t\tpass\n\t\n\t@property\n\tdef vgetter(self):\n\t\tpass\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "Int16Engine", "data": "class Int16Engine(IndexEngine):\n\t__class__ = Int16Engine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "Int32Engine", "data": "class Int32Engine(IndexEngine):\n\t__class__ = Int32Engine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "Int64Engine", "data": "class Int64Engine(IndexEngine):\n\t__class__ = Int64Engine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "Int8Engine", "data": "class Int8Engine(IndexEngine):\n\t__class__ = Int8Engine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "ObjectEngine", "data": "class ObjectEngine(IndexEngine):\n\t'\\n\tIndex Engine for use with object-dtype Index, namely the base class Index.\\n\t'\n\t__class__ = ObjectEngine\n\tdef __init__(self, *args, **kwargs):\n\t\t'\\n\tIndex Engine for use with object-dtype Index, namely the base class Index.\\n\t'\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "PeriodEngine", "data": "class PeriodEngine(Int64Engine):\n\t__class__ = PeriodEngine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n\tdef get_backfill_indexer(self):\n\t\tpass\n\t\n\tdef get_indexer(self):\n\t\tpass\n\t\n\tdef get_indexer_non_unique(self):\n\t\tpass\n\t\n\tdef get_pad_indexer(self):\n\t\tpass\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "TimedeltaEngine", "data": "class TimedeltaEngine(DatetimeEngine):\n\t__class__ = TimedeltaEngine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "UInt16Engine", "data": "class UInt16Engine(IndexEngine):\n\t__class__ = UInt16Engine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "UInt32Engine", "data": "class UInt32Engine(IndexEngine):\n\t__class__ = UInt32Engine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "UInt64Engine", "data": "class UInt64Engine(IndexEngine):\n\t__class__ = UInt64Engine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "class", "name": "UInt8Engine", "data": "class UInt8Engine(IndexEngine):\n\t__class__ = UInt8Engine\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\t__pyx_vtable__ = _mod_builtins.PyCapsule()\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_BaseMultiIndexCodesEngine", "data": "def __pyx_unpickle_BaseMultiIndexCodesEngine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_DatetimeEngine", "data": "def __pyx_unpickle_DatetimeEngine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_Enum", "data": "def __pyx_unpickle_Enum():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_Float32Engine", "data": "def __pyx_unpickle_Float32Engine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_Float64Engine", "data": "def __pyx_unpickle_Float64Engine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_IndexEngine", "data": "def __pyx_unpickle_IndexEngine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_Int16Engine", "data": "def __pyx_unpickle_Int16Engine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_Int32Engine", "data": "def __pyx_unpickle_Int32Engine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_Int64Engine", "data": "def __pyx_unpickle_Int64Engine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_Int8Engine", "data": "def __pyx_unpickle_Int8Engine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_ObjectEngine", "data": "def __pyx_unpickle_ObjectEngine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_PeriodEngine", "data": "def __pyx_unpickle_PeriodEngine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_TimedeltaEngine", "data": "def __pyx_unpickle_TimedeltaEngine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_UInt16Engine", "data": "def __pyx_unpickle_UInt16Engine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_UInt32Engine", "data": "def __pyx_unpickle_UInt32Engine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_UInt64Engine", "data": "def __pyx_unpickle_UInt64Engine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "__pyx_unpickle_UInt8Engine", "data": "def __pyx_unpickle_UInt8Engine():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "checknull", "data": "def checknull():\n\t'\\n\tReturn boolean describing of the input is NA-like, defined here as any\\n\tof:\\n\t - None\\n\t - nan\\n\t - NaT\\n\t - np.datetime64 representation of NaT\\n\t - np.timedelta64 representation of NaT\\n\\n\tParameters\\n\t----------\\n\tval : object\\n\\n\tReturns\\n\t-------\\n\tresult : bool\\n\\n\tNotes\\n\t-----\\n\tThe difference between `checknull` and `checknull_old` is that `checknull`\\n\tdoes *not* consider INF or NEGINF to be NA.\\n\t'\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "convert_scalar", "data": "def convert_scalar():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}, {"term": "def", "name": "get_value_at", "data": "def get_value_at():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins", "import datetime as _mod_datetime", "import pandas._libs.tslibs.timedeltas as _mod_pandas__libs_tslibs_timedeltas", "import pandas._libs.tslibs.timestamps as _mod_pandas__libs_tslibs_timestamps"]}], [{"term": "class", "name": "C", "data": "class C(object):\n\tdef b(self):\n\t\t#! ['b = math']\n\t\tb\n\t\t#! ['def b']\n\t\tself.b\n\t\t#! 14 ['def b']\n\t\tself.b()\n\t\t#! 11 ['param self']\n\t\tself.b\n\t\treturn 1\n\n\t#! ['def b']\n\tb\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "def", "name": "c", "data": "def c():\n\treturn ''\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "class", "name": "ClassVar", "data": "class ClassVar():\n\tx = 3\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "def", "name": "f", "data": "def f(t=None):\n\t#! 9 ['param t=None']\n\tt = t or 1\n\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "class", "name": "X", "data": "class X():\n\tpass\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "class", "name": "classFoo:", "data": "class Foo:\n\tdef foo(self):\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "class", "name": "classBar:", "data": "class Bar:\n\tdef bar(self):\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "class", "name": "Baz", "data": "class Baz(Foo, Bar):\n\tdef baz(self):\n\t\t#! ['def foo']\n\t\tsuper().foo\n\t\t#! ['def bar']\n\t\tsuper().bar\n\t\t#! ['instance Foo']\n\t\tsuper()\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "def", "name": "func", "data": "def func():\n\tclass A():\n\t\tdef b(self):\n\t\t\treturn 1\n\treturn A()\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "class", "name": "ClassDef", "data": "class ClassDef():\n\t\"\"\" abc \"\"\"\n\tpass\n", "description": " abc ", "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "def", "name": "ab3", "data": "def ab3(a=param): pass\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "def", "name": "dec", "data": "def dec(dec_param=3):\n\tpass\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "def", "name": "y", "data": "def y():\n\tpass\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "class", "name": "ClassDec", "data": "class ClassDec():\n\tdef class_func(func):\n\t\treturn func\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "def", "name": "x", "data": "def x():\n\tpass\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}, {"term": "def", "name": "z", "data": "def z():\n", "description": null, "category": "def", "imports": ["import math", "# imports", "#! ['module import_tree']", "import import_tree", "import_tree.a", "import import_tree.mod1", "from import_tree.mod1", "import_tree.mod1.a", "import import_tree.pkg", "import_tree.pkg.a", "import import_tree.pkg.mod1", "import_tree.pkg.mod1.a", "import_tree.a", "from import_tree.pkg import mod1", "from import_tree import mod1", "from import_tree.pkg.mod1 import a", "from .imports import os", "from . import some_variable"]}], [{"term": "class", "name": "BufferInfo", "data": "class BufferInfo(object):\n\tdef __init__(self):\n\t\tpass\n\t\tself.mode = 0\n\t\tself.keep = 0\n\t\tself.value = 0\n\t\tself.skill_id = 0\n\t\tself.max_override = 0\n\t\tself.override_num = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<B\", self.mode))\n\t\tbuff.extend(struct.pack(\"<b\", self.keep))\n\t\tbuff.extend(struct.pack(\"<l\", self.value))\n\t\tbuff.extend(struct.pack(\"<h\", self.skill_id))\n\t\tbuff.extend(struct.pack(\"<b\", self.max_override))\n\t\tbuff.extend(struct.pack(\"<b\", self.override_num))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.mode = struct.unpack_from(\"<B\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\t\tself.keep = struct.unpack_from(\"<b\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\t\tself.value = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.skill_id = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\t\tself.max_override = struct.unpack_from(\"<b\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\t\tself.override_num = struct.unpack_from(\"<b\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 10\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "PlayerKeyChangedUp", "data": "class PlayerKeyChangedUp(object):\n\t_module = 8\n\t_action = 0\n\n\tdef __init__(self):\n\t\tpass\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tpass\n\n\t@staticmethod\n\tdef size():\n\t\treturn 2\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "PlayerKeyChangedDown", "data": "class PlayerKeyChangedDown(object):\n\t_module = 8\n\t_action = 0\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.key = 0\n\t\tself.max_order = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<l\", self.key))\n\t\tbuff.extend(struct.pack(\"<b\", self.max_order))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.key = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.max_order = struct.unpack_from(\"<b\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 5\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "MissionLevelLockChangedDown", "data": "class MissionLevelLockChangedDown(object):\n\t_module = 8\n\t_action = 1\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.max_lock = 0\n\t\tself.award_lock = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<l\", self.max_lock))\n\t\tbuff.extend(struct.pack(\"<l\", self.award_lock))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.max_lock = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.award_lock = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 8\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "RoleExpChangeDown", "data": "class RoleExpChangeDown(object):\n\t_module = 8\n\t_action = 2\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.role_id = 0\n\t\tself.add_exp = 0\n\t\tself.exp = 0\n\t\tself.level = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<b\", self.role_id))\n\t\tbuff.extend(struct.pack(\"<q\", self.add_exp))\n\t\tbuff.extend(struct.pack(\"<q\", self.exp))\n\t\tbuff.extend(struct.pack(\"<h\", self.level))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.role_id = struct.unpack_from(\"<b\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\t\tself.add_exp = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\t\tself.exp = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\t\tself.level = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 19\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "PhysicalChangeDown", "data": "class PhysicalChangeDown(object):\n\t_module = 8\n\t_action = 3\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.value = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<h\", self.value))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.value = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 2\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "MoneyChangeDown", "data": "class MoneyChangeDown(object):\n\t_module = 8\n\t_action = 4\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.moneytype = 0\n\t\tself.value = 0\n\t\tself.timestamp = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<b\", self.moneytype))\n\t\tbuff.extend(struct.pack(\"<q\", self.value))\n\t\tbuff.extend(struct.pack(\"<q\", self.timestamp))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.moneytype = struct.unpack_from(\"<b\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\t\tself.value = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\t\tself.timestamp = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 17\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "SkillAddDown", "data": "class SkillAddDown(object):\n\t_module = 8\n\t_action = 5\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.role_id = 0\n\t\tself.skill_id = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<b\", self.role_id))\n\t\tbuff.extend(struct.pack(\"<h\", self.skill_id))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.role_id = struct.unpack_from(\"<b\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\t\tself.skill_id = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 3\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "ItemChangeDown", "data": "class ItemChangeDown(object):\n\t_module = 8\n\t_action = 6\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.items = []\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack('<B', len(self.items)))\n\t\tfor item in self.items:\n\t\t\tbuff.extend(item.encode())\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\t_items_size = struct.unpack_from(\"<B\", raw_msg, idx)[0]\n\t\tidx += 1\n\t\tfor i in range(_items_size):\n\t\t\tobj = ItemChangeDownItems()\n\t\t\tobj.decode(raw_msg[idx:])\n\t\t\tidx += obj.size()\n\t\t\tself.items.append(obj)\n\n\tdef size(self):\n\t\tsize = 1\n\t\tfor item in self.items:\n\t\t\tsize += item.size()\n\t\treturn size\n\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "ItemChangeDownItems", "data": "class ItemChangeDownItems(object):\n\tdef __init__(self):\n\t\tpass\n\t\tself.id = 0\n\t\tself.item_id = 0\n\t\tself.num = 0\n\t\tself.attack = 0\n\t\tself.defence = 0\n\t\tself.health = 0\n\t\tself.speed = 0\n\t\tself.cultivation = 0\n\t\tself.hit_level = 0\n\t\tself.critical_level = 0\n\t\tself.block_level = 0\n\t\tself.destroy_level = 0\n\t\tself.tenacity_level = 0\n\t\tself.dodge_level = 0\n\t\tself.refine_level = 0\n\t\tself.recast_attr = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<q\", self.id))\n\t\tbuff.extend(struct.pack(\"<h\", self.item_id))\n\t\tbuff.extend(struct.pack(\"<h\", self.num))\n\t\tbuff.extend(struct.pack(\"<l\", self.attack))\n\t\tbuff.extend(struct.pack(\"<l\", self.defence))\n\t\tbuff.extend(struct.pack(\"<l\", self.health))\n\t\tbuff.extend(struct.pack(\"<l\", self.speed))\n\t\tbuff.extend(struct.pack(\"<l\", self.cultivation))\n\t\tbuff.extend(struct.pack(\"<l\", self.hit_level))\n\t\tbuff.extend(struct.pack(\"<l\", self.critical_level))\n\t\tbuff.extend(struct.pack(\"<l\", self.block_level))\n\t\tbuff.extend(struct.pack(\"<l\", self.destroy_level))\n\t\tbuff.extend(struct.pack(\"<l\", self.tenacity_level))\n\t\tbuff.extend(struct.pack(\"<l\", self.dodge_level))\n\t\tbuff.extend(struct.pack(\"<h\", self.refine_level))\n\t\tbuff.extend(struct.pack(\"<B\", self.recast_attr))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.id = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\t\tself.item_id = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\t\tself.num = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\t\tself.attack = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.defence = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.health = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.speed = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.cultivation = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.hit_level = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.critical_level = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.block_level = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.destroy_level = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.tenacity_level = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.dodge_level = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.refine_level = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\t\tself.recast_attr = struct.unpack_from(\"<B\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 59\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "RoleBattleStatusChangeDown", "data": "class RoleBattleStatusChangeDown(object):\n\t_module = 8\n\t_action = 7\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.roles = []\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack('<B', len(self.roles)))\n\t\tfor item in self.roles:\n\t\t\tbuff.extend(item.encode())\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\t_roles_size = struct.unpack_from(\"<B\", raw_msg, idx)[0]\n\t\tidx += 1\n\t\tfor i in range(_roles_size):\n\t\t\tobj = RoleBattleStatusChangeDownRoles()\n\t\t\tobj.decode(raw_msg[idx:])\n\t\t\tidx += obj.size()\n\t\t\tself.roles.append(obj)\n\n\tdef size(self):\n\t\tsize = 1\n\t\tfor item in self.roles:\n\t\t\tsize += item.size()\n\t\treturn size\n\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "RoleBattleStatusChangeDownRoles", "data": "class RoleBattleStatusChangeDownRoles(object):\n\tdef __init__(self):\n\t\tpass\n\t\tself.role_id = 0\n\t\tself.health = 0\n\t\tself.buffs = []\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<b\", self.role_id))\n\t\tbuff.extend(struct.pack(\"<l\", self.health))\n\t\tbuff.extend(struct.pack('<B', len(self.buffs)))\n\t\tfor item in self.buffs:\n\t\t\tbuff.extend(item.encode())\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.role_id = struct.unpack_from(\"<b\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\t\tself.health = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\t_buffs_size = struct.unpack_from(\"<B\", raw_msg, idx)[0]\n\t\tidx += 1\n\t\tfor i in range(_buffs_size):\n\t\t\tobj = RoleBattleStatusChangeDownRolesBuffs()\n\t\t\tobj.decode(raw_msg[idx:])\n\t\t\tidx += obj.size()\n\t\t\tself.buffs.append(obj)\n\n\tdef size(self):\n\t\tsize = 6\n\t\tfor item in self.buffs:\n\t\t\tsize += item.size()\n\t\treturn size\n\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "RoleBattleStatusChangeDownRolesBuffs", "data": "class RoleBattleStatusChangeDownRolesBuffs(object):\n\tdef __init__(self):\n\t\tpass\n\t\tself.buffer = BufferInfo()\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(self.buffer.encode())\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.buffer.decode(raw_msg[idx:])\n\t\tidx += self.buffer.size()\n\n\tdef size(self):\n\t\tsize = 0\n\t\tsize += self.buffer.size()\n\t\treturn size\n\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "NewMailDown", "data": "class NewMailDown(object):\n\t_module = 8\n\t_action = 8\n\n\tdef __init__(self):\n\t\tpass\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tpass\n\n\t@staticmethod\n\tdef size():\n\t\treturn 0\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "HeartChangeDown", "data": "class HeartChangeDown(object):\n\t_module = 8\n\t_action = 9\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.value = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<h\", self.value))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.value = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 2\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "QuestChangeDown", "data": "class QuestChangeDown(object):\n\t_module = 8\n\t_action = 10\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.quest_id = 0\n\t\tself.state = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<h\", self.quest_id))\n\t\tbuff.extend(struct.pack(\"<b\", self.state))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.quest_id = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\t\tself.state = struct.unpack_from(\"<b\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 3\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "TownLockChangeDown", "data": "class TownLockChangeDown(object):\n\t_module = 8\n\t_action = 11\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.lock = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<l\", self.lock))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.lock = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 4\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "ChatDown", "data": "class ChatDown(object):\n\t_module = 8\n\t_action = 12\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.pid = 0\n\t\tself.role_id = 0\n\t\tself.nickname = ''\n\t\tself.level = 0\n\t\tself.fight_num = 0\n\t\tself.message = ''\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<q\", self.pid))\n\t\tbuff.extend(struct.pack(\"<b\", self.role_id))\n\t\tbuff.extend(struct.pack('<H', len(self.nickname)))\n\t\tbuff.extend(self.nickname)\n\t\tbuff.extend(struct.pack(\"<h\", self.level))\n\t\tbuff.extend(struct.pack(\"<l\", self.fight_num))\n\t\tbuff.extend(struct.pack('<H', len(self.message)))\n\t\tbuff.extend(self.message)\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.pid = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\t\tself.role_id = struct.unpack_from(\"<b\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\t\t_nickname_size = struct.unpack_from(\"<H\", raw_msg, idx)[0]\n\t\tidx += 2\n\t\tself.nickname = str(raw_msg[idx:idx+_nickname_size])\n\t\tidx += _nickname_size\n\n\t\tself.level = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\t\tself.fight_num = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\t_message_size = struct.unpack_from(\"<H\", raw_msg, idx)[0]\n\t\tidx += 2\n\t\tself.message = str(raw_msg[idx:idx+_message_size])\n\t\tidx += _message_size\n\n\tdef size(self):\n\t\tsize = 19\n\t\tsize += len(self.nickname)\n\t\tsize += len(self.message)\n\t\treturn size\n\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "FuncKeyChangeDown", "data": "class FuncKeyChangeDown(object):\n\t_module = 8\n\t_action = 13\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.func_key = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<h\", self.func_key))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.func_key = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 2\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "ItemRecastStateRebuildDown", "data": "class ItemRecastStateRebuildDown(object):\n\t_module = 8\n\t_action = 14\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.id = 0\n\t\tself.selected_attr = 0\n\t\tself.attrs = []\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<q\", self.id))\n\t\tbuff.extend(struct.pack(\"<B\", self.selected_attr))\n\t\tbuff.extend(struct.pack('<B', len(self.attrs)))\n\t\tfor item in self.attrs:\n\t\t\tbuff.extend(item.encode())\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.id = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\t\tself.selected_attr = struct.unpack_from(\"<B\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\t\t_attrs_size = struct.unpack_from(\"<B\", raw_msg, idx)[0]\n\t\tidx += 1\n\t\tfor i in range(_attrs_size):\n\t\t\tobj = ItemRecastStateRebuildDownAttrs()\n\t\t\tobj.decode(raw_msg[idx:])\n\t\t\tidx += obj.size()\n\t\t\tself.attrs.append(obj)\n\n\tdef size(self):\n\t\tsize = 10\n\t\tfor item in self.attrs:\n\t\t\tsize += item.size()\n\t\treturn size\n\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "ItemRecastStateRebuildDownAttrs", "data": "class ItemRecastStateRebuildDownAttrs(object):\n\tdef __init__(self):\n\t\tpass\n\t\tself.attr = 0\n\t\tself.value = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<B\", self.attr))\n\t\tbuff.extend(struct.pack(\"<l\", self.value))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.attr = struct.unpack_from(\"<B\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\t\tself.value = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 5\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "SendAnnouncementDown", "data": "class SendAnnouncementDown(object):\n\t_module = 8\n\t_action = 15\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.id = 0\n\t\tself.tpl_id = 0\n\t\tself.expire_time = 0\n\t\tself.parameters = ''\n\t\tself.content = ''\n\t\tself.spacing_time = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<q\", self.id))\n\t\tbuff.extend(struct.pack(\"<l\", self.tpl_id))\n\t\tbuff.extend(struct.pack(\"<q\", self.expire_time))\n\t\tbuff.extend(struct.pack('<H', len(self.parameters)))\n\t\tbuff.extend(self.parameters)\n\t\tbuff.extend(struct.pack('<H', len(self.content)))\n\t\tbuff.extend(self.content)\n\t\tbuff.extend(struct.pack(\"<l\", self.spacing_time))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.id = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\t\tself.tpl_id = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.expire_time = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\t\t_parameters_size = struct.unpack_from(\"<H\", raw_msg, idx)[0]\n\t\tidx += 2\n\t\tself.parameters = str(raw_msg[idx:idx+_parameters_size])\n\t\tidx += _parameters_size\n\n\t\t_content_size = struct.unpack_from(\"<H\", raw_msg, idx)[0]\n\t\tidx += 2\n\t\tself.content = str(raw_msg[idx:idx+_content_size])\n\t\tidx += _content_size\n\n\t\tself.spacing_time = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\tdef size(self):\n\t\tsize = 28\n\t\tsize += len(self.parameters)\n\t\tsize += len(self.content)\n\t\treturn size\n\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "VipLevelChangeDown", "data": "class VipLevelChangeDown(object):\n\t_module = 8\n\t_action = 16\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.level = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<h\", self.level))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.level = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 2\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "NotifyNewBuddyDown", "data": "class NotifyNewBuddyDown(object):\n\t_module = 8\n\t_action = 17\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.role_id = 0\n\t\tself.role_level = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<b\", self.role_id))\n\t\tbuff.extend(struct.pack(\"<h\", self.role_level))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.role_id = struct.unpack_from(\"<b\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\t\tself.role_level = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 3\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "HardLevelLockChangedDown", "data": "class HardLevelLockChangedDown(object):\n\t_module = 8\n\t_action = 18\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.lock = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<l\", self.lock))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.lock = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 4\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "SendSwordSoulDrawNumChangeDown", "data": "class SendSwordSoulDrawNumChangeDown(object):\n\t_module = 8\n\t_action = 19\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.num = 0\n\t\tself.cd_time = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<h\", self.num))\n\t\tbuff.extend(struct.pack(\"<q\", self.cd_time))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.num = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\t\tself.cd_time = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 10\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "SendHaveNewGhostDown", "data": "class SendHaveNewGhostDown(object):\n\t_module = 8\n\t_action = 21\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.player_ghost_id = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<q\", self.player_ghost_id))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.player_ghost_id = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 8\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "SendHeartRecoverTimeDown", "data": "class SendHeartRecoverTimeDown(object):\n\t_module = 8\n\t_action = 22\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.timestamp = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<q\", self.timestamp))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.timestamp = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 8\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "SendGlobalMailDown", "data": "class SendGlobalMailDown(object):\n\t_module = 8\n\t_action = 23\n\n\tdef __init__(self):\n\t\tpass\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tpass\n\n\t@staticmethod\n\tdef size():\n\t\treturn 0\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "SendPhysicalRecoverTimeDown", "data": "class SendPhysicalRecoverTimeDown(object):\n\t_module = 8\n\t_action = 24\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.timestamp = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<q\", self.timestamp))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.timestamp = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 8\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "SendFashionChangeDown", "data": "class SendFashionChangeDown(object):\n\t_module = 8\n\t_action = 25\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.fashion_id = 0\n\t\tself.expire_time = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<h\", self.fashion_id))\n\t\tbuff.extend(struct.pack(\"<q\", self.expire_time))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.fashion_id = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\t\tself.expire_time = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 10\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "TransErrorDown", "data": "class TransErrorDown(object):\n\t_module = 8\n\t_action = 26\n\n\tdef __init__(self):\n\t\tpass\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tpass\n\n\t@staticmethod\n\tdef size():\n\t\treturn 0\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "SendEventCenterChangeDown", "data": "class SendEventCenterChangeDown(object):\n\t_module = 8\n\t_action = 27\n\n\tdef __init__(self):\n\t\tpass\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tpass\n\n\t@staticmethod\n\tdef size():\n\t\treturn 0\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "MeditationStateDown", "data": "class MeditationStateDown(object):\n\t_module = 8\n\t_action = 29\n\n\tdef __init__(self):\n\t\tpass\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tpass\n\n\t@staticmethod\n\tdef size():\n\t\treturn 0\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "DeleteAnnouncementDown", "data": "class DeleteAnnouncementDown(object):\n\t_module = 8\n\t_action = 31\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.id = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<q\", self.id))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.id = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 8\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "SendHaveNewPetDown", "data": "class SendHaveNewPetDown(object):\n\t_module = 8\n\t_action = 32\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.pet_id = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<l\", self.pet_id))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.pet_id = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 4\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "SendLogoutDown", "data": "class SendLogoutDown(object):\n\t_module = 8\n\t_action = 33\n\n\tdef __init__(self):\n\t\tpass\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tpass\n\n\t@staticmethod\n\tdef size():\n\t\treturn 0\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "FameChangeDown", "data": "class FameChangeDown(object):\n\t_module = 8\n\t_action = 34\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.fame = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<l\", self.fame))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.fame = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 4\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "NotifyMonthCardOpenDown", "data": "class NotifyMonthCardOpenDown(object):\n\t_module = 8\n\t_action = 36\n\n\tdef __init__(self):\n\t\tpass\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tpass\n\n\t@staticmethod\n\tdef size():\n\t\treturn 0\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "NotifyMonthCardRenewalDown", "data": "class NotifyMonthCardRenewalDown(object):\n\t_module = 8\n\t_action = 37\n\n\tdef __init__(self):\n\t\tpass\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tpass\n\n\t@staticmethod\n\tdef size():\n\t\treturn 0\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "NotifyNewTotemDown", "data": "class NotifyNewTotemDown(object):\n\t_module = 8\n\t_action = 38\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.id = 0\n\t\tself.totem_id = 0\n\t\tself.skill = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<q\", self.id))\n\t\tbuff.extend(struct.pack(\"<h\", self.totem_id))\n\t\tbuff.extend(struct.pack(\"<h\", self.skill))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.id = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\t\tself.totem_id = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\t\tself.skill = struct.unpack_from(\"<h\", raw_msg, idx)[0]\n\t\tidx += 2\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 12\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "NotifyRuneChangeDown", "data": "class NotifyRuneChangeDown(object):\n\t_module = 8\n\t_action = 39\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.rock_rune_num = 0\n\t\tself.jade_rune_num = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<l\", self.rock_rune_num))\n\t\tbuff.extend(struct.pack(\"<l\", self.jade_rune_num))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.rock_rune_num = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\t\tself.jade_rune_num = struct.unpack_from(\"<l\", raw_msg, idx)[0]\n\t\tidx += 4\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 8\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "NotifyMonthCardChangeDown", "data": "class NotifyMonthCardChangeDown(object):\n\t_module = 8\n\t_action = 40\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.expire_at = 0\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<q\", self.expire_at))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.expire_at = struct.unpack_from(\"<q\", raw_msg, idx)[0]\n\t\tidx += 8\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 8\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "NotifyFirstRechargeStateDown", "data": "class NotifyFirstRechargeStateDown(object):\n\t_module = 8\n\t_action = 41\n\n\tdef __init__(self):\n\t\tpass\n\t\tself.never_recharge = False\n\n\tdef encode(self):\n\t\tbuff = bytearray()\n\t\tbuff.extend(struct.pack('<B', self._module))\n\t\tbuff.extend(struct.pack('<B', self._action))\n\t\tbuff.extend(struct.pack(\"<?\", self.never_recharge))\n\t\treturn buff\n\n\tdef decode(self, raw_msg):\n\t\tidx = 0\n\n\t\tself.never_recharge = struct.unpack_from(\"<?\", raw_msg, idx)[0]\n\t\tidx += 1\n\n\n\t@staticmethod\n\tdef size():\n\t\treturn 1\n\t\t\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}, {"term": "class", "name": "NotifyModule", "data": "class NotifyModule(interface.BaseModule):\n\tdecoder_map = {\n\t\t0: PlayerKeyChangedDown, \n\t\t1: MissionLevelLockChangedDown, \n\t\t2: RoleExpChangeDown, \n\t\t3: PhysicalChangeDown, \n\t\t4: MoneyChangeDown, \n\t\t5: SkillAddDown, \n\t\t6: ItemChangeDown, \n\t\t7: RoleBattleStatusChangeDown, \n\t\t8: NewMailDown, \n\t\t9: HeartChangeDown, \n\t\t10: QuestChangeDown, \n\t\t11: TownLockChangeDown, \n\t\t12: ChatDown, \n\t\t13: FuncKeyChangeDown, \n\t\t14: ItemRecastStateRebuildDown, \n\t\t15: SendAnnouncementDown, \n\t\t16: VipLevelChangeDown, \n\t\t17: NotifyNewBuddyDown, \n\t\t18: HardLevelLockChangedDown, \n\t\t19: SendSwordSoulDrawNumChangeDown, \n\t\t21: SendHaveNewGhostDown, \n\t\t22: SendHeartRecoverTimeDown, \n\t\t23: SendGlobalMailDown, \n\t\t24: SendPhysicalRecoverTimeDown, \n\t\t25: SendFashionChangeDown, \n\t\t26: TransErrorDown, \n\t\t27: SendEventCenterChangeDown, \n\t\t29: MeditationStateDown, \n\t\t31: DeleteAnnouncementDown, \n\t\t32: SendHaveNewPetDown, \n\t\t33: SendLogoutDown, \n\t\t34: FameChangeDown, \n\t\t36: NotifyMonthCardOpenDown, \n\t\t37: NotifyMonthCardRenewalDown, \n\t\t38: NotifyNewTotemDown, \n\t\t39: NotifyRuneChangeDown, \n\t\t40: NotifyMonthCardChangeDown, \n\t\t41: NotifyFirstRechargeStateDown, \n\t}\n\treceive_callback = {}\n\n\tdef decode(self, message):\n\t\taction = ord(message[0])\n\t\tdecoder_maker = self.decoder_map[action]\n\t\tmsg = decoder_maker()\n\t\tmsg.decode(message[1:])\n\t\treturn msg\n\n\tdef add_callback(self, action, callback):\n\t\tif self.receive_callback.has_key(action):\n\t\t\tself.receive_callback[action].append(callback)\n\t\telse:\n\t\t\tself.receive_callback[action] = [callback,]\n\n\tdef clear_callback(self):\n\t\tself.receive_callback = {}\n\n\tdef add_player_key_changed(self, callback):\n\t\tself.add_callback(0, callback)\n\n\tdef add_mission_level_lock_changed(self, callback):\n\t\tself.add_callback(1, callback)\n\n\tdef add_role_exp_change(self, callback):\n\t\tself.add_callback(2, callback)\n\n\tdef add_physical_change(self, callback):\n\t\tself.add_callback(3, callback)\n\n\tdef add_money_change(self, callback):\n\t\tself.add_callback(4, callback)\n\n\tdef add_skill_add(self, callback):\n\t\tself.add_callback(5, callback)\n\n\tdef add_item_change(self, callback):\n\t\tself.add_callback(6, callback)\n\n\tdef add_role_battle_status_change(self, callback):\n\t\tself.add_callback(7, callback)\n\n\tdef add_new_mail(self, callback):\n\t\tself.add_callback(8, callback)\n\n\tdef add_heart_change(self, callback):\n\t\tself.add_callback(9, callback)\n\n\tdef add_quest_change(self, callback):\n\t\tself.add_callback(10, callback)\n\n\tdef add_townLock_change(self, callback):\n\t\tself.add_callback(11, callback)\n\n\tdef add_chat(self, callback):\n\t\tself.add_callback(12, callback)\n\n\tdef add_func_key_change(self, callback):\n\t\tself.add_callback(13, callback)\n\n\tdef add_item_recast_state_rebuild(self, callback):\n\t\tself.add_callback(14, callback)\n\n\tdef add_send_announcement(self, callback):\n\t\tself.add_callback(15, callback)\n\n\tdef add_vip_level_change(self, callback):\n\t\tself.add_callback(16, callback)\n\n\tdef add_notify_new_buddy(self, callback):\n\t\tself.add_callback(17, callback)\n\n\tdef add_hard_level_lock_changed(self, callback):\n\t\tself.add_callback(18, callback)\n\n\tdef add_send_sword_soul_draw_num_change(self, callback):\n\t\tself.add_callback(19, callback)\n\n\tdef add_send_have_new_ghost(self, callback):\n\t\tself.add_callback(21, callback)\n\n\tdef add_send_heart_recover_time(self, callback):\n\t\tself.add_callback(22, callback)\n\n\tdef add_send_global_mail(self, callback):\n\t\tself.add_callback(23, callback)\n\n\tdef add_send_physical_recover_time(self, callback):\n\t\tself.add_callback(24, callback)\n\n\tdef add_send_fashion_change(self, callback):\n\t\tself.add_callback(25, callback)\n\n\tdef add_trans_error(self, callback):\n\t\tself.add_callback(26, callback)\n\n\tdef add_send_event_center_change(self, callback):\n\t\tself.add_callback(27, callback)\n\n\tdef add_meditation_state(self, callback):\n\t\tself.add_callback(29, callback)\n\n\tdef add_delete_announcement(self, callback):\n\t\tself.add_callback(31, callback)\n\n\tdef add_send_have_new_pet(self, callback):\n\t\tself.add_callback(32, callback)\n\n\tdef add_send_logout(self, callback):\n\t\tself.add_callback(33, callback)\n\n\tdef add_fame_change(self, callback):\n\t\tself.add_callback(34, callback)\n\n\tdef add_notify_month_card_open(self, callback):\n\t\tself.add_callback(36, callback)\n\n\tdef add_notify_month_card_renewal(self, callback):\n\t\tself.add_callback(37, callback)\n\n\tdef add_notify_new_totem(self, callback):\n\t\tself.add_callback(38, callback)\n\n\tdef add_notify_rune_change(self, callback):\n\t\tself.add_callback(39, callback)\n\n\tdef add_notify_month_card_change(self, callback):\n\t\tself.add_callback(40, callback)\n\n\tdef add_notify_first_recharge_state(self, callback):\n", "description": null, "category": "def", "imports": ["import struct", "import interface"]}], [{"term": "def", "name": "symtable", "data": "def symtable(code, filename, compile_type):\n\ttop = _symtable.symtable(code, filename, compile_type)\n\treturn _newSymbolTable(top, filename)\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_NONLOCAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "classSymbolTableFactory:", "data": "class SymbolTableFactory:\n\tdef __init__(self):\n\t\tself.__memo = weakref.WeakValueDictionary()\n\n\tdef new(self, table, filename):\n\t\tif table.type == _symtable.TYPE_FUNCTION:\n\t\t\treturn Function(table, filename)\n\t\tif table.type == _symtable.TYPE_CLASS:\n\t\t\treturn Class(table, filename)\n\t\treturn SymbolTable(table, filename)\n\n\tdef __call__(self, table, filename):\n\t\tkey = table, filename\n\t\tobj = self.__memo.get(key, None)\n\t\tif obj is None:\n\t\t\tobj = self.__memo[key] = self.new(table, filename)\n\t\treturn obj\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_NONLOCAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "SymbolTable", "data": "class SymbolTable(object):\n\n\tdef __init__(self, raw_table, filename):\n\t\tself._table = raw_table\n\t\tself._filename = filename\n\t\tself._symbols = {}\n\n\tdef __repr__(self):\n\t\tif self.__class__ == SymbolTable:\n\t\t\tkind = \"\"\n\t\telse:\n\t\t\tkind = \"%s \" % self.__class__.__name__\n\n\t\tif self._table.name == \"global\":\n\t\t\treturn \"<{0}SymbolTable for module {1}>\".format(kind, self._filename)\n\t\telse:\n\t\t\treturn \"<{0}SymbolTable for {1} in {2}>\".format(kind,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself._table.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself._filename)\n\n\tdef get_type(self):\n\t\tif self._table.type == _symtable.TYPE_MODULE:\n\t\t\treturn \"module\"\n\t\tif self._table.type == _symtable.TYPE_FUNCTION:\n\t\t\treturn \"function\"\n\t\tif self._table.type == _symtable.TYPE_CLASS:\n\t\t\treturn \"class\"\n\t\tassert self._table.type in (1, 2, 3), \\\n\t\t\t   \"unexpected type: {0}\".format(self._table.type)\n\n\tdef get_id(self):\n\t\treturn self._table.id\n\n\tdef get_name(self):\n\t\treturn self._table.name\n\n\tdef get_lineno(self):\n\t\treturn self._table.lineno\n\n\tdef is_optimized(self):\n\t\treturn bool(self._table.type == _symtable.TYPE_FUNCTION)\n\n\tdef is_nested(self):\n\t\treturn bool(self._table.nested)\n\n\tdef has_children(self):\n\t\treturn bool(self._table.children)\n\n\tdef has_exec(self):\n\t\t\"\"\"Return true if the scope uses exec.  Deprecated method.\"\"\"\n\t\treturn False\n\n\tdef get_identifiers(self):\n\t\treturn self._table.symbols.keys()\n\n\tdef lookup(self, name):\n\t\tsym = self._symbols.get(name)\n\t\tif sym is None:\n\t\t\tflags = self._table.symbols[name]\n\t\t\tnamespaces = self.__check_children(name)\n\t\t\tsym = self._symbols[name] = Symbol(name, flags, namespaces)\n\t\treturn sym\n\n\tdef get_symbols(self):\n\t\treturn [self.lookup(ident) for ident in self.get_identifiers()]\n\n\tdef __check_children(self, name):\n\t\treturn [_newSymbolTable(st, self._filename)\n\t\t\t\tfor st in self._table.children\n\t\t\t\tif st.name == name]\n\n\tdef get_children(self):\n\t\treturn [_newSymbolTable(st, self._filename)\n\t\t\t\tfor st in self._table.children]\n\n", "description": "Return true if the scope uses exec.  Deprecated method.", "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_NONLOCAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "Function", "data": "class Function(SymbolTable):\n\n\t# Default values for instance variables\n\t__params = None\n\t__locals = None\n\t__frees = None\n\t__globals = None\n\t__nonlocals = None\n\n\tdef __idents_matching(self, test_func):\n\t\treturn tuple(ident for ident in self.get_identifiers()\n\t\t\t\t\t if test_func(self._table.symbols[ident]))\n\n\tdef get_parameters(self):\n\t\tif self.__params is None:\n\t\t\tself.__params = self.__idents_matching(lambda x:x & DEF_PARAM)\n\t\treturn self.__params\n\n\tdef get_locals(self):\n\t\tif self.__locals is None:\n\t\t\tlocs = (LOCAL, CELL)\n\t\t\ttest = lambda x: ((x >> SCOPE_OFF) & SCOPE_MASK) in locs\n\t\t\tself.__locals = self.__idents_matching(test)\n\t\treturn self.__locals\n\n\tdef get_globals(self):\n\t\tif self.__globals is None:\n\t\t\tglob = (GLOBAL_IMPLICIT, GLOBAL_EXPLICIT)\n\t\t\ttest = lambda x:((x >> SCOPE_OFF) & SCOPE_MASK) in glob\n\t\t\tself.__globals = self.__idents_matching(test)\n\t\treturn self.__globals\n\n\tdef get_nonlocals(self):\n\t\tif self.__nonlocals is None:\n\t\t\tself.__nonlocals = self.__idents_matching(lambda x:x & DEF_NONLOCAL)\n\t\treturn self.__nonlocals\n\n\tdef get_frees(self):\n\t\tif self.__frees is None:\n\t\t\tis_free = lambda x:((x >> SCOPE_OFF) & SCOPE_MASK) == FREE\n\t\t\tself.__frees = self.__idents_matching(is_free)\n\t\treturn self.__frees\n\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_NONLOCAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "Class", "data": "class Class(SymbolTable):\n\n\t__methods = None\n\n\tdef get_methods(self):\n\t\tif self.__methods is None:\n\t\t\td = {}\n\t\t\tfor st in self._table.children:\n\t\t\t\td[st.name] = 1\n\t\t\tself.__methods = tuple(d)\n\t\treturn self.__methods\n\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_NONLOCAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "Symbol", "data": "class Symbol(object):\n\n\tdef __init__(self, name, flags, namespaces=None):\n\t\tself.__name = name\n\t\tself.__flags = flags\n\t\tself.__scope = (flags >> SCOPE_OFF) & SCOPE_MASK # like PyST_GetScope()\n\t\tself.__namespaces = namespaces or ()\n\n\tdef __repr__(self):\n\t\treturn \"<symbol {0!r}>\".format(self.__name)\n\n\tdef get_name(self):\n\t\treturn self.__name\n\n\tdef is_referenced(self):\n\t\treturn bool(self.__flags & _symtable.USE)\n\n\tdef is_parameter(self):\n\t\treturn bool(self.__flags & DEF_PARAM)\n\n\tdef is_global(self):\n\t\treturn bool(self.__scope in (GLOBAL_IMPLICIT, GLOBAL_EXPLICIT))\n\n\tdef is_nonlocal(self):\n\t\treturn bool(self.__flags & DEF_NONLOCAL)\n\n\tdef is_declared_global(self):\n\t\treturn bool(self.__scope == GLOBAL_EXPLICIT)\n\n\tdef is_local(self):\n\t\treturn bool(self.__flags & DEF_BOUND)\n\n\tdef is_annotated(self):\n\t\treturn bool(self.__flags & DEF_ANNOT)\n\n\tdef is_free(self):\n\t\treturn bool(self.__scope == FREE)\n\n\tdef is_imported(self):\n\t\treturn bool(self.__flags & DEF_IMPORT)\n\n\tdef is_assigned(self):\n\t\treturn bool(self.__flags & DEF_LOCAL)\n\n\tdef is_namespace(self):\n\t\t\"\"\"Returns true if name binding introduces new namespace.\n\n\t\tIf the name is used as the target of a function or class\n\t\tstatement, this will be true.\n\n\t\tNote that a single name can be bound to multiple objects.  If\n\t\tis_namespace() is true, the name may also be bound to other\n\t\tobjects, like an int or list, that does not introduce a new\n\t\tnamespace.\n\t\t\"\"\"\n\t\treturn bool(self.__namespaces)\n\n\tdef get_namespaces(self):\n\t\t\"\"\"Return a list of namespaces bound to this name\"\"\"\n\t\treturn self.__namespaces\n\n\tdef get_namespace(self):\n\t\t\"\"\"Returns the single namespace bound to this name.\n\n\t\tRaises ValueError if the name is bound to multiple namespaces.\n\t\t\"\"\"\n\t\tif len(self.__namespaces) != 1:\n\t\t\traise ValueError(\"name is bound to multiple namespaces\")\n\t\treturn self.__namespaces[0]\n", "description": "Returns true if name binding introduces new namespace.\n\n\t\tIf the name is used as the target of a function or class\n\t\tstatement, this will be true.\n\n\t\tNote that a single name can be bound to multiple objects.  If\n\t\tis_namespace() is true, the name may also be bound to other\n\t\tobjects, like an int or list, that does not introduce a new\n\t\tnamespace.\n\t\t", "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_NONLOCAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}], [{"term": "def", "name": "pt", "data": "def pt(p, t, pid):\n\tf = prototype((\"seupt\", flib),)\n\tresult = f(p, t, pid)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "pt2h", "data": "def pt2h(p, t):\n\tf = prototype((\"seupt\", flib),)\n\tresult = f(p, t, 4)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "pt2s", "data": "def pt2s(p, t):\n\tf = prototype((\"seupt\", flib),)\n\tresult = f(p, t, 5)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "pt2v", "data": "def pt2v(p, t):\n\tf = prototype((\"seupt\", flib),)\n\tresult = f(p, t, 3)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "pt2x", "data": "def pt2x(p, t):\n\tf = prototype((\"seupt\", flib),)\n\tresult = f(p, t, 15)\n\treturn result\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ph", "data": "def ph(p, h, pid):\n\tf = prototype((\"seuph\", flib),)\n\tresult = f(p, h, pid)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ph2s", "data": "def ph2s(p, h):\n\tf = prototype((\"seuph\", flib),)\n\tresult = f(p, h, 5)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ph2v", "data": "def ph2v(p, h):\n\tf = prototype((\"seuph\", flib),)\n\tresult = f(p, h, 3)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ph2t", "data": "def ph2t(p, h):\n\tf = prototype((\"seuph\", flib),)\n\tresult = f(p, h, 1)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ph2x", "data": "def ph2x(p, h):\n\tf = prototype((\"seuph\", flib),)\n\tresult = f(p, h, 15)\n\treturn result\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ps", "data": "def ps(p, s, pid):\n\tf = prototype((\"seups\", flib),)\n\tresult = f(p, s, pid)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ps2t", "data": "def ps2t(p, s):\n\tf = prototype((\"seups\", flib),)\n\tresult = f(p, s, 1)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ps2h", "data": "def ps2h(p, s):\n\tf = prototype((\"seups\", flib),)\n\tresult = f(p, s, 4)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ps2v", "data": "def ps2v(p, s):\n\tf = prototype((\"seups\", flib),)\n\tresult = f(p, s, 3)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ps2x", "data": "def ps2x(p, s):\n\tf = prototype((\"seups\", flib),)\n\tresult = f(p, s, 15)\n\treturn result\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "hs", "data": "def hs(h, s, pid):\n\tf = prototype((\"seuhs\", flib),)\n\tresult = f(h, s, pid)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "hs2t", "data": "def hs2t(h, s):\n\tf = prototype((\"seuhs\", flib),)\n\tresult = f(h, s, 1)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "hs2p", "data": "def hs2p(h, s):\n\tf = prototype((\"seuhs\", flib),)\n\tresult = f(h, s, 0)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "hs2v", "data": "def hs2v(h, s):\n\tf = prototype((\"seuhs\", flib),)\n\tresult = f(h, s, 3)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "hs2x", "data": "def hs2x(h, s):\n\tf = prototype((\"seuhs\", flib),)\n\tresult = f(h, s, 15)\n\treturn result\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ts", "data": "def ts(t, s, pid):\n\tf = prototype((\"seuts\", flib),)\n\tresult = f(t, s, pid)\n\treturn resul\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ts2p", "data": "def ts2p(t, s):\n\tf = prototype((\"seuts\", flib),)\n\tresult = f(t, s, 0)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ts2v", "data": "def ts2v(t, s):\n\tf = prototype((\"seuts\", flib),)\n\tresult = f(t, s, 3)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ts2h", "data": "def ts2h(t, s):\n\tf = prototype((\"seuts\", flib),)\n\tresult = f(t, s, 4)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ts2x", "data": "def ts2x(t, s):\n\tf = prototype((\"seuts\", flib),)\n\tresult = f(t, s, 15)\n\treturn result\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "px", "data": "def px(p, x, pid):\n\tf = prototype((\"seupx\", flib),)\n\tresult = f(p, x, pid)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "px2t", "data": "def px2t(p, x):\n\tf = prototype((\"seupx\", flib),)\n\tresult = f(p, x, 1)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "px2h", "data": "def px2h(p, x):\n\tf = prototype((\"seupx\", flib),)\n\tresult = f(p, x, 4)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "px2s", "data": "def px2s(p, x):\n\tf = prototype((\"seupx\", flib),)\n\tresult = f(p, x, 5)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "px2v", "data": "def px2v(p, x):\n\tf = prototype((\"seupx\", flib),)\n\tresult = f(p, x, 3)\n\treturn result\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "tx", "data": "def tx(t, x, pid):\n\tf = prototype((\"seutx\", flib),)\n\tresult = f(t, x, pid)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "tx2p", "data": "def tx2p(t, x):\n\tf = prototype((\"seutx\", flib),)\n\tresult = f(t, x, 0)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "tx2v", "data": "def tx2v(t, x):\n\tf = prototype((\"seutx\", flib),)\n\tresult = f(t, x, 3)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "tx2h", "data": "def tx2h(t, x):\n\tf = prototype((\"seutx\", flib),)\n\tresult = f(t, x, 4)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "tx2s", "data": "def tx2s(t, x):\n\tf = prototype((\"seutx\", flib),)\n\tresult = f(t, x, 5)\n\treturn result\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ishd", "data": "def ishd(p1, t1, p2):\n\tf = flib.seuishd\n\tf.argtypes = [c_double, c_double, c_double]\n\tf.restype = c_double\n\tresult = f(p1, t1, p2)\n\treturn result\n\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}, {"term": "def", "name": "ief", "data": "def ief(p1, t1, p2, t2):\n\tf = flib.seuief\n\tf.argtypes = [c_double, c_double, c_double, c_double]\n\tf.restype = c_double\n\tresult = f(p1, t1, p2, t2)\n", "description": null, "category": "def", "imports": ["from ctypes import *", "from platform import *"]}], [{"term": "class", "name": "C_NAType", "data": "class C_NAType(_mod_builtins.object):\n\t__class__ = C_NAType\n\tdef __init__(self, *args, **kwargs):\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __setstate__(self, state):\n\t\treturn None\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "class", "name": "NAType", "data": "class NAType(C_NAType):\n\t'\\n\tNA (\"not available\") missing value indicator.\\n\\n\t.. warning::\\n\\n\t   Experimental: the behaviour of NA can still change without warning.\\n\\n\t.. versionadded:: 1.0.0\\n\\n\tThe NA singleton is a missing value indicator defined by pandas. It is\\n\tused in certain new extension dtypes (currently the \"string\" dtype).\\n\t'\n\t_HANDLED_TYPES = _mod_builtins.tuple()\n\tdef __abs__(self):\n\t\treturn NAType()\n\t\n\tdef __add__(self, other):\n\t\treturn NAType()\n\t\n\tdef __and__(self, other):\n\t\treturn NAType()\n\t\n\t__array_priority__ = 1000\n\tdef __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n\t\tpass\n\t\n\tdef __bool__(self):\n\t\treturn False\n\t\n\t__class__ = NAType\n\t__dict__ = {}\n\tdef __divmod__(self, other):\n\t\treturn (0, 0)\n\t\n\tdef __eq__(self, other):\n\t\treturn False\n\t\n\tdef __floordiv__(self, other):\n\t\treturn 0\n\t\n\tdef __ge__(self, other):\n\t\treturn False\n\t\n\tdef __gt__(self, other):\n\t\treturn False\n\t\n\tdef __hash__(self):\n\t\treturn 0\n\t\n\tdef __init__(self, *args, **kwargs):\n\t\t'\\n\tNA (\"not available\") missing value indicator.\\n\\n\t.. warning::\\n\\n\t   Experimental: the behaviour of NA can still change without warning.\\n\\n\t.. versionadded:: 1.0.0\\n\\n\tThe NA singleton is a missing value indicator defined by pandas. It is\\n\tused in certain new extension dtypes (currently the \"string\" dtype).\\n\t'\n\t\tpass\n\t\n\t@classmethod\n\tdef __init_subclass__(cls):\n\t\t'This method is called when a class is subclassed.\\n\\nThe default implementation does nothing. It may be\\noverridden to extend subclasses.\\n'\n\t\treturn None\n\t\n\tdef __invert__(self):\n\t\treturn NAType()\n\t\n\tdef __le__(self, other):\n\t\treturn False\n\t\n\tdef __lt__(self, other):\n\t\treturn False\n\t\n\tdef __matmul__(self, other):\n\t\tpass\n\t\n\tdef __mod__(self, other):\n\t\treturn NAType()\n\t\n\tdef __mul__(self, other):\n\t\treturn NAType()\n\t\n\tdef __ne__(self, other):\n\t\treturn False\n\t\n\tdef __neg__(self):\n\t\treturn NAType()\n\t\n\tdef __or__(self, other):\n\t\treturn NAType()\n\t\n\tdef __pos__(self):\n\t\treturn NAType()\n\t\n\tdef __pow__(self, other):\n\t\treturn NAType()\n\t\n\tdef __radd__(self, other):\n\t\treturn NAType()\n\t\n\tdef __rand__(self, other):\n\t\treturn NAType()\n\t\n\tdef __rdivmod__(self, other):\n\t\treturn (0, 0)\n\t\n\tdef __reduce__(self):\n\t\treturn ''; return ()\n\t\n\tdef __repr__(self):\n\t\treturn 'unicode'\n\t\n\tdef __rfloordiv__(self, other):\n\t\treturn NAType()\n\t\n\tdef __rmatmul__(self, other):\n\t\tpass\n\t\n\tdef __rmod__(self, other):\n\t\treturn NAType()\n\t\n\tdef __rmul__(self, other):\n\t\treturn NAType()\n\t\n\tdef __ror__(self, other):\n\t\treturn NAType()\n\t\n\tdef __rpow__(self, other):\n\t\treturn NAType()\n\t\n\tdef __rsub__(self, other):\n\t\treturn NAType()\n\t\n\tdef __rtruediv__(self, other):\n\t\treturn NAType()\n\t\n\tdef __rxor__(self, other):\n\t\treturn NAType()\n\t\n\tdef __sub__(self, other):\n\t\treturn NAType()\n\t\n\t@classmethod\n\tdef __subclasshook__(cls, subclass):\n\t\t'Abstract classes can override this to customize issubclass().\\n\\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\\nIt should return True, False or NotImplemented.  If it returns\\nNotImplemented, the normal algorithm is used.  Otherwise, it\\noverrides the normal algorithm (and the outcome is cached).\\n'\n\t\treturn False\n\t\n\tdef __truediv__(self, other):\n\t\treturn 0.0\n\t\n\t@property\n\tdef __weakref__(self):\n\t\t'list of weak references to the object (if defined)'\n\t\tpass\n\t\n\tdef __xor__(self, other):\n\t\treturn NAType()\n\t\n\t_instance = NAType()\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "__pyx_unpickle_C_NAType", "data": "def __pyx_unpickle_C_NAType():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "_create_binary_propagating_op", "data": "def _create_binary_propagating_op():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "_create_unary_propagating_op", "data": "def _create_unary_propagating_op():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "checknull", "data": "def checknull():\n\t'\\n\tReturn boolean describing of the input is NA-like, defined here as any\\n\tof:\\n\t - None\\n\t - nan\\n\t - NaT\\n\t - np.datetime64 representation of NaT\\n\t - np.timedelta64 representation of NaT\\n\\n\tParameters\\n\t----------\\n\tval : object\\n\\n\tReturns\\n\t-------\\n\tresult : bool\\n\\n\tNotes\\n\t-----\\n\tThe difference between `checknull` and `checknull_old` is that `checknull`\\n\tdoes *not* consider INF or NEGINF to be NA.\\n\t'\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "checknull_old", "data": "def checknull_old():\n\t'\\n\tReturn boolean describing of the input is NA-like, defined here as any\\n\tof:\\n\t - None\\n\t - nan\\n\t - INF\\n\t - NEGINF\\n\t - NaT\\n\t - np.datetime64 representation of NaT\\n\t - np.timedelta64 representation of NaT\\n\\n\tParameters\\n\t----------\\n\tval : object\\n\\n\tReturns\\n\t-------\\n\tresult : bool\\n\\n\tNotes\\n\t-----\\n\tThe difference between `checknull` and `checknull_old` is that `checknull`\\n\tdoes *not* consider INF or NEGINF to be NA.\\n\t'\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "is_platform_32bit", "data": "def is_platform_32bit():\n\t'\\n\tChecking if the running platform is 32-bit.\\n\\n\tReturns\\n\t-------\\n\tbool\\n\t\tTrue if the running platform is 32-bit.\\n\t'\n\treturn bool\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "isnaobj", "data": "def isnaobj():\n\t'\\n\tReturn boolean mask denoting which elements of a 1-D array are na-like,\\n\taccording to the criteria defined in `checknull`:\\n\t - None\\n\t - nan\\n\t - NaT\\n\t - np.datetime64 representation of NaT\\n\t - np.timedelta64 representation of NaT\\n\\n\tParameters\\n\t----------\\n\tarr : ndarray\\n\\n\tReturns\\n\t-------\\n\tresult : ndarray (dtype=np.bool_)\\n\t'\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "isnaobj2d", "data": "def isnaobj2d():\n\t'\\n\tReturn boolean mask denoting which elements of a 2-D array are na-like,\\n\taccording to the criteria defined in `checknull`:\\n\t - None\\n\t - nan\\n\t - NaT\\n\t - np.datetime64 representation of NaT\\n\t - np.timedelta64 representation of NaT\\n\\n\tParameters\\n\t----------\\n\tarr : ndarray\\n\\n\tReturns\\n\t-------\\n\tresult : ndarray (dtype=np.bool_)\\n\\n\tNotes\\n\t-----\\n\tThe difference between `isnaobj2d` and `isnaobj2d_old` is that `isnaobj2d`\\n\tdoes *not* consider INF or NEGINF to be NA.\\n\t'\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "isnaobj2d_old", "data": "def isnaobj2d_old():\n\t'\\n\tReturn boolean mask denoting which elements of a 2-D array are na-like,\\n\taccording to the criteria defined in `checknull_old`:\\n\t - None\\n\t - nan\\n\t - INF\\n\t - NEGINF\\n\t - NaT\\n\t - np.datetime64 representation of NaT\\n\t - np.timedelta64 representation of NaT\\n\\n\tParameters\\n\t----------\\n\tarr : ndarray\\n\\n\tReturns\\n\t-------\\n\tresult : ndarray (dtype=np.bool_)\\n\\n\tNotes\\n\t-----\\n\tThe difference between `isnaobj2d` and `isnaobj2d_old` is that `isnaobj2d`\\n\tdoes *not* consider INF or NEGINF to be NA.\\n\t'\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "isnaobj_old", "data": "def isnaobj_old():\n\t'\\n\tReturn boolean mask denoting which elements of a 1-D array are na-like,\\n\tdefined as being any of:\\n\t - None\\n\t - nan\\n\t - INF\\n\t - NEGINF\\n\t - NaT\\n\\n\tParameters\\n\t----------\\n\tarr : ndarray\\n\\n\tReturns\\n\t-------\\n\tresult : ndarray (dtype=np.bool_)\\n\t'\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "isneginf_scalar", "data": "def isneginf_scalar():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "isposinf_scalar", "data": "def isposinf_scalar():\n\tpass\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}, {"term": "def", "name": "maybe_dispatch_ufunc_to_dunder_op", "data": "def maybe_dispatch_ufunc_to_dunder_op():\n\t\"\\n\tDispatch a ufunc to the equivalent dunder method.\\n\\n\tParameters\\n\t----------\\n\tself : ArrayLike\\n\t\tThe array whose dunder method we dispatch to\\n\tufunc : Callable\\n\t\tA NumPy ufunc\\n\tmethod : {'reduce', 'accumulate', 'reduceat', 'outer', 'at', '__call__'}\\n\tinputs : ArrayLike\\n\t\tThe input arrays.\\n\tkwargs : Any\\n\t\tThe additional keyword arguments, e.g. ``out``.\\n\\n\tReturns\\n\t-------\\n\tresult : Any\\n\t\tThe result of applying the ufunc\\n\t\"\n", "description": null, "category": "def", "imports": ["import builtins as _mod_builtins"]}], [{"term": "class", "name": "TestRectangle_instantiation", "data": "class TestRectangle_instantiation(unittest.TestCase):\n\t\"\"\"Unittests for testing instantiation of the Rectangle class.\"\"\"\n\n\tdef test_rectangle_is_base(self):\n\t\tself.assertIsInstance(Rectangle(10, 2), Base)\n\n\tdef test_no_args(self):\n\t\twith self.assertRaises(TypeError):\n\t\t\tRectangle()\n\n\tdef test_one_arg(self):\n\t\twith self.assertRaises(TypeError):\n\t\t\tRectangle(1)\n\n\tdef test_two_args(self):\n\t\tr1 = Rectangle(10, 2)\n\t\tr2 = Rectangle(2, 10)\n\t\tself.assertEqual(r1.id, r2.id - 1)\n\n\tdef test_three_args(self):\n\t\tr1 = Rectangle(2, 2, 4)\n\t\tr2 = Rectangle(4, 4, 2)\n\t\tself.assertEqual(r1.id, r2.id - 1)\n\n\tdef test_four_args(self):\n\t\tr1 = Rectangle(1, 2, 3, 4)\n\t\tr2 = Rectangle(4, 3, 2, 1)\n\t\tself.assertEqual(r1.id, r2.id - 1)\n\n\tdef test_five_args(self):\n\t\tself.assertEqual(7, Rectangle(10, 2, 0, 0, 7).id)\n\n\tdef test_more_than_five_args(self):\n\t\twith self.assertRaises(TypeError):\n\t\t\tRectangle(1, 2, 3, 4, 5, 6)\n\n\tdef test_width_private(self):\n\t\twith self.assertRaises(AttributeError):\n\t\t\tprint(Rectangle(5, 5, 0, 0, 1).__width)\n\n\tdef test_height_private(self):\n\t\twith self.assertRaises(AttributeError):\n\t\t\tprint(Rectangle(5, 5, 0, 0, 1).__height)\n\n\tdef test_x_private(self):\n\t\twith self.assertRaises(AttributeError):\n\t\t\tprint(Rectangle(5, 5, 0, 0, 1).__x)\n\n\tdef test_y_private(self):\n\t\twith self.assertRaises(AttributeError):\n\t\t\tprint(Rectangle(5, 5, 0, 0, 1).__y)\n\n\tdef test_width_getter(self):\n\t\tr = Rectangle(5, 7, 7, 5, 1)\n\t\tself.assertEqual(5, r.width)\n\n\tdef test_width_setter(self):\n\t\tr = Rectangle(5, 7, 7, 5, 1)\n\t\tr.width = 10\n\t\tself.assertEqual(10, r.width)\n\n\tdef test_height_getter(self):\n\t\tr = Rectangle(5, 7, 7, 5, 1)\n\t\tself.assertEqual(7, r.height)\n\n\tdef test_height_setter(self):\n\t\tr = Rectangle(5, 7, 7, 5, 1)\n\t\tr.height = 10\n\t\tself.assertEqual(10, r.height)\n\n\tdef test_x_getter(self):\n\t\tr = Rectangle(5, 7, 7, 5, 1)\n\t\tself.assertEqual(7, r.x)\n\n\tdef test_x_setter(self):\n\t\tr = Rectangle(5, 7, 7, 5, 1)\n\t\tr.x = 10\n\t\tself.assertEqual(10, r.x)\n\n\tdef test_y_getter(self):\n\t\tr = Rectangle(5, 7, 7, 5, 1)\n\t\tself.assertEqual(5, r.y)\n\n\tdef test_y_setter(self):\n\t\tr = Rectangle(5, 7, 7, 5, 1)\n\t\tr.y = 10\n\t\tself.assertEqual(10, r.y)\n\n", "description": "Unittests for testing instantiation of the Rectangle class.", "category": "def", "imports": ["import io", "import sys", "import unittest", "from models.base import Base", "from models.rectangle import Rectangle"]}, {"term": "class", "name": "TestRectangle_width", "data": "class TestRectangle_width(unittest.TestCase):\n\t\"\"\"Unittests for testing initialization of Rectangle width attribute.\"\"\"\n\n\tdef test_None_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(None, 2)\n\n\tdef test_str_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(\"invalid\", 2)\n\n\tdef test_float_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(5.5, 1)\n\n\tdef test_complex_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(complex(5), 2)\n\n\tdef test_dict_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle({\"a\": 1, \"b\": 2}, 2)\n\n\tdef test_bool_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(True, 2)\n\n\tdef test_list_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle([1, 2, 3], 2)\n\n\tdef test_set_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle({1, 2, 3}, 2)\n\n\tdef test_tuple_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle((1, 2, 3), 2)\n\n\tdef test_frozenset_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(frozenset({1, 2, 3, 1}), 2)\n\n\tdef test_range_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(range(5), 2)\n\n\tdef test_bytes_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(b'Python', 2)\n\n\tdef test_bytearray_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(bytearray(b'abcdefg'), 2)\n\n\tdef test_memoryview_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(memoryview(b'abcedfg'), 2)\n\n\tdef test_inf_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(float('inf'), 2)\n\n\tdef test_nan_width(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(float('nan'), 2)\n\n\tdef test_negative_width(self):\n\t\twith self.assertRaisesRegex(ValueError, \"width must be > 0\"):\n\t\t\tRectangle(-1, 2)\n\n\tdef test_zero_width(self):\n\t\twith self.assertRaisesRegex(ValueError, \"width must be > 0\"):\n\t\t\tRectangle(0, 2)\n\n", "description": "Unittests for testing initialization of Rectangle width attribute.", "category": "def", "imports": ["import io", "import sys", "import unittest", "from models.base import Base", "from models.rectangle import Rectangle"]}, {"term": "class", "name": "TestRectangle_height", "data": "class TestRectangle_height(unittest.TestCase):\n\t\"\"\"Unittests for testing initialization of Rectangle height attribute.\"\"\"\n\n\tdef test_None_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, None)\n\n\tdef test_str_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, \"invalid\")\n\n\tdef test_float_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, 5.5)\n\n\tdef test_complex_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, complex(5))\n\n\tdef test_dict_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, {\"a\": 1, \"b\": 2})\n\n\tdef test_list_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, [1, 2, 3])\n\n\tdef test_set_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, {1, 2, 3})\n\n\tdef test_tuple_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, (1, 2, 3))\n\n\tdef test_frozenset_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, frozenset({1, 2, 3, 1}))\n\n\tdef test_range_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, range(5))\n\n\tdef test_bytes_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, b'Python')\n\n\tdef test_bytearray_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, bytearray(b'abcdefg'))\n\n\tdef test_memoryview_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, memoryview(b'abcedfg'))\n\n\tdef test_inf_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, float('inf'))\n\n\tdef test_nan_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, float('nan'))\n\n\tdef test_negative_height(self):\n\t\twith self.assertRaisesRegex(ValueError, \"height must be > 0\"):\n\t\t\tRectangle(1, -1)\n\n\tdef test_zero_height(self):\n\t\twith self.assertRaisesRegex(ValueError, \"height must be > 0\"):\n\t\t\tRectangle(1, 0)\n\n", "description": "Unittests for testing initialization of Rectangle height attribute.", "category": "def", "imports": ["import io", "import sys", "import unittest", "from models.base import Base", "from models.rectangle import Rectangle"]}, {"term": "class", "name": "TestRectangle_x", "data": "class TestRectangle_x(unittest.TestCase):\n\t\"\"\"Unittests for testing initialization of Rectangle x attribute.\"\"\"\n\n\tdef test_None_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, None)\n\n\tdef test_str_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, \"invalid\", 2)\n\n\tdef test_float_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, 5.5, 9)\n\n\tdef test_complex_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, complex(5))\n\n\tdef test_dict_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, {\"a\": 1, \"b\": 2}, 2)\n\n\tdef test_bool_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, True, 2)\n\n\tdef test_list_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, [1, 2, 3], 2)\n\n\tdef test_set_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, {1, 2, 3}, 2)\n\n\tdef test_tuple_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, (1, 2, 3), 2)\n\n\tdef test_frozenset_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, frozenset({1, 2, 3, 1}))\n\n\tdef test_range_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, range(5))\n\n\tdef test_bytes_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, b'Python')\n\n\tdef test_bytearray_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, bytearray(b'abcdefg'))\n\n\tdef test_memoryview_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, memoryview(b'abcedfg'))\n\n\tdef test_inf_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, float('inf'), 2)\n\n\tdef test_nan_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, float('nan'), 2)\n\n\tdef test_negative_x(self):\n\t\twith self.assertRaisesRegex(ValueError, \"x must be >= 0\"):\n\t\t\tRectangle(5, 3, -1, 0)\n\n", "description": "Unittests for testing initialization of Rectangle x attribute.", "category": "def", "imports": ["import io", "import sys", "import unittest", "from models.base import Base", "from models.rectangle import Rectangle"]}, {"term": "class", "name": "TestRectangle_y", "data": "class TestRectangle_y(unittest.TestCase):\n\t\"\"\"Unittests for testing initialization of Rectangle y attribute.\"\"\"\n\n\tdef test_None_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 3, None)\n\n\tdef test_str_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 1, \"invalid\")\n\n\tdef test_float_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 3, 5.5)\n\n\tdef test_complex_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 3, complex(5))\n\n\tdef test_dict_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 1, {\"a\": 1, \"b\": 2})\n\n\tdef test_list_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 1, [1, 2, 3])\n\n\tdef test_set_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 1, {1, 2, 3})\n\n\tdef test_tuple_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 1, (1, 2, 3))\n\n\tdef test_frozenset_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 3, frozenset({1, 2, 3, 1}))\n\n\tdef test_range_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 3, range(5))\n\n\tdef test_bytes_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 3, b'Python')\n\n\tdef test_bytearray_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 3, bytearray(b'abcdefg'))\n\n\tdef test_memoryview_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 3, memoryview(b'abcedfg'))\n\n\tdef test_inf_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 1, float('inf'))\n\n\tdef test_nan_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tRectangle(1, 2, 1, float('nan'))\n\n\tdef test_negative_y(self):\n\t\twith self.assertRaisesRegex(ValueError, \"y must be >= 0\"):\n\t\t\tRectangle(3, 5, 0, -1)\n\n", "description": "Unittests for testing initialization of Rectangle y attribute.", "category": "def", "imports": ["import io", "import sys", "import unittest", "from models.base import Base", "from models.rectangle import Rectangle"]}, {"term": "class", "name": "TestRectangle_order_of_initialization", "data": "class TestRectangle_order_of_initialization(unittest.TestCase):\n\t\"\"\"Unittests for testing Rectangle order of attribute initialization.\"\"\"\n\n\tdef test_width_before_height(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(\"invalid width\", \"invalid height\")\n\n\tdef test_width_before_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(\"invalid width\", 2, \"invalid x\")\n\n\tdef test_width_before_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tRectangle(\"invalid width\", 2, 3, \"invalid y\")\n\n\tdef test_height_before_x(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, \"invalid height\", \"invalid x\")\n\n\tdef test_height_before_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tRectangle(1, \"invalid height\", 2, \"invalid y\")\n\n\tdef test_x_before_y(self):\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tRectangle(1, 2, \"invalid x\", \"invalid y\")\n\n", "description": "Unittests for testing Rectangle order of attribute initialization.", "category": "def", "imports": ["import io", "import sys", "import unittest", "from models.base import Base", "from models.rectangle import Rectangle"]}, {"term": "class", "name": "TestRectangle_area", "data": "class TestRectangle_area(unittest.TestCase):\n\t\"\"\"Unittests for testing the area method of the Rectangle class.\"\"\"\n\n\tdef test_area_small(self):\n\t\tr = Rectangle(10, 2, 0, 0, 0)\n\t\tself.assertEqual(20, r.area())\n\n\tdef test_area_large(self):\n\t\tr = Rectangle(999999999999999, 999999999999999999, 0, 0, 1)\n\t\tself.assertEqual(999999999999998999000000000000001, r.area())\n\n\tdef test_area_changed_attributes(self):\n\t\tr = Rectangle(2, 10, 1, 1, 1)\n\t\tr.width = 7\n\t\tr.height = 14\n\t\tself.assertEqual(98, r.area())\n\n\tdef test_area_one_arg(self):\n\t\tr = Rectangle(2, 10, 1, 1, 1)\n\t\twith self.assertRaises(TypeError):\n\t\t\tr.area(1)\n\n", "description": "Unittests for testing the area method of the Rectangle class.", "category": "def", "imports": ["import io", "import sys", "import unittest", "from models.base import Base", "from models.rectangle import Rectangle"]}, {"term": "class", "name": "TestRectangle_stdout", "data": "class TestRectangle_stdout(unittest.TestCase):\n\t\"\"\"Unittests for testing __str__ and display methods of Rectangle class.\"\"\"\n\n\t@staticmethod\n\tdef capture_stdout(rect, method):\n\t\t\"\"\"Captures and returns text printed to stdout.\n\n\t\tArgs:\n\t\t\trect (Rectangle): The Rectangle to print to stdout.\n\t\t\tmethod (str): The method to run on rect.\n\t\tReturns:\n\t\t\tThe text printed to stdout by calling method on sq.\n\t\t\"\"\"\n\t\tcapture = io.StringIO()\n\t\tsys.stdout = capture\n\t\tif method == \"print\":\n\t\t\tprint(rect)\n\t\telse:\n\t\t\trect.display()\n\t\tsys.stdout = sys.__stdout__\n\t\treturn capture\n\n\t# Test __str__ method\n\tdef test_str_method_print_width_height(self):\n\t\tr = Rectangle(4, 6)\n\t\tcapture = TestRectangle_stdout.capture_stdout(r, \"print\")\n\t\tcorrect = \"[Rectangle] ({}) 0/0 - 4/6\\n\".format(r.id)\n\t\tself.assertEqual(correct, capture.getvalue())\n\n\tdef test_str_method_width_height_x(self):\n\t\tr = Rectangle(5, 5, 1)\n\t\tcorrect = \"[Rectangle] ({}) 1/0 - 5/5\".format(r.id)\n\t\tself.assertEqual(correct, r.__str__())\n\n\tdef test_str_method_width_height_x_y(self):\n\t\tr = Rectangle(1, 8, 2, 4)\n\t\tcorrect = \"[Rectangle] ({}) 2/4 - 1/8\".format(r.id)\n\t\tself.assertEqual(correct, str(r))\n\n\tdef test_str_method_width_height_x_y_id(self):\n\t\tr = Rectangle(13, 21, 2, 4, 7)\n\t\tself.assertEqual(\"[Rectangle] (7) 2/4 - 13/21\", str(r))\n\n\tdef test_str_method_changed_attributes(self):\n\t\tr = Rectangle(7, 7, 0, 0, [4])\n\t\tr.width = 15\n\t\tr.height = 1\n\t\tr.x = 8\n\t\tr.y = 10\n\t\tself.assertEqual(\"[Rectangle] ([4]) 8/10 - 15/1\", str(r))\n\n\tdef test_str_method_one_arg(self):\n\t\tr = Rectangle(1, 2, 3, 4, 5)\n\t\twith self.assertRaises(TypeError):\n\t\t\tr.__str__(1)\n\n\t# Test display method\n\tdef test_display_width_height(self):\n\t\tr = Rectangle(2, 3, 0, 0, 0)\n\t\tcapture = TestRectangle_stdout.capture_stdout(r, \"display\")\n\t\tself.assertEqual(\"##\\n##\\n##\\n\", capture.getvalue())\n\n\tdef test_display_width_height_x(self):\n\t\tr = Rectangle(3, 2, 1, 0, 1)\n\t\tcapture = TestRectangle_stdout.capture_stdout(r, \"display\")\n\t\tself.assertEqual(\" ###\\n ###\\n\", capture.getvalue())\n\n\tdef test_display_width_height_y(self):\n\t\tr = Rectangle(4, 5, 0, 1, 0)\n\t\tcapture = TestRectangle_stdout.capture_stdout(r, \"display\")\n\t\tdisplay = \"\\n####\\n####\\n####\\n####\\n####\\n\"\n\t\tself.assertEqual(display, capture.getvalue())\n\n\tdef test_display_width_height_x_y(self):\n\t\tr = Rectangle(2, 4, 3, 2, 0)\n\t\tcapture = TestRectangle_stdout.capture_stdout(r, \"display\")\n\t\tdisplay = \"\\n\\n   ##\\n   ##\\n   ##\\n   ##\\n\"\n\t\tself.assertEqual(display, capture.getvalue())\n\n\tdef test_display_one_arg(self):\n\t\tr = Rectangle(5, 1, 2, 4, 7)\n\t\twith self.assertRaises(TypeError):\n\t\t\tr.display(1)\n\n", "description": "Unittests for testing __str__ and display methods of Rectangle class.", "category": "def", "imports": ["import io", "import sys", "import unittest", "from models.base import Base", "from models.rectangle import Rectangle"]}, {"term": "class", "name": "TestRectangle_update_args", "data": "class TestRectangle_update_args(unittest.TestCase):\n\t\"\"\"Unittests for testing update args method of the Rectangle class.\"\"\"\n\n\t# Test args\n\tdef test_update_args_zero(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update()\n\t\tself.assertEqual(\"[Rectangle] (10) 10/10 - 10/10\", str(r))\n\n\tdef test_update_args_one(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(89)\n\t\tself.assertEqual(\"[Rectangle] (89) 10/10 - 10/10\", str(r))\n\n\tdef test_update_args_two(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(89, 2)\n\t\tself.assertEqual(\"[Rectangle] (89) 10/10 - 2/10\", str(r))\n\n\tdef test_update_args_three(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(89, 2, 3)\n\t\tself.assertEqual(\"[Rectangle] (89) 10/10 - 2/3\", str(r))\n\n\tdef test_update_args_four(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(89, 2, 3, 4)\n\t\tself.assertEqual(\"[Rectangle] (89) 4/10 - 2/3\", str(r))\n\n\tdef test_update_args_five(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(89, 2, 3, 4, 5)\n\t\tself.assertEqual(\"[Rectangle] (89) 4/5 - 2/3\", str(r))\n\n\tdef test_update_args_more_than_five(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(89, 2, 3, 4, 5, 6)\n\t\tself.assertEqual(\"[Rectangle] (89) 4/5 - 2/3\", str(r))\n\n\tdef test_update_args_None_id(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(None)\n\t\tcorrect = \"[Rectangle] ({}) 10/10 - 10/10\".format(r.id)\n\t\tself.assertEqual(correct, str(r))\n\n\tdef test_update_args_None_id_and_more(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(None, 4, 5, 2)\n\t\tcorrect = \"[Rectangle] ({}) 2/10 - 4/5\".format(r.id)\n\t\tself.assertEqual(correct, str(r))\n\n\tdef test_update_args_twice(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(89, 2, 3, 4, 5, 6)\n\t\tr.update(6, 5, 4, 3, 2, 89)\n\t\tself.assertEqual(\"[Rectangle] (6) 3/2 - 5/4\", str(r))\n\n\tdef test_update_args_invalid_width_type(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tr.update(89, \"invalid\")\n\n\tdef test_update_args_width_zero(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"width must be > 0\"):\n\t\t\tr.update(89, 0)\n\n\tdef test_update_args_width_negative(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"width must be > 0\"):\n\t\t\tr.update(89, -5)\n\n\tdef test_update_args_invalid_height_type(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tr.update(89, 2, \"invalid\")\n\n\tdef test_update_args_height_zero(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"height must be > 0\"):\n\t\t\tr.update(89, 1, 0)\n\n\tdef test_update_args_height_negative(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"height must be > 0\"):\n\t\t\tr.update(89, 1, -5)\n\n\tdef test_update_args_invalid_x_type(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tr.update(89, 2, 3, \"invalid\")\n\n\tdef test_update_args_x_negative(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"x must be >= 0\"):\n\t\t\tr.update(89, 1, 2, -6)\n\n\tdef test_update_args_invalid_y(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tr.update(89, 2, 3, 4, \"invalid\")\n\n\tdef test_update_args_y_negative(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"y must be >= 0\"):\n\t\t\tr.update(89, 1, 2, 3, -6)\n\n\tdef test_update_args_width_before_height(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tr.update(89, \"invalid\", \"invalid\")\n\n\tdef test_update_args_width_before_x(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tr.update(89, \"invalid\", 1, \"invalid\")\n\n\tdef test_update_args_width_before_y(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tr.update(89, \"invalid\", 1, 2, \"invalid\")\n\n\tdef test_update_args_height_before_x(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tr.update(89, 1, \"invalid\", \"invalid\")\n\n\tdef test_update_args_height_before_y(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tr.update(89, 1, \"invalid\", 1, \"invalid\")\n\n\tdef test_update_args_x_before_y(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tr.update(89, 1, 2, \"invalid\", \"invalid\")\n\n", "description": "Unittests for testing update args method of the Rectangle class.", "category": "def", "imports": ["import io", "import sys", "import unittest", "from models.base import Base", "from models.rectangle import Rectangle"]}, {"term": "class", "name": "TestRectangle_update_kwargs", "data": "class TestRectangle_update_kwargs(unittest.TestCase):\n\t\"\"\"Unittests for testing update kwargs method of the Rectangle class.\"\"\"\n\n\tdef test_update_kwargs_one(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(id=1)\n\t\tself.assertEqual(\"[Rectangle] (1) 10/10 - 10/10\", str(r))\n\n\tdef test_update_kwargs_two(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(width=2, id=1)\n\t\tself.assertEqual(\"[Rectangle] (1) 10/10 - 2/10\", str(r))\n\n\tdef test_update_kwargs_three(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(width=2, height=3, id=89)\n\t\tself.assertEqual(\"[Rectangle] (89) 10/10 - 2/3\", str(r))\n\n\tdef test_update_kwargs_four(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(id=89, x=1, height=2, y=3, width=4)\n\t\tself.assertEqual(\"[Rectangle] (89) 1/3 - 4/2\", str(r))\n\n\tdef test_update_kwargs_five(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(y=5, x=8, id=99, width=1, height=2)\n\t\tself.assertEqual(\"[Rectangle] (99) 8/5 - 1/2\", str(r))\n\n\tdef test_update_kwargs_None_id(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(id=None)\n\t\tcorrect = \"[Rectangle] ({}) 10/10 - 10/10\".format(r.id)\n\t\tself.assertEqual(correct, str(r))\n\n\tdef test_update_kwargs_None_id_and_more(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(id=None, height=7, y=9)\n\t\tcorrect = \"[Rectangle] ({}) 10/9 - 10/7\".format(r.id)\n\t\tself.assertEqual(correct, str(r))\n\n\tdef test_update_kwargs_twice(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(id=89, x=1, height=2)\n\t\tr.update(y=3, height=15, width=2)\n\t\tself.assertEqual(\"[Rectangle] (89) 1/3 - 2/15\", str(r))\n\n\tdef test_update_kwargs_invalid_width_type(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"width must be an integer\"):\n\t\t\tr.update(width=\"invalid\")\n\n\tdef test_update_kwargs_width_zero(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"width must be > 0\"):\n\t\t\tr.update(width=0)\n\n\tdef test_update_kwargs_width_negative(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"width must be > 0\"):\n\t\t\tr.update(width=-5)\n\n\tdef test_update_kwargs_invalid_height_type(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"height must be an integer\"):\n\t\t\tr.update(height=\"invalid\")\n\n\tdef test_update_kwargs_height_zero(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"height must be > 0\"):\n\t\t\tr.update(height=0)\n\n\tdef test_update_kwargs_height_negative(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"height must be > 0\"):\n\t\t\tr.update(height=-5)\n\n\tdef test_update_kwargs_inavlid_x_type(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"x must be an integer\"):\n\t\t\tr.update(x=\"invalid\")\n\n\tdef test_update_kwargs_x_negative(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"x must be >= 0\"):\n\t\t\tr.update(x=-5)\n\n\tdef test_update_kwargs_invalid_y_type(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(TypeError, \"y must be an integer\"):\n\t\t\tr.update(y=\"invalid\")\n\n\tdef test_update_kwargs_y_negative(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\twith self.assertRaisesRegex(ValueError, \"y must be >= 0\"):\n\t\t\tr.update(y=-5)\n\n\tdef test_update_args_and_kwargs(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(89, 2, height=4, y=6)\n\t\tself.assertEqual(\"[Rectangle] (89) 10/10 - 2/10\", str(r))\n\n\tdef test_update_kwargs_wrong_keys(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(a=5, b=10)\n\t\tself.assertEqual(\"[Rectangle] (10) 10/10 - 10/10\", str(r))\n\n\tdef test_update_kwargs_some_wrong_keys(self):\n\t\tr = Rectangle(10, 10, 10, 10, 10)\n\t\tr.update(height=5, id=89, a=1, b=54, x=19, y=7)\n\t\tself.assertEqual(\"[Rectangle] (89) 19/7 - 10/5\", str(r))\n\n", "description": "Unittests for testing update kwargs method of the Rectangle class.", "category": "def", "imports": ["import io", "import sys", "import unittest", "from models.base import Base", "from models.rectangle import Rectangle"]}, {"term": "class", "name": "TestRectangle_to_dictionary", "data": "class TestRectangle_to_dictionary(unittest.TestCase):\n\t\"\"\"Unittests for testing to_dictionary method of the Rectangle class.\"\"\"\n\n\tdef test_to_dictionary_output(self):\n\t\tr = Rectangle(10, 2, 1, 9, 5)\n\t\tcorrect = {'x': 1, 'y': 9, 'id': 5, 'height': 2, 'width': 10}\n\t\tself.assertDictEqual(correct, r.to_dictionary())\n\n\tdef test_to_dictionary_no_object_changes(self):\n\t\tr1 = Rectangle(10, 2, 1, 9, 5)\n\t\tr2 = Rectangle(5, 9, 1, 2, 10)\n\t\tr2.update(**r1.to_dictionary())\n\t\tself.assertNotEqual(r1, r2)\n\n\tdef test_to_dictionary_arg(self):\n\t\tr = Rectangle(10, 2, 4, 1, 2)\n\t\twith self.assertRaises(TypeError):\n\t\t\tr.to_dictionary(1)\n", "description": "Unittests for testing to_dictionary method of the Rectangle class.", "category": "def", "imports": ["import io", "import sys", "import unittest", "from models.base import Base", "from models.rectangle import Rectangle"]}], [{"term": "def", "name": "load_extensions", "data": "def load_extensions(environment, extensions): ...\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Callable, Dict, Iterator, List, Optional, Text, Type, Union", "from .bccache import BytecodeCache", "from .loaders import BaseLoader", "from .runtime import Context, Undefined", "\tfrom typing import Awaitable, AsyncIterator"]}, {"term": "class", "name": "classEnvironment:", "data": "class Environment:\n\tsandboxed: bool\n\toverlayed: bool\n\tlinked_to: Any\n\tshared: bool\n\texception_handler: Any\n\texception_formatter: Any\n\tcode_generator_class: Any\n\tcontext_class: Any\n\tblock_start_string: Text\n\tblock_end_string: Text\n\tvariable_start_string: Text\n\tvariable_end_string: Text\n\tcomment_start_string: Text\n\tcomment_end_string: Text\n\tline_statement_prefix: Text\n\tline_comment_prefix: Text\n\ttrim_blocks: bool\n\tlstrip_blocks: Any\n\tnewline_sequence: Text\n\tkeep_trailing_newline: bool\n\tundefined: Type[Undefined]\n\toptimized: bool\n\tfinalize: Callable[..., Any]\n\tautoescape: Any\n\tfilters: Any\n\ttests: Any\n\tglobals: Dict[str, Any]\n\tloader: BaseLoader\n\tcache: Any\n\tbytecode_cache: BytecodeCache\n\tauto_reload: bool\n\textensions: List[Any]\n\tdef __init__(\n\t\tself,\n\t\tblock_start_string: Text = ...,\n\t\tblock_end_string: Text = ...,\n\t\tvariable_start_string: Text = ...,\n\t\tvariable_end_string: Text = ...,\n\t\tcomment_start_string: Any = ...,\n\t\tcomment_end_string: Text = ...,\n\t\tline_statement_prefix: Text = ...,\n\t\tline_comment_prefix: Text = ...,\n\t\ttrim_blocks: bool = ...,\n\t\tlstrip_blocks: bool = ...,\n\t\tnewline_sequence: Text = ...,\n\t\tkeep_trailing_newline: bool = ...,\n\t\textensions: List[Any] = ...,\n\t\toptimized: bool = ...,\n\t\tundefined: Type[Undefined] = ...,\n\t\tfinalize: Optional[Callable[..., Any]] = ...,\n\t\tautoescape: Union[bool, Callable[[str], bool]] = ...,\n\t\tloader: Optional[BaseLoader] = ...,\n\t\tcache_size: int = ...,\n\t\tauto_reload: bool = ...,\n\t\tbytecode_cache: Optional[BytecodeCache] = ...,\n\t\tenable_async: bool = ...,\n\t) -> None: ...\n\tdef add_extension(self, extension): ...\n\tdef extend(self, **attributes): ...\n\tdef overlay(\n\t\tself,\n\t\tblock_start_string: Text = ...,\n\t\tblock_end_string: Text = ...,\n\t\tvariable_start_string: Text = ...,\n\t\tvariable_end_string: Text = ...,\n\t\tcomment_start_string: Any = ...,\n\t\tcomment_end_string: Text = ...,\n\t\tline_statement_prefix: Text = ...,\n\t\tline_comment_prefix: Text = ...,\n\t\ttrim_blocks: bool = ...,\n\t\tlstrip_blocks: bool = ...,\n\t\textensions: List[Any] = ...,\n\t\toptimized: bool = ...,\n\t\tundefined: Type[Undefined] = ...,\n\t\tfinalize: Callable[..., Any] = ...,\n\t\tautoescape: bool = ...,\n\t\tloader: Optional[BaseLoader] = ...,\n\t\tcache_size: int = ...,\n\t\tauto_reload: bool = ...,\n\t\tbytecode_cache: Optional[BytecodeCache] = ...,\n\t): ...\n\tlexer: Any\n\tdef iter_extensions(self): ...\n\tdef getitem(self, obj, argument): ...\n\tdef getattr(self, obj, attribute): ...\n\tdef call_filter(self, name, value, args: Optional[Any] = ..., kwargs: Optional[Any] = ..., context: Optional[Any] = ..., eval_ctx: Optional[Any] = ...): ...\n\tdef call_test(self, name, value, args: Optional[Any] = ..., kwargs: Optional[Any] = ...): ...\n\tdef parse(self, source, name: Optional[Any] = ..., filename: Optional[Any] = ...): ...\n\tdef lex(self, source, name: Optional[Any] = ..., filename: Optional[Any] = ...): ...\n\tdef preprocess(self, source: Text, name: Optional[Any] = ..., filename: Optional[Any] = ...): ...\n\tdef compile(self, source, name: Optional[Any] = ..., filename: Optional[Any] = ..., raw: bool = ..., defer_init: bool = ...): ...\n\tdef compile_expression(self, source: Text, undefined_to_none: bool = ...): ...\n\tdef compile_templates(self, target, extensions: Optional[Any] = ..., filter_func: Optional[Any] = ..., zip: str = ..., log_function: Optional[Any] = ..., ignore_errors: bool = ..., py_compile: bool = ...): ...\n\tdef list_templates(self, extensions: Optional[Any] = ..., filter_func: Optional[Any] = ...): ...\n\tdef handle_exception(self, exc_info: Optional[Any] = ..., rendered: bool = ..., source_hint: Optional[Any] = ...): ...\n\tdef join_path(self, template: Union[Template, Text], parent: Text) -> Text: ...\n\tdef get_template(self, name: Union[Template, Text], parent: Optional[Text] = ..., globals: Optional[Any] = ...) -> Template: ...\n\tdef select_template(self, names: List[Union[Template, Text]], parent: Optional[Text] = ..., globals: Optional[Dict[str, Any]] = ...) -> Template: ...\n\tdef get_or_select_template(self, template_name_or_list: Union[Union[Template, Text], List[Union[Template, Text]]], parent: Optional[Text] = ..., globals: Optional[Dict[str, Any]] = ...) -> Template: ...\n\tdef from_string(self, source: Text, globals: Optional[Dict[str, Any]] = ..., template_class: Optional[Type[Template]] = ...) -> Template: ...\n\tdef make_globals(self, d: Optional[Dict[str, Any]]) -> Dict[str, Any]: ...\n\n\t# Frequently added extensions are included here:\n\t# from InternationalizationExtension:\n\tdef install_gettext_translations(self, translations: Any, newstyle: Optional[bool]): ...\n\tdef install_null_translations(self, newstyle: Optional[bool]): ...\n\tdef install_gettext_callables(self, gettext: Callable[..., Any], ngettext: Callable[..., Any], newstyle: Optional[bool]): ...\n\tdef uninstall_gettext_translations(self, translations: Any): ...\n\tdef extract_translations(self, source: Any, gettext_functions: Any): ...\n\tnewstyle_gettext: bool\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Callable, Dict, Iterator, List, Optional, Text, Type, Union", "from .bccache import BytecodeCache", "from .loaders import BaseLoader", "from .runtime import Context, Undefined", "\tfrom typing import Awaitable, AsyncIterator"]}, {"term": "class", "name": "classTemplate:", "data": "class Template:\n\tdef __new__(cls, source, block_start_string: Any = ..., block_end_string: Any = ..., variable_start_string: Any = ..., variable_end_string: Any = ..., comment_start_string: Any = ..., comment_end_string: Any = ..., line_statement_prefix: Any = ..., line_comment_prefix: Any = ..., trim_blocks: Any = ..., lstrip_blocks: Any = ..., newline_sequence: Any = ..., keep_trailing_newline: Any = ..., extensions: Any = ..., optimized: bool = ..., undefined: Any = ..., finalize: Optional[Any] = ..., autoescape: bool = ...): ...\n\tenvironment: Environment = ...\n\t@classmethod\n\tdef from_code(cls, environment, code, globals, uptodate: Optional[Any] = ...): ...\n\t@classmethod\n\tdef from_module_dict(cls, environment, module_dict, globals): ...\n\tdef render(self, *args, **kwargs) -> Text: ...\n\tdef stream(self, *args, **kwargs) -> TemplateStream: ...\n\tdef generate(self, *args, **kwargs) -> Iterator[Text]: ...\n\tdef new_context(self, vars: Optional[Dict[str, Any]] = ..., shared: bool = ..., locals: Optional[Dict[str, Any]] = ...) -> Context: ...\n\tdef make_module(self, vars: Optional[Dict[str, Any]] = ..., shared: bool = ..., locals: Optional[Dict[str, Any]] = ...) -> Context: ...\n\t@property\n\tdef module(self) -> Any: ...\n\tdef get_corresponding_lineno(self, lineno): ...\n\t@property\n\tdef is_up_to_date(self) -> bool: ...\n\t@property\n\tdef debug_info(self): ...\n\n\tif sys.version_info >= (3, 6):\n\t\tdef render_async(self, *args, **kwargs) -> Awaitable[Text]: ...\n\t\tdef generate_async(self, *args, **kwargs) -> AsyncIterator[Text]: ...\n\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Callable, Dict, Iterator, List, Optional, Text, Type, Union", "from .bccache import BytecodeCache", "from .loaders import BaseLoader", "from .runtime import Context, Undefined", "\tfrom typing import Awaitable, AsyncIterator"]}, {"term": "class", "name": "classTemplateModule:", "data": "class TemplateModule:\n\t__name__: Any\n\tdef __init__(self, template, context) -> None: ...\n\tdef __html__(self): ...\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Callable, Dict, Iterator, List, Optional, Text, Type, Union", "from .bccache import BytecodeCache", "from .loaders import BaseLoader", "from .runtime import Context, Undefined", "\tfrom typing import Awaitable, AsyncIterator"]}, {"term": "class", "name": "classTemplateExpression:", "data": "class TemplateExpression:\n\tdef __init__(self, template, undefined_to_none) -> None: ...\n\tdef __call__(self, *args, **kwargs): ...\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Callable, Dict, Iterator, List, Optional, Text, Type, Union", "from .bccache import BytecodeCache", "from .loaders import BaseLoader", "from .runtime import Context, Undefined", "\tfrom typing import Awaitable, AsyncIterator"]}, {"term": "class", "name": "classTemplateStream:", "data": "class TemplateStream:\n\tdef __init__(self, gen) -> None: ...\n\tdef dump(self, fp, encoding: Optional[Text] = ..., errors: Text = ...): ...\n\tbuffered: bool\n\tdef disable_buffering(self) -> None: ...\n\tdef enable_buffering(self, size: int = ...) -> None: ...\n\tdef __iter__(self): ...\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Callable, Dict, Iterator, List, Optional, Text, Type, Union", "from .bccache import BytecodeCache", "from .loaders import BaseLoader", "from .runtime import Context, Undefined", "\tfrom typing import Awaitable, AsyncIterator"]}], [{"term": "def", "name": "repr_arg", "data": "def repr_arg(x):\n\tif isinstance(x, dict):\n\t\treturn util.sorted_dict_repr(x)\n\telse:\n\t\treturn repr(x)\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "class", "name": "%s", "data": "class %s(object):\n\tdef __init__(self, *args):\n\t\tself.args = args\n\tdef __repr__(self):\n\t\treturn \"%%s(%%s)\" %% (\n\t\t\tself.__class__.__name__,\n\t\t\t\", \".join(repr_arg(x) for x in self.args)\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "class", "name": "LexerTest", "data": "class LexerTest(TemplateTest):\n\n\tdef _compare(self, node, expected):\n\t\teq_(repr(node), repr(expected))\n\n\tdef test_text_and_tag(self):\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "%defname=\"foo", "data": "\t\t<%def name=\"foo()\">\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_unclosed_tag", "data": "\tdef test_unclosed_tag(self):\n\t\ttemplate = \"\"\"\n\t\t\n\t\t\t<%def name=\"foo()\">\n\t\t\t other text\n\t\t\"\"\"\n\t\ttry:\n\t\t\tnodes = Lexer(template).parse()\n\t\t\tassert False\n\t\texcept exceptions.SyntaxException, e:\n\t\t\tassert str(e) == \"Unclosed tag: <%def> at line: 5 char: 9\"\n", "description": "\n\t\t\n\t\t\t<%def name=\"foo()\">\n\t\t\t other text\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_onlyclosed_tag", "data": "\tdef test_onlyclosed_tag(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t\t<%def name=\"foo()\">\n\t\t\t\tfoo\n\t\t\t</%def>\n\t\t\t\n\t\t\t</%namespace>\n\t\t\t\n\t\t\thi.\n\t\t\"\"\"\n\t\tself.assertRaises(exceptions.SyntaxException,\n\t\t\t\t\t\t  Lexer(template).parse)\n", "description": "\n\t\t\t<%def name=\"foo()\">\n\t\t\t\tfoo\n\t\t\t</%def>\n\t\t\t\n\t\t\t</%namespace>\n\t\t\t\n\t\t\thi.\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_noexpr_allowed", "data": "\tdef test_noexpr_allowed(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t\t<%namespace name=\"${foo}\"/>\n\t\t\"\"\"\n\t\tself.assertRaises(exceptions.CompileException,\n\t\t\t\t\t\t  Lexer(template).parse)\n", "description": "\n\t\t\t<%namespace name=\"${foo}\"/>\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_unmatched_tag", "data": "\tdef test_unmatched_tag(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t<%namespace name=\"bar\">\n\t\t<%def name=\"foo()\">\n\t\t\tfoo\n\t\t\t</%namespace>\n\t\t</%def>\n\t\t\n\t\t\n", "description": "\n\t\t<%namespace name=\"bar\">\n\t\t<%def name=\"foo()\">\n\t\t\tfoo\n\t\t\t</%namespace>\n\t\t</%def>\n\t\t\n\t\t\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_nonexistent_tag", "data": "\tdef test_nonexistent_tag(self):\n\t\ttemplate = \"\"\"\n\t\t\t<%lala x=\"5\"/>\n\t\t\"\"\"\n\t\tself.assertRaises(exceptions.CompileException,\n\t\t\t\t\t\t  Lexer(template).parse)\n", "description": "\n\t\t\t<%lala x=\"5\"/>\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_wrongcase_tag", "data": "\tdef test_wrongcase_tag(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t\t<%DEF name=\"foo()\">\n\t\t\t</%def>\n\t\t\n\t\t\"\"\"\n\t\tself.assertRaises(exceptions.CompileException,\n\t\t\t\t\t\t  Lexer(template).parse)\n", "description": "\n\t\t\t<%DEF name=\"foo()\">\n\t\t\t</%def>\n\t\t\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_percent_escape", "data": "\tdef test_percent_escape(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n", "description": "\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_text_tag", "data": "\tdef test_text_tag(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t## comment\n\t\t% if foo:\n\t\t\thi\n\t\t% endif\n\t\t<%text>\n\t\t\t# more code\n\t\t\t\n\t\t\t% more code\n\t\t\t<%illegal compionent>/></>\n\t\t\t<%def name=\"laal()\">def</%def>\n\t\t\t\n\t\t\t\n\t\t</%text>\n\n\t\t<%def name=\"foo()\">this is foo</%def>\n\t\t\n\t\t% if bar:\n\t\t\tcode\n\t\t% endif\n\t\t\"\"\"\n\t\tnode = Lexer(template).parse()\n\t\tself._compare(node, \n\t\t\tTemplateNode({}, [Text(u'\\n', (1, 1)),\n\t\t\t  Comment(u'comment', (2, 1)), \n\t\t\t  ControlLine(u'if', u'if foo:', False, (3, 1)),\n\t\t\t  Text(u'\t\t\thi\\n', (4, 1)),\n\t\t\t  ControlLine(u'if', u'endif', True, (5, 1)),\n\t\t\t  Text(u'\t\t', (6, 1)), TextTag(u'text', {},\n\t\t\t  (6, 9),\n\t\t\t  [Text(u'''\\n\t\t\t# more code\\n\t\t\t'''\n\t\t\t  '''\\n\t\t\t% more code\\n\t\t\t'''\n\t\t\t  '''<%illegal compionent>/></>\\n\t\t\t'''\n\t\t\t  '''<%def name=\"laal()\">def</%def>\\n\t   '''\n\t\t\t  '''\t \\n\t\t\t\\n\t\t''',\n\t\t\t\t\t  (6, 16))]), Text(u'''\n\n\t\t''', (14, 17)),\n\t\t\t\t\t  DefTag(u'def', {u'name': u'foo()'}, (16, 9),\n\t\t\t\t\t  [Text(u'this is foo', (16, 28))]),\n\t\t\t\t\t  Text(u'''\\n\t\t\\n''', (16, 46)),\n\t\t\t\t\t  ControlLine(u'if', u'if bar:', False, (18, 1)),\n\t\t\t\t\t  Text(u'\t\t\tcode\\n', (19, 1)),\n\t\t\t\t\t  ControlLine(u'if', u'endif', True, (20, 1)),\n\t\t\t\t\t  Text(u'\t\t', (21, 1))]))\n", "description": "\n\t\t## comment\n\t\t% if foo:\n\t\t\thi\n\t\t% endif\n\t\t<%text>\n\t\t\t# more code\n\t\t\t\n\t\t\t% more code\n\t\t\t<%illegal compionent>/></>\n\t\t\t<%def name=\"laal()\">def</%def>\n\t\t\t\n\t\t\t\n\t\t</%text>\n\n\t\t<%def name=\"foo()\">this is foo</%def>\n\t\t\n\t\t% if bar:\n\t\t\tcode\n\t\t% endif\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_def_syntax", "data": "\tdef test_def_syntax(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t<%def lala>\n\t\t\thi\n", "description": "\n\t\t<%def lala>\n\t\t\thi\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_def_syntax_2", "data": "\tdef test_def_syntax_2(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t<%def name=\"lala\">\n\t\t\thi\n", "description": "\n\t\t<%def name=\"lala\">\n\t\t\thi\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_whitespace_equals", "data": "\tdef test_whitespace_equals(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t\t<%def name = \"adef()\" >\n\t\t\t  adef\n\t\t\t</%def>\n\t\t\"\"\"\n\t\tnode = Lexer(template).parse()\n\t\tself._compare(node, TemplateNode({}, [Text(u'\\n\t\t\t',\n\t\t\t\t\t  (1, 1)), DefTag(u'def', {u'name': u'adef()'}, (2,\n\t\t\t\t\t  13),\n\t\t\t\t\t  [Text(u'''\\n\t\t\t  adef\\n\t\t\t''',\n\t\t\t\t\t  (2, 36))]), Text(u'\\n\t\t', (4, 20))]))\n", "description": "\n\t\t\t<%def name = \"adef()\" >\n\t\t\t  adef\n\t\t\t</%def>\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_ns_tag_closed", "data": "\tdef test_ns_tag_closed(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t\n\t\t\t<%self:go x=\"1\" y=\"2\" z=\"${'hi' + ' ' + 'there'}\"/>\n\t\t\"\"\"\n\t\tnodes = Lexer(template).parse()\n\t\tself._compare(nodes, TemplateNode({},\n\t\t\t\t\t  [Text(u'''\n\t\t\n\t\t\t''', (1, 1)),\n\t\t\t\t\t  CallNamespaceTag(u'self:go', {u'x': u'1', u'y'\n\t\t\t\t\t  : u'2', u'z': u\"${'hi' + ' ' + 'there'}\"}, (3,\n\t\t\t\t\t  13), []), Text(u'\\n\t\t', (3, 64))]))\n", "description": "\n\t\t\n\t\t\t<%self:go x=\"1\" y=\"2\" z=\"${'hi' + ' ' + 'there'}\"/>\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_ns_tag_empty", "data": "\tdef test_ns_tag_empty(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t\t<%form:option value=\"\"></%form:option>\n\t\t\"\"\"\n\t\tnodes = Lexer(template).parse()\n\t\tself._compare(nodes, TemplateNode({}, [Text(u'\\n\t\t\t',\n\t\t\t\t\t  (1, 1)), CallNamespaceTag(u'form:option',\n\t\t\t\t\t  {u'value': u''}, (2, 13), []), Text(u'\\n\t\t'\n\t\t\t\t\t  , (2, 51))]))\n", "description": "\n\t\t\t<%form:option value=\"\"></%form:option>\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_ns_tag_open", "data": "\tdef test_ns_tag_open(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t\n\t\t\t<%self:go x=\"1\" y=\"${process()}\">\n\t\t\t\tthis is the body\n\t\t\t</%self:go>\n\t\t\"\"\"\n\t\tnodes = Lexer(template).parse()\n\t\tself._compare(nodes, TemplateNode({},\n\t\t\t\t\t  [Text(u'''\n\t\t\n\t\t\t''', (1, 1)),\n\t\t\t\t\t  CallNamespaceTag(u'self:go', {u'x': u'1', u'y'\n\t\t\t\t\t  : u'${process()}'}, (3, 13),\n\t\t\t\t\t  [Text(u'''\n\t\t\t\tthis is the body\n\t\t\t''',\n\t\t\t\t\t  (3, 46))]), Text(u'\\n\t\t', (5, 24))]))\n", "description": "\n\t\t\n\t\t\t<%self:go x=\"1\" y=\"${process()}\">\n\t\t\t\tthis is the body\n\t\t\t</%self:go>\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_expr_in_attribute", "data": "\tdef test_expr_in_attribute(self):\n\t\t\"\"\"test some slightly trickier expressions.\n\t\t\n\t\tyou can still trip up the expression parsing, though, unless we\n\t\tintegrated really deeply somehow with AST.\"\"\"\n\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t\t<%call expr=\"foo>bar and 'lala' or 'hoho'\"/>\n\t\t\t<%call expr='foo<bar and hoho>lala and \"x\" + \"y\"'/>\n\t\t\"\"\"\n\t\tnodes = Lexer(template).parse()\n\t\tself._compare(nodes, TemplateNode({}, [Text(u'\\n\t\t\t',\n\t\t\t\t\t  (1, 1)), CallTag(u'call', {u'expr'\n\t\t\t\t\t  : u\"foo>bar and 'lala' or 'hoho'\"}, (2, 13), []),\n\t\t\t\t\t  Text(u'\\n\t\t\t', (2, 57)), CallTag(u'call'\n\t\t\t\t\t  , {u'expr': u'foo<bar and hoho>lala and \"x\" + \"y\"'\n\t\t\t\t\t  }, (3, 13), []), Text(u'\\n\t\t', (3, 64))]))\n", "description": "test some slightly trickier expressions.\n\t\t\n\t\tyou can still trip up the expression parsing, though, unless we\n\t\tintegrated really deeply somehow with AST.", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_pagetag", "data": "\tdef test_pagetag(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t\t<%page cached=\"True\", args=\"a, b\"/>\n\t\t\t\n\t\t\tsome template\n\t\t\"\"\"\n\t\tnodes = Lexer(template).parse()\n\t\tself._compare(nodes, TemplateNode({}, [Text(u'\\n\t\t\t',\n\t\t\t\t\t  (1, 1)), PageTag(u'page', {u'args': u'a, b',\n\t\t\t\t\t  u'cached': u'True'}, (2, 13), []),\n\t\t\t\t\t  Text(u'''\n\t\t\t\n\t\t\tsome template\n\t\t''',\n\t\t\t\t\t  (2, 48))]))\n", "description": "\n\t\t\t<%page cached=\"True\", args=\"a, b\"/>\n\t\t\t\n\t\t\tsome template\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_nesting", "data": "\tdef test_nesting(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t\n\t\t<%namespace name=\"ns\">\n\t\t\t<%def name=\"lala(hi, there)\">\n\t\t\t\t<%call expr=\"something()\"/>\n\t\t\t</%def>\n\t\t</%namespace>\n\t\t\n\t\t\"\"\"\n\t\tnodes = Lexer(template).parse()\n\t\tself._compare(nodes, TemplateNode({},\n\t\t\t\t\t  [Text(u'''\n\t\t\n\t\t''', (1, 1)),\n\t\t\t\t\t  NamespaceTag(u'namespace', {u'name': u'ns'}, (3,\n\t\t\t\t\t  9), [Text(u'\\n\t\t\t', (3, 31)),\n\t\t\t\t\t  DefTag(u'def', {u'name': u'lala(hi, there)'}, (4,\n\t\t\t\t\t  13), [Text(u'\\n\t\t\t\t', (4, 42)),\n\t\t\t\t\t  CallTag(u'call', {u'expr': u'something()'}, (5,\n\t\t\t\t\t  17), []), Text(u'\\n\t\t\t', (5, 44))]),\n\t\t\t\t\t  Text(u'\\n\t\t', (6, 20))]),\n\t\t\t\t\t  Text(u'''\n\t\t\n\t\t''', (7, 22))]))\n", "description": "\n\t\t\n\t\t<%namespace name=\"ns\">\n\t\t\t<%def name=\"lala(hi, there)\">\n\t\t\t\t<%call expr=\"something()\"/>\n\t\t\t</%def>\n\t\t</%namespace>\n\t\t\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "eftest_code", "data": "\t\tdef test_code(self):\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "eftest_code", "data": "\t\tdef test_code(self):\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_code_and_tags", "data": "\tdef test_code_and_tags(self):\n\t\ttemplate = \\\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "defname=\"x", "data": "\t<%def name=\"x()\">\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "defname=\"y", "data": "\t<%def name=\"y()\">\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_expression", "data": "\tdef test_expression(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\tthis is some ${text} and this is ${textwith | escapes, moreescapes}\n\t\t<%def name=\"hi()\">\n\t\t\tgive me ${foo()} and ${bar()}\n\t\t</%def>\n", "description": "\n\t\tthis is some ${text} and this is ${textwith | escapes, moreescapes}\n\t\t<%def name=\"hi()\">\n\t\t\tgive me ${foo()} and ${bar()}\n\t\t</%def>\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_tricky_expression", "data": "\tdef test_tricky_expression(self):\n\t\ttemplate = \"\"\"\n\t\t\n\t\t\t${x and \"|\" or \"hi\"}\n\t\t\"\"\"\n\t\tnodes = Lexer(template).parse()\n\t\tself._compare(\n\t\t\tnodes,\n\t\t\tTemplateNode({}, [\n\t\t\t\tText(u'\\n\t\t\\n\t\t\t', (1, 1)), \n\t\t\t\tExpression(u'x and \"|\" or \"hi\"', [], (3, 13)), \n\t\t\t\tText(u'\\n\t\t', (3, 33))\n\t\t\t])\n\t\t)\n\n\t\ttemplate = \"\"\"\n\t\t\n\t\t\t${hello + '''heres '{|}' text | | }''' | escape1}\n\t\t\"\"\"\n\t\tnodes = Lexer(template).parse()\n\t\tself._compare(\n\t\t\tnodes,\n\t\t\tTemplateNode({}, [\n\t\t\t\tText(u'\\n\t\t\\n\t\t\t', (1, 1)), \n\t\t\t\tExpression(u\"hello + '''heres '{|}' text | | }''' \", \n\t\t\t\t\t\t\t\t['escape1'], (3, 13)), \n\t\t\t\tText(u'\\n\t\t', (3, 62))\n\t\t\t])\n\t\t)\n", "description": "\n\t\t\n\t\t\t${x and \"|\" or \"hi\"}\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_tricky_code", "data": "\tdef test_tricky_code(self):\n\t\tif util.py3k:\n\t\t\ttemplate = \"\"\"<% print('hi %>') %>\"\"\"\n\t\t\tnodes = Lexer(template).parse()\n\t\t\tself._compare(nodes, TemplateNode({},\n\t\t\t\t\t\t  [Code(u\"print('hi %>') \\n\", False, (1, 1))]))\n\t\telse:\n\t\t\ttemplate = \"\"\"<% print 'hi %>' %>\"\"\"\n\t\t\tnodes = Lexer(template).parse()\n\t\t\tself._compare(nodes, TemplateNode({},\n\t\t\t\t\t\t  [Code(u\"print 'hi %>' \\n\", False, (1, 1))]))\n", "description": "<% print('hi %>') %>", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_tricky_code_2", "data": "\tdef test_tricky_code_2(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"<% \n\t\t# someone's comment\n\t\t%>\n\t\t\"\"\"\n\t\tnodes = Lexer(template).parse()\n\t\tself._compare(nodes, TemplateNode({},\n\t\t\t\t\t  [Code(u\"\"\" \n\t\t# someone's comment\n", "description": "<% \n\t\t# someone's comment\n\t\t%>\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "eftest_tricky_code_3", "data": "\t\tdef test_tricky_code_3(self):\n\t\t\ttemplate = \\\n\t\t\t\t\"\"\"<%\n\t\t\tprint('hi')\n\t\t\t# this is a comment\n\t\t\t# another comment\n\t\t\tx = 7 # someone's '''comment\n", "description": "<%\n\t\t\tprint('hi')\n\t\t\t# this is a comment\n\t\t\t# another comment\n\t\t\tx = 7 # someone's '''comment\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "eftest_tricky_code_3", "data": "\t\tdef test_tricky_code_3(self):\n\t\t\ttemplate = \\\n\t\t\t\t\"\"\"<%\n\t\t\tprint 'hi'\n\t\t\t# this is a comment\n\t\t\t# another comment\n\t\t\tx = 7 # someone's '''comment\n", "description": "<%\n\t\t\tprint 'hi'\n\t\t\t# this is a comment\n\t\t\t# another comment\n\t\t\tx = 7 # someone's '''comment\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_control_lines", "data": "\tdef test_control_lines(self):\n\t\ttemplate = \\\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_control_lines_2", "data": "\tdef test_control_lines_2(self):\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_long_control_lines", "data": "\tdef test_long_control_lines(self):\n\t\ttemplate = \\\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_unmatched_control", "data": "\tdef test_unmatched_control(self):\n\t\ttemplate = \"\"\"\n\n\t\t% if foo:\n\t\t\t% for x in range(1,5):\n", "description": "\n\n\t\t% if foo:\n\t\t\t% for x in range(1,5):\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_unmatched_control_2", "data": "\tdef test_unmatched_control_2(self):\n\t\ttemplate = \"\"\"\n\n\t\t% if foo:\n\t\t\t% for x in range(1,5):\n", "description": "\n\n\t\t% if foo:\n\t\t\t% for x in range(1,5):\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_unmatched_control_3", "data": "\tdef test_unmatched_control_3(self):\n\t\ttemplate = \"\"\"\n\n\t\t% if foo:\n\t\t\t% for x in range(1,5):\n\t\t\t% endlala\n", "description": "\n\n\t\t% if foo:\n\t\t\t% for x in range(1,5):\n\t\t\t% endlala\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_ternary_control", "data": "\tdef test_ternary_control(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t% if x:\n\t\t\thi\n\t\t% elif y+7==10:\n\t\t\tthere\n\t\t% elif lala:\n\t\t\tlala\n\t\t% else:\n\t\t\thi\n", "description": "\n\t\t% if x:\n\t\t\thi\n\t\t% elif y+7==10:\n\t\t\tthere\n\t\t% elif lala:\n\t\t\tlala\n\t\t% else:\n\t\t\thi\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_integration", "data": "\tdef test_integration(self):\n\t\ttemplate = \\\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "efname=\"header", "data": "<%def name=\"header()\">\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "efname=\"footer", "data": "<%def name=\"footer()\">\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_comment_after_statement", "data": "\tdef test_comment_after_statement(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t% if x: #comment\n\t\t\thi\n\t\t% else: #next\n\t\t\thi\n", "description": "\n\t\t% if x: #comment\n\t\t\thi\n\t\t% else: #next\n\t\t\thi\n", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_crlf", "data": "\tdef test_crlf(self):\n\t\ttemplate = open(self._file_path(\"crlf.html\"), 'rb').read()\n\t\tnodes = Lexer(template).parse()\n\t\tself._compare(\n\t\t\tnodes,\n\t\t\tTemplateNode({}, [\n\t\t\t\tText(u'<html>\\r\\n\\r\\n', (1, 1)), \n\t\t\t\tPageTag(u'page', {\n\t\t\t\t\t\t\tu'args': u\"a=['foo',\\n\t\t\t\t'bar']\"\n\t\t\t\t\t\t}, (3, 1), []), \n\t\t\t\tText(u'\\r\\n\\r\\nlike the name says.\\r\\n\\r\\n', (4, 26)), \n\t\t\t\tControlLine(u'for', u'for x in [1,2,3]:', False, (8, 1)), \n\t\t\t\tText(u'\t\t', (9, 1)), \n\t\t\t\tExpression(u'x', [], (9, 9)), \n\t\t\t\tControlLine(u'for', u'endfor', True, (10, 1)), \n\t\t\t\tText(u'\\r\\n', (11, 1)), \n\t\t\t\tExpression(u\"trumpeter == 'Miles' and \"\n\t\t\t\t\t\t\t\t\"trumpeter or \\\\\\n\t  'Dizzy'\", \n\t\t\t\t\t\t\t\t[], (12, 1)), \n\t\t\t\tText(u'\\r\\n\\r\\n', (13, 15)), \n\t\t\t\tDefTag(u'def', {u'name': u'hi()'}, (15, 1), [\n\t\t\t\t\tText(u'\\r\\n\thi!\\r\\n', (15, 19))]), \n\t\t\t\t\tText(u'\\r\\n\\r\\n</html>\\r\\n', (17, 8))\n\t\t\t\t])\n\t\t)\n\t\tassert flatten_result(Template(template).render()) \\\n\t\t\t== \"\"\"<html> like the name says. 1 2 3 Dizzy </html>\"\"\"\n", "description": "<html> like the name says. 1 2 3 Dizzy </html>", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_comments", "data": "\tdef test_comments(self):\n\t\ttemplate = \\\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_docs", "data": "\tdef test_docs(self):\n\t\ttemplate = \\\n\t\t\t\"\"\"\n\t\t<%doc>\n\t\t\tthis is a comment\n\t\t</%doc>\n\t\t<%def name=\"foo()\">\n\t\t\t<%doc>\n\t\t\t\tthis is the foo func\n\t\t\t</%doc>\n\t\t</%def>\n\t\t\"\"\"\n\t\tnodes = Lexer(template).parse()\n\t\tself._compare(nodes, \n\t\t\tTemplateNode({}, [Text(u'\\n\t\t', (1,\n\t\t\t  1)),\n\t\t\t  Comment(u'''\\n\t\t\tthis is a comment\\n\t\t''',\n\t\t\t  (2, 9)), Text(u'\\n\t\t', (4, 16)),\n\t\t\t  DefTag(u'def', {u'name': u'foo()'}, (5, 9),\n\t\t\t  [Text(u'\\n\t\t\t', (5, 28)),\n\t\t\t  Comment(u'''\\n\t\t\t\tthis is the foo func\\n'''\n\t\t\t\t'''\t\t\t''',\n\t\t\t  (6, 13)), Text(u'\\n\t\t', (8, 20))]),\n\t\t\t  Text(u'\\n\t\t', (9, 16))]))\n", "description": "\n\t\t<%doc>\n\t\t\tthis is a comment\n\t\t</%doc>\n\t\t<%def name=\"foo()\">\n\t\t\t<%doc>\n\t\t\t\tthis is the foo func\n\t\t\t</%doc>\n\t\t</%def>\n\t\t", "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}, {"term": "def", "name": "ftest_preprocess", "data": "\tdef test_preprocess(self):\n\n\t\tdef preproc(text):\n\t\t\treturn re.sub(r'(?<=\\n)\\s*#[^#]', '##', text)\n\n\t\ttemplate = \\\n", "description": null, "category": "def", "imports": ["import unittest", "from mako.lexer import Lexer", "from mako import exceptions, util", "from util import flatten_result, result_lines", "from mako.template import Template", "import re", "from test import TemplateTest, template_base, skip_if, eq_, assert_raises_message", "from mako import parsetree", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), ", "\t\timport foo", "\t\t\t\tCode(u'\\nimport foo\\n\t\\n', True, (8, 5)), "]}], [{"term": "class", "name": "BaseStyle", "data": "class BaseStyle(object):\n\n\tdef __init__(self, doc, indent_width=2):\n\t\tself.doc = doc\n\t\tself.indent_width = indent_width\n\t\tself._indent = 0\n\t\tself.keep_data = True\n\n\t@property\n\tdef indentation(self):\n\t\treturn self._indent\n\n\t@indentation.setter\n\tdef indentation(self, value):\n\t\tself._indent = value\n\n\tdef new_paragraph(self):\n\t\treturn '\\n%s' % self.spaces()\n\n\tdef indent(self):\n\t\tself._indent += 1\n\n\tdef dedent(self):\n\t\tif self._indent > 0:\n\t\t\tself._indent -= 1\n\n\tdef spaces(self):\n\t\treturn ' ' * (self._indent * self.indent_width)\n\n\tdef bold(self, s):\n\t\treturn s\n\n\tdef ref(self, link, title=None):\n\t\treturn link\n\n\tdef h2(self, s):\n\t\treturn s\n\n\tdef h3(self, s):\n\t\treturn s\n\n\tdef underline(self, s):\n\t\treturn s\n\n\tdef italics(self, s):\n\t\treturn s\n\n", "description": null, "category": "def", "imports": ["import logging", "\tdef start_important(self, attrs=None):", "\tdef end_important(self):"]}, {"term": "class", "name": "ReSTStyle", "data": "class ReSTStyle(BaseStyle):\n\n\tdef __init__(self, doc, indent_width=2):\n\t\tBaseStyle.__init__(self, doc, indent_width)\n\t\tself.do_p = True\n\t\tself.a_href = None\n\t\tself.list_depth = 0\n\n\tdef new_paragraph(self):\n\t\tself.doc.write('\\n\\n%s' % self.spaces())\n\n\tdef new_line(self):\n\t\tself.doc.write('\\n%s' % self.spaces())\n\n\tdef _start_inline(self, markup):\n\t\tself.doc.write(markup)\n\n\tdef _end_inline(self, markup):\n\t\t# Sometimes the HTML markup has whitespace between the end\n\t\t# of the text inside the inline markup and the closing element\n\t\t# (e.g. <b>foobar </b>).  This trailing space will cause\n\t\t# problems in the ReST inline markup so we remove it here\n\t\t# by popping the last item written off the stack, striping\n\t\t# the whitespace and then pushing it back on the stack.\n\t\tlast_write = self.doc.pop_write()\n\t\tself.doc.push_write(last_write.rstrip(' '))\n\t\tself.doc.write(markup + ' ')\n\n\tdef start_bold(self, attrs=None):\n\t\tself._start_inline('**')\n\n\tdef end_bold(self):\n\t\tself._end_inline('**')\n\n\tdef start_b(self, attrs=None):\n\t\tself.doc.do_translation = True\n\t\tself.start_bold(attrs)\n\n\tdef end_b(self):\n\t\tself.doc.do_translation = False\n\t\tself.end_bold()\n\n\tdef bold(self, s):\n\t\tif s:\n\t\t\tself.start_bold()\n\t\t\tself.doc.write(s)\n\t\t\tself.end_bold()\n\n\tdef ref(self, title, link=None):\n\t\tif link is None:\n\t\t\tlink = title\n\t\tself.doc.write(':doc:`%s <%s>`' % (title, link))\n\n\tdef _heading(self, s, border_char):\n\t\tborder = border_char * len(s)\n\t\tself.new_paragraph()\n\t\tself.doc.write('%s\\n%s\\n%s' % (border, s, border))\n\t\tself.new_paragraph()\n\n\tdef h1(self, s):\n\t\tself._heading(s, '*')\n\n\tdef h2(self, s):\n\t\tself._heading(s, '=')\n\n\tdef h3(self, s):\n\t\tself._heading(s, '-')\n\n\tdef start_italics(self, attrs=None):\n\t\tself._start_inline('*')\n\n\tdef end_italics(self):\n\t\tself._end_inline('*')\n\n\tdef italics(self, s):\n\t\tif s:\n\t\t\tself.start_italics()\n\t\t\tself.doc.write(s)\n\t\t\tself.end_italics()\n\n\tdef start_p(self, attrs=None):\n\t\tif self.do_p:\n\t\t\tself.doc.write('\\n\\n%s' % self.spaces())\n\n\tdef end_p(self):\n\t\tif self.do_p:\n\t\t\tself.doc.write('\\n\\n%s' % self.spaces())\n\n\tdef start_code(self, attrs=None):\n\t\tself.doc.do_translation = True\n\t\tself._start_inline('``')\n\n\tdef end_code(self):\n\t\tself.doc.do_translation = False\n\t\tself._end_inline('``')\n\n\tdef code(self, s):\n\t\tif s:\n\t\t\tself.start_code()\n\t\t\tself.doc.write(s)\n\t\t\tself.end_code()\n\n\tdef start_note(self, attrs=None):\n\t\tself.new_paragraph()\n\t\tself.doc.write('.. note::')\n\t\tself.indent()\n\t\tself.new_paragraph()\n\n\tdef end_note(self):\n\t\tself.dedent()\n\t\tself.new_paragraph()\n\n\tdef start_important(self, attrs=None):\n\t\tself.new_paragraph()\n\t\tself.doc.write('.. warning::')\n\t\tself.indent()\n\t\tself.new_paragraph()\n\n\tdef end_important(self):\n\t\tself.dedent()\n\t\tself.new_paragraph()\n\n\tdef start_a(self, attrs=None):\n\t\tif attrs:\n\t\t\tfor attr_key, attr_value in attrs:\n\t\t\t\tif attr_key == 'href':\n\t\t\t\t\tself.a_href = attr_value\n\t\t\t\t\tself.doc.write('`')\n\t\telse:\n\t\t\t# There are some model documentation that\n\t\t\t# looks like this: <a>DescribeInstances</a>.\n\t\t\t# In this case we just write out an empty\n\t\t\t# string.\n\t\t\tself.doc.write(' ')\n\t\tself.doc.do_translation = True\n\n\tdef link_target_definition(self, refname, link):\n\t\tself.doc.writeln('.. _%s: %s' % (refname, link))\n\n\tdef sphinx_reference_label(self, label, text=None):\n\t\tif text is None:\n\t\t\ttext = label\n\t\tif self.doc.target == 'html':\n\t\t\tself.doc.write(':ref:`%s <%s>`' % (text, label))\n\t\telse:\n\t\t\tself.doc.write(text)\n\n\tdef end_a(self):\n\t\tself.doc.do_translation = False\n\t\tif self.a_href:\n\t\t\tlast_write = self.doc.pop_write()\n\t\t\tlast_write = last_write.rstrip(' ')\n\t\t\tif last_write and last_write != '`':\n\t\t\t\tif ':' in last_write:\n\t\t\t\t\tlast_write = last_write.replace(':', r'\\:')\n\t\t\t\tself.doc.push_write(last_write)\n\t\t\t\tself.doc.hrefs[last_write] = self.a_href\n\t\t\t\tself.doc.write('`_')\n\t\t\telif last_write == '`':\n\t\t\t\t# Look at start_a().  It will do a self.doc.write('`')\n\t\t\t\t# which is the start of the link title.  If that is the\n\t\t\t\t# case then there was no link text.  We should just\n\t\t\t\t# use an inline link.  The syntax of this is\n\t\t\t\t# `<http://url>`_\n\t\t\t\tself.doc.push_write('`<%s>`_' % self.a_href)\n\t\t\telse:\n\t\t\t\tself.doc.push_write(self.a_href)\n\t\t\t\tself.doc.hrefs[self.a_href] = self.a_href\n\t\t\t\tself.doc.write('`_')\n\t\t\tself.a_href = None\n\t\tself.doc.write(' ')\n\n\tdef start_i(self, attrs=None):\n\t\tself.doc.do_translation = True\n\t\tself.start_italics()\n\n\tdef end_i(self):\n\t\tself.doc.do_translation = False\n\t\tself.end_italics()\n\n\tdef start_li(self, attrs=None):\n\t\tself.new_line()\n\t\tself.do_p = False\n\t\tself.doc.write('* ')\n\n\tdef end_li(self):\n\t\tself.do_p = True\n\t\tself.new_line()\n\n\tdef li(self, s):\n\t\tif s:\n\t\t\tself.start_li()\n\t\t\tself.doc.writeln(s)\n\t\t\tself.end_li()\n\n\tdef start_ul(self, attrs=None):\n\t\tif self.list_depth != 0:\n\t\t\tself.indent()\n\t\tself.list_depth += 1\n\t\tself.new_paragraph()\n\n\tdef end_ul(self):\n\t\tself.list_depth -= 1\n\t\tif self.list_depth != 0:\n\t\t\tself.dedent()\n\t\tself.new_paragraph()\n\n\tdef start_ol(self, attrs=None):\n\t\t# TODO: Need to control the bullets used for LI items\n\t\tif self.list_depth != 0:\n\t\t\tself.indent()\n\t\tself.list_depth += 1\n\t\tself.new_paragraph()\n\n\tdef end_ol(self):\n\t\tself.list_depth -= 1\n\t\tif self.list_depth != 0:\n\t\t\tself.dedent()\n\t\tself.new_paragraph()\n\n\tdef start_examples(self, attrs=None):\n\t\tself.doc.keep_data = False\n\n\tdef end_examples(self):\n\t\tself.doc.keep_data = True\n\n\tdef start_fullname(self, attrs=None):\n\t\tself.doc.keep_data = False\n\n\tdef end_fullname(self):\n\t\tself.doc.keep_data = True\n\n\tdef start_codeblock(self, attrs=None):\n\t\tself.doc.write('::')\n\t\tself.indent()\n\t\tself.new_paragraph()\n\n\tdef end_codeblock(self):\n\t\tself.dedent()\n\t\tself.new_paragraph()\n\n\tdef codeblock(self, code):\n\t\t\"\"\"\n\t\tLiteral code blocks are introduced by ending a paragraph with\n\t\tthe special marker ::.  The literal block must be indented\n\t\t(and, like all paragraphs, separated from the surrounding\n\t\tones by blank lines).\n\t\t\"\"\"\n\t\tself.start_codeblock()\n\t\tself.doc.writeln(code)\n\t\tself.end_codeblock()\n\n\tdef toctree(self):\n\t\tif self.doc.target == 'html':\n\t\t\tself.doc.write('\\n.. toctree::\\n')\n\t\t\tself.doc.write('  :maxdepth: 1\\n')\n\t\t\tself.doc.write('  :titlesonly:\\n\\n')\n\t\telse:\n\t\t\tself.start_ul()\n\n\tdef tocitem(self, item, file_name=None):\n\t\tif self.doc.target == 'man':\n\t\t\tself.li(item)\n\t\telse:\n\t\t\tif file_name:\n\t\t\t\tself.doc.writeln('  %s' % file_name)\n\t\t\telse:\n\t\t\t\tself.doc.writeln('  %s' % item)\n\n\tdef hidden_toctree(self):\n\t\tif self.doc.target == 'html':\n\t\t\tself.doc.write('\\n.. toctree::\\n')\n\t\t\tself.doc.write('  :maxdepth: 1\\n')\n\t\t\tself.doc.write('  :hidden:\\n\\n')\n\n\tdef hidden_tocitem(self, item):\n\t\tif self.doc.target == 'html':\n\t\t\tself.tocitem(item)\n\n\tdef table_of_contents(self, title=None, depth=None):\n\t\tself.doc.write('.. contents:: ')\n\t\tif title is not None:\n\t\t\tself.doc.writeln(title)\n\t\tif depth is not None:\n\t\t\tself.doc.writeln('   :depth: %s' % depth)\n\n\tdef start_sphinx_py_class(self, class_name):\n\t\tself.new_paragraph()\n\t\tself.doc.write('.. py:class:: %s' % class_name)\n\t\tself.indent()\n\t\tself.new_paragraph()\n\n\tdef end_sphinx_py_class(self):\n\t\tself.dedent()\n\t\tself.new_paragraph()\n\n\tdef start_sphinx_py_method(self, method_name, parameters=None):\n\t\tself.new_paragraph()\n\t\tcontent = '.. py:method:: %s' % method_name\n\t\tif parameters is not None:\n\t\t\tcontent += '(%s)' % parameters\n\t\tself.doc.write(content)\n\t\tself.indent()\n\t\tself.new_paragraph()\n\n\tdef end_sphinx_py_method(self):\n\t\tself.dedent()\n\t\tself.new_paragraph()\n\n\tdef start_sphinx_py_attr(self, attr_name):\n\t\tself.new_paragraph()\n\t\tself.doc.write('.. py:attribute:: %s' % attr_name)\n\t\tself.indent()\n\t\tself.new_paragraph()\n\n\tdef end_sphinx_py_attr(self):\n\t\tself.dedent()\n\t\tself.new_paragraph()\n\n\tdef write_py_doc_string(self, docstring):\n\t\tdocstring_lines = docstring.splitlines()\n\t\tfor docstring_line in docstring_lines:\n\t\t\tself.doc.writeln(docstring_line)\n\n\tdef external_link(self, title, link):\n\t\tif self.doc.target == 'html':\n\t\t\tself.doc.write('`%s <%s>`_' % (title, link))\n\t\telse:\n", "description": "\n\t\tLiteral code blocks are introduced by ending a paragraph with\n\t\tthe special marker ::.  The literal block must be indented\n\t\t(and, like all paragraphs, separated from the surrounding\n\t\tones by blank lines).\n\t\t", "category": "def", "imports": ["import logging", "\tdef start_important(self, attrs=None):", "\tdef end_important(self):"]}], [{"term": "def", "name": "read_init_file", "data": "def read_init_file(filename: str = ...) -> None: ...\n", "description": null, "category": "def", "imports": ["from typing import Callable, Optional, Sequence", "import sys"]}, {"term": "def", "name": "redisplay", "data": "def redisplay() -> None: ...\n", "description": null, "category": "def", "imports": ["from typing import Callable, Optional, Sequence", "import sys"]}, {"term": "def", "name": "set_history_length", "data": "def set_history_length(length: int) -> None: ...\n", "description": null, "category": "def", "imports": ["from typing import Callable, Optional, Sequence", "import sys"]}, {"term": "def", "name": "add_history", "data": "def add_history(string: str) -> None: ...\n", "description": null, "category": "def", "imports": ["from typing import Callable, Optional, Sequence", "import sys"]}, {"term": "def", "name": "set_pre_input_hook", "data": "def set_pre_input_hook(function: Optional[Callable[[], None]] = ...) -> None: ...\n", "description": null, "category": "def", "imports": ["from typing import Callable, Optional, Sequence", "import sys"]}], [{"term": "def", "name": "init_logging", "data": "def init_logging(): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional, Text", "import logging", "from .s3.connection import S3Connection"]}, {"term": "class", "name": "NullHandler", "data": "class NullHandler(logging.Handler):\n\tdef emit(self, record): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional, Text", "import logging", "from .s3.connection import S3Connection"]}], [{"term": "class", "name": "_SupportsIndex", "data": "class _SupportsIndex(Protocol):\n\tdef __index__(self) -> int: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "_SupportsTrunc", "data": "class _SupportsTrunc(Protocol):\n\tdef __trunc__(self) -> int: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "classobject:", "data": "class object:\n\t__doc__: str | None\n\t__dict__: Dict[str, Any]\n\t__slots__: Text | Iterable[Text]\n\t__module__: str\n\t@property\n\tdef __class__(self: _T) -> Type[_T]: ...\n\t@__class__.setter\n\tdef __class__(self, __type: Type[object]) -> None: ...  # noqa: F811\n\tdef __init__(self) -> None: ...\n\tdef __new__(cls) -> Any: ...\n\tdef __setattr__(self, name: str, value: Any) -> None: ...\n\tdef __eq__(self, o: object) -> bool: ...\n\tdef __ne__(self, o: object) -> bool: ...\n\tdef __str__(self) -> str: ...\n\tdef __repr__(self) -> str: ...\n\tdef __hash__(self) -> int: ...\n\tdef __format__(self, format_spec: str) -> str: ...\n\tdef __getattribute__(self, name: str) -> Any: ...\n\tdef __delattr__(self, name: str) -> None: ...\n\tdef __sizeof__(self) -> int: ...\n\tdef __reduce__(self) -> str | Tuple[Any, ...]: ...\n\tdef __reduce_ex__(self, protocol: int) -> str | Tuple[Any, ...]: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "staticmethod", "data": "class staticmethod(object):  # Special, only valid as a decorator.\n\t__func__: Callable[..., Any]\n\tdef __init__(self, f: Callable[..., Any]) -> None: ...\n\tdef __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n\tdef __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "classmethod", "data": "class classmethod(object):  # Special, only valid as a decorator.\n\t__func__: Callable[..., Any]\n\tdef __init__(self, f: Callable[..., Any]) -> None: ...\n\tdef __new__(cls: Type[_T], *args: Any, **kwargs: Any) -> _T: ...\n\tdef __get__(self, obj: _T, type: Type[_T] | None = ...) -> Callable[..., Any]: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "type", "data": "class type(object):\n\t__base__: type\n\t__bases__: Tuple[type, ...]\n\t__basicsize__: int\n\t__dict__: Dict[str, Any]\n\t__dictoffset__: int\n\t__flags__: int\n\t__itemsize__: int\n\t__module__: str\n\t__mro__: Tuple[type, ...]\n\t__name__: str\n\t__weakrefoffset__: int\n\t@overload\n\tdef __init__(self, o: object) -> None: ...\n\t@overload\n\tdef __init__(self, name: str, bases: Tuple[type, ...], dict: Dict[str, Any]) -> None: ...\n\t@overload\n\tdef __new__(cls, o: object) -> type: ...\n\t@overload\n\tdef __new__(cls, name: str, bases: Tuple[type, ...], namespace: Dict[str, Any]) -> type: ...\n\tdef __call__(self, *args: Any, **kwds: Any) -> Any: ...\n\tdef __subclasses__(self: _TT) -> List[_TT]: ...\n\t# Note: the documentation doesn't specify what the return type is, the standard\n\t# implementation seems to be returning a list.\n\tdef mro(self) -> List[type]: ...\n\tdef __instancecheck__(self, instance: Any) -> bool: ...\n\tdef __subclasscheck__(self, subclass: type) -> bool: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "super", "data": "class super(object):\n\t@overload\n\tdef __init__(self, t: Any, obj: Any) -> None: ...\n\t@overload\n\tdef __init__(self, t: Any) -> None: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "classint:", "data": "class int:\n\t@overload\n\tdef __new__(cls: Type[_T], x: Text | bytes | SupportsInt | _SupportsIndex | _SupportsTrunc = ...) -> _T: ...\n\t@overload\n\tdef __new__(cls: Type[_T], x: Text | bytes | bytearray, base: int) -> _T: ...\n\t@property\n\tdef real(self) -> int: ...\n\t@property\n\tdef imag(self) -> int: ...\n\t@property\n\tdef numerator(self) -> int: ...\n\t@property\n\tdef denominator(self) -> int: ...\n\tdef conjugate(self) -> int: ...\n\tdef bit_length(self) -> int: ...\n\tdef __add__(self, x: int) -> int: ...\n\tdef __sub__(self, x: int) -> int: ...\n\tdef __mul__(self, x: int) -> int: ...\n\tdef __floordiv__(self, x: int) -> int: ...\n\tdef __div__(self, x: int) -> int: ...\n\tdef __truediv__(self, x: int) -> float: ...\n\tdef __mod__(self, x: int) -> int: ...\n\tdef __divmod__(self, x: int) -> Tuple[int, int]: ...\n\tdef __radd__(self, x: int) -> int: ...\n\tdef __rsub__(self, x: int) -> int: ...\n\tdef __rmul__(self, x: int) -> int: ...\n\tdef __rfloordiv__(self, x: int) -> int: ...\n\tdef __rdiv__(self, x: int) -> int: ...\n\tdef __rtruediv__(self, x: int) -> float: ...\n\tdef __rmod__(self, x: int) -> int: ...\n\tdef __rdivmod__(self, x: int) -> Tuple[int, int]: ...\n\t@overload\n\tdef __pow__(self, __x: Literal[2], __modulo: int | None = ...) -> int: ...\n\t@overload\n\tdef __pow__(self, __x: int, __modulo: int | None = ...) -> Any: ...  # Return type can be int or float, depending on x.\n\tdef __rpow__(self, x: int, mod: int | None = ...) -> Any: ...\n\tdef __and__(self, n: int) -> int: ...\n\tdef __or__(self, n: int) -> int: ...\n\tdef __xor__(self, n: int) -> int: ...\n\tdef __lshift__(self, n: int) -> int: ...\n\tdef __rshift__(self, n: int) -> int: ...\n\tdef __rand__(self, n: int) -> int: ...\n\tdef __ror__(self, n: int) -> int: ...\n\tdef __rxor__(self, n: int) -> int: ...\n\tdef __rlshift__(self, n: int) -> int: ...\n\tdef __rrshift__(self, n: int) -> int: ...\n\tdef __neg__(self) -> int: ...\n\tdef __pos__(self) -> int: ...\n\tdef __invert__(self) -> int: ...\n\tdef __trunc__(self) -> int: ...\n\tdef __getnewargs__(self) -> Tuple[int]: ...\n\tdef __eq__(self, x: object) -> bool: ...\n\tdef __ne__(self, x: object) -> bool: ...\n\tdef __lt__(self, x: int) -> bool: ...\n\tdef __le__(self, x: int) -> bool: ...\n\tdef __gt__(self, x: int) -> bool: ...\n\tdef __ge__(self, x: int) -> bool: ...\n\tdef __str__(self) -> str: ...\n\tdef __float__(self) -> float: ...\n\tdef __int__(self) -> int: ...\n\tdef __abs__(self) -> int: ...\n\tdef __hash__(self) -> int: ...\n\tdef __nonzero__(self) -> bool: ...\n\tdef __index__(self) -> int: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "classfloat:", "data": "class float:\n\tdef __new__(cls: Type[_T], x: SupportsFloat | _SupportsIndex | Text | bytes | bytearray = ...) -> _T: ...\n\tdef as_integer_ratio(self) -> Tuple[int, int]: ...\n\tdef hex(self) -> str: ...\n\tdef is_integer(self) -> bool: ...\n\t@classmethod\n\tdef fromhex(cls, __s: str) -> float: ...\n\t@property\n\tdef real(self) -> float: ...\n\t@property\n\tdef imag(self) -> float: ...\n\tdef conjugate(self) -> float: ...\n\tdef __add__(self, x: float) -> float: ...\n\tdef __sub__(self, x: float) -> float: ...\n\tdef __mul__(self, x: float) -> float: ...\n\tdef __floordiv__(self, x: float) -> float: ...\n\tdef __div__(self, x: float) -> float: ...\n\tdef __truediv__(self, x: float) -> float: ...\n\tdef __mod__(self, x: float) -> float: ...\n\tdef __divmod__(self, x: float) -> Tuple[float, float]: ...\n\tdef __pow__(\n\t\tself, x: float, mod: None = ...\n\t) -> float: ...  # In Python 3, returns complex if self is negative and x is not whole\n\tdef __radd__(self, x: float) -> float: ...\n\tdef __rsub__(self, x: float) -> float: ...\n\tdef __rmul__(self, x: float) -> float: ...\n\tdef __rfloordiv__(self, x: float) -> float: ...\n\tdef __rdiv__(self, x: float) -> float: ...\n\tdef __rtruediv__(self, x: float) -> float: ...\n\tdef __rmod__(self, x: float) -> float: ...\n\tdef __rdivmod__(self, x: float) -> Tuple[float, float]: ...\n\tdef __rpow__(self, x: float, mod: None = ...) -> float: ...\n\tdef __getnewargs__(self) -> Tuple[float]: ...\n\tdef __trunc__(self) -> int: ...\n\tdef __eq__(self, x: object) -> bool: ...\n\tdef __ne__(self, x: object) -> bool: ...\n\tdef __lt__(self, x: float) -> bool: ...\n\tdef __le__(self, x: float) -> bool: ...\n\tdef __gt__(self, x: float) -> bool: ...\n\tdef __ge__(self, x: float) -> bool: ...\n\tdef __neg__(self) -> float: ...\n\tdef __pos__(self) -> float: ...\n\tdef __str__(self) -> str: ...\n\tdef __int__(self) -> int: ...\n\tdef __float__(self) -> float: ...\n\tdef __abs__(self) -> float: ...\n\tdef __hash__(self) -> int: ...\n\tdef __nonzero__(self) -> bool: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "classcomplex:", "data": "class complex:\n\t@overload\n\tdef __new__(cls: Type[_T], real: float = ..., imag: float = ...) -> _T: ...\n\t@overload\n\tdef __new__(cls: Type[_T], real: str | SupportsComplex | _SupportsIndex) -> _T: ...\n\t@property\n\tdef real(self) -> float: ...\n\t@property\n\tdef imag(self) -> float: ...\n\tdef conjugate(self) -> complex: ...\n\tdef __add__(self, x: complex) -> complex: ...\n\tdef __sub__(self, x: complex) -> complex: ...\n\tdef __mul__(self, x: complex) -> complex: ...\n\tdef __pow__(self, x: complex, mod: None = ...) -> complex: ...\n\tdef __div__(self, x: complex) -> complex: ...\n\tdef __truediv__(self, x: complex) -> complex: ...\n\tdef __radd__(self, x: complex) -> complex: ...\n\tdef __rsub__(self, x: complex) -> complex: ...\n\tdef __rmul__(self, x: complex) -> complex: ...\n\tdef __rpow__(self, x: complex, mod: None = ...) -> complex: ...\n\tdef __rdiv__(self, x: complex) -> complex: ...\n\tdef __rtruediv__(self, x: complex) -> complex: ...\n\tdef __eq__(self, x: object) -> bool: ...\n\tdef __ne__(self, x: object) -> bool: ...\n\tdef __neg__(self) -> complex: ...\n\tdef __pos__(self) -> complex: ...\n\tdef __str__(self) -> str: ...\n\tdef __complex__(self) -> complex: ...\n\tdef __abs__(self) -> float: ...\n\tdef __hash__(self) -> int: ...\n\tdef __nonzero__(self) -> bool: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "basestring", "data": "class basestring(metaclass=ABCMeta): ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "unicode", "data": "class unicode(basestring, Sequence[unicode]):\n\t@overload\n\tdef __init__(self) -> None: ...\n\t@overload\n\tdef __init__(self, o: object) -> None: ...\n\t@overload\n\tdef __init__(self, o: str, encoding: unicode = ..., errors: unicode = ...) -> None: ...\n\tdef capitalize(self) -> unicode: ...\n\tdef center(self, width: int, fillchar: unicode = ...) -> unicode: ...\n\tdef count(self, x: unicode) -> int: ...\n\tdef decode(self, encoding: unicode = ..., errors: unicode = ...) -> unicode: ...\n\tdef encode(self, encoding: unicode = ..., errors: unicode = ...) -> str: ...\n\tdef endswith(self, __suffix: unicode | Tuple[unicode, ...], __start: int | None = ..., __end: int | None = ...) -> bool: ...\n\tdef expandtabs(self, tabsize: int = ...) -> unicode: ...\n\tdef find(self, sub: unicode, start: int = ..., end: int = ...) -> int: ...\n\tdef format(self, *args: object, **kwargs: object) -> unicode: ...\n\tdef index(self, sub: unicode, start: int = ..., end: int = ...) -> int: ...\n\tdef isalnum(self) -> bool: ...\n\tdef isalpha(self) -> bool: ...\n\tdef isdecimal(self) -> bool: ...\n\tdef isdigit(self) -> bool: ...\n\tdef isidentifier(self) -> bool: ...\n\tdef islower(self) -> bool: ...\n\tdef isnumeric(self) -> bool: ...\n\tdef isprintable(self) -> bool: ...\n\tdef isspace(self) -> bool: ...\n\tdef istitle(self) -> bool: ...\n\tdef isupper(self) -> bool: ...\n\tdef join(self, iterable: Iterable[unicode]) -> unicode: ...\n\tdef ljust(self, width: int, fillchar: unicode = ...) -> unicode: ...\n\tdef lower(self) -> unicode: ...\n\tdef lstrip(self, chars: unicode = ...) -> unicode: ...\n\tdef partition(self, sep: unicode) -> Tuple[unicode, unicode, unicode]: ...\n\tdef replace(self, old: unicode, new: unicode, count: int = ...) -> unicode: ...\n\tdef rfind(self, sub: unicode, start: int = ..., end: int = ...) -> int: ...\n\tdef rindex(self, sub: unicode, start: int = ..., end: int = ...) -> int: ...\n\tdef rjust(self, width: int, fillchar: unicode = ...) -> unicode: ...\n\tdef rpartition(self, sep: unicode) -> Tuple[unicode, unicode, unicode]: ...\n\tdef rsplit(self, sep: unicode | None = ..., maxsplit: int = ...) -> List[unicode]: ...\n\tdef rstrip(self, chars: unicode = ...) -> unicode: ...\n\tdef split(self, sep: unicode | None = ..., maxsplit: int = ...) -> List[unicode]: ...\n\tdef splitlines(self, keepends: bool = ...) -> List[unicode]: ...\n\tdef startswith(self, __prefix: unicode | Tuple[unicode, ...], __start: int | None = ..., __end: int | None = ...) -> bool: ...\n\tdef strip(self, chars: unicode = ...) -> unicode: ...\n\tdef swapcase(self) -> unicode: ...\n\tdef title(self) -> unicode: ...\n\tdef translate(self, table: Dict[int, Any] | unicode) -> unicode: ...\n\tdef upper(self) -> unicode: ...\n\tdef zfill(self, width: int) -> unicode: ...\n\t@overload\n\tdef __getitem__(self, i: int) -> unicode: ...\n\t@overload\n\tdef __getitem__(self, s: slice) -> unicode: ...\n\tdef __getslice__(self, start: int, stop: int) -> unicode: ...\n\tdef __add__(self, s: unicode) -> unicode: ...\n\tdef __mul__(self, n: int) -> unicode: ...\n\tdef __rmul__(self, n: int) -> unicode: ...\n\tdef __mod__(self, x: Any) -> unicode: ...\n\tdef __eq__(self, x: object) -> bool: ...\n\tdef __ne__(self, x: object) -> bool: ...\n\tdef __lt__(self, x: unicode) -> bool: ...\n\tdef __le__(self, x: unicode) -> bool: ...\n\tdef __gt__(self, x: unicode) -> bool: ...\n\tdef __ge__(self, x: unicode) -> bool: ...\n\tdef __len__(self) -> int: ...\n\t# The argument type is incompatible with Sequence\n\tdef __contains__(self, s: unicode | bytes) -> bool: ...  # type: ignore\n\tdef __iter__(self) -> Iterator[unicode]: ...\n\tdef __str__(self) -> str: ...\n\tdef __repr__(self) -> str: ...\n\tdef __int__(self) -> int: ...\n\tdef __float__(self) -> float: ...\n\tdef __hash__(self) -> int: ...\n\tdef __getnewargs__(self) -> Tuple[unicode]: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "_FormatMapMapping", "data": "class _FormatMapMapping(Protocol):\n\tdef __getitem__(self, __key: str) -> Any: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "str", "data": "class str(Sequence[str], basestring):\n\tdef __init__(self, o: object = ...) -> None: ...\n\tdef capitalize(self) -> str: ...\n\tdef center(self, __width: int, __fillchar: str = ...) -> str: ...\n\tdef count(self, x: Text, __start: int | None = ..., __end: int | None = ...) -> int: ...\n\tdef decode(self, encoding: Text = ..., errors: Text = ...) -> unicode: ...\n\tdef encode(self, encoding: Text = ..., errors: Text = ...) -> bytes: ...\n\tdef endswith(self, __suffix: Text | Tuple[Text, ...], __start: int | None = ..., __end: int | None = ...) -> bool: ...\n\tdef expandtabs(self, tabsize: int = ...) -> str: ...\n\tdef find(self, sub: Text, __start: int | None = ..., __end: int | None = ...) -> int: ...\n\tdef format(self, *args: object, **kwargs: object) -> str: ...\n\tdef format_map(self, map: _FormatMapMapping) -> str: ...\n\tdef index(self, sub: Text, __start: int | None = ..., __end: int | None = ...) -> int: ...\n\tdef isalnum(self) -> bool: ...\n\tdef isalpha(self) -> bool: ...\n\tdef isdigit(self) -> bool: ...\n\tdef islower(self) -> bool: ...\n\tdef isspace(self) -> bool: ...\n\tdef istitle(self) -> bool: ...\n\tdef isupper(self) -> bool: ...\n\tdef join(self, __iterable: Iterable[AnyStr]) -> AnyStr: ...\n\tdef ljust(self, __width: int, __fillchar: str = ...) -> str: ...\n\tdef lower(self) -> str: ...\n\t@overload\n\tdef lstrip(self, __chars: str = ...) -> str: ...\n\t@overload\n\tdef lstrip(self, __chars: unicode) -> unicode: ...\n\t@overload\n\tdef partition(self, __sep: bytearray) -> Tuple[str, bytearray, str]: ...\n\t@overload\n\tdef partition(self, __sep: str) -> Tuple[str, str, str]: ...\n\t@overload\n\tdef partition(self, __sep: unicode) -> Tuple[unicode, unicode, unicode]: ...\n\tdef replace(self, __old: AnyStr, __new: AnyStr, __count: int = ...) -> AnyStr: ...\n\tdef rfind(self, sub: Text, __start: int | None = ..., __end: int | None = ...) -> int: ...\n\tdef rindex(self, sub: Text, __start: int | None = ..., __end: int | None = ...) -> int: ...\n\tdef rjust(self, __width: int, __fillchar: str = ...) -> str: ...\n\t@overload\n\tdef rpartition(self, __sep: bytearray) -> Tuple[str, bytearray, str]: ...\n\t@overload\n\tdef rpartition(self, __sep: str) -> Tuple[str, str, str]: ...\n\t@overload\n\tdef rpartition(self, __sep: unicode) -> Tuple[unicode, unicode, unicode]: ...\n\t@overload\n\tdef rsplit(self, sep: str | None = ..., maxsplit: int = ...) -> List[str]: ...\n\t@overload\n\tdef rsplit(self, sep: unicode, maxsplit: int = ...) -> List[unicode]: ...\n\t@overload\n\tdef rstrip(self, __chars: str = ...) -> str: ...\n\t@overload\n\tdef rstrip(self, __chars: unicode) -> unicode: ...\n\t@overload\n\tdef split(self, sep: str | None = ..., maxsplit: int = ...) -> List[str]: ...\n\t@overload\n\tdef split(self, sep: unicode, maxsplit: int = ...) -> List[unicode]: ...\n\tdef splitlines(self, keepends: bool = ...) -> List[str]: ...\n\tdef startswith(self, __prefix: Text | Tuple[Text, ...], __start: int | None = ..., __end: int | None = ...) -> bool: ...\n\t@overload\n\tdef strip(self, __chars: str = ...) -> str: ...\n\t@overload\n\tdef strip(self, chars: unicode) -> unicode: ...\n\tdef swapcase(self) -> str: ...\n\tdef title(self) -> str: ...\n\tdef translate(self, __table: AnyStr | None, deletechars: AnyStr = ...) -> AnyStr: ...\n\tdef upper(self) -> str: ...\n\tdef zfill(self, __width: int) -> str: ...\n\tdef __add__(self, s: AnyStr) -> AnyStr: ...\n\t# Incompatible with Sequence.__contains__\n\tdef __contains__(self, o: str | Text) -> bool: ...  # type: ignore\n\tdef __eq__(self, x: object) -> bool: ...\n\tdef __ge__(self, x: Text) -> bool: ...\n\tdef __getitem__(self, i: int | slice) -> str: ...\n\tdef __gt__(self, x: Text) -> bool: ...\n\tdef __hash__(self) -> int: ...\n\tdef __iter__(self) -> Iterator[str]: ...\n\tdef __le__(self, x: Text) -> bool: ...\n\tdef __len__(self) -> int: ...\n\tdef __lt__(self, x: Text) -> bool: ...\n\tdef __mod__(self, x: Any) -> str: ...\n\tdef __mul__(self, n: int) -> str: ...\n\tdef __ne__(self, x: object) -> bool: ...\n\tdef __repr__(self) -> str: ...\n\tdef __rmul__(self, n: int) -> str: ...\n\tdef __str__(self) -> str: ...\n\tdef __getnewargs__(self) -> Tuple[str]: ...\n\tdef __getslice__(self, start: int, stop: int) -> str: ...\n\tdef __float__(self) -> float: ...\n\tdef __int__(self) -> int: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "bytearray", "data": "class bytearray(MutableSequence[int], ByteString):\n\t@overload\n\tdef __init__(self) -> None: ...\n\t@overload\n\tdef __init__(self, ints: Iterable[int]) -> None: ...\n\t@overload\n\tdef __init__(self, string: str) -> None: ...\n\t@overload\n\tdef __init__(self, string: Text, encoding: Text, errors: Text = ...) -> None: ...\n\t@overload\n\tdef __init__(self, length: int) -> None: ...\n\tdef capitalize(self) -> bytearray: ...\n\tdef center(self, __width: int, __fillchar: bytes = ...) -> bytearray: ...\n\tdef count(self, __sub: str) -> int: ...\n\tdef decode(self, encoding: Text = ..., errors: Text = ...) -> str: ...\n\tdef endswith(self, __suffix: bytes | Tuple[bytes, ...], __start: int | None = ..., __end: int | None = ...) -> bool: ...\n\tdef expandtabs(self, tabsize: int = ...) -> bytearray: ...\n\tdef extend(self, iterable: str | Iterable[int]) -> None: ...\n\tdef find(self, __sub: str, __start: int = ..., __end: int = ...) -> int: ...\n\tdef index(self, __sub: str, __start: int = ..., __end: int = ...) -> int: ...\n\tdef insert(self, __index: int, __item: int) -> None: ...\n\tdef isalnum(self) -> bool: ...\n\tdef isalpha(self) -> bool: ...\n\tdef isdigit(self) -> bool: ...\n\tdef islower(self) -> bool: ...\n\tdef isspace(self) -> bool: ...\n\tdef istitle(self) -> bool: ...\n\tdef isupper(self) -> bool: ...\n\tdef join(self, __iterable: Iterable[str]) -> bytearray: ...\n\tdef ljust(self, __width: int, __fillchar: str = ...) -> bytearray: ...\n\tdef lower(self) -> bytearray: ...\n\tdef lstrip(self, __bytes: bytes | None = ...) -> bytearray: ...\n\tdef partition(self, __sep: bytes) -> Tuple[bytearray, bytearray, bytearray]: ...\n\tdef replace(self, __old: bytes, __new: bytes, __count: int = ...) -> bytearray: ...\n\tdef rfind(self, __sub: bytes, __start: int = ..., __end: int = ...) -> int: ...\n\tdef rindex(self, __sub: bytes, __start: int = ..., __end: int = ...) -> int: ...\n\tdef rjust(self, __width: int, __fillchar: bytes = ...) -> bytearray: ...\n\tdef rpartition(self, __sep: bytes) -> Tuple[bytearray, bytearray, bytearray]: ...\n\tdef rsplit(self, sep: bytes | None = ..., maxsplit: int = ...) -> List[bytearray]: ...\n\tdef rstrip(self, __bytes: bytes | None = ...) -> bytearray: ...\n\tdef split(self, sep: bytes | None = ..., maxsplit: int = ...) -> List[bytearray]: ...\n\tdef splitlines(self, keepends: bool = ...) -> List[bytearray]: ...\n\tdef startswith(self, __prefix: bytes | Tuple[bytes, ...], __start: int | None = ..., __end: int | None = ...) -> bool: ...\n\tdef strip(self, __bytes: bytes | None = ...) -> bytearray: ...\n\tdef swapcase(self) -> bytearray: ...\n\tdef title(self) -> bytearray: ...\n\tdef translate(self, __table: str) -> bytearray: ...\n\tdef upper(self) -> bytearray: ...\n\tdef zfill(self, __width: int) -> bytearray: ...\n\t@classmethod\n\tdef fromhex(cls, __string: str) -> bytearray: ...\n\tdef __len__(self) -> int: ...\n\tdef __iter__(self) -> Iterator[int]: ...\n\tdef __str__(self) -> str: ...\n\tdef __repr__(self) -> str: ...\n\tdef __int__(self) -> int: ...\n\tdef __float__(self) -> float: ...\n\t__hash__: None  # type: ignore\n\t@overload\n\tdef __getitem__(self, i: int) -> int: ...\n\t@overload\n\tdef __getitem__(self, s: slice) -> bytearray: ...\n\t@overload\n\tdef __setitem__(self, i: int, x: int) -> None: ...\n\t@overload\n\tdef __setitem__(self, s: slice, x: Iterable[int] | bytes) -> None: ...\n\tdef __delitem__(self, i: int | slice) -> None: ...\n\tdef __getslice__(self, start: int, stop: int) -> bytearray: ...\n\tdef __setslice__(self, start: int, stop: int, x: Sequence[int] | str) -> None: ...\n\tdef __delslice__(self, start: int, stop: int) -> None: ...\n\tdef __add__(self, s: bytes) -> bytearray: ...\n\tdef __mul__(self, n: int) -> bytearray: ...\n\t# Incompatible with Sequence.__contains__\n\tdef __contains__(self, o: int | bytes) -> bool: ...  # type: ignore\n\tdef __eq__(self, x: object) -> bool: ...\n\tdef __ne__(self, x: object) -> bool: ...\n\tdef __lt__(self, x: bytes) -> bool: ...\n\tdef __le__(self, x: bytes) -> bool: ...\n\tdef __gt__(self, x: bytes) -> bool: ...\n\tdef __ge__(self, x: bytes) -> bool: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "memoryview", "data": "class memoryview(Sized, Container[str]):\n\tformat: str\n\titemsize: int\n\tshape: Tuple[int, ...] | None\n\tstrides: Tuple[int, ...] | None\n\tsuboffsets: Tuple[int, ...] | None\n\treadonly: bool\n\tndim: int\n\tdef __init__(self, obj: ReadableBuffer) -> None: ...\n\t@overload\n\tdef __getitem__(self, i: int) -> str: ...\n\t@overload\n\tdef __getitem__(self, s: slice) -> memoryview: ...\n\tdef __contains__(self, x: object) -> bool: ...\n\tdef __iter__(self) -> Iterator[str]: ...\n\tdef __len__(self) -> int: ...\n\t@overload\n\tdef __setitem__(self, s: slice, o: bytes) -> None: ...\n\t@overload\n\tdef __setitem__(self, i: int, o: int) -> None: ...\n\tdef tobytes(self) -> bytes: ...\n\tdef tolist(self) -> List[int]: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "bool", "data": "class bool(int):\n\tdef __new__(cls: Type[_T], __o: object = ...) -> _T: ...\n\t@overload\n\tdef __and__(self, x: bool) -> bool: ...\n\t@overload\n\tdef __and__(self, x: int) -> int: ...\n\t@overload\n\tdef __or__(self, x: bool) -> bool: ...\n\t@overload\n\tdef __or__(self, x: int) -> int: ...\n\t@overload\n\tdef __xor__(self, x: bool) -> bool: ...\n\t@overload\n\tdef __xor__(self, x: int) -> int: ...\n\t@overload\n\tdef __rand__(self, x: bool) -> bool: ...\n\t@overload\n\tdef __rand__(self, x: int) -> int: ...\n\t@overload\n\tdef __ror__(self, x: bool) -> bool: ...\n\t@overload\n\tdef __ror__(self, x: int) -> int: ...\n\t@overload\n\tdef __rxor__(self, x: bool) -> bool: ...\n\t@overload\n\tdef __rxor__(self, x: int) -> int: ...\n\tdef __getnewargs__(self) -> Tuple[int]: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "slice", "data": "class slice(object):\n\tstart: Any\n\tstep: Any\n\tstop: Any\n\t@overload\n\tdef __init__(self, stop: Any) -> None: ...\n\t@overload\n\tdef __init__(self, start: Any, stop: Any, step: Any = ...) -> None: ...\n\t__hash__: None  # type: ignore\n\tdef indices(self, len: int) -> Tuple[int, int, int]: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "tuple", "data": "class tuple(Sequence[_T_co], Generic[_T_co]):\n\tdef __new__(cls: Type[_T], iterable: Iterable[_T_co] = ...) -> _T: ...\n\tdef __len__(self) -> int: ...\n\tdef __contains__(self, x: object) -> bool: ...\n\t@overload\n\tdef __getitem__(self, x: int) -> _T_co: ...\n\t@overload\n\tdef __getitem__(self, x: slice) -> Tuple[_T_co, ...]: ...\n\tdef __iter__(self) -> Iterator[_T_co]: ...\n\tdef __lt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n\tdef __le__(self, x: Tuple[_T_co, ...]) -> bool: ...\n\tdef __gt__(self, x: Tuple[_T_co, ...]) -> bool: ...\n\tdef __ge__(self, x: Tuple[_T_co, ...]) -> bool: ...\n\t@overload\n\tdef __add__(self, x: Tuple[_T_co, ...]) -> Tuple[_T_co, ...]: ...\n\t@overload\n\tdef __add__(self, x: Tuple[Any, ...]) -> Tuple[Any, ...]: ...\n\tdef __mul__(self, n: int) -> Tuple[_T_co, ...]: ...\n\tdef __rmul__(self, n: int) -> Tuple[_T_co, ...]: ...\n\tdef count(self, __value: Any) -> int: ...\n\tdef index(self, __value: Any) -> int: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "classfunction:", "data": "class function:\n\t# TODO not defined in builtins!\n\t__name__: str\n\t__module__: str\n\t__code__: CodeType\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "list", "data": "class list(MutableSequence[_T], Generic[_T]):\n\t@overload\n\tdef __init__(self) -> None: ...\n\t@overload\n\tdef __init__(self, iterable: Iterable[_T]) -> None: ...\n\tdef append(self, __object: _T) -> None: ...\n\tdef extend(self, __iterable: Iterable[_T]) -> None: ...\n\tdef pop(self, __index: int = ...) -> _T: ...\n\tdef index(self, __value: _T, __start: int = ..., __stop: int = ...) -> int: ...\n\tdef count(self, __value: _T) -> int: ...\n\tdef insert(self, __index: int, __object: _T) -> None: ...\n\tdef remove(self, __value: _T) -> None: ...\n\tdef reverse(self) -> None: ...\n\tdef sort(self, cmp: Callable[[_T, _T], Any] = ..., key: Callable[[_T], Any] = ..., reverse: bool = ...) -> None: ...\n\tdef __len__(self) -> int: ...\n\tdef __iter__(self) -> Iterator[_T]: ...\n\tdef __str__(self) -> str: ...\n\t__hash__: None  # type: ignore\n\t@overload\n\tdef __getitem__(self, i: int) -> _T: ...\n\t@overload\n\tdef __getitem__(self, s: slice) -> List[_T]: ...\n\t@overload\n\tdef __setitem__(self, i: int, o: _T) -> None: ...\n\t@overload\n\tdef __setitem__(self, s: slice, o: Iterable[_T]) -> None: ...\n\tdef __delitem__(self, i: int | slice) -> None: ...\n\tdef __getslice__(self, start: int, stop: int) -> List[_T]: ...\n\tdef __setslice__(self, start: int, stop: int, o: Sequence[_T]) -> None: ...\n\tdef __delslice__(self, start: int, stop: int) -> None: ...\n\tdef __add__(self, x: List[_T]) -> List[_T]: ...\n\tdef __iadd__(self: _S, x: Iterable[_T]) -> _S: ...\n\tdef __mul__(self, n: int) -> List[_T]: ...\n\tdef __rmul__(self, n: int) -> List[_T]: ...\n\tdef __contains__(self, o: object) -> bool: ...\n\tdef __reversed__(self) -> Iterator[_T]: ...\n\tdef __gt__(self, x: List[_T]) -> bool: ...\n\tdef __ge__(self, x: List[_T]) -> bool: ...\n\tdef __lt__(self, x: List[_T]) -> bool: ...\n\tdef __le__(self, x: List[_T]) -> bool: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "dict", "data": "class dict(MutableMapping[_KT, _VT], Generic[_KT, _VT]):\n\t# NOTE: Keyword arguments are special. If they are used, _KT must include\n\t#\t   str, but we have no way of enforcing it here.\n\t@overload\n\tdef __init__(self, **kwargs: _VT) -> None: ...\n\t@overload\n\tdef __init__(self, map: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT) -> None: ...\n\t@overload\n\tdef __init__(self, iterable: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n\tdef __new__(cls: Type[_T1], *args: Any, **kwargs: Any) -> _T1: ...\n\tdef has_key(self, k: _KT) -> bool: ...\n\tdef clear(self) -> None: ...\n\tdef copy(self) -> Dict[_KT, _VT]: ...\n\tdef popitem(self) -> Tuple[_KT, _VT]: ...\n\tdef setdefault(self, __key: _KT, __default: _VT = ...) -> _VT: ...\n\t@overload\n\tdef update(self, __m: Mapping[_KT, _VT], **kwargs: _VT) -> None: ...\n\t@overload\n\tdef update(self, __m: Iterable[Tuple[_KT, _VT]], **kwargs: _VT) -> None: ...\n\t@overload\n\tdef update(self, **kwargs: _VT) -> None: ...\n\tdef iterkeys(self) -> Iterator[_KT]: ...\n\tdef itervalues(self) -> Iterator[_VT]: ...\n\tdef iteritems(self) -> Iterator[Tuple[_KT, _VT]]: ...\n\tdef viewkeys(self) -> KeysView[_KT]: ...\n\tdef viewvalues(self) -> ValuesView[_VT]: ...\n\tdef viewitems(self) -> ItemsView[_KT, _VT]: ...\n\t@classmethod\n\t@overload\n\tdef fromkeys(cls, __iterable: Iterable[_T]) -> Dict[_T, Any]: ...\n\t@classmethod\n\t@overload\n\tdef fromkeys(cls, __iterable: Iterable[_T], __value: _S) -> Dict[_T, _S]: ...\n\tdef __len__(self) -> int: ...\n\tdef __getitem__(self, k: _KT) -> _VT: ...\n\tdef __setitem__(self, k: _KT, v: _VT) -> None: ...\n\tdef __delitem__(self, v: _KT) -> None: ...\n\tdef __iter__(self) -> Iterator[_KT]: ...\n\tdef __str__(self) -> str: ...\n\t__hash__: None  # type: ignore\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "set", "data": "class set(MutableSet[_T], Generic[_T]):\n\tdef __init__(self, iterable: Iterable[_T] = ...) -> None: ...\n\tdef add(self, element: _T) -> None: ...\n\tdef clear(self) -> None: ...\n\tdef copy(self) -> Set[_T]: ...\n\tdef difference(self, *s: Iterable[Any]) -> Set[_T]: ...\n\tdef difference_update(self, *s: Iterable[Any]) -> None: ...\n\tdef discard(self, element: _T) -> None: ...\n\tdef intersection(self, *s: Iterable[Any]) -> Set[_T]: ...\n\tdef intersection_update(self, *s: Iterable[Any]) -> None: ...\n\tdef isdisjoint(self, s: Iterable[Any]) -> bool: ...\n\tdef issubset(self, s: Iterable[Any]) -> bool: ...\n\tdef issuperset(self, s: Iterable[Any]) -> bool: ...\n\tdef pop(self) -> _T: ...\n\tdef remove(self, element: _T) -> None: ...\n\tdef symmetric_difference(self, s: Iterable[_T]) -> Set[_T]: ...\n\tdef symmetric_difference_update(self, s: Iterable[_T]) -> None: ...\n\tdef union(self, *s: Iterable[_T]) -> Set[_T]: ...\n\tdef update(self, *s: Iterable[_T]) -> None: ...\n\tdef __len__(self) -> int: ...\n\tdef __contains__(self, o: object) -> bool: ...\n\tdef __iter__(self) -> Iterator[_T]: ...\n\tdef __str__(self) -> str: ...\n\tdef __and__(self, s: AbstractSet[object]) -> Set[_T]: ...\n\tdef __iand__(self, s: AbstractSet[object]) -> Set[_T]: ...\n\tdef __or__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n\tdef __ior__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n\t@overload\n\tdef __sub__(self: Set[str], s: AbstractSet[Text | None]) -> Set[_T]: ...\n\t@overload\n\tdef __sub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n\t@overload  # type: ignore\n\tdef __isub__(self: Set[str], s: AbstractSet[Text | None]) -> Set[_T]: ...\n\t@overload\n\tdef __isub__(self, s: AbstractSet[_T | None]) -> Set[_T]: ...\n\tdef __xor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n\tdef __ixor__(self, s: AbstractSet[_S]) -> Set[_T | _S]: ...\n\tdef __le__(self, s: AbstractSet[object]) -> bool: ...\n\tdef __lt__(self, s: AbstractSet[object]) -> bool: ...\n\tdef __ge__(self, s: AbstractSet[object]) -> bool: ...\n\tdef __gt__(self, s: AbstractSet[object]) -> bool: ...\n\t__hash__: None  # type: ignore\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "frozenset", "data": "class frozenset(AbstractSet[_T_co], Generic[_T_co]):\n\tdef __init__(self, iterable: Iterable[_T_co] = ...) -> None: ...\n\tdef copy(self) -> FrozenSet[_T_co]: ...\n\tdef difference(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n\tdef intersection(self, *s: Iterable[object]) -> FrozenSet[_T_co]: ...\n\tdef isdisjoint(self, s: Iterable[_T_co]) -> bool: ...\n\tdef issubset(self, s: Iterable[object]) -> bool: ...\n\tdef issuperset(self, s: Iterable[object]) -> bool: ...\n\tdef symmetric_difference(self, s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n\tdef union(self, *s: Iterable[_T_co]) -> FrozenSet[_T_co]: ...\n\tdef __len__(self) -> int: ...\n\tdef __contains__(self, o: object) -> bool: ...\n\tdef __iter__(self) -> Iterator[_T_co]: ...\n\tdef __str__(self) -> str: ...\n\tdef __and__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n\tdef __or__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n\tdef __sub__(self, s: AbstractSet[_T_co]) -> FrozenSet[_T_co]: ...\n\tdef __xor__(self, s: AbstractSet[_S]) -> FrozenSet[_T_co | _S]: ...\n\tdef __le__(self, s: AbstractSet[object]) -> bool: ...\n\tdef __lt__(self, s: AbstractSet[object]) -> bool: ...\n\tdef __ge__(self, s: AbstractSet[object]) -> bool: ...\n\tdef __gt__(self, s: AbstractSet[object]) -> bool: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "enumerate", "data": "class enumerate(Iterator[Tuple[int, _T]], Generic[_T]):\n\tdef __init__(self, iterable: Iterable[_T], start: int = ...) -> None: ...\n\tdef __iter__(self) -> Iterator[Tuple[int, _T]]: ...\n\tdef next(self) -> Tuple[int, _T]: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "xrange", "data": "class xrange(Sized, Iterable[int], Reversible[int]):\n\t@overload\n\tdef __init__(self, stop: int) -> None: ...\n\t@overload\n\tdef __init__(self, start: int, stop: int, step: int = ...) -> None: ...\n\tdef __len__(self) -> int: ...\n\tdef __iter__(self) -> Iterator[int]: ...\n\tdef __getitem__(self, i: _SupportsIndex) -> int: ...\n\tdef __reversed__(self) -> Iterator[int]: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "property", "data": "class property(object):\n\tdef __init__(\n\t\tself,\n\t\tfget: Callable[[Any], Any] | None = ...,\n\t\tfset: Callable[[Any, Any], None] | None = ...,\n\t\tfdel: Callable[[Any], None] | None = ...,\n\t\tdoc: str | None = ...,\n\t) -> None: ...\n\tdef getter(self, fget: Callable[[Any], Any]) -> property: ...\n\tdef setter(self, fset: Callable[[Any, Any], None]) -> property: ...\n\tdef deleter(self, fdel: Callable[[Any], None]) -> property: ...\n\tdef __get__(self, obj: Any, type: type | None = ...) -> Any: ...\n\tdef __set__(self, obj: Any, value: Any) -> None: ...\n\tdef __delete__(self, obj: Any) -> None: ...\n\tdef fget(self) -> Any: ...\n\tdef fset(self, value: Any) -> None: ...\n\tdef fdel(self) -> None: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "_NotImplementedType", "data": "class _NotImplementedType(Any):  # type: ignore\n\t# A little weird, but typing the __call__ as NotImplemented makes the error message\n\t# for NotImplemented() much better\n\t__call__: NotImplemented  # type: ignore\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "cmp", "data": "def cmp(__x: Any, __y: Any) -> int: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "dir", "data": "def dir(__o: object = ...) -> List[str]: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "eval", "data": "def eval(\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "getattr", "data": "def getattr(__o: Any, name: Text) -> Any: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "map", "data": "def map(\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "map", "data": "def map(\n\t__func: None,\n\t__iter1: Iterable[_T1],\n\t__iter2: Iterable[_T2],\n\t__iter3: Iterable[_T3],\n\t__iter4: Iterable[_T4],\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "map", "data": "def map(\n\t__func: None,\n\t__iter1: Iterable[Any],\n\t__iter2: Iterable[Any],\n\t__iter3: Iterable[Any],\n\t__iter4: Iterable[Any],\n\t__iter5: Iterable[Any],\n\t__iter6: Iterable[Any],\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "map", "data": "def map(\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "map", "data": "def map(\n\t__func: Callable[[_T1, _T2, _T3, _T4], _S],\n\t__iter1: Iterable[_T1],\n\t__iter2: Iterable[_T2],\n\t__iter3: Iterable[_T3],\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "map", "data": "def map(\n\t__func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n\t__iter1: Iterable[_T1],\n\t__iter2: Iterable[_T2],\n\t__iter3: Iterable[_T3],\n\t__iter4: Iterable[_T4],\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "map", "data": "def map(\n\t__func: Callable[..., _S],\n\t__iter1: Iterable[Any],\n\t__iter2: Iterable[Any],\n\t__iter3: Iterable[Any],\n\t__iter4: Iterable[Any],\n\t__iter5: Iterable[Any],\n\t__iter6: Iterable[Any],\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "ord", "data": "def ord(__c: Text | bytes) -> int: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "print", "data": "def print(*values: object, sep: Text | None = ..., end: Text | None = ..., file: SupportsWrite[Any] | None = ...) -> None: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "_SupportsPow2", "data": "class _SupportsPow2(Protocol[_E, _T_co]):\n\tdef __pow__(self, __other: _E) -> _T_co: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "_SupportsPow3", "data": "class _SupportsPow3(Protocol[_E, _M, _T_co]):\n\tdef __pow__(self, __other: _E, __modulo: _M) -> _T_co: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "sorted", "data": "def sorted(\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "zip", "data": "def zip(\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "zip", "data": "def zip(\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "zip", "data": "def zip(\n\t__iter1: Iterable[Any],\n\t__iter2: Iterable[Any],\n\t__iter3: Iterable[Any],\n\t__iter4: Iterable[Any],\n\t__iter5: Iterable[Any],\n\t__iter6: Iterable[Any],\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "def", "name": "__import__", "data": "def __import__(\n\tname: Text,\n\tglobals: Mapping[str, Any] | None = ...,\n\tlocals: Mapping[str, Any] | None = ...,\n\tfromlist: Sequence[str] = ...,\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "classellipsis:...", "data": "class ellipsis: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "buffer", "data": "class buffer(Sized):\n\tdef __init__(self, object: _AnyBuffer, offset: int = ..., size: int = ...) -> None: ...\n\tdef __add__(self, other: _AnyBuffer) -> str: ...\n\tdef __cmp__(self, other: _AnyBuffer) -> bool: ...\n\tdef __getitem__(self, key: int | slice) -> str: ...\n\tdef __getslice__(self, i: int, j: int) -> str: ...\n\tdef __len__(self) -> int: ...\n\tdef __mul__(self, x: int) -> str: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "BaseException", "data": "class BaseException(object):\n\targs: Tuple[Any, ...]\n\tmessage: Any\n\tdef __init__(self, *args: object) -> None: ...\n\tdef __str__(self) -> str: ...\n\tdef __repr__(self) -> str: ...\n\tdef __getitem__(self, i: int) -> Any: ...\n\tdef __getslice__(self, start: int, stop: int) -> Tuple[Any, ...]: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "KeyboardInterrupt", "data": "class KeyboardInterrupt(BaseException): ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "SystemExit", "data": "class SystemExit(BaseException):\n\tcode: int\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "StandardError", "data": "class StandardError(Exception): ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "EnvironmentError", "data": "class EnvironmentError(StandardError):\n\terrno: int\n\tstrerror: str\n\t# TODO can this be unicode?\n\tfilename: str\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "RuntimeError", "data": "class RuntimeError(_StandardError): ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "SyntaxError", "data": "class SyntaxError(_StandardError):\n\tmsg: str\n\tlineno: int | None\n\toffset: int | None\n\ttext: str | None\n\tfilename: str | None\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "UnboundLocalError", "data": "class UnboundLocalError(NameError): ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "WindowsError", "data": "class WindowsError(OSError):\n\twinerror: int\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "UnicodeError", "data": "class UnicodeError(ValueError): ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "UnicodeDecodeError", "data": "class UnicodeDecodeError(UnicodeError):\n\tencoding: str\n\tobject: bytes\n\tstart: int\n\tend: int\n\treason: str\n\tdef __init__(self, __encoding: str, __object: bytes, __start: int, __end: int, __reason: str) -> None: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "UnicodeEncodeError", "data": "class UnicodeEncodeError(UnicodeError):\n\tencoding: str\n\tobject: Text\n\tstart: int\n\tend: int\n\treason: str\n\tdef __init__(self, __encoding: str, __object: Text, __start: int, __end: int, __reason: str) -> None: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "BytesWarning", "data": "class BytesWarning(Warning): ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}, {"term": "class", "name": "file", "data": "class file(BinaryIO):\n\t@overload\n\tdef __init__(self, file: str, mode: str = ..., buffering: int = ...) -> None: ...\n\t@overload\n\tdef __init__(self, file: unicode, mode: str = ..., buffering: int = ...) -> None: ...\n\t@overload\n\tdef __init__(self, file: int, mode: str = ..., buffering: int = ...) -> None: ...\n\tdef __iter__(self) -> Iterator[str]: ...\n\tdef next(self) -> str: ...\n\tdef read(self, n: int = ...) -> str: ...\n\tdef __enter__(self) -> BinaryIO: ...\n\tdef __exit__(self, t: type | None = ..., exc: BaseException | None = ..., tb: Any | None = ...) -> bool | None: ...\n\tdef flush(self) -> None: ...\n\tdef fileno(self) -> int: ...\n\tdef isatty(self) -> bool: ...\n\tdef close(self) -> None: ...\n\tdef readable(self) -> bool: ...\n\tdef writable(self) -> bool: ...\n\tdef seekable(self) -> bool: ...\n\tdef seek(self, offset: int, whence: int = ...) -> int: ...\n\tdef tell(self) -> int: ...\n\tdef readline(self, limit: int = ...) -> str: ...\n\tdef readlines(self, hint: int = ...) -> List[str]: ...\n\tdef write(self, data: str) -> int: ...\n\tdef writelines(self, data: Iterable[str]) -> None: ...\n", "description": null, "category": "def", "imports": ["from _typeshed import ReadableBuffer, SupportsKeysAndGetItem, SupportsWrite", "from abc import ABCMeta", "from ast import mod", "from types import CodeType", "from typing import (", "from typing_extensions import Literal, final", "# This is only available after from __future__ import print_function.", "def __import__("]}], [{"term": "class", "name": "BlockTest", "data": "class BlockTest(TemplateTest):\n\tdef test_anonymous_block_namespace_raises(self):\n\t\tassert_raises_message(\n\t\t\texceptions.CompileException,\n\t\t\t\"Can't put anonymous blocks inside <%namespace>\",\n\t\t\tTemplate, \"\"\"\n\t\t\t\t<%namespace name=\"foo\">\n\t\t\t\t\t<%block>\n\t\t\t\t\t\tblock\n\t\t\t\t\t</%block>\n\t\t\t\t</%namespace>\n\t\t\t\"\"\"\n\t\t)\n\n\tdef test_anonymous_block_in_call(self):\n\t\ttemplate = Template(\"\"\"\n\t\t\n\t\t\t<%self:foo x=\"5\">\n\t\t\t\t<%block>\n\t\t\t\t\tthis is the block x\n\t\t\t\t</%block>\n\t\t\t</%self:foo>\n\t\t\t\n\t\t\t<%def name=\"foo(x)\">\n\t\t\t\tfoo:\n\t\t\t\t${caller.body()}\n\t\t\t</%def>\n\t\t\"\"\")\n\t\tself._do_test(\n\t\t\ttemplate,\n\t\t\t[\"foo:\", \"this is the block x\"],\n\t\t\tfilters=result_lines\n\t\t)\n\n\tdef test_named_block_in_call(self):\n\t\tassert_raises_message(\n\t\t\texceptions.CompileException,\n\t\t\t\"Named block 'y' not allowed inside of <%call> tag\",\n\t\t\tTemplate,\"\"\"\n\t\t\n\t\t\t<%self:foo x=\"5\">\n\t\t\t\t<%block name=\"y\">\n\t\t\t\t\tthis is the block\n\t\t\t\t</%block>\n\t\t\t</%self:foo>\n\t\t\t\n\t\t\t<%def name=\"foo(x)\">\n\t\t\t\tfoo:\n\t\t\t\t${caller.body()}\n\t\t\t\t${caller.y()}\n\t\t\t</%def>\n\t\t\"\"\")\n\n\tdef test_name_collision_blocks_toplevel(self):\n\t\tassert_raises_message(\n\t\t\texceptions.CompileException,\n\t\t\t\"%def or %block named 'x' already exists in this template\",\n\t\t\tTemplate,\n\t\t\t\"\"\"\n\t\t\t\t<%block name=\"x\">\n\t\t\t\t\tblock\n\t\t\t\t</%block>\n\t\t\t\t\n\t\t\t\tfoob \n\t\t\t\t\n\t\t\t\t<%block name=\"x\">\n\t\t\t\t\tblock\n\t\t\t\t</%block>\n\t\t\t\"\"\"\n\t\t)\n\n\tdef test_name_collision_blocks_nested_block(self):\n\t\tassert_raises_message(\n\t\t\texceptions.CompileException,\n\t\t\t\"%def or %block named 'x' already exists in this template\",\n\t\t\tTemplate,\n\t\t\t\"\"\"\n\t\t\t\t<%block>\n\t\t\t\t<%block name=\"x\">\n\t\t\t\t\tblock\n\t\t\t\t</%block>\n\t\t\t\t\n\t\t\t\tfoob \n\t\t\t\t\n\t\t\t\t<%block name=\"x\">\n\t\t\t\t\tblock\n\t\t\t\t</%block>\n\t\t\t\t</%block>\n\t\t\t\"\"\"\n\t\t)\n\n\tdef test_name_collision_blocks_nested_def(self):\n\t\tassert_raises_message(\n\t\t\texceptions.CompileException,\n\t\t\t\"Named block 'x' not allowed inside of def 'foo'\",\n\t\t\tTemplate,\n\t\t\t\"\"\"\n\t\t\t\t<%def name=\"foo()\">\n\t\t\t\t<%block name=\"x\">\n\t\t\t\t\tblock\n\t\t\t\t</%block>\n\t\t\t\t\n\t\t\t\tfoob \n\t\t\t\t\n\t\t\t\t<%block name=\"x\">\n\t\t\t\t\tblock\n\t\t\t\t</%block>\n\t\t\t\t</%def>\n\t\t\t\"\"\"\n\t\t)\n\n\tdef test_name_collision_block_def_toplevel(self):\n\t\tassert_raises_message(\n\t\t\texceptions.CompileException,\n\t\t\t\"%def or %block named 'x' already exists in this template\",\n\t\t\tTemplate,\n\t\t\t\"\"\"\n\t\t\t\t<%block name=\"x\">\n\t\t\t\t\tblock\n\t\t\t\t</%block>\n\t\t\t\t\n\t\t\t\tfoob \n\t\t\t\t\n\t\t\t\t<%def name=\"x()\">\n\t\t\t\t\tblock\n\t\t\t\t</%def>\n\t\t\t\"\"\"\n\t\t)\n\n\tdef test_name_collision_def_block_toplevel(self):\n\t\tassert_raises_message(\n\t\t\texceptions.CompileException,\n\t\t\t\"%def or %block named 'x' already exists in this template\",\n\t\t\tTemplate,\n\t\t\t\"\"\"\n\t\t\t\t<%def name=\"x()\">\n\t\t\t\t\tblock\n\t\t\t\t</%def>\n\n\t\t\t\tfoob \n\t\t\t\t\n\t\t\t\t<%block name=\"x\">\n\t\t\t\t\tblock\n\t\t\t\t</%block>\n\t\t\t\t\n\t\t\t\"\"\"\n\t\t)\n\n\tdef test_named_block_renders(self):\n\t\ttemplate = Template(\"\"\"\n\t\t\tabove\n\t\t\t<%block name=\"header\">\n\t\t\t\tthe header\n\t\t\t</%block>\n\t\t\tbelow\n\t\t\"\"\")\n\t\tself._do_test(template, [\"above\", \"the header\", \"below\"], \n\t\t\t\tfilters=result_lines)\n\n\tdef test_inherited_block_no_render(self):\n\t\tl = TemplateLookup()\n\t\tl.put_string(\"index\",\n\t\t\t\"\"\"\n\t\t\t\t<%inherit file=\"base\"/>\n\t\t\t\t<%block name=\"header\">\n\t\t\t\t\tindex header\n\t\t\t\t</%block>\n\t\t\t\"\"\"\n\t\t)\n\t\tl.put_string(\"base\",\"\"\"\n\t\t\tabove\n\t\t\t<%block name=\"header\">\n\t\t\t\tthe header\n\t\t\t</%block>\n\t\t\t\n\t\t\t${next.body()}\n\t\t\tbelow\n\t\t\"\"\")\n\t\tself._do_test(l.get_template(\"index\"), \n\t\t\t\t[\"above\", \"index header\", \"below\"], \n\t\t\t\tfilters=result_lines)\n\n\tdef test_no_named_in_def(self):\n\t\tassert_raises_message(\n\t\t\texceptions.CompileException,\n\t\t\t\"Named block 'y' not allowed inside of def 'q'\",\n\t\t\tTemplate,\n\t\t\t\"\"\"\n\t\t\t<%def name=\"q()\">\n\t\t\t\t<%block name=\"y\">\n\t\t\t\t</%block>\n\t\t\t</%def>\n\t\t\"\"\")\n\n\tdef test_inherited_block_nested_both(self):\n\t\tl = TemplateLookup()\n\t\tl.put_string(\"index\",\n\t\t\t\"\"\"\n\t\t\t\t<%inherit file=\"base\"/>\n\t\t\t\t<%block name=\"title\">\n\t\t\t\t\tindex title\n\t\t\t\t</%block>\n\t\t\t\t\n\t\t\t\t<%block name=\"header\">\n\t\t\t\t\tindex header\n\t\t\t\t\t${parent.header()}\n\t\t\t\t</%block>\n\t\t\t\"\"\"\n\t\t)\n\t\tl.put_string(\"base\",\"\"\"\n\t\t\tabove\n\t\t\t<%block name=\"header\">\n\t\t\t\tbase header\n\t\t\t\t<%block name=\"title\">\n\t\t\t\t\tthe title\n\t\t\t\t</%block>\n\t\t\t</%block>\n\t\t\t\n\t\t\t${next.body()}\n\t\t\tbelow\n\t\t\"\"\")\n\t\tself._do_test(l.get_template(\"index\"), \n\t\t\t\t[\"above\", \"index header\", \"base header\", \"index title\", \"below\"], \n\t\t\t\tfilters=result_lines)\n\n\tdef test_inherited_block_nested_inner_only(self):\n\t\tl = TemplateLookup()\n\t\tl.put_string(\"index\",\n\t\t\t\"\"\"\n\t\t\t\t<%inherit file=\"base\"/>\n\t\t\t\t<%block name=\"title\">\n\t\t\t\t\tindex title\n\t\t\t\t</%block>\n\t\t\t\t\n\t\t\t\"\"\"\n\t\t)\n\t\tl.put_string(\"base\",\"\"\"\n\t\t\tabove\n\t\t\t<%block name=\"header\">\n\t\t\t\tbase header\n\t\t\t\t<%block name=\"title\">\n\t\t\t\t\tthe title\n\t\t\t\t</%block>\n\t\t\t</%block>\n\t\t\t\n\t\t\t${next.body()}\n\t\t\tbelow\n\t\t\"\"\")\n\t\tself._do_test(l.get_template(\"index\"), \n\t\t\t\t[\"above\", \"base header\", \"index title\", \"below\"], \n\t\t\t\tfilters=result_lines)\n\n\tdef test_noninherited_block_no_render(self):\n\t\tl = TemplateLookup()\n\t\tl.put_string(\"index\",\n\t\t\t\"\"\"\n\t\t\t\t<%inherit file=\"base\"/>\n\t\t\t\t<%block name=\"some_thing\">\n\t\t\t\t\tsome thing\n\t\t\t\t</%block>\n\t\t\t\"\"\"\n\t\t)\n\t\tl.put_string(\"base\",\"\"\"\n\t\t\tabove\n\t\t\t<%block name=\"header\">\n\t\t\t\tthe header\n\t\t\t</%block>\n\t\t\t\n\t\t\t${next.body()}\n\t\t\tbelow\n\t\t\"\"\")\n\t\tself._do_test(l.get_template(\"index\"), \n\t\t\t\t[\"above\", \"the header\", \"some thing\", \"below\"], \n\t\t\t\tfilters=result_lines)\n\n\tdef test_no_conflict_nested_one(self):\n\t\tl = TemplateLookup()\n\t\tl.put_string(\"index\",\n\t\t\t\"\"\"\n\t\t\t\t<%inherit file=\"base\"/>\n\t\t\t\t<%block>\n\t\t\t\t\t<%block name=\"header\">\n\t\t\t\t\t\tinner header\n\t\t\t\t\t</%block>\n\t\t\t\t</%block>\n\t\t\t\"\"\"\n\t\t)\n\t\tl.put_string(\"base\",\"\"\"\n\t\t\tabove\n\t\t\t<%block name=\"header\">\n\t\t\t\tthe header\n\t\t\t</%block>\n\t\t\t\n\t\t\t${next.body()}\n\t\t\tbelow\n\t\t\"\"\")\n\t\tself._do_test(l.get_template(\"index\"), \n\t\t\t\t[\"above\", \"inner header\", \"below\"], \n\t\t\t\tfilters=result_lines)\n\n\tdef test_nested_dupe_names_raise(self):\n\t\tassert_raises_message(\n\t\t\texceptions.CompileException,\n\t\t\t\"%def or %block named 'header' already exists in this template.\",\n\t\t\tTemplate,\n\t\t\t\"\"\"\n\t\t\t\t<%inherit file=\"base\"/>\n\t\t\t\t<%block name=\"header\">\n\t\t\t\t\t<%block name=\"header\">\n\t\t\t\t\t\tinner header\n\t\t\t\t\t</%block>\n\t\t\t\t</%block>\n\t\t\t\"\"\"\n\t\t)\n\n\tdef test_two_levels_one(self):\n\t\tl = TemplateLookup()\n\t\tl.put_string(\"index\",\n\t\t\t\"\"\"\n\t\t\t\t<%inherit file=\"middle\"/>\n\t\t\t\t<%block name=\"header\">\n\t\t\t\t\tindex header\n\t\t\t\t</%block>\n\t\t\t\t<%block>\n\t\t\t\t\tindex anon\n\t\t\t\t</%block>\n\t\t\t\"\"\"\n\t\t)\n\t\tl.put_string(\"middle\", \"\"\"\n\t\t\t<%inherit file=\"base\"/>\n\t\t\t<%block>\n\t\t\t\tmiddle anon\n\t\t\t</%block>\n\t\t\t${next.body()}\n\t\t\"\"\")\n\t\tl.put_string(\"base\",\"\"\"\n\t\t\tabove\n\t\t\t<%block name=\"header\">\n\t\t\t\tthe header\n\t\t\t</%block>\n\t\t\t\n\t\t\t${next.body()}\n\t\t\tbelow\n\t\t\"\"\")\n\t\tself._do_test(l.get_template(\"index\"), \n\t\t\t\t[\"above\", \"index header\", \"middle anon\", \n\t\t\t\t\"index anon\", \"below\"], \n\t\t\t\tfilters=result_lines)\n\n\tdef test_filter(self):\n\t\ttemplate = Template(\"\"\"\n\t\t\t<%block filter=\"h\">\n\t\t\t\t<html>\n\t\t\t</%block>\n\t\t\"\"\")\n\t\tself._do_test(template, [u'&lt;html&gt;'], \n\t\t\t\t\tfilters=result_lines)\n\n\tdef test_anon_in_named(self):\n\t\ttemplate = Template(\"\"\"\n\t\t\t<%block name=\"x\">\n\t\t\t\touter above\n\t\t\t\t<%block>\n\t\t\t\t\tinner\n\t\t\t\t</%block>\n\t\t\t\touter below\n\t\t\t</%block>\n\t\t\"\"\")\n\t\tself._test_block_in_block(template)\n\n\tdef test_named_in_anon(self):\n\t\ttemplate = Template(\"\"\"\n\t\t\t<%block>\n\t\t\t\touter above\n\t\t\t\t<%block name=\"x\">\n\t\t\t\t\tinner\n\t\t\t\t</%block>\n\t\t\t\touter below\n\t\t\t</%block>\n\t\t\"\"\")\n\t\tself._test_block_in_block(template)\n\n\tdef test_anon_in_anon(self):\n\t\ttemplate = Template(\"\"\"\n\t\t\t<%block>\n\t\t\t\touter above\n\t\t\t\t<%block>\n\t\t\t\t\tinner\n\t\t\t\t</%block>\n\t\t\t\touter below\n\t\t\t</%block>\n\t\t\"\"\")\n\t\tself._test_block_in_block(template)\n\n\tdef test_named_in_named(self):\n\t\ttemplate = Template(\"\"\"\n\t\t\t<%block name=\"x\">\n\t\t\t\touter above\n\t\t\t\t<%block name=\"y\">\n\t\t\t\t\tinner\n\t\t\t\t</%block>\n\t\t\t\touter below\n\t\t\t</%block>\n\t\t\"\"\")\n\t\tself._test_block_in_block(template)\n\n\tdef _test_block_in_block(self, template):\n\t\tself._do_test(template, \n\t\t\t[\"outer above\", \"inner\", \"outer below\"],\n\t\t\tfilters=result_lines\n\t\t)\n\n\tdef test_iteration(self):\n\t\tt = Template(\"\"\"\n\t\t\t% for i in (1, 2, 3):\n\t\t\t\t<%block>${i}</%block>\n\t\t\t% endfor\n\t\t\"\"\")\n\t\tself._do_test(t, \n\t\t\t[\"1\", \"2\", \"3\"],\n\t\t\tfilters=result_lines\n\t\t)\n\n\tdef test_conditional(self):\n\t\tt = Template(\"\"\"\n\t\t\t% if True:\n\t\t\t\t<%block>true</%block>\n\t\t\t% endif\n\n\t\t\t% if False:\n\t\t\t\t<%block>false</%block>\n\t\t\t% endif\n\t\t\"\"\")\n\t\tself._do_test(t, \n\t\t\t[\"true\"],\n\t\t\tfilters=result_lines\n\t\t)\n\n\tdef test_block_overridden_by_def(self):\n\t\tl = TemplateLookup()\n\t\tl.put_string(\"index\",\n\t\t\t\"\"\"\n\t\t\t\t<%inherit file=\"base\"/>\n\t\t\t\t<%def name=\"header()\">\n\t\t\t\t\tinner header\n\t\t\t\t</%def>\n\t\t\t\"\"\"\n\t\t)\n\t\tl.put_string(\"base\",\"\"\"\n\t\t\tabove\n\t\t\t<%block name=\"header\">\n\t\t\t\tthe header\n\t\t\t</%block>\n\t\t\t\n\t\t\t${next.body()}\n\t\t\tbelow\n\t\t\"\"\")\n\t\tself._do_test(l.get_template(\"index\"), \n\t\t\t\t[\"above\", \"inner header\", \"below\"], \n\t\t\t\tfilters=result_lines)\n\n\tdef test_def_overridden_by_block(self):\n\t\tl = TemplateLookup()\n\t\tl.put_string(\"index\",\n\t\t\t\"\"\"\n\t\t\t\t<%inherit file=\"base\"/>\n\t\t\t\t<%block name=\"header\">\n\t\t\t\t\tinner header\n\t\t\t\t</%block>\n\t\t\t\"\"\"\n\t\t)\n\t\tl.put_string(\"base\",\"\"\"\n\t\t\tabove\n\t\t\t${self.header()}\n\t\t\t<%def name=\"header()\">\n\t\t\t\tthe header\n\t\t\t</%def>\n\t\t\t\n\t\t\t${next.body()}\n\t\t\tbelow\n\t\t\"\"\")\n\t\tself._do_test(l.get_template(\"index\"), \n\t\t\t\t[\"above\", \"inner header\", \"below\"], \n\t\t\t\tfilters=result_lines)\n\n\tdef test_block_args(self):\n\t\tl = TemplateLookup()\n\t\tl.put_string(\"caller\", \"\"\"\n\t\t\n\t\t\t<%include file=\"callee\" args=\"val1='3', val2='4'\"/>\n\t\t\t\n\t\t\"\"\")\n\t\tl.put_string(\"callee\", \"\"\"\n\t\t\t<%page args=\"val1, val2\"/>\n\t\t\t<%block name=\"foob\" args=\"val1, val2\">\n\t\t\t\tfoob, ${val1}, ${val2}\n\t\t\t</%block>\n\t\t\"\"\")\n\t\tself._do_test(\n\t\t\tl.get_template(\"caller\"),\n\t\t\t[u'foob, 3, 4'],\n\t\t\tfilters=result_lines\n\t\t)\n\n\tdef test_block_variables_contextual(self):\n\t\tt = Template(\"\"\"\t\t\t\n\t\t\t<%block name=\"foob\" >\n\t\t\t\tfoob, ${val1}, ${val2}\n\t\t\t</%block>\n\t\t\"\"\")\n\t\tself._do_test(\n\t\t\tt,\n\t\t\t[u'foob, 3, 4'],\n\t\t\ttemplate_args={'val1':3, 'val2':4},\n\t\t\tfilters=result_lines\n\t\t)\n\n\tdef test_block_args_contextual(self):\n\t\tt = Template(\"\"\"\t\t\t\n\t\t\t<%page args=\"val1\"/>\n\t\t\t<%block name=\"foob\" args=\"val1\">\n\t\t\t\tfoob, ${val1}, ${val2}\n\t\t\t</%block>\n\t\t\"\"\")\n\t\tself._do_test(\n\t\t\tt,\n\t\t\t[u'foob, 3, 4'],\n\t\t\ttemplate_args={'val1':3, 'val2':4},\n\t\t\tfilters=result_lines\n\t\t)\n\n\tdef test_block_pageargs_contextual(self):\n\t\tt = Template(\"\"\"\t\t\t\n\t\t\t<%block name=\"foob\">\n\t\t\t\tfoob, ${pageargs['val1']}, ${pageargs['val2']}\n\t\t\t</%block>\n\t\t\"\"\")\n\t\tself._do_test(\n\t\t\tt,\n\t\t\t[u'foob, 3, 4'],\n\t\t\ttemplate_args={'val1':3, 'val2':4},\n\t\t\tfilters=result_lines\n\t\t)\n\n\tdef test_block_pageargs(self):\n\t\tl = TemplateLookup()\n\t\tl.put_string(\"caller\", \"\"\"\n\t\t\n\t\t\t<%include file=\"callee\" args=\"val1='3', val2='4'\"/>\n\t\t\t\n\t\t\"\"\")\n\t\tl.put_string(\"callee\", \"\"\"\n\t\t\t<%block name=\"foob\">\n\t\t\t\tfoob, ${pageargs['val1']}, ${pageargs['val2']}\n\t\t\t</%block>\n\t\t\"\"\")\n\t\tself._do_test(\n\t\t\tl.get_template(\"caller\"),\n\t\t\t[u'foob, 3, 4'],\n\t\t\tfilters=result_lines\n", "description": "\n\t\t\t\t<%namespace name=\"foo\">\n\t\t\t\t\t<%block>\n\t\t\t\t\t\tblock\n\t\t\t\t\t</%block>\n\t\t\t\t</%namespace>\n\t\t\t", "category": "def", "imports": ["from mako.template import Template", "from mako.lookup import TemplateLookup", "from mako import exceptions", "from test import TemplateTest, assert_raises, assert_raises_message", "from util import flatten_result, result_lines"]}], [{"term": "class", "name": "class_SslDummy:", "data": "class _SslDummy:\n\tdef __getattr__(self, name): ...\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Optional", "\tfrom SocketServer import ThreadingMixIn, ForkingMixIn", "\tfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler", "\tfrom socketserver import ThreadingMixIn, ForkingMixIn", "\tfrom http.server import HTTPServer, BaseHTTPRequestHandler"]}, {"term": "class", "name": "WSGIRequestHandler", "data": "class WSGIRequestHandler(BaseHTTPRequestHandler):\n\t@property\n\tdef server_version(self): ...\n\tdef make_environ(self): ...\n\tenviron: Any\n\tclose_connection: Any\n\tdef run_wsgi(self): ...\n\tdef handle(self): ...\n\tdef initiate_shutdown(self): ...\n\tdef connection_dropped(self, error, environ: Optional[Any] = ...): ...\n\traw_requestline: Any\n\tdef handle_one_request(self): ...\n\tdef send_response(self, code, message: Optional[Any] = ...): ...\n\tdef version_string(self): ...\n\tdef address_string(self): ...\n\tdef port_integer(self): ...\n\tdef log_request(self, code: object = ..., size: object = ...) -> None: ...\n\tdef log_error(self, *args): ...\n\tdef log_message(self, format, *args): ...\n\tdef log(self, type, message, *args): ...\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Optional", "\tfrom SocketServer import ThreadingMixIn, ForkingMixIn", "\tfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler", "\tfrom socketserver import ThreadingMixIn, ForkingMixIn", "\tfrom http.server import HTTPServer, BaseHTTPRequestHandler"]}, {"term": "def", "name": "load_ssl_context", "data": "def load_ssl_context(cert_file, pkey_file: Optional[Any] = ..., protocol: Optional[Any] = ...): ...\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Optional", "\tfrom SocketServer import ThreadingMixIn, ForkingMixIn", "\tfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler", "\tfrom socketserver import ThreadingMixIn, ForkingMixIn", "\tfrom http.server import HTTPServer, BaseHTTPRequestHandler"]}, {"term": "class", "name": "class_SSLContext:", "data": "class _SSLContext:\n\tdef __init__(self, protocol): ...\n\tdef load_cert_chain(self, certfile, keyfile: Optional[Any] = ..., password: Optional[Any] = ...): ...\n\tdef wrap_socket(self, sock, **kwargs): ...\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Optional", "\tfrom SocketServer import ThreadingMixIn, ForkingMixIn", "\tfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler", "\tfrom socketserver import ThreadingMixIn, ForkingMixIn", "\tfrom http.server import HTTPServer, BaseHTTPRequestHandler"]}, {"term": "def", "name": "select_ip_version", "data": "def select_ip_version(host, port): ...\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Optional", "\tfrom SocketServer import ThreadingMixIn, ForkingMixIn", "\tfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler", "\tfrom socketserver import ThreadingMixIn, ForkingMixIn", "\tfrom http.server import HTTPServer, BaseHTTPRequestHandler"]}, {"term": "class", "name": "BaseWSGIServer", "data": "class BaseWSGIServer(HTTPServer):\n\tmultithread: Any\n\tmultiprocess: Any\n\trequest_queue_size: Any\n\taddress_family: Any\n\tapp: Any\n\tpassthrough_errors: Any\n\tshutdown_signal: Any\n\thost: Any\n\tport: Any\n\tsocket: Any\n\tserver_address: Any\n\tssl_context: Any\n\tdef __init__(self, host, port, app, handler: Optional[Any] = ..., passthrough_errors: bool = ...,\n\t\t\t\t ssl_context: Optional[Any] = ..., fd: Optional[Any] = ...): ...\n\tdef log(self, type, message, *args): ...\n\tdef serve_forever(self): ...\n\tdef handle_error(self, request, client_address): ...\n\tdef get_request(self): ...\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Optional", "\tfrom SocketServer import ThreadingMixIn, ForkingMixIn", "\tfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler", "\tfrom socketserver import ThreadingMixIn, ForkingMixIn", "\tfrom http.server import HTTPServer, BaseHTTPRequestHandler"]}, {"term": "class", "name": "ThreadedWSGIServer", "data": "class ThreadedWSGIServer(ThreadingMixIn, BaseWSGIServer):\n\tmultithread: Any\n\tdaemon_threads: Any\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Optional", "\tfrom SocketServer import ThreadingMixIn, ForkingMixIn", "\tfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler", "\tfrom socketserver import ThreadingMixIn, ForkingMixIn", "\tfrom http.server import HTTPServer, BaseHTTPRequestHandler"]}, {"term": "class", "name": "ForkingWSGIServer", "data": "class ForkingWSGIServer(ForkingMixIn, BaseWSGIServer):\n\tmultiprocess: Any\n\tmax_children: Any\n\tdef __init__(self, host, port, app, processes: int = ..., handler: Optional[Any] = ..., passthrough_errors: bool = ...,\n\t\t\t\t ssl_context: Optional[Any] = ..., fd: Optional[Any] = ...): ...\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Optional", "\tfrom SocketServer import ThreadingMixIn, ForkingMixIn", "\tfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler", "\tfrom socketserver import ThreadingMixIn, ForkingMixIn", "\tfrom http.server import HTTPServer, BaseHTTPRequestHandler"]}, {"term": "def", "name": "make_server", "data": "def make_server(host: Optional[Any] = ..., port: Optional[Any] = ..., app: Optional[Any] = ..., threaded: bool = ...,\n\t\t\t\tprocesses: int = ..., request_handler: Optional[Any] = ..., passthrough_errors: bool = ...,\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Optional", "\tfrom SocketServer import ThreadingMixIn, ForkingMixIn", "\tfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler", "\tfrom socketserver import ThreadingMixIn, ForkingMixIn", "\tfrom http.server import HTTPServer, BaseHTTPRequestHandler"]}, {"term": "def", "name": "run_simple", "data": "def run_simple(hostname, port, application, use_reloader: bool = ..., use_debugger: bool = ..., use_evalex: bool = ...,\n\t\t\t   extra_files: Optional[Any] = ..., reloader_interval: int = ..., reloader_type: str = ..., threaded: bool = ...,\n\t\t\t   processes: int = ..., request_handler: Optional[Any] = ..., static_files: Optional[Any] = ...,\n", "description": null, "category": "def", "imports": ["import sys", "from typing import Any, Optional", "\tfrom SocketServer import ThreadingMixIn, ForkingMixIn", "\tfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler", "\tfrom socketserver import ThreadingMixIn, ForkingMixIn", "\tfrom http.server import HTTPServer, BaseHTTPRequestHandler"]}], [{"term": "def", "name": "symtable", "data": "def symtable(code, filename, compile_type):\n\ttop = _symtable.symtable(code, filename, compile_type)\n\treturn _newSymbolTable(top, filename)\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "classSymbolTableFactory:", "data": "class SymbolTableFactory:\n\tdef __init__(self):\n\t\tself.__memo = weakref.WeakValueDictionary()\n\n\tdef new(self, table, filename):\n\t\tif table.type == _symtable.TYPE_FUNCTION:\n\t\t\treturn Function(table, filename)\n\t\tif table.type == _symtable.TYPE_CLASS:\n\t\t\treturn Class(table, filename)\n\t\treturn SymbolTable(table, filename)\n\n\tdef __call__(self, table, filename):\n\t\tkey = table, filename\n\t\tobj = self.__memo.get(key, None)\n\t\tif obj is None:\n\t\t\tobj = self.__memo[key] = self.new(table, filename)\n\t\treturn obj\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "SymbolTable", "data": "class SymbolTable(object):\n\n\tdef __init__(self, raw_table, filename):\n\t\tself._table = raw_table\n\t\tself._filename = filename\n\t\tself._symbols = {}\n\n\tdef __repr__(self):\n\t\tif self.__class__ == SymbolTable:\n\t\t\tkind = \"\"\n\t\telse:\n\t\t\tkind = \"%s \" % self.__class__.__name__\n\n\t\tif self._table.name == \"global\":\n\t\t\treturn \"<{0}SymbolTable for module {1}>\".format(kind, self._filename)\n\t\telse:\n\t\t\treturn \"<{0}SymbolTable for {1} in {2}>\".format(kind,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself._table.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself._filename)\n\n\tdef get_type(self):\n\t\tif self._table.type == _symtable.TYPE_MODULE:\n\t\t\treturn \"module\"\n\t\tif self._table.type == _symtable.TYPE_FUNCTION:\n\t\t\treturn \"function\"\n\t\tif self._table.type == _symtable.TYPE_CLASS:\n\t\t\treturn \"class\"\n\t\tassert self._table.type in (1, 2, 3), \\\n\t\t\t   \"unexpected type: {0}\".format(self._table.type)\n\n\tdef get_id(self):\n\t\treturn self._table.id\n\n\tdef get_name(self):\n\t\treturn self._table.name\n\n\tdef get_lineno(self):\n\t\treturn self._table.lineno\n\n\tdef is_optimized(self):\n\t\treturn bool(self._table.type == _symtable.TYPE_FUNCTION)\n\n\tdef is_nested(self):\n\t\treturn bool(self._table.nested)\n\n\tdef has_children(self):\n\t\treturn bool(self._table.children)\n\n\tdef has_exec(self):\n\t\t\"\"\"Return true if the scope uses exec.  Deprecated method.\"\"\"\n\t\treturn False\n\n\tdef get_identifiers(self):\n\t\treturn self._table.symbols.keys()\n\n\tdef lookup(self, name):\n\t\tsym = self._symbols.get(name)\n\t\tif sym is None:\n\t\t\tflags = self._table.symbols[name]\n\t\t\tnamespaces = self.__check_children(name)\n\t\t\tsym = self._symbols[name] = Symbol(name, flags, namespaces)\n\t\treturn sym\n\n\tdef get_symbols(self):\n\t\treturn [self.lookup(ident) for ident in self.get_identifiers()]\n\n\tdef __check_children(self, name):\n\t\treturn [_newSymbolTable(st, self._filename)\n\t\t\t\tfor st in self._table.children\n\t\t\t\tif st.name == name]\n\n\tdef get_children(self):\n\t\treturn [_newSymbolTable(st, self._filename)\n\t\t\t\tfor st in self._table.children]\n\n", "description": "Return true if the scope uses exec.  Deprecated method.", "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "Function", "data": "class Function(SymbolTable):\n\n\t# Default values for instance variables\n\t__params = None\n\t__locals = None\n\t__frees = None\n\t__globals = None\n\n\tdef __idents_matching(self, test_func):\n\t\treturn tuple(ident for ident in self.get_identifiers()\n\t\t\t\t\t if test_func(self._table.symbols[ident]))\n\n\tdef get_parameters(self):\n\t\tif self.__params is None:\n\t\t\tself.__params = self.__idents_matching(lambda x:x & DEF_PARAM)\n\t\treturn self.__params\n\n\tdef get_locals(self):\n\t\tif self.__locals is None:\n\t\t\tlocs = (LOCAL, CELL)\n\t\t\ttest = lambda x: ((x >> SCOPE_OFF) & SCOPE_MASK) in locs\n\t\t\tself.__locals = self.__idents_matching(test)\n\t\treturn self.__locals\n\n\tdef get_globals(self):\n\t\tif self.__globals is None:\n\t\t\tglob = (GLOBAL_IMPLICIT, GLOBAL_EXPLICIT)\n\t\t\ttest = lambda x:((x >> SCOPE_OFF) & SCOPE_MASK) in glob\n\t\t\tself.__globals = self.__idents_matching(test)\n\t\treturn self.__globals\n\n\tdef get_frees(self):\n\t\tif self.__frees is None:\n\t\t\tis_free = lambda x:((x >> SCOPE_OFF) & SCOPE_MASK) == FREE\n\t\t\tself.__frees = self.__idents_matching(is_free)\n\t\treturn self.__frees\n\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "Class", "data": "class Class(SymbolTable):\n\n\t__methods = None\n\n\tdef get_methods(self):\n\t\tif self.__methods is None:\n\t\t\td = {}\n\t\t\tfor st in self._table.children:\n\t\t\t\td[st.name] = 1\n\t\t\tself.__methods = tuple(d)\n\t\treturn self.__methods\n\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "Symbol", "data": "class Symbol(object):\n\n\tdef __init__(self, name, flags, namespaces=None):\n\t\tself.__name = name\n\t\tself.__flags = flags\n\t\tself.__scope = (flags >> SCOPE_OFF) & SCOPE_MASK # like PyST_GetScope()\n\t\tself.__namespaces = namespaces or ()\n\n\tdef __repr__(self):\n\t\treturn \"<symbol {0!r}>\".format(self.__name)\n\n\tdef get_name(self):\n\t\treturn self.__name\n\n\tdef is_referenced(self):\n\t\treturn bool(self.__flags & _symtable.USE)\n\n\tdef is_parameter(self):\n\t\treturn bool(self.__flags & DEF_PARAM)\n\n\tdef is_global(self):\n\t\treturn bool(self.__scope in (GLOBAL_IMPLICIT, GLOBAL_EXPLICIT))\n\n\tdef is_declared_global(self):\n\t\treturn bool(self.__scope == GLOBAL_EXPLICIT)\n\n\tdef is_local(self):\n\t\treturn bool(self.__flags & DEF_BOUND)\n\n\tdef is_annotated(self):\n\t\treturn bool(self.__flags & DEF_ANNOT)\n\n\tdef is_free(self):\n\t\treturn bool(self.__scope == FREE)\n\n\tdef is_imported(self):\n\t\treturn bool(self.__flags & DEF_IMPORT)\n\n\tdef is_assigned(self):\n\t\treturn bool(self.__flags & DEF_LOCAL)\n\n\tdef is_namespace(self):\n\t\t\"\"\"Returns true if name binding introduces new namespace.\n\n\t\tIf the name is used as the target of a function or class\n\t\tstatement, this will be true.\n\n\t\tNote that a single name can be bound to multiple objects.  If\n\t\tis_namespace() is true, the name may also be bound to other\n\t\tobjects, like an int or list, that does not introduce a new\n\t\tnamespace.\n\t\t\"\"\"\n\t\treturn bool(self.__namespaces)\n\n\tdef get_namespaces(self):\n\t\t\"\"\"Return a list of namespaces bound to this name\"\"\"\n\t\treturn self.__namespaces\n\n\tdef get_namespace(self):\n\t\t\"\"\"Returns the single namespace bound to this name.\n\n\t\tRaises ValueError if the name is bound to multiple namespaces.\n\t\t\"\"\"\n\t\tif len(self.__namespaces) != 1:\n\t\t\traise ValueError(\"name is bound to multiple namespaces\")\n\t\treturn self.__namespaces[0]\n", "description": "Returns true if name binding introduces new namespace.\n\n\t\tIf the name is used as the target of a function or class\n\t\tstatement, this will be true.\n\n\t\tNote that a single name can be bound to multiple objects.  If\n\t\tis_namespace() is true, the name may also be bound to other\n\t\tobjects, like an int or list, that does not introduce a new\n\t\tnamespace.\n\t\t", "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef is_imported(self):", "\timport os, sys"]}], [{"term": "class", "name": "UserString", "data": "class UserString(collections.Sequence):\n\tdef __init__(self, seq):\n\t\tif isinstance(seq, basestring):\n\t\t\tself.data = seq\n\t\telif isinstance(seq, UserString):\n\t\t\tself.data = seq.data[:]\n\t\telse:\n\t\t\tself.data = str(seq)\n\tdef __str__(self): return str(self.data)\n\tdef __repr__(self): return repr(self.data)\n\tdef __int__(self): return int(self.data)\n\tdef __long__(self): return long(self.data)\n\tdef __float__(self): return float(self.data)\n\tdef __complex__(self): return complex(self.data)\n\tdef __hash__(self): return hash(self.data)\n\n\tdef __cmp__(self, string):\n\t\tif isinstance(string, UserString):\n\t\t\treturn cmp(self.data, string.data)\n\t\telse:\n\t\t\treturn cmp(self.data, string)\n\tdef __contains__(self, char):\n\t\treturn char in self.data\n\n\tdef __len__(self): return len(self.data)\n\tdef __getitem__(self, index): return self.__class__(self.data[index])\n\tdef __getslice__(self, start, end):\n\t\tstart = max(start, 0); end = max(end, 0)\n\t\treturn self.__class__(self.data[start:end])\n\n\tdef __add__(self, other):\n\t\tif isinstance(other, UserString):\n\t\t\treturn self.__class__(self.data + other.data)\n\t\telif isinstance(other, basestring):\n\t\t\treturn self.__class__(self.data + other)\n\t\telse:\n\t\t\treturn self.__class__(self.data + str(other))\n\tdef __radd__(self, other):\n\t\tif isinstance(other, basestring):\n\t\t\treturn self.__class__(other + self.data)\n\t\telse:\n\t\t\treturn self.__class__(str(other) + self.data)\n\tdef __mul__(self, n):\n\t\treturn self.__class__(self.data*n)\n\t__rmul__ = __mul__\n\tdef __mod__(self, args):\n\t\treturn self.__class__(self.data % args)\n\n\t# the following methods are defined in alphabetical order:\n\tdef capitalize(self): return self.__class__(self.data.capitalize())\n\tdef center(self, width, *args):\n\t\treturn self.__class__(self.data.center(width, *args))\n\tdef count(self, sub, start=0, end=sys.maxint):\n\t\treturn self.data.count(sub, start, end)\n\tdef decode(self, encoding=None, errors=None): # XXX improve this?\n\t\tif encoding:\n\t\t\tif errors:\n\t\t\t\treturn self.__class__(self.data.decode(encoding, errors))\n\t\t\telse:\n\t\t\t\treturn self.__class__(self.data.decode(encoding))\n\t\telse:\n\t\t\treturn self.__class__(self.data.decode())\n\tdef encode(self, encoding=None, errors=None): # XXX improve this?\n\t\tif encoding:\n\t\t\tif errors:\n\t\t\t\treturn self.__class__(self.data.encode(encoding, errors))\n\t\t\telse:\n\t\t\t\treturn self.__class__(self.data.encode(encoding))\n\t\telse:\n\t\t\treturn self.__class__(self.data.encode())\n\tdef endswith(self, suffix, start=0, end=sys.maxint):\n\t\treturn self.data.endswith(suffix, start, end)\n\tdef expandtabs(self, tabsize=8):\n\t\treturn self.__class__(self.data.expandtabs(tabsize))\n\tdef find(self, sub, start=0, end=sys.maxint):\n\t\treturn self.data.find(sub, start, end)\n\tdef index(self, sub, start=0, end=sys.maxint):\n\t\treturn self.data.index(sub, start, end)\n\tdef isalpha(self): return self.data.isalpha()\n\tdef isalnum(self): return self.data.isalnum()\n\tdef isdecimal(self): return self.data.isdecimal()\n\tdef isdigit(self): return self.data.isdigit()\n\tdef islower(self): return self.data.islower()\n\tdef isnumeric(self): return self.data.isnumeric()\n\tdef isspace(self): return self.data.isspace()\n\tdef istitle(self): return self.data.istitle()\n\tdef isupper(self): return self.data.isupper()\n\tdef join(self, seq): return self.data.join(seq)\n\tdef ljust(self, width, *args):\n\t\treturn self.__class__(self.data.ljust(width, *args))\n\tdef lower(self): return self.__class__(self.data.lower())\n\tdef lstrip(self, chars=None): return self.__class__(self.data.lstrip(chars))\n\tdef partition(self, sep):\n\t\treturn self.data.partition(sep)\n\tdef replace(self, old, new, maxsplit=-1):\n\t\treturn self.__class__(self.data.replace(old, new, maxsplit))\n\tdef rfind(self, sub, start=0, end=sys.maxint):\n\t\treturn self.data.rfind(sub, start, end)\n\tdef rindex(self, sub, start=0, end=sys.maxint):\n\t\treturn self.data.rindex(sub, start, end)\n\tdef rjust(self, width, *args):\n\t\treturn self.__class__(self.data.rjust(width, *args))\n\tdef rpartition(self, sep):\n\t\treturn self.data.rpartition(sep)\n\tdef rstrip(self, chars=None): return self.__class__(self.data.rstrip(chars))\n\tdef split(self, sep=None, maxsplit=-1):\n\t\treturn self.data.split(sep, maxsplit)\n\tdef rsplit(self, sep=None, maxsplit=-1):\n\t\treturn self.data.rsplit(sep, maxsplit)\n\tdef splitlines(self, keepends=0): return self.data.splitlines(keepends)\n\tdef startswith(self, prefix, start=0, end=sys.maxint):\n\t\treturn self.data.startswith(prefix, start, end)\n\tdef strip(self, chars=None): return self.__class__(self.data.strip(chars))\n\tdef swapcase(self): return self.__class__(self.data.swapcase())\n\tdef title(self): return self.__class__(self.data.title())\n\tdef translate(self, *args):\n\t\treturn self.__class__(self.data.translate(*args))\n\tdef upper(self): return self.__class__(self.data.upper())\n\tdef zfill(self, width): return self.__class__(self.data.zfill(width))\n", "description": null, "category": "def", "imports": ["import sys", "import collections", "\t\tfrom warnings import warnpy3k", "\timport os", "\t\tfrom test import test_support", "\t__import__('test.test_' + called_as.lower())"]}, {"term": "class", "name": "MutableString", "data": "class MutableString(UserString, collections.MutableSequence):\n\t\"\"\"mutable string objects\n\n\tPython strings are immutable objects.  This has the advantage, that\n\tstrings may be used as dictionary keys.  If this property isn't needed\n\tand you insist on changing string values in place instead, you may cheat\n\tand use MutableString.\n\n\tBut the purpose of this class is an educational one: to prevent\n\tpeople from inventing their own mutable string class derived\n\tfrom UserString and than forget thereby to remove (override) the\n\t__hash__ method inherited from UserString.  This would lead to\n\terrors that would be very hard to track down.\n\n\tA faster and better solution is to rewrite your program using lists.\"\"\"\n\tdef __init__(self, string=\"\"):\n\t\tfrom warnings import warnpy3k\n\t\twarnpy3k('the class UserString.MutableString has been removed in '\n\t\t\t\t\t'Python 3.0', stacklevel=2)\n\t\tself.data = string\n\n\t# We inherit object.__hash__, so we must deny this explicitly\n\t__hash__ = None\n\n\tdef __setitem__(self, index, sub):\n\t\tif isinstance(index, slice):\n\t\t\tif isinstance(sub, UserString):\n\t\t\t\tsub = sub.data\n\t\t\telif not isinstance(sub, basestring):\n\t\t\t\tsub = str(sub)\n\t\t\tstart, stop, step = index.indices(len(self.data))\n\t\t\tif step == -1:\n\t\t\t\tstart, stop = stop+1, start+1\n\t\t\t\tsub = sub[::-1]\n\t\t\telif step != 1:\n\t\t\t\t# XXX(twouters): I guess we should be reimplementing\n\t\t\t\t# the extended slice assignment/deletion algorithm here...\n\t\t\t\traise TypeError, \"invalid step in slicing assignment\"\n\t\t\tstart = min(start, stop)\n\t\t\tself.data = self.data[:start] + sub + self.data[stop:]\n\t\telse:\n\t\t\tif index < 0:\n\t\t\t\tindex += len(self.data)\n\t\t\tif index < 0 or index >= len(self.data): raise IndexError\n\t\t\tself.data = self.data[:index] + sub + self.data[index+1:]\n\tdef __delitem__(self, index):\n\t\tif isinstance(index, slice):\n\t\t\tstart, stop, step = index.indices(len(self.data))\n\t\t\tif step == -1:\n\t\t\t\tstart, stop = stop+1, start+1\n\t\t\telif step != 1:\n\t\t\t\t# XXX(twouters): see same block in __setitem__\n\t\t\t\traise TypeError, \"invalid step in slicing deletion\"\n\t\t\tstart = min(start, stop)\n\t\t\tself.data = self.data[:start] + self.data[stop:]\n\t\telse:\n\t\t\tif index < 0:\n\t\t\t\tindex += len(self.data)\n\t\t\tif index < 0 or index >= len(self.data): raise IndexError\n\t\t\tself.data = self.data[:index] + self.data[index+1:]\n\tdef __setslice__(self, start, end, sub):\n\t\tstart = max(start, 0); end = max(end, 0)\n\t\tif isinstance(sub, UserString):\n\t\t\tself.data = self.data[:start]+sub.data+self.data[end:]\n\t\telif isinstance(sub, basestring):\n\t\t\tself.data = self.data[:start]+sub+self.data[end:]\n\t\telse:\n\t\t\tself.data =  self.data[:start]+str(sub)+self.data[end:]\n\tdef __delslice__(self, start, end):\n\t\tstart = max(start, 0); end = max(end, 0)\n\t\tself.data = self.data[:start] + self.data[end:]\n\tdef immutable(self):\n\t\treturn UserString(self.data)\n\tdef __iadd__(self, other):\n\t\tif isinstance(other, UserString):\n\t\t\tself.data += other.data\n\t\telif isinstance(other, basestring):\n\t\t\tself.data += other\n\t\telse:\n\t\t\tself.data += str(other)\n\t\treturn self\n\tdef __imul__(self, n):\n\t\tself.data *= n\n\t\treturn self\n\tdef insert(self, index, value):\n\t\tself[index:index] = value\n", "description": "mutable string objects\n\n\tPython strings are immutable objects.  This has the advantage, that\n\tstrings may be used as dictionary keys.  If this property isn't needed\n\tand you insist on changing string values in place instead, you may cheat\n\tand use MutableString.\n\n\tBut the purpose of this class is an educational one: to prevent\n\tpeople from inventing their own mutable string class derived\n\tfrom UserString and than forget thereby to remove (override) the\n\t__hash__ method inherited from UserString.  This would lead to\n\terrors that would be very hard to track down.\n\n\tA faster and better solution is to rewrite your program using lists.", "category": "def", "imports": ["import sys", "import collections", "\t\tfrom warnings import warnpy3k", "\timport os", "\t\tfrom test import test_support", "\t__import__('test.test_' + called_as.lower())"]}], [{"term": "def", "name": "_parents", "data": "def _parents(node):\n\twhile node.parent:\n\t\tnode = node.parent\n\t\tyield node\n", "description": null, "category": "def", "imports": ["from __future__ import print_function", "import os.path", "import posixpath", "import re", "\tfrom urllib.request import url2pathname  # pylint: disable=deprecated-module", "\tfrom urllib import url2pathname  # pylint: disable=deprecated-module", "from docutils import nodes", "from sphinx import addnodes, util, builders", "from sphinx.locale import admonitionlabels", "from odoo.tools import pycompat", "\t\t\t'important': 'alert-warning',", "\tvisit_important = lambda self, node: self.visit_admonition(node, 'important')", "\tdepart_important = depart_admonition"]}, {"term": "class", "name": "BootstrapTranslator", "data": "class BootstrapTranslator(nodes.NodeVisitor, object):\n\thead_prefix = 'head_prefix'\n\thead = 'head'\n\tstylesheet = 'stylesheet'\n\tbody_prefix = 'body_prefix'\n\tbody_pre_docinfo = 'body_pre_docinfo'\n\tdocinfo = 'docinfo'\n\tbody_suffix = 'body_suffix'\n\tsubtitle = 'subtitle'\n\theader = 'header'\n\tfooter = 'footer'\n\thtml_prolog = 'html_prolog'\n\thtml_head = 'html_head'\n\thtml_title = 'html_title'\n\thtml_subtitle = 'html_subtitle'\n\n\t# <meta> tags\n\tmeta = [\n\t\t'<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">',\n\t\t'<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">'\n\t]\n\n\tdef __init__(self, document, builder):\n\t\t# order of parameter swapped between Sphinx 1.x and 2.x, check if\n\t\t# we're running 1.x and swap back\n\t\tif not isinstance(builder, builders.Builder):\n\t\t\tbuilder, document = document, builder\n\t\tsuper(BootstrapTranslator, self).__init__(document)\n\t\tself.builder = builder\n\t\tself.body = []\n\t\tself.fragment = self.body\n\t\tself.html_body = self.body\n\t\t# document title\n\t\tself.title = []\n\t\tself.start_document_title = 0\n\t\tself.first_title = False\n\n\t\tself.context = []\n\t\tself.section_level = 0\n\n\t\tself.config = self.builder.config\n\t\tself.highlightlang = self.highlightlang_base = self.builder.config.highlight_language\n\t\tself.highlightopts = getattr(builder.config, 'highlight_options', {})\n\n\t\tself.first_param = 1\n\t\tself.optional_param_level = 0\n\t\tself.required_params_left = 0\n\t\tself.param_separator = ','\n\n\tdef encode(self, text):\n\t\treturn pycompat.text_type(text).translate({\n\t\t\tord('&'): u'&amp;',\n\t\t\tord('<'): u'&lt;',\n\t\t\tord('\"'): u'&quot;',\n\t\t\tord('>'): u'&gt;',\n\t\t\t0xa0: u'&nbsp;'\n\t\t})\n\n\tdef starttag(self, node, tagname, **attributes):\n\t\ttagname = pycompat.text_type(tagname).lower()\n\n\t\t# extract generic attributes\n\t\tattrs = {name.lower(): value for name, value in attributes.items()}\n\t\tattrs.update(\n\t\t\t(name, value) for name, value in node.attributes.items()\n\t\t\tif name.startswith('data-')\n\t\t)\n\n\t\tprefix = []\n\t\tpostfix = []\n\n\t\t# handle possibly multiple ids\n\t\tassert 'id' not in attrs, \"starttag can't be passed a single id attribute, use a list of ids\"\n\t\tids = node.get('ids', []) + attrs.pop('ids', [])\n\t\tif ids:\n\t\t\t_ids = iter(ids)\n\t\t\tattrs['id'] = next(_ids)\n\t\t\tpostfix.extend(u'<i id=\"{}\"></i>'.format(_id) for _id in _ids)\n\n\t\t# set CSS class\n\t\tclasses = set(node.get('classes', []) + attrs.pop('class', '').split())\n\t\tif classes:\n\t\t\tattrs['class'] = u' '.join(classes)\n\n\t\treturn u'{prefix}<{tag} {attrs}>{postfix}'.format(\n\t\t\tprefix=u''.join(prefix),\n\t\t\ttag=tagname,\n\t\t\tattrs=u' '.join(u'{}=\"{}\"'.format(name, self.attval(value))\n\t\t\t\t\t\t\tfor name,  value in attrs.items()),\n\t\t\tpostfix=u''.join(postfix),\n\t\t)\n\t# only \"space characters\" SPACE, CHARACTER TABULATION, LINE FEED,\n\t# FORM FEED and CARRIAGE RETURN should be collapsed, not al White_Space\n\tdef attval(self, value, whitespace=re.compile(u'[ \\t\\n\\f\\r]+')):\n\t\treturn self.encode(whitespace.sub(u' ', pycompat.text_type(value)))\n\n\tdef astext(self):\n\t\treturn u''.join(self.body)\n\n\tdef unknown_visit(self, node):\n\t\tprint(\"unknown node\", node.__class__.__name__)\n\t\tself.body.append(u'[UNKNOWN NODE {}]'.format(node.__class__.__name__))\n\t\traise nodes.SkipNode\n\n\tdef visit_highlightlang(self, node):\n\t\tself.highlightlang = node['lang']\n\tdef depart_highlightlang(self, node):\n\t\tpass\n\n\tdef visit_document(self, node):\n\t\tself.first_title = True\n\tdef depart_document(self, node):\n\t\tpass\n\n\tdef visit_section(self, node):\n\t\t# close \"parent\" or preceding section, unless this is the opening of\n\t\t# the first section\n\t\tif self.section_level:\n\t\t\tself.body.append(u'</section>')\n\t\tself.section_level += 1\n\n\t\tself.body.append(self.starttag(node, 'section'))\n\tdef depart_section(self, node):\n\t\tself.section_level -= 1\n\t\t# close last section of document\n\t\tif not self.section_level:\n\t\t\tself.body.append(u'</section>')\n\n\tdef visit_topic(self, node):\n\t\tself.body.append(self.starttag(node, 'nav'))\n\tdef depart_topic(self, node):\n\t\tself.body.append(u'</nav>')\n\n\tdef is_compact_paragraph(self, node):\n\t\tparent = node.parent\n\t\tif isinstance(parent, (nodes.document, nodes.compound,\n\t\t\t\t\t\t\t   addnodes.desc_content,\n\t\t\t\t\t\t\t   addnodes.versionmodified)):\n\t\t\t# Never compact paragraphs in document or compound.\n\t\t\treturn False\n\n\t\tfor key, value in node.attlist():\n\t\t\t# we can ignore a few specific classes, all other non-default\n\t\t\t# attributes require that a <p> node remains\n\t\t\tif key != 'classes' or value not in ([], ['first'], ['last'], ['first', 'last']):\n\t\t\t\treturn False\n\n\t\tfirst = isinstance(node.parent[0], nodes.label)\n\t\tfor child in parent.children[first:]:\n\t\t\t# only first paragraph can be compact\n\t\t\tif isinstance(child, nodes.Invisible):\n\t\t\t\tcontinue\n\t\t\tif child is node:\n\t\t\t\tbreak\n\t\t\treturn False\n\t\tparent_length = len([\n\t\t\t1 for n in parent\n\t\t\tif not isinstance(n, (nodes.Invisible, nodes.label))\n\t\t])\n\t\treturn parent_length == 1\n\n\tdef visit_paragraph(self, node):\n\t\tif self.is_compact_paragraph(node):\n\t\t\tself.context.append(u'')\n\t\t\treturn\n\t\tself.body.append(self.starttag(node, 'p'))\n\t\tself.context.append(u'</p>')\n\tdef depart_paragraph(self, node):\n\t\tself.body.append(self.context.pop())\n\tdef visit_compact_paragraph(self, node):\n\t\tpass\n\tdef depart_compact_paragraph(self, node):\n\t\tpass\n\n\tdef visit_literal_block(self, node):\n\t\tif node.rawsource != node.astext():\n\t\t\t# most probably a parsed-literal block -- don't highlight\n\t\t\tself.body.append(self.starttag(node, 'pre'))\n\t\t\treturn\n\t\tlang = self.highlightlang\n\t\thighlight_args = node.get('highlight_args', {})\n\t\tif 'language' in node:\n\t\t\t# code-block directives\n\t\t\tlang = node['language']\n\t\t\thighlight_args['force'] = True\n\t\tlinenos = node.get('linenos', False)\n\t\tif lang is self.highlightlang_base:\n\t\t\t# only pass highlighter options for original language\n\t\t\topts = self.highlightopts\n\t\telse:\n\t\t\topts = {}\n\n\t\tdef warner(msg, **kw):\n\t\t\tself.builder.warn(msg, (self.builder.current_docname, node.line))\n\t\thighlighted = self.builder.highlighter.highlight_block(\n\t\t\tnode.rawsource, lang, opts=opts, warn=warner, linenos=linenos,\n\t\t\t**highlight_args)\n\t\tself.body.append(self.starttag(node, 'div', CLASS='highlight-%s' % lang))\n\t\tself.body.append(highlighted)\n\t\tself.body.append(u'</div>\\n')\n\t\traise nodes.SkipNode\n\tdef depart_literal_block(self, node):\n\t\tself.body.append(u'</pre>')\n\n\tdef visit_bullet_list(self, node):\n\t\tself.body.append(self.starttag(node, 'ul'))\n\tdef depart_bullet_list(self, node):\n\t\tself.body.append(u'</ul>')\n\tdef visit_enumerated_list(self, node):\n\t\tself.body.append(self.starttag(node, 'ol'))\n\tdef depart_enumerated_list(self, node):\n\t\tself.body.append(u'</ol>')\n\tdef visit_list_item(self, node):\n\t\tself.body.append(self.starttag(node, 'li'))\n\tdef depart_list_item(self, node):\n\t\tself.body.append(u'</li>')\n\tdef visit_definition_list(self, node):\n\t\tself.body.append(self.starttag(node, 'dl'))\n\tdef depart_definition_list(self, node):\n\t\tself.body.append(u'</dl>')\n\tdef visit_definition_list_item(self, node):\n\t\tpass\n\tdef depart_definition_list_item(self, node):\n\t\tpass\n\tdef visit_term(self, node):\n\t\tself.body.append(self.starttag(node, 'dt'))\n\tdef depart_term(self, node):\n\t\tself.body.append(u'</dt>')\n\tdef visit_termsep(self, node):\n\t\tself.body.append(self.starttag(node, 'br'))\n\t\traise nodes.SkipNode\n\tdef visit_definition(self, node):\n\t\tself.body.append(self.starttag(node, 'dd'))\n\tdef depart_definition(self, node):\n\t\tself.body.append(u'</dd>')\n\n\tdef visit_admonition(self, node, type=None):\n\t\tclss = {\n\t\t\t# ???: 'alert-success',\n\n\t\t\t'note': 'alert-info',\n\t\t\t'hint': 'alert-info',\n\t\t\t'tip': 'alert-info',\n\t\t\t'seealso': 'alert-go_to',\n\n\t\t\t'warning': 'alert-warning',\n\t\t\t'attention': 'alert-warning',\n\t\t\t'caution': 'alert-warning',\n\t\t\t'important': 'alert-warning',\n\n\t\t\t'danger': 'alert-danger',\n\t\t\t'error': 'alert-danger',\n\n\t\t\t'exercise': 'alert-exercise',\n\t\t}\n\t\tself.body.append(self.starttag(node, 'div', role='alert', CLASS='alert {}'.format(\n\t\t\tclss.get(type, '')\n\t\t)))\n\t\tif 'alert-dismissible' in node.get('classes', []):\n\t\t\tself.body.append(\n\t\t\t\tu'<button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-label=\"Close\">'\n\t\t\t\tu'<span aria-hidden=\"true\">&times;</span>'\n\t\t\t\tu'</button>')\n\t\tif type:\n\t\t\tnode.insert(0, nodes.title(type, admonitionlabels[type]))\n\tdef depart_admonition(self, node):\n\t\tself.body.append(u'</div>')\n\tvisit_note = lambda self, node: self.visit_admonition(node, 'note')\n\tvisit_warning = lambda self, node: self.visit_admonition(node, 'warning')\n\tvisit_attention = lambda self, node: self.visit_admonition(node, 'attention')\n\tvisit_caution = lambda self, node: self.visit_admonition(node, 'caution')\n\tvisit_danger = lambda self, node: self.visit_admonition(node, 'danger')\n\tvisit_error = lambda self, node: self.visit_admonition(node, 'error')\n\tvisit_hint = lambda self, node: self.visit_admonition(node, 'hint')\n\tvisit_important = lambda self, node: self.visit_admonition(node, 'important')\n\tvisit_tip = lambda self, node: self.visit_admonition(node, 'tip')\n\tvisit_exercise = lambda self, node: self.visit_admonition(node, 'exercise')\n\tvisit_seealso = lambda self, node: self.visit_admonition(node, 'seealso')\n\tdepart_note = depart_admonition\n\tdepart_warning = depart_admonition\n\tdepart_attention = depart_admonition\n\tdepart_caution = depart_admonition\n\tdepart_danger = depart_admonition\n\tdepart_error = depart_admonition\n\tdepart_hint = depart_admonition\n\tdepart_important = depart_admonition\n\tdepart_tip = depart_admonition\n\tdepart_exercise = depart_admonition\n\tdepart_seealso = depart_admonition\n\tdef visit_versionmodified(self, node):\n\t\tself.body.append(self.starttag(node, 'div', CLASS=node['type']))\n\tdef depart_versionmodified(self, node):\n\t\tself.body.append(u'</div>')\n\n\tdef visit_title(self, node):\n\t\tparent = node.parent\n\t\tclosing = u'</h3>'\n\t\tif isinstance(parent, nodes.Admonition):\n\t\t\tself.body.append(self.starttag(node, 'h3', CLASS='alert-title'))\n\t\telif isinstance(node.parent, nodes.document):\n\t\t\tself.body.append(self.starttag(node, 'h1'))\n\t\t\tclosing = u'</h1>'\n\t\t\tself.start_document_title = len(self.body)\n\t\telse:\n\t\t\tassert isinstance(parent, nodes.section), \"expected a section node as parent to the title, found {}\".format(parent)\n\t\t\tif self.first_title:\n\t\t\t\tself.first_title = False\n\t\t\t\traise nodes.SkipNode()\n\t\t\tnodename = 'h{}'.format(self.section_level)\n\t\t\tself.body.append(self.starttag(node, nodename))\n\t\t\tclosing = u'</{}>'.format(nodename)\n\t\tself.context.append(closing)\n\tdef depart_title(self, node):\n\t\tself.body.append(self.context.pop())\n\t\tif self.start_document_title:\n\t\t\tself.title = self.body[self.start_document_title:-1]\n\t\t\tself.start_document_title = 0\n\t\t\tdel self.body[:]\n\n\t# the rubric should be a smaller heading than the current section, up to\n\t# h6... maybe \"h7\" should be a ``p`` instead?\n\tdef visit_rubric(self, node):\n\t\tself.body.append(self.starttag(node, 'h{}'.format(min(self.section_level + 1, 6))))\n\tdef depart_rubric(self, node):\n\t\tself.body.append(u'</h{}>'.format(min(self.section_level + 1, 6)))\n\n\tdef visit_block_quote(self, node):\n\t\tself.body.append(self.starttag(node, 'blockquote'))\n\tdef depart_block_quote(self, node):\n\t\tself.body.append(u'</blockquote>')\n\tdef visit_attribution(self, node):\n\t\tself.body.append(self.starttag(node, 'footer'))\n\tdef depart_attribution(self, node):\n\t\tself.body.append(u'</footer>')\n\n\tdef visit_container(self, node):\n\t\tself.body.append(self.starttag(node, 'div'))\n\tdef depart_container(self, node):\n\t\tself.body.append(u'</div>')\n\tdef visit_compound(self, node):\n\t\tself.body.append(self.starttag(node, 'div'))\n\tdef depart_compound(self, node):\n\t\tself.body.append(u'</div>')\n\n\tdef visit_image(self, node):\n\t\turi = node['uri']\n\t\tif uri in self.builder.images:\n\t\t\turi = posixpath.join(self.builder.imgpath,\n\t\t\t\t\t\t\t\t self.builder.images[uri])\n\t\tattrs = {'src': uri, 'class': 'img-responsive'}\n\t\tif 'alt' in node:\n\t\t\tattrs['alt'] = node['alt']\n\t\tif 'align' in node:\n\t\t\tif node['align'] == 'center':\n\t\t\t\tattrs['class'] += ' center-block'\n\t\t\telse:\n\t\t\t\tdoc = None\n\t\t\t\tif node.source:\n\t\t\t\t\tdoc = node.source\n\t\t\t\t\tif node.line:\n\t\t\t\t\t\tdoc += ':%d' % node.line\n\t\t\t\tself.builder.app.warn(\n\t\t\t\t\t\"Unsupported alignment value \\\"%s\\\"\" % node['align'],\n\t\t\t\t\tlocation=doc\n\t\t\t\t)\n\t\telif 'align' in node.parent and node.parent['align'] == 'center':\n\t\t\t# figure > image\n\t\t\tattrs['class'] += ' center-block'\n\n\t\t# todo: explicit width/height/scale?\n\t\tself.body.append(self.starttag(node, 'img', **attrs))\n\tdef depart_image(self, node): pass\n\tdef visit_figure(self, node):\n\t\tself.body.append(self.starttag(node, 'div'))\n\tdef depart_figure(self, node):\n\t\tself.body.append(u'</div>')\n\tdef visit_caption(self, node):\n\t\t# first paragraph of figure content\n\t\tself.body.append(self.starttag(node, 'h4'))\n\tdef depart_caption(self, node):\n\t\tself.body.append(u'</h4>')\n\tdef visit_legend(self, node): pass\n\tdef depart_legend(self, node): pass\n\n\tdef visit_line(self, node):\n\t\tself.body.append(self.starttag(node, 'div', CLASS='line'))\n\t\t# ensure the line still takes the room it needs\n\t\tif not len(node): self.body.append(u'<br />')\n\tdef depart_line(self, node):\n\t\tself.body.append(u'</div>')\n\n\tdef visit_line_block(self, node):\n\t\tself.body.append(self.starttag(node, 'div', CLASS='line-block'))\n\tdef depart_line_block(self, node):\n\t\tself.body.append(u'</div>')\n\n\tdef visit_table(self, node):\n\t\tself.body.append(self.starttag(node, 'table', CLASS='table'))\n\tdef depart_table(self, node):\n\t\tself.body.append(u'</table>')\n\tdef visit_tgroup(self, node): pass\n\tdef depart_tgroup(self, node): pass\n\tdef visit_colspec(self, node): raise nodes.SkipNode\n\tdef visit_thead(self, node):\n\t\tself.body.append(self.starttag(node, 'thead'))\n\tdef depart_thead(self, node):\n\t\tself.body.append(u'</thead>')\n\tdef visit_tbody(self, node):\n\t\tself.body.append(self.starttag(node, 'tbody'))\n\tdef depart_tbody(self, node):\n\t\tself.body.append(u'</tbody>')\n\tdef visit_row(self, node):\n\t\tself.body.append(self.starttag(node, 'tr'))\n\tdef depart_row(self, node):\n\t\tself.body.append(u'</tr>')\n\tdef visit_entry(self, node):\n\t\tif isinstance(node.parent.parent, nodes.thead):\n\t\t\ttagname = 'th'\n\t\telse:\n\t\t\ttagname = 'td'\n\t\tself.body.append(self.starttag(node, tagname))\n\t\tself.context.append(tagname)\n\tdef depart_entry(self, node):\n\t\tself.body.append(u'</{}>'.format(self.context.pop()))\n\n\tdef visit_Text(self, node):\n\t\tself.body.append(self.encode(node.astext()))\n\tdef depart_Text(self, node):\n\t\tpass\n\tdef visit_literal(self, node):\n\t\tself.body.append(self.starttag(node, 'code'))\n\tdef depart_literal(self, node):\n\t\tself.body.append(u'</code>')\n\tvisit_literal_emphasis = visit_literal\n\tdepart_literal_emphasis = depart_literal\n\tdef visit_emphasis(self, node):\n\t\tself.body.append(self.starttag(node, 'em'))\n\tdef depart_emphasis(self, node):\n\t\tself.body.append(u'</em>')\n\tdef visit_strong(self, node):\n\t\tself.body.append(self.starttag(node, 'strong'))\n\tdef depart_strong(self, node):\n\t\tself.body.append(u'</strong>')\n\tvisit_literal_strong = visit_strong\n\tdepart_literal_strong = depart_strong\n\tdef visit_inline(self, node):\n\t\tself.body.append(self.starttag(node, 'span'))\n\tdef depart_inline(self, node):\n\t\tself.body.append(u'</span>')\n\tdef visit_abbreviation(self, node):\n\t\tattrs = {}\n\t\tif 'explanation' in node:\n\t\t\tattrs['title'] = node['explanation']\n\t\tself.body.append(self.starttag(node, 'abbr', **attrs))\n\tdef depart_abbreviation(self, node):\n\t\tself.body.append(u'</abbr>')\n\n\tdef visit_reference(self, node):\n\t\tattrs = {\n\t\t\t'class': 'reference',\n\t\t\t'href': node['refuri'] if 'refuri' in node else '#' + node['refid']\n\t\t}\n\t\tattrs['class'] += ' internal' if (node.get('internal') or 'refuri' not in node) else ' external'\n\t\tif any(isinstance(ancestor, nodes.Admonition) for ancestor in _parents(node)):\n\t\t\tattrs['class'] += ' alert-link'\n\n\t\tif 'reftitle' in node:\n\t\t\tattrs['title'] = node['reftitle']\n\n\t\tself.body.append(self.starttag(node, 'a', **attrs))\n\tdef depart_reference(self, node):\n\t\tself.body.append(u'</a>')\n\tdef visit_target(self, node): pass\n\tdef depart_target(self, node): pass\n\tdef visit_footnote(self, node):\n\t\tself.body.append(self.starttag(node, 'div', CLASS='footnote'))\n\t\tself.footnote_backrefs(node)\n\tdef depart_footnote(self, node):\n\t\tself.body.append(u'</div>')\n\tdef visit_footnote_reference(self, node):\n\t\tself.body.append(self.starttag(\n\t\t\tnode, 'a', href='#' + node['refid'], CLASS=\"footnote-ref\"))\n\tdef depart_footnote_reference(self, node):\n\t\tself.body.append(u'</a>')\n\tdef visit_label(self, node):\n\t\tself.body.append(self.starttag(node, 'span', CLASS='footnote-label'))\n\t\tself.body.append(u'%s[' % self.context.pop())\n\tdef depart_label(self, node):\n\t\t# Context added in footnote_backrefs.\n\t\tself.body.append(u']%s</span> %s' % (self.context.pop(), self.context.pop()))\n\tdef footnote_backrefs(self, node):\n\t\t# should store following data on context stack (in that order since\n\t\t# they'll be popped so LIFO)\n\t\t#\n\t\t# * outside (after) label\n\t\t# * after label text\n\t\t# * before label text\n\t\tbackrefs = node['backrefs']\n\t\tif not backrefs:\n\t\t\tself.context.extend(['', '', ''])\n\t\telif len(backrefs) == 1:\n\t\t\tself.context.extend([\n\t\t\t\t'',\n\t\t\t\t'</a>',\n\t\t\t\t'<a class=\"footnote-backref\" href=\"#%s\">' % backrefs[0]\n\t\t\t])\n\t\telse:\n\t\t\tbacklinks = (\n\t\t\t\t'<a class=\"footnote-backref\" href=\"#%s\">%s</a>' % (backref, i)\n\t\t\t\tfor i, backref in enumerate(backrefs, start=1)\n\t\t\t)\n\t\t\tself.context.extend([\n\t\t\t\t'<em class=\"footnote-backrefs\">(%s)</em> ' % ', '.join(backlinks),\n\t\t\t\t'',\n\t\t\t\t''\n\t\t\t])\n\n\tdef visit_desc(self, node):\n\t\tself.body.append(self.starttag(node, 'section', CLASS='code-' + node['objtype']))\n\tdef depart_desc(self, node):\n\t\tself.body.append(u'</section>')\n\tdef visit_desc_signature(self, node):\n\t\tself.body.append(self.starttag(node, 'h6'))\n\t\tself.body.append(u'<code>')\n\tdef depart_desc_signature(self, node):\n\t\tself.body.append(u'</code>')\n\t\tself.body.append(u'</h6>')\n\tdef visit_desc_addname(self, node): pass\n\tdef depart_desc_addname(self, node): pass\n\tdef visit_desc_type(self, node): pass\n\tdef depart_desc_type(self, node): pass\n\tdef visit_desc_returns(self, node):\n\t\tself.body.append(u' \u2192 ')\n\tdef depart_desc_returns(self, node):\n\t\tpass\n\tdef visit_desc_name(self, node): pass\n\tdef depart_desc_name(self, node): pass\n\tdef visit_desc_parameterlist(self, node):\n\t\tself.body.append(u'(')\n\t\tself.first_param = True\n\t\tself.optional_param_level = 0\n\t\t# How many required parameters are left.\n\t\tself.required_params_left = sum(isinstance(c, addnodes.desc_parameter) for c in node.children)\n\t\tself.param_separator = node.child_text_separator\n\tdef depart_desc_parameterlist(self, node):\n\t\tself.body.append(u')')\n\t# If required parameters are still to come, then put the comma after\n\t# the parameter.  Otherwise, put the comma before.  This ensures that\n\t# signatures like the following render correctly (see issue #1001):\n\t#\n\t#\t foo([a, ]b, c[, d])\n\t#\n\tdef visit_desc_parameter(self, node):\n\t\tif self.first_param:\n\t\t\tself.first_param = 0\n\t\telif not self.required_params_left:\n\t\t\tself.body.append(self.param_separator)\n\t\tif self.optional_param_level == 0:\n\t\t\tself.required_params_left -= 1\n\t\tif 'noemph' not in node: self.body.append(u'<em>')\n\tdef depart_desc_parameter(self, node):\n\t\tif 'noemph' not in node: self.body.append(u'</em>')\n\t\tif self.required_params_left:\n\t\t\tself.body.append(self.param_separator)\n\tdef visit_desc_optional(self, node):\n\t\tself.optional_param_level += 1\n\t\tself.body.append(u'[')\n\tdef depart_desc_optional(self, node):\n\t\tself.optional_param_level -= 1\n\t\tself.body.append(u']')\n\tdef visit_desc_annotation(self, node):\n\t\tself.body.append(self.starttag(node, 'em'))\n\tdef depart_desc_annotation(self, node):\n\t\tself.body.append(u'</em>')\n\tdef visit_desc_content(self, node): pass\n\tdef depart_desc_content(self, node): pass\n\tdef visit_field_list(self, node):\n\t\t self.body.append(self.starttag(node, 'div', CLASS='code-fields'))\n\tdef depart_field_list(self, node):\n\t\tself.body.append(u'</div>')\n\tdef visit_field(self, node):\n\t\tself.body.append(self.starttag(node, 'div', CLASS='code-field'))\n\tdef depart_field(self, node):\n\t\tself.body.append(u'</div>')\n\tdef visit_field_name(self, node):\n\t\tself.body.append(self.starttag(node, 'div', CLASS='code-field-name'))\n\tdef depart_field_name(self, node):\n\t\tself.body.append(u'</div>')\n\tdef visit_field_body(self, node):\n\t\tself.body.append(self.starttag(node, 'div', CLASS='code-field-body'))\n\tdef depart_field_body(self, node):\n\t\tself.body.append(u'</div>')\n\n\tdef visit_glossary(self, node): pass\n\tdef depart_glossary(self, node): pass\n\n\tdef visit_comment(self, node): raise nodes.SkipNode\n\tdef visit_toctree(self, node):\n\t\t# div class=row {{ section_type }}\n\t\t#   h2 class=col-sm-12\n\t\t#\t {{ section title }}\n\t\t#   div class=col-sm-6 col-md-3\n\t\t#\t figure class=card\n\t\t#\t   a href=current_link style=background-image: document-image-attribute class=card-img\n\t\t#\t\t figcaption\n\t\t#\t\t   {{ card title }}\n\t\tenv = self.builder.env\n\t\tconf = self.builder.app.config\n\t\tfor title, ref in ((e[0], e[1]) for e in node['entries']):\n\t\t\t# external URL, no toc, can't recurse into\n\t\t\tif ref not in env.tocs:\n\t\t\t\tcontinue\n\t\t\ttoc = env.tocs[ref].traverse(addnodes.toctree)\n\n\t\t\tclasses = env.metadata[ref].get('types', 'tutorials')\n\t\t\tclasses += ' toc-single-entry' if not toc else ' toc-section'\n\t\t\tself.body.append(self.starttag(node, 'div', CLASS=\"row \" + classes))\n\t\t\tself.body.append(u'<div class=\"col-sm-12\"><h2>')\n\t\t\tself.body.append(title if title else util.nodes.clean_astext(env.titles[ref]))\n\t\t\tself.body.append(u'</h2></div>')\n\n\t\t\tentries = [(title, ref)] if not toc else ((e[0], e[1]) for e in toc[0]['entries'])\n\t\t\tfor subtitle, subref in entries:\n\t\t\t\tbaseuri = self.builder.get_target_uri(node['parent'])\n\n\t\t\t\tif subref in env.metadata:\n\t\t\t\t\tcover = env.metadata[subref].get('banner', conf.odoo_cover_default)\n\t\t\t\telif subref in conf.odoo_cover_external:\n\t\t\t\t\tcover = conf.odoo_cover_external[subref]\n\t\t\t\telse:\n\t\t\t\t\tcover = conf.odoo_cover_default_external\n\n\t\t\t\tif cover:\n\t\t\t\t\tbanner = '_static/' + cover\n\t\t\t\t\tbase, ext = os.path.splitext(banner)\n\t\t\t\t\tsmall = \"{}.small{}\".format(base, ext)\n\t\t\t\t\tif os.path.isfile(url2pathname(small)):\n\t\t\t\t\t\tbanner = small\n\t\t\t\t\tstyle = u\"background-image: url('{}')\".format(\n\t\t\t\t\t\tutil.relative_uri(baseuri, banner) or '#')\n\t\t\t\telse:\n\t\t\t\t\tstyle = u''\n\n\t\t\t\tself.body.append(u\"\"\"\n\t\t\t\t<div class=\"col-sm-6 col-md-3\">\n\t\t\t\t<figure class=\"card\">\n\t\t\t\t\t<a href=\"{link}\" class=\"card-img\">\n\t\t\t\t\t\t<span style=\"{style}\"></span>\n\t\t\t\t\t\t<figcaption>{title}</figcaption>\n\t\t\t\t\t</a>\n\t\t\t\t</figure>\n\t\t\t\t</div>\n\t\t\t\t\"\"\".format(\n\t\t\t\t\tlink=subref if util.url_re.match(subref) else util.relative_uri(\n\t\t\t\t\t\tbaseuri, self.builder.get_target_uri(subref)),\n\t\t\t\t\tstyle=style,\n\t\t\t\t\ttitle=subtitle if subtitle else util.nodes.clean_astext(env.titles[subref]),\n\t\t\t\t))\n\n\t\t\tself.body.append(u'</div>')\n\t\traise nodes.SkipNode\n\n\tdef visit_index(self, node): raise nodes.SkipNode\n\n\tdef visit_raw(self, node):\n\t\tif 'html' in node.get('format', '').split():\n\t\t\tt = 'span' if isinstance(node.parent, nodes.TextElement) else 'div'\n\t\t\tif node['classes']:\n\t\t\t\tself.body.append(self.starttag(node, t))\n\t\t\tself.body.append(node.astext())\n\t\t\tif node['classes']:\n\t\t\t\tself.body.append('</%s>' % t)\n\t\t# Keep non-HTML raw text out of output:\n\t\traise nodes.SkipNode\n\n\t# internal node\n\tdef visit_substitution_definition(self, node): raise nodes.SkipNode\n\n\t# without set_translator, add_node doesn't work correctly, so the\n\t# serialization of html_domain nodes needs to be embedded here\n\tdef visit_div(self, node):\n\t\tself.body.append(self.starttag(node, 'div'))\n\tdef depart_div(self, node):\n\t\tself.body.append(u'</div>\\n')\n\tdef visit_address(self, node):\n\t\tself.body.append(self.starttag(node, 'address'))\n\tdef depart_address(self, node):\n\t\tself.body.append(u'</address>')\n", "description": "\n\t\t\t\t<div class=\"col-sm-6 col-md-3\">\n\t\t\t\t<figure class=\"card\">\n\t\t\t\t\t<a href=\"{link}\" class=\"card-img\">\n\t\t\t\t\t\t<span style=\"{style}\"></span>\n\t\t\t\t\t\t<figcaption>{title}</figcaption>\n\t\t\t\t\t</a>\n\t\t\t\t</figure>\n\t\t\t\t</div>\n\t\t\t\t", "category": "def", "imports": ["from __future__ import print_function", "import os.path", "import posixpath", "import re", "\tfrom urllib.request import url2pathname  # pylint: disable=deprecated-module", "\tfrom urllib import url2pathname  # pylint: disable=deprecated-module", "from docutils import nodes", "from sphinx import addnodes, util, builders", "from sphinx.locale import admonitionlabels", "from odoo.tools import pycompat", "\t\t\t'important': 'alert-warning',", "\tvisit_important = lambda self, node: self.visit_admonition(node, 'important')", "\tdepart_important = depart_admonition"]}], [{"term": "class", "name": "classHashable:", "data": "class Hashable:\n\t__metaclass__ = ABCMeta\n\n\t@abstractmethod\n\tdef __hash__(self):\n\t\treturn 0\n\n\t@classmethod\n\tdef __subclasshook__(cls, C):\n\t\tif cls is Hashable:\n\t\t\tfor B in C.__mro__:\n\t\t\t\tif \"__hash__\" in B.__dict__:\n\t\t\t\t\tif B.__dict__[\"__hash__\"]:\n\t\t\t\t\t\treturn True\n\t\t\t\t\tbreak\n\t\treturn NotImplemented\n\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "classIterable:", "data": "class Iterable:\n\t__metaclass__ = ABCMeta\n\n\t@abstractmethod\n\tdef __iter__(self):\n\t\twhile False:\n\t\t\tyield None\n\n\t@classmethod\n\tdef __subclasshook__(cls, C):\n\t\tif cls is Iterable:\n\t\t\tif any(\"__iter__\" in B.__dict__ for B in C.__mro__):\n\t\t\t\treturn True\n\t\treturn NotImplemented\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "Iterator", "data": "class Iterator(Iterable):\n\n\t@abstractmethod\n\tdef next(self):\n\t\traise StopIteration\n\n\tdef __iter__(self):\n\t\treturn self\n\n\t@classmethod\n\tdef __subclasshook__(cls, C):\n\t\tif cls is Iterator:\n\t\t\tif any(\"next\" in B.__dict__ for B in C.__mro__):\n\t\t\t\treturn True\n\t\treturn NotImplemented\n\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "classSized:", "data": "class Sized:\n\t__metaclass__ = ABCMeta\n\n\t@abstractmethod\n\tdef __len__(self):\n\t\treturn 0\n\n\t@classmethod\n\tdef __subclasshook__(cls, C):\n\t\tif cls is Sized:\n\t\t\tif any(\"__len__\" in B.__dict__ for B in C.__mro__):\n\t\t\t\treturn True\n\t\treturn NotImplemented\n\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "classContainer:", "data": "class Container:\n\t__metaclass__ = ABCMeta\n\n\t@abstractmethod\n\tdef __contains__(self, x):\n\t\treturn False\n\n\t@classmethod\n\tdef __subclasshook__(cls, C):\n\t\tif cls is Container:\n\t\t\tif any(\"__contains__\" in B.__dict__ for B in C.__mro__):\n\t\t\t\treturn True\n\t\treturn NotImplemented\n\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "classCallable:", "data": "class Callable:\n\t__metaclass__ = ABCMeta\n\n\t@abstractmethod\n\tdef __call__(self, *args, **kwds):\n\t\treturn False\n\n\t@classmethod\n\tdef __subclasshook__(cls, C):\n\t\tif cls is Callable:\n\t\t\tif any(\"__call__\" in B.__dict__ for B in C.__mro__):\n\t\t\t\treturn True\n\t\treturn NotImplemented\n\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "Set", "data": "class Set(Sized, Iterable, Container):\n\t\"\"\"A set is a finite, iterable container.\n\n\tThis class provides concrete generic implementations of all\n\tmethods except for __contains__, __iter__ and __len__.\n\n\tTo override the comparisons (presumably for speed, as the\n\tsemantics are fixed), all you have to do is redefine __le__ and\n\tthen the other operations will automatically follow suit.\n\t\"\"\"\n\n\tdef __le__(self, other):\n\t\tif not isinstance(other, Set):\n\t\t\treturn NotImplemented\n\t\tif len(self) > len(other):\n\t\t\treturn False\n\t\tfor elem in self:\n\t\t\tif elem not in other:\n\t\t\t\treturn False\n\t\treturn True\n\n\tdef __lt__(self, other):\n\t\tif not isinstance(other, Set):\n\t\t\treturn NotImplemented\n\t\treturn len(self) < len(other) and self.__le__(other)\n\n\tdef __gt__(self, other):\n\t\tif not isinstance(other, Set):\n\t\t\treturn NotImplemented\n\t\treturn other < self\n\n\tdef __ge__(self, other):\n\t\tif not isinstance(other, Set):\n\t\t\treturn NotImplemented\n\t\treturn other <= self\n\n\tdef __eq__(self, other):\n\t\tif not isinstance(other, Set):\n\t\t\treturn NotImplemented\n\t\treturn len(self) == len(other) and self.__le__(other)\n\n\tdef __ne__(self, other):\n\t\treturn not (self == other)\n\n\t@classmethod\n\tdef _from_iterable(cls, it):\n\t\t'''Construct an instance of the class from any iterable input.\n\n\t\tMust override this method if the class constructor signature\n\t\tdoes not accept an iterable for an input.\n\t\t'''\n\t\treturn cls(it)\n\n\tdef __and__(self, other):\n\t\tif not isinstance(other, Iterable):\n\t\t\treturn NotImplemented\n\t\treturn self._from_iterable(value for value in other if value in self)\n\n\tdef isdisjoint(self, other):\n\t\tfor value in other:\n\t\t\tif value in self:\n\t\t\t\treturn False\n\t\treturn True\n\n\tdef __or__(self, other):\n\t\tif not isinstance(other, Iterable):\n\t\t\treturn NotImplemented\n\t\tchain = (e for s in (self, other) for e in s)\n\t\treturn self._from_iterable(chain)\n\n\tdef __sub__(self, other):\n\t\tif not isinstance(other, Set):\n\t\t\tif not isinstance(other, Iterable):\n\t\t\t\treturn NotImplemented\n\t\t\tother = self._from_iterable(other)\n\t\treturn self._from_iterable(value for value in self\n\t\t\t\t\t\t\t\t   if value not in other)\n\n\tdef __xor__(self, other):\n\t\tif not isinstance(other, Set):\n\t\t\tif not isinstance(other, Iterable):\n\t\t\t\treturn NotImplemented\n\t\t\tother = self._from_iterable(other)\n\t\treturn (self - other) | (other - self)\n\n\t# Sets are not hashable by default, but subclasses can change this\n\t__hash__ = None\n\n\tdef _hash(self):\n\t\t\"\"\"Compute the hash value of a set.\n\n\t\tNote that we don't define __hash__: not all sets are hashable.\n\t\tBut if you define a hashable set type, its __hash__ should\n\t\tcall this function.\n\n\t\tThis must be compatible __eq__.\n\n\t\tAll sets ought to compare equal if they contain the same\n\t\telements, regardless of how they are implemented, and\n\t\tregardless of the order of the elements; so there's not much\n\t\tfreedom for __eq__ or __hash__.  We match the algorithm used\n\t\tby the built-in frozenset type.\n\t\t\"\"\"\n\t\tMAX = sys.maxint\n\t\tMASK = 2 * MAX + 1\n\t\tn = len(self)\n\t\th = 1927868237 * (n + 1)\n\t\th &= MASK\n\t\tfor x in self:\n\t\t\thx = hash(x)\n\t\t\th ^= (hx ^ (hx << 16) ^ 89869747)  * 3644798167\n\t\t\th &= MASK\n\t\th = h * 69069 + 907133923\n\t\th &= MASK\n\t\tif h > MAX:\n\t\t\th -= MASK + 1\n\t\tif h == -1:\n\t\t\th = 590923713\n\t\treturn h\n", "description": "A set is a finite, iterable container.\n\n\tThis class provides concrete generic implementations of all\n\tmethods except for __contains__, __iter__ and __len__.\n\n\tTo override the comparisons (presumably for speed, as the\n\tsemantics are fixed), all you have to do is redefine __le__ and\n\tthen the other operations will automatically follow suit.\n\t", "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "MutableSet", "data": "class MutableSet(Set):\n\n\t@abstractmethod\n\tdef add(self, value):\n\t\t\"\"\"Add an element.\"\"\"\n\t\traise NotImplementedError\n\n\t@abstractmethod\n\tdef discard(self, value):\n\t\t\"\"\"Remove an element.  Do not raise an exception if absent.\"\"\"\n\t\traise NotImplementedError\n\n\tdef remove(self, value):\n\t\t\"\"\"Remove an element. If not a member, raise a KeyError.\"\"\"\n\t\tif value not in self:\n\t\t\traise KeyError(value)\n\t\tself.discard(value)\n\n\tdef pop(self):\n\t\t\"\"\"Return the popped value.  Raise KeyError if empty.\"\"\"\n\t\tit = iter(self)\n\t\ttry:\n\t\t\tvalue = next(it)\n\t\texcept StopIteration:\n\t\t\traise KeyError\n\t\tself.discard(value)\n\t\treturn value\n\n\tdef clear(self):\n\t\t\"\"\"This is slow (creates N new iterators!) but effective.\"\"\"\n\t\ttry:\n\t\t\twhile True:\n\t\t\t\tself.pop()\n\t\texcept KeyError:\n\t\t\tpass\n\n\tdef __ior__(self, it):\n\t\tfor value in it:\n\t\t\tself.add(value)\n\t\treturn self\n\n\tdef __iand__(self, it):\n\t\tfor value in (self - it):\n\t\t\tself.discard(value)\n\t\treturn self\n\n\tdef __ixor__(self, it):\n\t\tif not isinstance(it, Set):\n\t\t\tit = self._from_iterable(it)\n\t\tfor value in it:\n\t\t\tif value in self:\n\t\t\t\tself.discard(value)\n\t\t\telse:\n\t\t\t\tself.add(value)\n\t\treturn self\n\n\tdef __isub__(self, it):\n\t\tfor value in it:\n\t\t\tself.discard(value)\n\t\treturn self\n", "description": "Add an element.", "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "Mapping", "data": "class Mapping(Sized, Iterable, Container):\n\n\t@abstractmethod\n\tdef __getitem__(self, key):\n\t\traise KeyError\n\n\tdef get(self, key, default=None):\n\t\ttry:\n\t\t\treturn self[key]\n\t\texcept KeyError:\n\t\t\treturn default\n\n\tdef __contains__(self, key):\n\t\ttry:\n\t\t\tself[key]\n\t\texcept KeyError:\n\t\t\treturn False\n\t\telse:\n\t\t\treturn True\n\n\tdef iterkeys(self):\n\t\treturn iter(self)\n\n\tdef itervalues(self):\n\t\tfor key in self:\n\t\t\tyield self[key]\n\n\tdef iteritems(self):\n\t\tfor key in self:\n\t\t\tyield (key, self[key])\n\n\tdef keys(self):\n\t\treturn list(self)\n\n\tdef items(self):\n\t\treturn [(key, self[key]) for key in self]\n\n\tdef values(self):\n\t\treturn [self[key] for key in self]\n\n\t# Mappings are not hashable by default, but subclasses can change this\n\t__hash__ = None\n\n\tdef __eq__(self, other):\n\t\treturn isinstance(other, Mapping) and \\\n\t\t\t   dict(self.items()) == dict(other.items())\n\n\tdef __ne__(self, other):\n\t\treturn not (self == other)\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "MappingView", "data": "class MappingView(Sized):\n\n\tdef __init__(self, mapping):\n\t\tself._mapping = mapping\n\n\tdef __len__(self):\n\t\treturn len(self._mapping)\n\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "KeysView", "data": "class KeysView(MappingView, Set):\n\n\tdef __contains__(self, key):\n\t\treturn key in self._mapping\n\n\tdef __iter__(self):\n\t\tfor key in self._mapping:\n\t\t\tyield key\n\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "ItemsView", "data": "class ItemsView(MappingView, Set):\n\n\tdef __contains__(self, item):\n\t\tkey, value = item\n\t\ttry:\n\t\t\tv = self._mapping[key]\n\t\texcept KeyError:\n\t\t\treturn False\n\t\telse:\n\t\t\treturn v == value\n\n\tdef __iter__(self):\n\t\tfor key in self._mapping:\n\t\t\tyield (key, self._mapping[key])\n\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "ValuesView", "data": "class ValuesView(MappingView):\n\n\tdef __contains__(self, value):\n\t\tfor key in self._mapping:\n\t\t\tif value == self._mapping[key]:\n\t\t\t\treturn True\n\t\treturn False\n\n\tdef __iter__(self):\n\t\tfor key in self._mapping:\n\t\t\tyield self._mapping[key]\n\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "MutableMapping", "data": "class MutableMapping(Mapping):\n\n\t@abstractmethod\n\tdef __setitem__(self, key, value):\n\t\traise KeyError\n\n\t@abstractmethod\n\tdef __delitem__(self, key):\n\t\traise KeyError\n\n\t__marker = object()\n\n\tdef pop(self, key, default=__marker):\n\t\ttry:\n\t\t\tvalue = self[key]\n\t\texcept KeyError:\n\t\t\tif default is self.__marker:\n\t\t\t\traise\n\t\t\treturn default\n\t\telse:\n\t\t\tdel self[key]\n\t\t\treturn value\n\n\tdef popitem(self):\n\t\ttry:\n\t\t\tkey = next(iter(self))\n\t\texcept StopIteration:\n\t\t\traise KeyError\n\t\tvalue = self[key]\n\t\tdel self[key]\n\t\treturn key, value\n\n\tdef clear(self):\n\t\ttry:\n\t\t\twhile True:\n\t\t\t\tself.popitem()\n\t\texcept KeyError:\n\t\t\tpass\n\n\tdef update(self, other=(), **kwds):\n\t\tif isinstance(other, Mapping):\n\t\t\tfor key in other:\n\t\t\t\tself[key] = other[key]\n\t\telif hasattr(other, \"keys\"):\n\t\t\tfor key in other.keys():\n\t\t\t\tself[key] = other[key]\n\t\telse:\n\t\t\tfor key, value in other:\n\t\t\t\tself[key] = value\n\t\tfor key, value in kwds.items():\n\t\t\tself[key] = value\n\n\tdef setdefault(self, key, default=None):\n\t\ttry:\n\t\t\treturn self[key]\n\t\texcept KeyError:\n\t\t\tself[key] = default\n\t\treturn default\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "Sequence", "data": "class Sequence(Sized, Iterable, Container):\n\t\"\"\"All the operations on a read-only sequence.\n\n\tConcrete subclasses must override __new__ or __init__,\n\t__getitem__, and __len__.\n\t\"\"\"\n\n\t@abstractmethod\n\tdef __getitem__(self, index):\n\t\traise IndexError\n\n\tdef __iter__(self):\n\t\ti = 0\n\t\ttry:\n\t\t\twhile True:\n\t\t\t\tv = self[i]\n\t\t\t\tyield v\n\t\t\t\ti += 1\n\t\texcept IndexError:\n\t\t\treturn\n\n\tdef __contains__(self, value):\n\t\tfor v in self:\n\t\t\tif v == value:\n\t\t\t\treturn True\n\t\treturn False\n\n\tdef __reversed__(self):\n\t\tfor i in reversed(range(len(self))):\n\t\t\tyield self[i]\n\n\tdef index(self, value):\n\t\tfor i, v in enumerate(self):\n\t\t\tif v == value:\n\t\t\t\treturn i\n\t\traise ValueError\n\n\tdef count(self, value):\n\t\treturn sum(1 for v in self if v == value)\n", "description": "All the operations on a read-only sequence.\n\n\tConcrete subclasses must override __new__ or __init__,\n\t__getitem__, and __len__.\n\t", "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}, {"term": "class", "name": "MutableSequence", "data": "class MutableSequence(Sequence):\n\n\t@abstractmethod\n\tdef __setitem__(self, index, value):\n\t\traise IndexError\n\n\t@abstractmethod\n\tdef __delitem__(self, index):\n\t\traise IndexError\n\n\t@abstractmethod\n\tdef insert(self, index, value):\n\t\traise IndexError\n\n\tdef append(self, value):\n\t\tself.insert(len(self), value)\n\n\tdef reverse(self):\n\t\tn = len(self)\n\t\tfor i in range(n//2):\n\t\t\tself[i], self[n-i-1] = self[n-i-1], self[i]\n\n\tdef extend(self, values):\n\t\tfor v in values:\n\t\t\tself.append(v)\n\n\tdef pop(self, index=-1):\n\t\tv = self[index]\n\t\tdel self[index]\n\t\treturn v\n\n\tdef remove(self, value):\n\t\tdel self[self.index(value)]\n\n\tdef __iadd__(self, values):\n\t\tself.extend(values)\n", "description": null, "category": "def", "imports": ["DON'T USE THIS MODULE DIRECTLY!  The classes here should be imported", "from abc import ABCMeta, abstractmethod", "import sys"]}], [{"term": "class", "name": "classDerObject:", "data": "class DerObject:\n\ttypeTags: Any\n\ttypeTag: Any\n\tpayload: Any\n\tdef __init__(self, ASN1Type: Optional[Any] = ..., payload: Any = ...) -> None: ...\n\tdef isType(self, ASN1Type): ...\n\tdef encode(self): ...\n\tdef decode(self, derEle, noLeftOvers: int = ...): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional"]}, {"term": "class", "name": "DerInteger", "data": "class DerInteger(DerObject):\n\tvalue: Any\n\tdef __init__(self, value: int = ...) -> None: ...\n\tpayload: Any\n\tdef encode(self): ...\n\tdef decode(self, derEle, noLeftOvers: int = ...): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional"]}, {"term": "class", "name": "DerSequence", "data": "class DerSequence(DerObject):\n\tdef __init__(self, startSeq: Optional[Any] = ...) -> None: ...\n\tdef __delitem__(self, n): ...\n\tdef __getitem__(self, n): ...\n\tdef __setitem__(self, key, value): ...\n\tdef __setslice__(self, i, j, sequence): ...\n\tdef __delslice__(self, i, j): ...\n\tdef __getslice__(self, i, j): ...\n\tdef __len__(self): ...\n\tdef append(self, item): ...\n\tdef hasInts(self): ...\n\tdef hasOnlyInts(self): ...\n\tpayload: Any\n\tdef encode(self): ...\n\tdef decode(self, derEle, noLeftOvers: int = ...): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional"]}, {"term": "class", "name": "DerOctetString", "data": "class DerOctetString(DerObject):\n\tpayload: Any\n\tdef __init__(self, value: Any = ...) -> None: ...\n\tdef decode(self, derEle, noLeftOvers: int = ...): ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional"]}, {"term": "class", "name": "DerNull", "data": "class DerNull(DerObject):\n\tdef __init__(self) -> None: ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional"]}, {"term": "class", "name": "DerObjectId", "data": "class DerObjectId(DerObject):\n\tdef __init__(self) -> None: ...\n", "description": null, "category": "def", "imports": ["from typing import Any, Optional"]}], [{"term": "def", "name": "interleave", "data": "def interleave(inter, f, seq):\n\t\"\"\"Call f on each item in seq, calling inter() in between.\n\t\"\"\"\n\tseq = iter(seq)\n\ttry:\n\t\tf(seq.next())\n\texcept StopIteration:\n\t\tpass\n\telse:\n\t\tfor x in seq:\n\t\t\tinter()\n\t\t\tf(x)\n", "description": "Call f on each item in seq, calling inter() in between.\n\t", "category": "def", "imports": ["import sys", "import _ast", "import cStringIO", "import os", "\t\tself.fill(\"import \")", "\t\tself.write(\" import \")"]}, {"term": "class", "name": "classUnparser:", "data": "class Unparser:\n\t\"\"\"Methods in this class recursively traverse an AST and\n\toutput source code for the abstract syntax; original formatting\n\tis disregarged. \"\"\"\n\n\tdef __init__(self, tree, file = sys.stdout):\n\t\t\"\"\"Unparser(tree, file=sys.stdout) -> None.\n\t\t Print the source for tree to file.\"\"\"\n\t\tself.f = file\n\t\tself._indent = 0\n\t\tself.dispatch(tree)\n\t\tprint >>self.f,\"\"\n\t\tself.f.flush()\n\n\tdef fill(self, text = \"\"):\n\t\t\"Indent a piece of text, according to the current indentation level\"\n\t\tself.f.write(\"\\n\"+\"\t\"*self._indent + text)\n\n\tdef write(self, text):\n\t\t\"Append a piece of text to the current line.\"\n\t\tself.f.write(text)\n\n\tdef enter(self):\n\t\t\"Print ':', and increase the indentation.\"\n\t\tself.write(\":\")\n\t\tself._indent += 1\n\n\tdef leave(self):\n\t\t\"Decrease the indentation level.\"\n\t\tself._indent -= 1\n\n\tdef dispatch(self, tree):\n\t\t\"Dispatcher function, dispatching tree type T to method _T.\"\n\t\tif isinstance(tree, list):\n\t\t\tfor t in tree:\n\t\t\t\tself.dispatch(t)\n\t\t\treturn\n\t\tmeth = getattr(self, \"_\"+tree.__class__.__name__)\n\t\tmeth(tree)\n\n\n\t############### Unparsing methods ######################\n\t# There should be one method per concrete grammar type #\n\t# Constructors should be grouped by sum type. Ideally, #\n\t# this would follow the order in the grammar, but\t  #\n\t# currently doesn't.\t\t\t\t\t\t\t\t   #\n\t########################################################\n\n\tdef _Module(self, tree):\n\t\tfor stmt in tree.body:\n\t\t\tself.dispatch(stmt)\n\n\t# stmt\n\tdef _Expr(self, tree):\n\t\tself.fill()\n\t\tself.dispatch(tree.value)\n\n\tdef _Import(self, t):\n\t\tself.fill(\"import \")\n\t\tinterleave(lambda: self.write(\", \"), self.dispatch, t.names)\n\n\tdef _ImportFrom(self, t):\n\t\tself.fill(\"from \")\n\t\tself.write(t.module)\n\t\tself.write(\" import \")\n\t\tinterleave(lambda: self.write(\", \"), self.dispatch, t.names)\n\t\t# XXX(jpe) what is level for?\n\n\tdef _Assign(self, t):\n\t\tself.fill()\n\t\tfor target in t.targets:\n\t\t\tself.dispatch(target)\n\t\t\tself.write(\" = \")\n\t\tself.dispatch(t.value)\n\n\tdef _AugAssign(self, t):\n\t\tself.fill()\n\t\tself.dispatch(t.target)\n\t\tself.write(\" \"+self.binop[t.op.__class__.__name__]+\"= \")\n\t\tself.dispatch(t.value)\n\n\tdef _Return(self, t):\n\t\tself.fill(\"return\")\n\t\tif t.value:\n\t\t\tself.write(\" \")\n\t\t\tself.dispatch(t.value)\n\n\tdef _Pass(self, t):\n\t\tself.fill(\"pass\")\n\n\tdef _Break(self, t):\n\t\tself.fill(\"break\")\n\n\tdef _Continue(self, t):\n\t\tself.fill(\"continue\")\n\n\tdef _Delete(self, t):\n\t\tself.fill(\"del \")\n\t\tself.dispatch(t.targets)\n\n\tdef _Assert(self, t):\n\t\tself.fill(\"assert \")\n\t\tself.dispatch(t.test)\n\t\tif t.msg:\n\t\t\tself.write(\", \")\n\t\t\tself.dispatch(t.msg)\n\n\tdef _Exec(self, t):\n\t\tself.fill(\"exec \")\n\t\tself.dispatch(t.body)\n\t\tif t.globals:\n\t\t\tself.write(\" in \")\n\t\t\tself.dispatch(t.globals)\n\t\tif t.locals:\n\t\t\tself.write(\", \")\n\t\t\tself.dispatch(t.locals)\n\n\tdef _Print(self, t):\n\t\tself.fill(\"print \")\n\t\tdo_comma = False\n\t\tif t.dest:\n\t\t\tself.write(\">>\")\n\t\t\tself.dispatch(t.dest)\n\t\t\tdo_comma = True\n\t\tfor e in t.values:\n\t\t\tif do_comma:self.write(\", \")\n\t\t\telse:do_comma=True\n\t\t\tself.dispatch(e)\n\t\tif not t.nl:\n\t\t\tself.write(\",\")\n\n\tdef _Global(self, t):\n\t\tself.fill(\"global \")\n\t\tinterleave(lambda: self.write(\", \"), self.write, t.names)\n\n\tdef _Yield(self, t):\n\t\tself.write(\"(\")\n\t\tself.write(\"yield\")\n\t\tif t.value:\n\t\t\tself.write(\" \")\n\t\t\tself.dispatch(t.value)\n\t\tself.write(\")\")\n\n\tdef _Raise(self, t):\n\t\tself.fill('raise ')\n\t\tif t.type:\n\t\t\tself.dispatch(t.type)\n\t\tif t.inst:\n\t\t\tself.write(\", \")\n\t\t\tself.dispatch(t.inst)\n\t\tif t.tback:\n\t\t\tself.write(\", \")\n\t\t\tself.dispatch(t.tback)\n\n\tdef _TryExcept(self, t):\n\t\tself.fill(\"try\")\n\t\tself.enter()\n\t\tself.dispatch(t.body)\n\t\tself.leave()\n\n\t\tfor ex in t.handlers:\n\t\t\tself.dispatch(ex)\n\t\tif t.orelse:\n\t\t\tself.fill(\"else\")\n\t\t\tself.enter()\n\t\t\tself.dispatch(t.orelse)\n\t\t\tself.leave()\n\n\tdef _TryFinally(self, t):\n\t\tself.fill(\"try\")\n\t\tself.enter()\n\t\tself.dispatch(t.body)\n\t\tself.leave()\n\n\t\tself.fill(\"finally\")\n\t\tself.enter()\n\t\tself.dispatch(t.finalbody)\n\t\tself.leave()\n\n\tdef _ExceptHandler(self, t):\n\t\tself.fill(\"except\")\n\t\tif t.type:\n\t\t\tself.write(\" \")\n\t\t\tself.dispatch(t.type)\n\t\tif t.name:\n\t\t\tself.write(\", \")\n\t\t\tself.dispatch(t.name)\n\t\tself.enter()\n\t\tself.dispatch(t.body)\n\t\tself.leave()\n\n\tdef _ClassDef(self, t):\n\t\tself.write(\"\\n\")\n\t\tself.fill(\"class \"+t.name)\n\t\tif t.bases:\n\t\t\tself.write(\"(\")\n\t\t\tfor a in t.bases:\n\t\t\t\tself.dispatch(a)\n\t\t\t\tself.write(\", \")\n\t\t\tself.write(\")\")\n\t\tself.enter()\n\t\tself.dispatch(t.body)\n\t\tself.leave()\n\n\tdef _FunctionDef(self, t):\n\t\tself.write(\"\\n\")\n\t\tfor deco in t.decorator_list:\n\t\t\tself.fill(\"@\")\n\t\t\tself.dispatch(deco)\n\t\tself.fill(\"def \"+t.name + \"(\")\n\t\tself.dispatch(t.args)\n\t\tself.write(\")\")\n\t\tself.enter()\n\t\tself.dispatch(t.body)\n\t\tself.leave()\n\n\tdef _For(self, t):\n\t\tself.fill(\"for \")\n\t\tself.dispatch(t.target)\n\t\tself.write(\" in \")\n\t\tself.dispatch(t.iter)\n\t\tself.enter()\n\t\tself.dispatch(t.body)\n\t\tself.leave()\n\t\tif t.orelse:\n\t\t\tself.fill(\"else\")\n\t\t\tself.enter()\n\t\t\tself.dispatch(t.orelse)\n\t\t\tself.leave\n\n\tdef _If(self, t):\n\t\tself.fill(\"if \")\n\t\tself.dispatch(t.test)\n\t\tself.enter()\n\t\t# XXX elif?\n\t\tself.dispatch(t.body)\n\t\tself.leave()\n\t\tif t.orelse:\n\t\t\tself.fill(\"else\")\n\t\t\tself.enter()\n\t\t\tself.dispatch(t.orelse)\n\t\t\tself.leave()\n\n\tdef _While(self, t):\n\t\tself.fill(\"while \")\n\t\tself.dispatch(t.test)\n\t\tself.enter()\n\t\tself.dispatch(t.body)\n\t\tself.leave()\n\t\tif t.orelse:\n\t\t\tself.fill(\"else\")\n\t\t\tself.enter()\n\t\t\tself.dispatch(t.orelse)\n\t\t\tself.leave\n\n\tdef _With(self, t):\n\t\tself.fill(\"with \")\n\t\tself.dispatch(t.context_expr)\n\t\tif t.optional_vars:\n\t\t\tself.write(\" as \")\n\t\t\tself.dispatch(t.optional_vars)\n\t\tself.enter()\n\t\tself.dispatch(t.body)\n\t\tself.leave()\n\n\t# expr\n\tdef _Str(self, tree):\n\t\tself.write(repr(tree.s))\n\n\tdef _Name(self, t):\n\t\tself.write(t.id)\n\n\tdef _Repr(self, t):\n\t\tself.write(\"`\")\n\t\tself.dispatch(t.value)\n\t\tself.write(\"`\")\n\n\tdef _Num(self, t):\n\t\tself.write(repr(t.n))\n\n\tdef _List(self, t):\n\t\tself.write(\"[\")\n\t\tinterleave(lambda: self.write(\", \"), self.dispatch, t.elts)\n\t\tself.write(\"]\")\n\n\tdef _ListComp(self, t):\n\t\tself.write(\"[\")\n\t\tself.dispatch(t.elt)\n\t\tfor gen in t.generators:\n\t\t\tself.dispatch(gen)\n\t\tself.write(\"]\")\n\n\tdef _GeneratorExp(self, t):\n\t\tself.write(\"(\")\n\t\tself.dispatch(t.elt)\n\t\tfor gen in t.generators:\n\t\t\tself.dispatch(gen)\n\t\tself.write(\")\")\n\n\tdef _comprehension(self, t):\n\t\tself.write(\" for \")\n\t\tself.dispatch(t.target)\n\t\tself.write(\" in \")\n\t\tself.dispatch(t.iter)\n\t\tfor if_clause in t.ifs:\n\t\t\tself.write(\" if \")\n\t\t\tself.dispatch(if_clause)\n\n\tdef _IfExp(self, t):\n\t\tself.write(\"(\")\n\t\tself.dispatch(t.body)\n\t\tself.write(\" if \")\n\t\tself.dispatch(t.test)\n\t\tself.write(\" else \")\n\t\tself.dispatch(t.orelse)\n\t\tself.write(\")\")\n\n\tdef _Dict(self, t):\n\t\tself.write(\"{\")\n\t\tdef writem((k, v)):\n\t\t\tself.dispatch(k)\n\t\t\tself.write(\": \")\n\t\t\tself.dispatch(v)\n\t\tinterleave(lambda: self.write(\", \"), writem, zip(t.keys, t.values))\n\t\tself.write(\"}\")\n\n\tdef _Tuple(self, t):\n\t\tself.write(\"(\")\n\t\tif len(t.elts) == 1:\n\t\t\t(elt,) = t.elts\n\t\t\tself.dispatch(elt)\n\t\t\tself.write(\",\")\n\t\telse:\n\t\t\tinterleave(lambda: self.write(\", \"), self.dispatch, t.elts)\n\t\tself.write(\")\")\n\n\tunop = {\"Invert\":\"~\", \"Not\": \"not\", \"UAdd\":\"+\", \"USub\":\"-\"}\n\tdef _UnaryOp(self, t):\n\t\tself.write(self.unop[t.op.__class__.__name__])\n\t\tself.write(\"(\")\n\t\tself.dispatch(t.operand)\n\t\tself.write(\")\")\n\n\tbinop = { \"Add\":\"+\", \"Sub\":\"-\", \"Mult\":\"*\", \"Div\":\"/\", \"Mod\":\"%\",\n\t\t\t\t\t\"LShift\":\">>\", \"RShift\":\"<<\", \"BitOr\":\"|\", \"BitXor\":\"^\", \"BitAnd\":\"&\",\n\t\t\t\t\t\"FloorDiv\":\"//\", \"Pow\": \"**\"}\n\tdef _BinOp(self, t):\n\t\tself.write(\"(\")\n\t\tself.dispatch(t.left)\n\t\tself.write(\" \" + self.binop[t.op.__class__.__name__] + \" \")\n\t\tself.dispatch(t.right)\n\t\tself.write(\")\")\n\n\tcmpops = {\"Eq\":\"==\", \"NotEq\":\"!=\", \"Lt\":\"<\", \"LtE\":\"<=\", \"Gt\":\">\", \"GtE\":\">=\",\n\t\t\t\t\t\t\"Is\":\"is\", \"IsNot\":\"is not\", \"In\":\"in\", \"NotIn\":\"not in\"}\n\tdef _Compare(self, t):\n\t\tself.write(\"(\")\n\t\tself.dispatch(t.left)\n\t\tfor o, e in zip(t.ops, t.comparators):\n\t\t\tself.write(\" \" + self.cmpops[o.__class__.__name__] + \" \")\n\t\t\tself.dispatch(e)\n\t\t\tself.write(\")\")\n\n\tboolops = {_ast.And: 'and', _ast.Or: 'or'}\n\tdef _BoolOp(self, t):\n\t\tself.write(\"(\")\n\t\ts = \" %s \" % self.boolops[t.op.__class__]\n\t\tinterleave(lambda: self.write(s), self.dispatch, t.values)\n\t\tself.write(\")\")\n\n\tdef _Attribute(self,t):\n\t\tself.dispatch(t.value)\n\t\tself.write(\".\")\n\t\tself.write(t.attr)\n\n\tdef _Call(self, t):\n\t\tself.dispatch(t.func)\n\t\tself.write(\"(\")\n\t\tcomma = False\n\t\tfor e in t.args:\n\t\t\tif comma: self.write(\", \")\n\t\t\telse: comma = True\n\t\t\tself.dispatch(e)\n\t\tfor e in t.keywords:\n\t\t\tif comma: self.write(\", \")\n\t\t\telse: comma = True\n\t\t\tself.dispatch(e)\n\t\tif t.starargs:\n\t\t\tif comma: self.write(\", \")\n\t\t\telse: comma = True\n\t\t\tself.write(\"*\")\n\t\t\tself.dispatch(t.starargs)\n\t\tif t.kwargs:\n\t\t\tif comma: self.write(\", \")\n\t\t\telse: comma = True\n\t\t\tself.write(\"**\")\n\t\t\tself.dispatch(t.kwargs)\n\t\tself.write(\")\")\n\n\tdef _Subscript(self, t):\n\t\tself.dispatch(t.value)\n\t\tself.write(\"[\")\n\t\tself.dispatch(t.slice)\n\t\tself.write(\"]\")\n\n\t# slice\n\tdef _Ellipsis(self, t):\n\t\tself.write(\"...\")\n\n\tdef _Index(self, t):\n\t\tself.dispatch(t.value)\n\n\tdef _Slice(self, t):\n\t\tif t.lower:\n\t\t\tself.dispatch(t.lower)\n\t\tself.write(\":\")\n\t\tif t.upper:\n\t\t\tself.dispatch(t.upper)\n\t\tif t.step:\n\t\t\tself.write(\":\")\n\t\t\tself.dispatch(t.step)\n\n\tdef _ExtSlice(self, t):\n\t\tinterleave(lambda: self.write(', '), self.dispatch, t.dims)\n\n\t# others\n\tdef _arguments(self, t):\n\t\tfirst = True\n\t\tnonDef = len(t.args)-len(t.defaults)\n\t\tfor a in t.args[0:nonDef]:\n\t\t\tif first:first = False\n\t\t\telse: self.write(\", \")\n\t\t\tself.dispatch(a)\n\t\tfor a,d in zip(t.args[nonDef:], t.defaults):\n\t\t\tif first:first = False\n\t\t\telse: self.write(\", \")\n\t\t\tself.dispatch(a),\n\t\t\tself.write(\"=\")\n\t\t\tself.dispatch(d)\n\t\tif t.vararg:\n\t\t\tif first:first = False\n\t\t\telse: self.write(\", \")\n\t\t\tself.write(\"*\"+t.vararg)\n\t\tif t.kwarg:\n\t\t\tif first:first = False\n\t\t\telse: self.write(\", \")\n\t\t\tself.write(\"**\"+t.kwarg)\n\n\tdef _keyword(self, t):\n\t\tself.write(t.arg)\n\t\tself.write(\"=\")\n\t\tself.dispatch(t.value)\n\n\tdef _Lambda(self, t):\n\t\tself.write(\"lambda \")\n\t\tself.dispatch(t.args)\n\t\tself.write(\": \")\n\t\tself.dispatch(t.body)\n\n\tdef _alias(self, t):\n\t\tself.write(t.name)\n\t\tif t.asname:\n\t\t\tself.write(\" as \"+t.asname)\n", "description": "Methods in this class recursively traverse an AST and\n\toutput source code for the abstract syntax; original formatting\n\tis disregarged. ", "category": "def", "imports": ["import sys", "import _ast", "import cStringIO", "import os", "\t\tself.fill(\"import \")", "\t\tself.write(\" import \")"]}, {"term": "def", "name": "roundtrip", "data": "def roundtrip(filename, output=sys.stdout):\n\tsource = open(filename).read()\n\ttree = compile(source, filename, \"exec\", _ast.PyCF_ONLY_AST)\n\tUnparser(tree, output)\n\n\n", "description": null, "category": "def", "imports": ["import sys", "import _ast", "import cStringIO", "import os", "\t\tself.fill(\"import \")", "\t\tself.write(\" import \")"]}, {"term": "def", "name": "testdir", "data": "def testdir(a):\n\ttry:\n\t\tnames = [n for n in os.listdir(a) if n.endswith('.py')]\n\texcept OSError:\n\t\tprint >> sys.stderr, \"Directory not readable: %s\" % a\n\telse:\n\t\tfor n in names:\n\t\t\tfullname = os.path.join(a, n)\n\t\t\tif os.path.isfile(fullname):\n\t\t\t\toutput = cStringIO.StringIO()\n\t\t\t\tprint 'Testing %s' % fullname\n\t\t\t\ttry:\n\t\t\t\t\troundtrip(fullname, output)\n\t\t\t\texcept Exception, e:\n\t\t\t\t\tprint '  Failed to compile, exception is %s' % repr(e)\n\t\t\telif os.path.isdir(fullname):\n\t\t\t\ttestdir(fullname)\n", "description": null, "category": "def", "imports": ["import sys", "import _ast", "import cStringIO", "import os", "\t\tself.fill(\"import \")", "\t\tself.write(\" import \")"]}, {"term": "def", "name": "main", "data": "def main(args):\n\tif args[0] == '--testdir':\n\t\tfor a in args[1:]:\n\t\t\ttestdir(a)\n\telse:\n\t\tfor a in args:\n\t\t\troundtrip(a)\n", "description": null, "category": "def", "imports": ["import sys", "import _ast", "import cStringIO", "import os", "\t\tself.fill(\"import \")", "\t\tself.write(\" import \")"]}], [{"term": "class", "name": "AwaitException", "data": "class AwaitException(Exception):\n\tpass\n\n", "description": null, "category": "def", "imports": ["import inspect", "import types", "import unittest", "from test.support import import_module", "asyncio = import_module(\"asyncio\")"]}, {"term": "def", "name": "awaitable", "data": "def awaitable(*, throw=False):\n\tif throw:\n\t\tyield ('throw',)\n\telse:\n\t\tyield ('result',)\n\n", "description": null, "category": "def", "imports": ["import inspect", "import types", "import unittest", "from test.support import import_module", "asyncio = import_module(\"asyncio\")"]}, {"term": "def", "name": "run_until_complete", "data": "def run_until_complete(coro):\n\texc = False\n\twhile True:\n\t\ttry:\n\t\t\tif exc:\n\t\t\t\texc = False\n\t\t\t\tfut = coro.throw(AwaitException)\n\t\t\telse:\n\t\t\t\tfut = coro.send(None)\n\t\texcept StopIteration as ex:\n\t\t\treturn ex.args[0]\n\n\t\tif fut == ('throw',):\n\t\t\texc = True\n\n", "description": null, "category": "def", "imports": ["import inspect", "import types", "import unittest", "from test.support import import_module", "asyncio = import_module(\"asyncio\")"]}, {"term": "def", "name": "to_list", "data": "def to_list(gen):\n\tasync def iterate():\n\t\tres = []\n\t\tasync for i in gen:\n\t\t\tres.append(i)\n\t\treturn res\n\n\treturn run_until_complete(iterate())\n\n", "description": null, "category": "def", "imports": ["import inspect", "import types", "import unittest", "from test.support import import_module", "asyncio = import_module(\"asyncio\")"]}, {"term": "class", "name": "AsyncGenSyntaxTest", "data": "class AsyncGenSyntaxTest(unittest.TestCase):\n\n\tdef test_async_gen_syntax_01(self):\n\t\tcode = '''async def foo():\n\t\t\tawait abc\n\t\t\tyield from 123\n\t\t'''\n\n\t\twith self.assertRaisesRegex(SyntaxError, 'yield from.*inside async'):\n\t\t\texec(code, {}, {})\n\n\tdef test_async_gen_syntax_02(self):\n\t\tcode = '''async def foo():\n\t\t\tyield from 123\n\t\t'''\n\n\t\twith self.assertRaisesRegex(SyntaxError, 'yield from.*inside async'):\n\t\t\texec(code, {}, {})\n\n\tdef test_async_gen_syntax_03(self):\n\t\tcode = '''async def foo():\n\t\t\tawait abc\n\t\t\tyield\n\t\t\treturn 123\n\t\t'''\n\n\t\twith self.assertRaisesRegex(SyntaxError, 'return.*value.*async gen'):\n\t\t\texec(code, {}, {})\n\n\tdef test_async_gen_syntax_04(self):\n\t\tcode = '''async def foo():\n\t\t\tyield\n\t\t\treturn 123\n\t\t'''\n\n\t\twith self.assertRaisesRegex(SyntaxError, 'return.*value.*async gen'):\n\t\t\texec(code, {}, {})\n\n\tdef test_async_gen_syntax_05(self):\n\t\tcode = '''async def foo():\n\t\t\tif 0:\n\t\t\t\tyield\n\t\t\treturn 12\n\t\t'''\n\n\t\twith self.assertRaisesRegex(SyntaxError, 'return.*value.*async gen'):\n\t\t\texec(code, {}, {})\n\n", "description": null, "category": "def", "imports": ["import inspect", "import types", "import unittest", "from test.support import import_module", "asyncio = import_module(\"asyncio\")"]}, {"term": "class", "name": "AsyncGenTest", "data": "class AsyncGenTest(unittest.TestCase):\n\n\tdef compare_generators(self, sync_gen, async_gen):\n\t\tdef sync_iterate(g):\n\t\t\tres = []\n\t\t\twhile True:\n\t\t\t\ttry:\n\t\t\t\t\tres.append(g.__next__())\n\t\t\t\texcept StopIteration:\n\t\t\t\t\tres.append('STOP')\n\t\t\t\t\tbreak\n\t\t\t\texcept Exception as ex:\n\t\t\t\t\tres.append(str(type(ex)))\n\t\t\treturn res\n\n\t\tdef async_iterate(g):\n\t\t\tres = []\n\t\t\twhile True:\n\t\t\t\ttry:\n\t\t\t\t\tg.__anext__().__next__()\n\t\t\t\texcept StopAsyncIteration:\n\t\t\t\t\tres.append('STOP')\n\t\t\t\t\tbreak\n\t\t\t\texcept StopIteration as ex:\n\t\t\t\t\tif ex.args:\n\t\t\t\t\t\tres.append(ex.args[0])\n\t\t\t\t\telse:\n\t\t\t\t\t\tres.append('EMPTY StopIteration')\n\t\t\t\t\t\tbreak\n\t\t\t\texcept Exception as ex:\n\t\t\t\t\tres.append(str(type(ex)))\n\t\t\treturn res\n\n\t\tsync_gen_result = sync_iterate(sync_gen)\n\t\tasync_gen_result = async_iterate(async_gen)\n\t\tself.assertEqual(sync_gen_result, async_gen_result)\n\t\treturn async_gen_result\n\n\tdef test_async_gen_iteration_01(self):\n\t\tasync def gen():\n\t\t\tawait awaitable()\n\t\t\ta = yield 123\n\t\t\tself.assertIs(a, None)\n\t\t\tawait awaitable()\n\t\t\tyield 456\n\t\t\tawait awaitable()\n\t\t\tyield 789\n\n\t\tself.assertEqual(to_list(gen()), [123, 456, 789])\n\n\tdef test_async_gen_iteration_02(self):\n\t\tasync def gen():\n\t\t\tawait awaitable()\n\t\t\tyield 123\n\t\t\tawait awaitable()\n\n\t\tg = gen()\n\t\tai = g.__aiter__()\n\t\tself.assertEqual(ai.__anext__().__next__(), ('result',))\n\n\t\ttry:\n\t\t\tai.__anext__().__next__()\n\t\texcept StopIteration as ex:\n\t\t\tself.assertEqual(ex.args[0], 123)\n\t\telse:\n\t\t\tself.fail('StopIteration was not raised')\n\n\t\tself.assertEqual(ai.__anext__().__next__(), ('result',))\n\n\t\ttry:\n\t\t\tai.__anext__().__next__()\n\t\texcept StopAsyncIteration as ex:\n\t\t\tself.assertFalse(ex.args)\n\t\telse:\n\t\t\tself.fail('StopAsyncIteration was not raised')\n\n\tdef test_async_gen_exception_03(self):\n\t\tasync def gen():\n\t\t\tawait awaitable()\n\t\t\tyield 123\n\t\t\tawait awaitable(throw=True)\n\t\t\tyield 456\n\n\t\twith self.assertRaises(AwaitException):\n\t\t\tto_list(gen())\n\n\tdef test_async_gen_exception_04(self):\n\t\tasync def gen():\n\t\t\tawait awaitable()\n\t\t\tyield 123\n\t\t\t1 / 0\n\n\t\tg = gen()\n\t\tai = g.__aiter__()\n\t\tself.assertEqual(ai.__anext__().__next__(), ('result',))\n\n\t\ttry:\n\t\t\tai.__anext__().__next__()\n\t\texcept StopIteration as ex:\n\t\t\tself.assertEqual(ex.args[0], 123)\n\t\telse:\n\t\t\tself.fail('StopIteration was not raised')\n\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tai.__anext__().__next__()\n\n\tdef test_async_gen_exception_05(self):\n\t\tasync def gen():\n\t\t\tyield 123\n\t\t\traise StopAsyncIteration\n\n\t\twith self.assertRaisesRegex(RuntimeError,\n\t\t\t\t\t\t\t\t\t'async generator.*StopAsyncIteration'):\n\t\t\tto_list(gen())\n\n\tdef test_async_gen_exception_06(self):\n\t\tasync def gen():\n\t\t\tyield 123\n\t\t\traise StopIteration\n\n\t\twith self.assertRaisesRegex(RuntimeError,\n\t\t\t\t\t\t\t\t\t'async generator.*StopIteration'):\n\t\t\tto_list(gen())\n\n\tdef test_async_gen_exception_07(self):\n\t\tdef sync_gen():\n\t\t\ttry:\n\t\t\t\tyield 1\n\t\t\t\t1 / 0\n\t\t\tfinally:\n\t\t\t\tyield 2\n\t\t\t\tyield 3\n\n\t\t\tyield 100\n\n\t\tasync def async_gen():\n\t\t\ttry:\n\t\t\t\tyield 1\n\t\t\t\t1 / 0\n\t\t\tfinally:\n\t\t\t\tyield 2\n\t\t\t\tyield 3\n\n\t\t\tyield 100\n\n\t\tself.compare_generators(sync_gen(), async_gen())\n\n\tdef test_async_gen_exception_08(self):\n\t\tdef sync_gen():\n\t\t\ttry:\n\t\t\t\tyield 1\n\t\t\tfinally:\n\t\t\t\tyield 2\n\t\t\t\t1 / 0\n\t\t\t\tyield 3\n\n\t\t\tyield 100\n\n\t\tasync def async_gen():\n\t\t\ttry:\n\t\t\t\tyield 1\n\t\t\t\tawait awaitable()\n\t\t\tfinally:\n\t\t\t\tawait awaitable()\n\t\t\t\tyield 2\n\t\t\t\t1 / 0\n\t\t\t\tyield 3\n\n\t\t\tyield 100\n\n\t\tself.compare_generators(sync_gen(), async_gen())\n\n\tdef test_async_gen_exception_09(self):\n\t\tdef sync_gen():\n\t\t\ttry:\n\t\t\t\tyield 1\n\t\t\t\t1 / 0\n\t\t\tfinally:\n\t\t\t\tyield 2\n\t\t\t\tyield 3\n\n\t\t\tyield 100\n\n\t\tasync def async_gen():\n\t\t\ttry:\n\t\t\t\tawait awaitable()\n\t\t\t\tyield 1\n\t\t\t\t1 / 0\n\t\t\tfinally:\n\t\t\t\tyield 2\n\t\t\t\tawait awaitable()\n\t\t\t\tyield 3\n\n\t\t\tyield 100\n\n\t\tself.compare_generators(sync_gen(), async_gen())\n\n\tdef test_async_gen_exception_10(self):\n\t\tasync def gen():\n\t\t\tyield 123\n\t\twith self.assertRaisesRegex(TypeError,\n\t\t\t\t\t\t\t\t\t\"non-None value .* async generator\"):\n\t\t\tgen().__anext__().send(100)\n\n\tdef test_async_gen_api_01(self):\n\t\tasync def gen():\n\t\t\tyield 123\n\n\t\tg = gen()\n\n\t\tself.assertEqual(g.__name__, 'gen')\n\t\tg.__name__ = '123'\n\t\tself.assertEqual(g.__name__, '123')\n\n\t\tself.assertIn('.gen', g.__qualname__)\n\t\tg.__qualname__ = '123'\n\t\tself.assertEqual(g.__qualname__, '123')\n\n\t\tself.assertIsNone(g.ag_await)\n\t\tself.assertIsInstance(g.ag_frame, types.FrameType)\n\t\tself.assertFalse(g.ag_running)\n\t\tself.assertIsInstance(g.ag_code, types.CodeType)\n\n\t\tself.assertTrue(inspect.isawaitable(g.aclose()))\n\n", "description": null, "category": "def", "imports": ["import inspect", "import types", "import unittest", "from test.support import import_module", "asyncio = import_module(\"asyncio\")"]}, {"term": "class", "name": "AsyncGenAsyncioTest", "data": "class AsyncGenAsyncioTest(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tself.loop = asyncio.new_event_loop()\n\t\tasyncio.set_event_loop(None)\n\n\tdef tearDown(self):\n\t\tself.loop.close()\n\t\tself.loop = None\n\n\tasync def to_list(self, gen):\n\t\tres = []\n\t\tasync for i in gen:\n\t\t\tres.append(i)\n\t\treturn res\n\n\tdef test_async_gen_asyncio_01(self):\n\t\tasync def gen():\n\t\t\tyield 1\n\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\tyield 2\n\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\treturn\n\t\t\tyield 3\n\n\t\tres = self.loop.run_until_complete(self.to_list(gen()))\n\t\tself.assertEqual(res, [1, 2])\n\n\tdef test_async_gen_asyncio_02(self):\n\t\tasync def gen():\n\t\t\tyield 1\n\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\tyield 2\n\t\t\t1 / 0\n\t\t\tyield 3\n\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tself.loop.run_until_complete(self.to_list(gen()))\n\n\tdef test_async_gen_asyncio_03(self):\n\t\tloop = self.loop\n\n\t\tclass Gen:\n\t\t\tasync def __aiter__(self):\n\t\t\t\tyield 1\n\t\t\t\tawait asyncio.sleep(0.01, loop=loop)\n\t\t\t\tyield 2\n\n\t\tres = loop.run_until_complete(self.to_list(Gen()))\n\t\tself.assertEqual(res, [1, 2])\n\n\tdef test_async_gen_asyncio_anext_04(self):\n\t\tasync def foo():\n\t\t\tyield 1\n\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\ttry:\n\t\t\t\tyield 2\n\t\t\t\tyield 3\n\t\t\texcept ZeroDivisionError:\n\t\t\t\tyield 1000\n\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\tyield 4\n\n\t\tasync def run1():\n\t\t\tit = foo().__aiter__()\n\n\t\t\tself.assertEqual(await it.__anext__(), 1)\n\t\t\tself.assertEqual(await it.__anext__(), 2)\n\t\t\tself.assertEqual(await it.__anext__(), 3)\n\t\t\tself.assertEqual(await it.__anext__(), 4)\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait it.__anext__()\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait it.__anext__()\n\n\t\tasync def run2():\n\t\t\tit = foo().__aiter__()\n\n\t\t\tself.assertEqual(await it.__anext__(), 1)\n\t\t\tself.assertEqual(await it.__anext__(), 2)\n\t\t\ttry:\n\t\t\t\tit.__anext__().throw(ZeroDivisionError)\n\t\t\texcept StopIteration as ex:\n\t\t\t\tself.assertEqual(ex.args[0], 1000)\n\t\t\telse:\n\t\t\t\tself.fail('StopIteration was not raised')\n\t\t\tself.assertEqual(await it.__anext__(), 4)\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait it.__anext__()\n\n\t\tself.loop.run_until_complete(run1())\n\t\tself.loop.run_until_complete(run2())\n\n\tdef test_async_gen_asyncio_anext_05(self):\n\t\tasync def foo():\n\t\t\tv = yield 1\n\t\t\tv = yield v\n\t\t\tyield v * 100\n\n\t\tasync def run():\n\t\t\tit = foo().__aiter__()\n\n\t\t\ttry:\n\t\t\t\tit.__anext__().send(None)\n\t\t\texcept StopIteration as ex:\n\t\t\t\tself.assertEqual(ex.args[0], 1)\n\t\t\telse:\n\t\t\t\tself.fail('StopIteration was not raised')\n\n\t\t\ttry:\n\t\t\t\tit.__anext__().send(10)\n\t\t\texcept StopIteration as ex:\n\t\t\t\tself.assertEqual(ex.args[0], 10)\n\t\t\telse:\n\t\t\t\tself.fail('StopIteration was not raised')\n\n\t\t\ttry:\n\t\t\t\tit.__anext__().send(12)\n\t\t\texcept StopIteration as ex:\n\t\t\t\tself.assertEqual(ex.args[0], 1200)\n\t\t\telse:\n\t\t\t\tself.fail('StopIteration was not raised')\n\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait it.__anext__()\n\n\t\tself.loop.run_until_complete(run())\n\n\tdef test_async_gen_asyncio_anext_06(self):\n\t\tDONE = 0\n\n\t\t# test synchronous generators\n\t\tdef foo():\n\t\t\ttry:\n\t\t\t\tyield\n\t\t\texcept:\n\t\t\t\tpass\n\t\tg = foo()\n\t\tg.send(None)\n\t\twith self.assertRaises(StopIteration):\n\t\t\tg.send(None)\n\n\t\t# now with asynchronous generators\n\n\t\tasync def gen():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\tyield\n\t\t\texcept:\n\t\t\t\tpass\n\t\t\tDONE = 1\n\n\t\tasync def run():\n\t\t\tnonlocal DONE\n\t\t\tg = gen()\n\t\t\tawait g.asend(None)\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait g.asend(None)\n\t\t\tDONE += 10\n\n\t\tself.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 11)\n\n\tdef test_async_gen_asyncio_anext_tuple(self):\n\t\tasync def foo():\n\t\t\ttry:\n\t\t\t\tyield (1,)\n\t\t\texcept ZeroDivisionError:\n\t\t\t\tyield (2,)\n\n\t\tasync def run():\n\t\t\tit = foo().__aiter__()\n\n\t\t\tself.assertEqual(await it.__anext__(), (1,))\n\t\t\twith self.assertRaises(StopIteration) as cm:\n\t\t\t\tit.__anext__().throw(ZeroDivisionError)\n\t\t\tself.assertEqual(cm.exception.args[0], (2,))\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait it.__anext__()\n\n\t\tself.loop.run_until_complete(run())\n\n\tdef test_async_gen_asyncio_anext_stopiteration(self):\n\t\tasync def foo():\n\t\t\ttry:\n\t\t\t\tyield StopIteration(1)\n\t\t\texcept ZeroDivisionError:\n\t\t\t\tyield StopIteration(3)\n\n\t\tasync def run():\n\t\t\tit = foo().__aiter__()\n\n\t\t\tv = await it.__anext__()\n\t\t\tself.assertIsInstance(v, StopIteration)\n\t\t\tself.assertEqual(v.value, 1)\n\t\t\twith self.assertRaises(StopIteration) as cm:\n\t\t\t\tit.__anext__().throw(ZeroDivisionError)\n\t\t\tv = cm.exception.args[0]\n\t\t\tself.assertIsInstance(v, StopIteration)\n\t\t\tself.assertEqual(v.value, 3)\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait it.__anext__()\n\n\t\tself.loop.run_until_complete(run())\n\n\tdef test_async_gen_asyncio_aclose_06(self):\n\t\tasync def foo():\n\t\t\ttry:\n\t\t\t\tyield 1\n\t\t\t\t1 / 0\n\t\t\tfinally:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tyield 12\n\n\t\tasync def run():\n\t\t\tgen = foo()\n\t\t\tit = gen.__aiter__()\n\t\t\tawait it.__anext__()\n\t\t\tawait gen.aclose()\n\n\t\twith self.assertRaisesRegex(\n\t\t\t\tRuntimeError,\n\t\t\t\t\"async generator ignored GeneratorExit\"):\n\t\t\tself.loop.run_until_complete(run())\n\n\tdef test_async_gen_asyncio_aclose_07(self):\n\t\tDONE = 0\n\n\t\tasync def foo():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\tyield 1\n\t\t\t\t1 / 0\n\t\t\tfinally:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tDONE += 1\n\t\t\tDONE += 1000\n\n\t\tasync def run():\n\t\t\tgen = foo()\n\t\t\tit = gen.__aiter__()\n\t\t\tawait it.__anext__()\n\t\t\tawait gen.aclose()\n\n\t\tself.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 1)\n\n\tdef test_async_gen_asyncio_aclose_08(self):\n\t\tDONE = 0\n\n\t\tfut = asyncio.Future(loop=self.loop)\n\n\t\tasync def foo():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\tyield 1\n\t\t\t\tawait fut\n\t\t\t\tDONE += 1000\n\t\t\t\tyield 2\n\t\t\tfinally:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tDONE += 1\n\t\t\tDONE += 1000\n\n\t\tasync def run():\n\t\t\tgen = foo()\n\t\t\tit = gen.__aiter__()\n\t\t\tself.assertEqual(await it.__anext__(), 1)\n\t\t\tt = self.loop.create_task(it.__anext__())\n\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\tawait gen.aclose()\n\t\t\treturn t\n\n\t\tt = self.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 1)\n\n\t\t# Silence ResourceWarnings\n\t\tfut.cancel()\n\t\tt.cancel()\n\t\tself.loop.run_until_complete(asyncio.sleep(0.01, loop=self.loop))\n\n\tdef test_async_gen_asyncio_gc_aclose_09(self):\n\t\tDONE = 0\n\n\t\tasync def gen():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\twhile True:\n\t\t\t\t\tyield 1\n\t\t\tfinally:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tDONE = 1\n\n\t\tasync def run():\n\t\t\tg = gen()\n\t\t\tawait g.__anext__()\n\t\t\tawait g.__anext__()\n\t\t\tdel g\n\n\t\t\tawait asyncio.sleep(0.1, loop=self.loop)\n\n\t\tself.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 1)\n\n\tdef test_async_gen_asyncio_aclose_10(self):\n\t\tDONE = 0\n\n\t\t# test synchronous generators\n\t\tdef foo():\n\t\t\ttry:\n\t\t\t\tyield\n\t\t\texcept:\n\t\t\t\tpass\n\t\tg = foo()\n\t\tg.send(None)\n\t\tg.close()\n\n\t\t# now with asynchronous generators\n\n\t\tasync def gen():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\tyield\n\t\t\texcept:\n\t\t\t\tpass\n\t\t\tDONE = 1\n\n\t\tasync def run():\n\t\t\tnonlocal DONE\n\t\t\tg = gen()\n\t\t\tawait g.asend(None)\n\t\t\tawait g.aclose()\n\t\t\tDONE += 10\n\n\t\tself.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 11)\n\n\tdef test_async_gen_asyncio_aclose_11(self):\n\t\tDONE = 0\n\n\t\t# test synchronous generators\n\t\tdef foo():\n\t\t\ttry:\n\t\t\t\tyield\n\t\t\texcept:\n\t\t\t\tpass\n\t\t\tyield\n\t\tg = foo()\n\t\tg.send(None)\n\t\twith self.assertRaisesRegex(RuntimeError, 'ignored GeneratorExit'):\n\t\t\tg.close()\n\n\t\t# now with asynchronous generators\n\n\t\tasync def gen():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\tyield\n\t\t\texcept:\n\t\t\t\tpass\n\t\t\tyield\n\t\t\tDONE += 1\n\n\t\tasync def run():\n\t\t\tnonlocal DONE\n\t\t\tg = gen()\n\t\t\tawait g.asend(None)\n\t\t\twith self.assertRaisesRegex(RuntimeError, 'ignored GeneratorExit'):\n\t\t\t\tawait g.aclose()\n\t\t\tDONE += 10\n\n\t\tself.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 10)\n\n\tdef test_async_gen_asyncio_asend_01(self):\n\t\tDONE = 0\n\n\t\t# Sanity check:\n\t\tdef sgen():\n\t\t\tv = yield 1\n\t\t\tyield v * 2\n\t\tsg = sgen()\n\t\tv = sg.send(None)\n\t\tself.assertEqual(v, 1)\n\t\tv = sg.send(100)\n\t\tself.assertEqual(v, 200)\n\n\t\tasync def gen():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tv = yield 1\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tyield v * 2\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\treturn\n\t\t\tfinally:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tDONE = 1\n\n\t\tasync def run():\n\t\t\tg = gen()\n\n\t\t\tv = await g.asend(None)\n\t\t\tself.assertEqual(v, 1)\n\n\t\t\tv = await g.asend(100)\n\t\t\tself.assertEqual(v, 200)\n\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait g.asend(None)\n\n\t\tself.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 1)\n\n\tdef test_async_gen_asyncio_asend_02(self):\n\t\tDONE = 0\n\n\t\tasync def sleep_n_crash(delay):\n\t\t\tawait asyncio.sleep(delay, loop=self.loop)\n\t\t\t1 / 0\n\n\t\tasync def gen():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tv = yield 1\n\t\t\t\tawait sleep_n_crash(0.01)\n\t\t\t\tDONE += 1000\n\t\t\t\tyield v * 2\n\t\t\tfinally:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tDONE = 1\n\n\t\tasync def run():\n\t\t\tg = gen()\n\n\t\t\tv = await g.asend(None)\n\t\t\tself.assertEqual(v, 1)\n\n\t\t\tawait g.asend(100)\n\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\tself.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 1)\n\n\tdef test_async_gen_asyncio_asend_03(self):\n\t\tDONE = 0\n\n\t\tasync def sleep_n_crash(delay):\n\t\t\tfut = asyncio.ensure_future(asyncio.sleep(delay, loop=self.loop),\n\t\t\t\t\t\t\t\t\t\tloop=self.loop)\n\t\t\tself.loop.call_later(delay / 2, lambda: fut.cancel())\n\t\t\treturn await fut\n\n\t\tasync def gen():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tv = yield 1\n\t\t\t\tawait sleep_n_crash(0.01)\n\t\t\t\tDONE += 1000\n\t\t\t\tyield v * 2\n\t\t\tfinally:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tDONE = 1\n\n\t\tasync def run():\n\t\t\tg = gen()\n\n\t\t\tv = await g.asend(None)\n\t\t\tself.assertEqual(v, 1)\n\n\t\t\tawait g.asend(100)\n\n\t\twith self.assertRaises(asyncio.CancelledError):\n\t\t\tself.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 1)\n\n\tdef test_async_gen_asyncio_athrow_01(self):\n\t\tDONE = 0\n\n\t\tclass FooEr(Exception):\n\t\t\tpass\n\n\t\t# Sanity check:\n\t\tdef sgen():\n\t\t\ttry:\n\t\t\t\tv = yield 1\n\t\t\texcept FooEr:\n\t\t\t\tv = 1000\n\t\t\tyield v * 2\n\t\tsg = sgen()\n\t\tv = sg.send(None)\n\t\tself.assertEqual(v, 1)\n\t\tv = sg.throw(FooEr)\n\t\tself.assertEqual(v, 2000)\n\t\twith self.assertRaises(StopIteration):\n\t\t\tsg.send(None)\n\n\t\tasync def gen():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\ttry:\n\t\t\t\t\tv = yield 1\n\t\t\t\texcept FooEr:\n\t\t\t\t\tv = 1000\n\t\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tyield v * 2\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\t# return\n\t\t\tfinally:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tDONE = 1\n\n\t\tasync def run():\n\t\t\tg = gen()\n\n\t\t\tv = await g.asend(None)\n\t\t\tself.assertEqual(v, 1)\n\n\t\t\tv = await g.athrow(FooEr)\n\t\t\tself.assertEqual(v, 2000)\n\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait g.asend(None)\n\n\t\tself.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 1)\n\n\tdef test_async_gen_asyncio_athrow_02(self):\n\t\tDONE = 0\n\n\t\tclass FooEr(Exception):\n\t\t\tpass\n\n\t\tasync def sleep_n_crash(delay):\n\t\t\tfut = asyncio.ensure_future(asyncio.sleep(delay, loop=self.loop),\n\t\t\t\t\t\t\t\t\t\tloop=self.loop)\n\t\t\tself.loop.call_later(delay / 2, lambda: fut.cancel())\n\t\t\treturn await fut\n\n\t\tasync def gen():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\ttry:\n\t\t\t\t\tv = yield 1\n\t\t\t\texcept FooEr:\n\t\t\t\t\tawait sleep_n_crash(0.01)\n\t\t\t\tyield v * 2\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\t# return\n\t\t\tfinally:\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tDONE = 1\n\n\t\tasync def run():\n\t\t\tg = gen()\n\n\t\t\tv = await g.asend(None)\n\t\t\tself.assertEqual(v, 1)\n\n\t\t\ttry:\n\t\t\t\tawait g.athrow(FooEr)\n\t\t\texcept asyncio.CancelledError:\n\t\t\t\tself.assertEqual(DONE, 1)\n\t\t\t\traise\n\t\t\telse:\n\t\t\t\tself.fail('CancelledError was not raised')\n\n\t\twith self.assertRaises(asyncio.CancelledError):\n\t\t\tself.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 1)\n\n\tdef test_async_gen_asyncio_athrow_03(self):\n\t\tDONE = 0\n\n\t\t# test synchronous generators\n\t\tdef foo():\n\t\t\ttry:\n\t\t\t\tyield\n\t\t\texcept:\n\t\t\t\tpass\n\t\tg = foo()\n\t\tg.send(None)\n\t\twith self.assertRaises(StopIteration):\n\t\t\tg.throw(ValueError)\n\n\t\t# now with asynchronous generators\n\n\t\tasync def gen():\n\t\t\tnonlocal DONE\n\t\t\ttry:\n\t\t\t\tyield\n\t\t\texcept:\n\t\t\t\tpass\n\t\t\tDONE = 1\n\n\t\tasync def run():\n\t\t\tnonlocal DONE\n\t\t\tg = gen()\n\t\t\tawait g.asend(None)\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait g.athrow(ValueError)\n\t\t\tDONE += 10\n\n\t\tself.loop.run_until_complete(run())\n\t\tself.assertEqual(DONE, 11)\n\n\tdef test_async_gen_asyncio_athrow_tuple(self):\n\t\tasync def gen():\n\t\t\ttry:\n\t\t\t\tyield 1\n\t\t\texcept ZeroDivisionError:\n\t\t\t\tyield (2,)\n\n\t\tasync def run():\n\t\t\tg = gen()\n\t\t\tv = await g.asend(None)\n\t\t\tself.assertEqual(v, 1)\n\t\t\tv = await g.athrow(ZeroDivisionError)\n\t\t\tself.assertEqual(v, (2,))\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait g.asend(None)\n\n\t\tself.loop.run_until_complete(run())\n\n\tdef test_async_gen_asyncio_athrow_stopiteration(self):\n\t\tasync def gen():\n\t\t\ttry:\n\t\t\t\tyield 1\n\t\t\texcept ZeroDivisionError:\n\t\t\t\tyield StopIteration(2)\n\n\t\tasync def run():\n\t\t\tg = gen()\n\t\t\tv = await g.asend(None)\n\t\t\tself.assertEqual(v, 1)\n\t\t\tv = await g.athrow(ZeroDivisionError)\n\t\t\tself.assertIsInstance(v, StopIteration)\n\t\t\tself.assertEqual(v.value, 2)\n\t\t\twith self.assertRaises(StopAsyncIteration):\n\t\t\t\tawait g.asend(None)\n\n\t\tself.loop.run_until_complete(run())\n\n\tdef test_async_gen_asyncio_shutdown_01(self):\n\t\tfinalized = 0\n\n\t\tasync def waiter(timeout):\n\t\t\tnonlocal finalized\n\t\t\ttry:\n\t\t\t\tawait asyncio.sleep(timeout, loop=self.loop)\n\t\t\t\tyield 1\n\t\t\tfinally:\n\t\t\t\tawait asyncio.sleep(0, loop=self.loop)\n\t\t\t\tfinalized += 1\n\n\t\tasync def wait():\n\t\t\tasync for _ in waiter(1):\n\t\t\t\tpass\n\n\t\tt1 = self.loop.create_task(wait())\n\t\tt2 = self.loop.create_task(wait())\n\n\t\tself.loop.run_until_complete(asyncio.sleep(0.1, loop=self.loop))\n\n\t\tself.loop.run_until_complete(self.loop.shutdown_asyncgens())\n\t\tself.assertEqual(finalized, 2)\n\n\t\t# Silence warnings\n\t\tt1.cancel()\n\t\tt2.cancel()\n\t\tself.loop.run_until_complete(asyncio.sleep(0.1, loop=self.loop))\n\n\tdef test_async_gen_asyncio_shutdown_02(self):\n\t\tlogged = 0\n\n\t\tdef logger(loop, context):\n\t\t\tnonlocal logged\n\t\t\tself.assertIn('asyncgen', context)\n\t\t\texpected = 'an error occurred during closing of asynchronous'\n\t\t\tif expected in context['message']:\n\t\t\t\tlogged += 1\n\n\t\tasync def waiter(timeout):\n\t\t\ttry:\n\t\t\t\tawait asyncio.sleep(timeout, loop=self.loop)\n\t\t\t\tyield 1\n\t\t\tfinally:\n\t\t\t\t1 / 0\n\n\t\tasync def wait():\n\t\t\tasync for _ in waiter(1):\n\t\t\t\tpass\n\n\t\tt = self.loop.create_task(wait())\n\t\tself.loop.run_until_complete(asyncio.sleep(0.1, loop=self.loop))\n\n\t\tself.loop.set_exception_handler(logger)\n\t\tself.loop.run_until_complete(self.loop.shutdown_asyncgens())\n\n\t\tself.assertEqual(logged, 1)\n\n\t\t# Silence warnings\n\t\tt.cancel()\n\t\tself.loop.run_until_complete(asyncio.sleep(0.1, loop=self.loop))\n\n\tdef test_async_gen_expression_01(self):\n\t\tasync def arange(n):\n\t\t\tfor i in range(n):\n\t\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\t\tyield i\n\n\t\tdef make_arange(n):\n\t\t\t# This syntax is legal starting with Python 3.7\n\t\t\treturn (i * 2 async for i in arange(n))\n\n\t\tasync def run():\n\t\t\treturn [i async for i in make_arange(10)]\n\n\t\tres = self.loop.run_until_complete(run())\n\t\tself.assertEqual(res, [i * 2 for i in range(10)])\n\n\tdef test_async_gen_expression_02(self):\n\t\tasync def wrap(n):\n\t\t\tawait asyncio.sleep(0.01, loop=self.loop)\n\t\t\treturn n\n\n\t\tdef make_arange(n):\n\t\t\t# This syntax is legal starting with Python 3.7\n\t\t\treturn (i * 2 for i in range(n) if await wrap(i))\n\n\t\tasync def run():\n\t\t\treturn [i async for i in make_arange(10)]\n\n\t\tres = self.loop.run_until_complete(run())\n\t\tself.assertEqual(res, [i * 2 for i in range(1, 10)])\n\n", "description": null, "category": "def", "imports": ["import inspect", "import types", "import unittest", "from test.support import import_module", "asyncio = import_module(\"asyncio\")"]}], [{"term": "class", "name": "wrapper", "data": "class wrapper(simplewrapper): ...\n\n", "description": null, "category": "def", "imports": ["from typing import Generic, overload, TypeVar, Union"]}, {"term": "class", "name": "array", "data": "class array(Generic[T]):\n\n\t@overload\n\tdef __getitem__(self, i: int) -> T: ...\n\n\t@overload\n\tdef __getitem__(self, s: slice) -> array[T]: ...\n\n\tdef __len__(self) -> int: ...\n\n", "description": null, "category": "def", "imports": ["from typing import Generic, overload, TypeVar, Union"]}, {"term": "class", "name": "classvoidptr:", "data": "class voidptr:\n\n\tdef __init__(addr: Union[int, Buffer], size: int = -1, writeable: bool = True) -> None: ...\n\n\tdef __int__(self) -> int: ...\n\n\t@overload\n\tdef __getitem__(self, i: int) -> bytes: ...\n\n\t@overload\n\tdef __getitem__(self, s: slice) -> voidptr: ...\n\n\tdef __hex__(self) -> str: ...\n\n\tdef __len__(self) -> int: ...\n\n\tdef __setitem__(self, i: Union[int, slice], v: Buffer) -> None: ...\n\n\tdef asarray(self, size: int = -1) -> array: ...\n\n\t# Python doesn't expose the capsule type.\n\t#def ascapsule(self) -> capsule: ...\n\n\tdef asstring(self, size: int = -1) -> bytes: ...\n\n\tdef getsize(self) -> int: ...\n\n\tdef getwriteable(self) -> bool: ...\n\n\tdef setsize(self, size: int) -> None: ...\n\n\tdef setwriteable(self, bool) -> None: ...\n\n", "description": null, "category": "def", "imports": ["from typing import Generic, overload, TypeVar, Union"]}], [{"term": "class", "name": "ContextManagerTestCase", "data": "class ContextManagerTestCase(unittest.TestCase):\n\n\tdef test_contextmanager_plain(self):\n\t\tstate = []\n\t\t@contextmanager\n\t\tdef woohoo():\n\t\t\tstate.append(1)\n\t\t\tyield 42\n\t\t\tstate.append(999)\n\t\twith woohoo() as x:\n\t\t\tself.assertEqual(state, [1])\n\t\t\tself.assertEqual(x, 42)\n\t\t\tstate.append(x)\n\t\tself.assertEqual(state, [1, 42, 999])\n\n\tdef test_contextmanager_finally(self):\n\t\tstate = []\n\t\t@contextmanager\n\t\tdef woohoo():\n\t\t\tstate.append(1)\n\t\t\ttry:\n\t\t\t\tyield 42\n\t\t\tfinally:\n\t\t\t\tstate.append(999)\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\twith woohoo() as x:\n\t\t\t\tself.assertEqual(state, [1])\n\t\t\t\tself.assertEqual(x, 42)\n\t\t\t\tstate.append(x)\n\t\t\t\traise ZeroDivisionError()\n\t\tself.assertEqual(state, [1, 42, 999])\n\n\tdef test_contextmanager_no_reraise(self):\n\t\t@contextmanager\n\t\tdef whee():\n\t\t\tyield\n\t\tctx = whee()\n\t\tctx.__enter__()\n\t\t# Calling __exit__ should not result in an exception\n\t\tself.assertFalse(ctx.__exit__(TypeError, TypeError(\"foo\"), None))\n\n\tdef test_contextmanager_trap_yield_after_throw(self):\n\t\t@contextmanager\n\t\tdef whoo():\n\t\t\ttry:\n\t\t\t\tyield\n\t\t\texcept:\n\t\t\t\tyield\n\t\tctx = whoo()\n\t\tctx.__enter__()\n\t\tself.assertRaises(\n\t\t\tRuntimeError, ctx.__exit__, TypeError, TypeError(\"foo\"), None\n\t\t)\n\n\tdef test_contextmanager_except(self):\n\t\tstate = []\n\t\t@contextmanager\n\t\tdef woohoo():\n\t\t\tstate.append(1)\n\t\t\ttry:\n\t\t\t\tyield 42\n\t\t\texcept ZeroDivisionError, e:\n\t\t\t\tstate.append(e.args[0])\n\t\t\t\tself.assertEqual(state, [1, 42, 999])\n\t\twith woohoo() as x:\n\t\t\tself.assertEqual(state, [1])\n\t\t\tself.assertEqual(x, 42)\n\t\t\tstate.append(x)\n\t\t\traise ZeroDivisionError(999)\n\t\tself.assertEqual(state, [1, 42, 999])\n\n\tdef _create_contextmanager_attribs(self):\n\t\tdef attribs(**kw):\n\t\t\tdef decorate(func):\n\t\t\t\tfor k,v in kw.items():\n\t\t\t\t\tsetattr(func,k,v)\n\t\t\t\treturn func\n\t\t\treturn decorate\n\t\t@contextmanager\n\t\t@attribs(foo='bar')\n\t\tdef baz(spam):\n\t\t\t\"\"\"Whee!\"\"\"\n\t\treturn baz\n\n\tdef test_contextmanager_attribs(self):\n\t\tbaz = self._create_contextmanager_attribs()\n\t\tself.assertEqual(baz.__name__,'baz')\n\t\tself.assertEqual(baz.foo, 'bar')\n\n\t@unittest.skipIf(sys.flags.optimize >= 2,\n\t\t\t\t\t \"Docstrings are omitted with -O2 and above\")\n\tdef test_contextmanager_doc_attrib(self):\n\t\tbaz = self._create_contextmanager_attribs()\n\t\tself.assertEqual(baz.__doc__, \"Whee!\")\n", "description": "Whee!", "category": "def", "imports": ["import sys", "import tempfile", "import unittest", "from contextlib import *  # Tests __all__", "from test import test_support", "\timport threading"]}, {"term": "class", "name": "NestedTestCase", "data": "class NestedTestCase(unittest.TestCase):\n\n\t# XXX This needs more work\n\n\tdef test_nested(self):\n\t\t@contextmanager\n\t\tdef a():\n\t\t\tyield 1\n\t\t@contextmanager\n\t\tdef b():\n\t\t\tyield 2\n\t\t@contextmanager\n\t\tdef c():\n\t\t\tyield 3\n\t\twith nested(a(), b(), c()) as (x, y, z):\n\t\t\tself.assertEqual(x, 1)\n\t\t\tself.assertEqual(y, 2)\n\t\t\tself.assertEqual(z, 3)\n\n\tdef test_nested_cleanup(self):\n\t\tstate = []\n\t\t@contextmanager\n\t\tdef a():\n\t\t\tstate.append(1)\n\t\t\ttry:\n\t\t\t\tyield 2\n\t\t\tfinally:\n\t\t\t\tstate.append(3)\n\t\t@contextmanager\n\t\tdef b():\n\t\t\tstate.append(4)\n\t\t\ttry:\n\t\t\t\tyield 5\n\t\t\tfinally:\n\t\t\t\tstate.append(6)\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\twith nested(a(), b()) as (x, y):\n\t\t\t\tstate.append(x)\n\t\t\t\tstate.append(y)\n\t\t\t\t1 // 0\n\t\tself.assertEqual(state, [1, 4, 2, 5, 6, 3])\n\n\tdef test_nested_right_exception(self):\n\t\t@contextmanager\n\t\tdef a():\n\t\t\tyield 1\n\t\tclass b(object):\n\t\t\tdef __enter__(self):\n\t\t\t\treturn 2\n\t\t\tdef __exit__(self, *exc_info):\n\t\t\t\ttry:\n\t\t\t\t\traise Exception()\n\t\t\t\texcept:\n\t\t\t\t\tpass\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\twith nested(a(), b()) as (x, y):\n\t\t\t\t1 // 0\n\t\tself.assertEqual((x, y), (1, 2))\n\n\tdef test_nested_b_swallows(self):\n\t\t@contextmanager\n\t\tdef a():\n\t\t\tyield\n\t\t@contextmanager\n\t\tdef b():\n\t\t\ttry:\n\t\t\t\tyield\n\t\t\texcept:\n\t\t\t\t# Swallow the exception\n\t\t\t\tpass\n\t\ttry:\n\t\t\twith nested(a(), b()):\n\t\t\t\t1 // 0\n\t\texcept ZeroDivisionError:\n\t\t\tself.fail(\"Didn't swallow ZeroDivisionError\")\n\n\tdef test_nested_break(self):\n\t\t@contextmanager\n\t\tdef a():\n\t\t\tyield\n\t\tstate = 0\n\t\twhile True:\n\t\t\tstate += 1\n\t\t\twith nested(a(), a()):\n\t\t\t\tbreak\n\t\t\tstate += 10\n\t\tself.assertEqual(state, 1)\n\n\tdef test_nested_continue(self):\n\t\t@contextmanager\n\t\tdef a():\n\t\t\tyield\n\t\tstate = 0\n\t\twhile state < 3:\n\t\t\tstate += 1\n\t\t\twith nested(a(), a()):\n\t\t\t\tcontinue\n\t\t\tstate += 10\n\t\tself.assertEqual(state, 3)\n\n\tdef test_nested_return(self):\n\t\t@contextmanager\n\t\tdef a():\n\t\t\ttry:\n\t\t\t\tyield\n\t\t\texcept:\n\t\t\t\tpass\n\t\tdef foo():\n\t\t\twith nested(a(), a()):\n\t\t\t\treturn 1\n\t\t\treturn 10\n\t\tself.assertEqual(foo(), 1)\n", "description": null, "category": "def", "imports": ["import sys", "import tempfile", "import unittest", "from contextlib import *  # Tests __all__", "from test import test_support", "\timport threading"]}, {"term": "class", "name": "ClosingTestCase", "data": "class ClosingTestCase(unittest.TestCase):\n\n\t# XXX This needs more work\n\n\tdef test_closing(self):\n\t\tstate = []\n\t\tclass C:\n\t\t\tdef close(self):\n\t\t\t\tstate.append(1)\n\t\tx = C()\n\t\tself.assertEqual(state, [])\n\t\twith closing(x) as y:\n\t\t\tself.assertEqual(x, y)\n\t\tself.assertEqual(state, [1])\n\n\tdef test_closing_error(self):\n\t\tstate = []\n\t\tclass C:\n\t\t\tdef close(self):\n\t\t\t\tstate.append(1)\n\t\tx = C()\n\t\tself.assertEqual(state, [])\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\twith closing(x) as y:\n\t\t\t\tself.assertEqual(x, y)\n\t\t\t\t1 // 0\n\t\tself.assertEqual(state, [1])\n", "description": null, "category": "def", "imports": ["import sys", "import tempfile", "import unittest", "from contextlib import *  # Tests __all__", "from test import test_support", "\timport threading"]}, {"term": "class", "name": "FileContextTestCase", "data": "class FileContextTestCase(unittest.TestCase):\n\n\tdef testWithOpen(self):\n\t\ttfn = tempfile.mktemp()\n\t\ttry:\n\t\t\tf = None\n\t\t\twith open(tfn, \"w\") as f:\n\t\t\t\tself.assertFalse(f.closed)\n\t\t\t\tf.write(\"Booh\\n\")\n\t\t\tself.assertTrue(f.closed)\n\t\t\tf = None\n\t\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\t\twith open(tfn, \"r\") as f:\n\t\t\t\t\tself.assertFalse(f.closed)\n\t\t\t\t\tself.assertEqual(f.read(), \"Booh\\n\")\n\t\t\t\t\t1 // 0\n\t\t\tself.assertTrue(f.closed)\n\t\tfinally:\n\t\t\ttest_support.unlink(tfn)\n", "description": null, "category": "def", "imports": ["import sys", "import tempfile", "import unittest", "from contextlib import *  # Tests __all__", "from test import test_support", "\timport threading"]}, {"term": "class", "name": "LockContextTestCase", "data": "class LockContextTestCase(unittest.TestCase):\n\n\tdef boilerPlate(self, lock, locked):\n\t\tself.assertFalse(locked())\n\t\twith lock:\n\t\t\tself.assertTrue(locked())\n\t\tself.assertFalse(locked())\n\t\twith self.assertRaises(ZeroDivisionError):\n\t\t\twith lock:\n\t\t\t\tself.assertTrue(locked())\n\t\t\t\t1 // 0\n\t\tself.assertFalse(locked())\n\n\tdef testWithLock(self):\n\t\tlock = threading.Lock()\n\t\tself.boilerPlate(lock, lock.locked)\n\n\tdef testWithRLock(self):\n\t\tlock = threading.RLock()\n\t\tself.boilerPlate(lock, lock._is_owned)\n\n\tdef testWithCondition(self):\n\t\tlock = threading.Condition()\n\t\tdef locked():\n\t\t\treturn lock._is_owned()\n\t\tself.boilerPlate(lock, locked)\n\n\tdef testWithSemaphore(self):\n\t\tlock = threading.Semaphore()\n\t\tdef locked():\n\t\t\tif lock.acquire(False):\n\t\t\t\tlock.release()\n\t\t\t\treturn False\n\t\t\telse:\n\t\t\t\treturn True\n\t\tself.boilerPlate(lock, locked)\n\n\tdef testWithBoundedSemaphore(self):\n\t\tlock = threading.BoundedSemaphore()\n\t\tdef locked():\n\t\t\tif lock.acquire(False):\n\t\t\t\tlock.release()\n\t\t\t\treturn False\n\t\t\telse:\n\t\t\t\treturn True\n\t\tself.boilerPlate(lock, locked)\n", "description": null, "category": "def", "imports": ["import sys", "import tempfile", "import unittest", "from contextlib import *  # Tests __all__", "from test import test_support", "\timport threading"]}, {"term": "def", "name": "test_main", "data": "def test_main():\n\twith test_support.check_warnings((\"With-statements now directly support \"\n\t\t\t\t\t\t\t\t\t  \"multiple context managers\",\n\t\t\t\t\t\t\t\t\t  DeprecationWarning)):\n\t\ttest_support.run_unittest(__name__)\n", "description": null, "category": "def", "imports": ["import sys", "import tempfile", "import unittest", "from contextlib import *  # Tests __all__", "from test import test_support", "\timport threading"]}], [{"term": "class", "name": "FSharpRef", "data": "class FSharpRef(Generic[T]):\n\tdef __init__(self, contentsOrGetter: Union_[T, Callable[[], T]], setter: Optional[Callable[[T], None]] = None) -> None:\n\n\t\tcontents = contentsOrGetter\n\n\t\tdef set_contents(value: T):\n\t\t\tnonlocal contents\n\t\t\tcontents = value\n\n\t\tif callable(setter):\n\t\t\tself.getter = contentsOrGetter\n\t\t\tself.setter = setter\n\t\telse:\n\t\t\tself.getter = lambda: contents\n\t\t\tself.setter = set_contents\n\n\t@property\n\tdef contents(self) -> T:\n\t\treturn self.getter()\n\n\t@contents.setter\n\tdef contents(self, v) -> None:\n\t\tself.setter(v)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "class", "name": "Union", "data": "class Union(IComparable):\n\tdef __init__(self):\n\t\tself.tag: int\n\t\tself.fields: Tuple[int, ...] = ()\n\n\t@abstractstaticmethod\n\tdef cases() -> List[str]:\n\t\t...\n\n\t@property\n\tdef name(self) -> str:\n\t\treturn self.cases()[self.tag]\n\n\tdef to_JSON(self) -> str:\n\t\traise NotImplementedError\n\n\tdef __str__(self) -> str:\n\t\tif not len(self.fields):\n\t\t\treturn self.name\n\n\t\tfields = \"\"\n\t\twith_parens = True\n\t\tif len(self.fields) == 1:\n\t\t\tfield = str(self.fields[0])\n\t\t\twith_parens = field.find(\" \") >= 0\n\t\t\tfields = field\n\t\telse:\n\t\t\tfields = \", \".join(map(str, self.fields))\n\n\t\treturn self.name + (\" (\" if with_parens else \" \") + fields + (\")\" if with_parens else \"\")\n\n\tdef __repr__(self) -> str:\n\t\treturn str(self)\n\n\tdef __hash__(self) -> int:\n\t\thashes = map(hash, self.fields)\n\t\treturn hash([hash(self.tag), *hashes])\n\n\tdef __eq__(self, other: Any) -> bool:\n\t\tif self is other:\n\t\t\treturn True\n\t\tif not isinstance(other, Union):\n\t\t\treturn False\n\n\t\tif self.tag == other.tag:\n\t\t\treturn self.fields == other.fields\n\n\t\treturn False\n\n\tdef __lt__(self, other: Any) -> bool:\n\t\tif self.tag == other.tag:\n\t\t\treturn self.fields < other.fields\n\n\t\treturn self.tag < other.tag\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "record_equals", "data": "def record_equals(self: Record, other: Record) -> bool:\n\tif self is other:\n\t\treturn True\n\n\ta = self.__dict__ if hasattr(self, \"__dict__\") else self\n\tb = other.__dict__ if hasattr(other, \"__dict__\") else other\n\n\treturn a == b\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "record_compare_to", "data": "def record_compare_to(self: Record, other: Record):\n\tif self is other:\n\t\treturn 0\n\n\telse:\n\t\tfor name in self.__dict__.keys():\n\t\t\tif self.__dict__[name] < other.__dict__.get(name):\n\t\t\t\treturn -1\n\t\t\telif self.__dict__[name] > other.__dict__.get(name):\n\t\t\t\treturn 1\n\n\t\treturn 0\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "record_to_string", "data": "def record_to_string(self: Record) -> str:\n\treturn \"{ \" + \"\\n  \".join(map(lambda kv: kv[0] + \" = \" + str(kv[1]), self.__dict__.items())) + \" }\"\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "recordGetHashCode", "data": "def recordGetHashCode(self):\n\treturn hash(*self.values())\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "class", "name": "Record", "data": "class Record(IComparable):\n\t# def toJSON(self) -> str:\n\t#\treturn record_to_JSON(self)\n\n\tdef __str__(self) -> str:\n\t\treturn record_to_string(self)\n\n\tdef __repr__(self) -> str:\n\t\treturn str(self)\n\n\tdef GetHashCode(self) -> int:\n\t\treturn recordGetHashCode(self)\n\n\tdef Equals(self, other: Record) -> bool:\n\t\treturn record_equals(self, other)\n\n\tdef CompareTo(self, other: Record) -> int:\n\t\treturn record_compare_to(self, other)\n\n\tdef __lt__(self, other: Any) -> bool:\n\t\treturn True if self.CompareTo(other) == -1 else False\n\n\tdef __eq__(self, other: Any) -> bool:\n\t\treturn self.Equals(other)\n\n\tdef __hash__(self) -> int:\n\t\treturn recordGetHashCode(self)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "class", "name": "classAttribute:", "data": "class Attribute:\n\tpass\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "seq_to_string", "data": "def seq_to_string(self: Iterable[Any]) -> str:\n\tstr = \"[\"\n\n\tfor count, x in enumerate(self):\n\t\tif count == 0:\n\t\t\tstr += to_string(x)\n\n\t\telif count == 100:\n\t\t\tstr += \"; ...\"\n\t\t\tbreak\n\n\t\telse:\n\t\t\tstr += \"; \" + to_string(x)\n\n\treturn str + \"]\"\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "to_string", "data": "def to_string(x: Any, callStack: int = 0) -> str:\n\tif x is not None:\n\t\t# if (typeof x.toString === \"function\") {\n\t\t#\treturn x.toString();\n\n\t\tif isinstance(x, Iterable) and not hasattr(x, \"__str__\"):\n\t\t\treturn seq_to_string(x)\n\n\t\t# else: // TODO: Date?\n\t\t#\t const cons = Object.getPrototypeOf(x).constructor;\n\t\t#\t return cons === Object && callStack < 10\n\t\t#\t\t // Same format as recordToString\n\t\t#\t\t ? \"{ \" + Object.entries(x).map(([k, v]) => k + \" = \" + toString(v, callStack + 1)).join(\"\\n  \") + \" }\"\n\t\t#\t\t : cons.name;\n\n\treturn str(x)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "class", "name": "Exception", "data": "class Exception(Exception):\n\tdef __init__(self, msg: Optional[str] = None):\n\t\tself.msg = msg\n\n\tdef __eq__(self, other: Any) -> bool:\n\t\tif self is other:\n\t\t\treturn True\n\n\t\tif other is None:\n\t\t\treturn False\n\n\t\treturn self.msg == other.msg\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "class", "name": "FSharpException", "data": "class FSharpException(Exception, IComparable):\n\tdef __init__(self):\n\t\tself.Data0: Any = None\n\n\t# def toJSON(self):\n\t#\treturn record_to_JSON(self)\n\n\tdef __str__(self):\n\t\treturn record_to_string(self)\n\n\tdef __repr__(self) -> str:\n\t\treturn str(self)\n\n\tdef __eq__(self, other: Any) -> bool:\n\t\tif self is other:\n\t\t\treturn True\n\n\t\tif other is None:\n\t\t\treturn False\n\n\t\treturn self.Data0 == other.Data0\n\n\tdef __lt__(self, other: Any) -> bool:\n\t\tif not isinstance(other, FSharpException):\n\t\t\treturn False\n\n\t\tif self.Data0:\n\t\t\tif other.Data0:\n\t\t\t\treturn self.Data0 < other.Data0\n\t\t\telse:\n\t\t\t\treturn False\n\n\t\telif not self.Data0:\n\t\t\tif other.Data0:\n\t\t\t\treturn False\n\t\t\telse:\n\t\t\t\treturn True\n\n\t\treturn super().__lt__(other)\n\n\tdef __hash__(self) -> int:\n\t\treturn hash(self.Data0)\n\n\tdef GetHashCode(self) -> int:\n\t\treturn recordGetHashCode(self)\n\n\tdef Equals(self, other: FSharpException):\n\t\treturn record_equals(self, other)\n\n\tdef CompareTo(self, other: FSharpException):\n\t\treturn record_compare_to(self, other)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "Int8Array", "data": "def Int8Array(lst: List[int]):\n\treturn array.array(\"b\", lst)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "Uint8Array", "data": "def Uint8Array(lst: List[int]):\n\treturn bytearray(lst)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "Int16Array", "data": "def Int16Array(lst: List[int]):\n\treturn array.array(\"h\", lst)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "Uint16Array", "data": "def Uint16Array(lst: List[int]):\n\treturn array.array(\"H\", lst)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "Int32Array", "data": "def Int32Array(lst: List[int]):\n\treturn array.array(\"i\", lst)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "Uint32Array", "data": "def Uint32Array(lst: List[int]):\n\treturn array.array(\"I\", lst)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "Float32Array", "data": "def Float32Array(lst: List[float]):\n\treturn array.array(\"f\", lst)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}, {"term": "def", "name": "Float64Array", "data": "def Float64Array(lst: List[float]):\n\treturn array.array(\"d\", lst)\n\n", "description": null, "category": "def", "imports": ["from __future__ import annotations", "from abc import abstractstaticmethod", "from typing import Any, Callable, Generic, Iterable, List, Optional, Tuple, TypeVar", "from typing import Union as Union_", "from typing import cast", "import array", "from .util import IComparable, equals"]}], [{"term": "def", "name": "want_bytes", "data": "def want_bytes(s: Union[Text, bytes], encoding: Text = ..., errors: Text = ...) -> bytes: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "BadData", "data": "class BadData(Exception):\n\tmessage: str\n\tdef __init__(self, message: str) -> None: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "BadPayload", "data": "class BadPayload(BadData):\n\toriginal_error: Optional[Exception]\n\tdef __init__(self, message: str, original_error: Optional[Exception] = ...) -> None: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "BadSignature", "data": "class BadSignature(BadData):\n\tpayload: Optional[Any]\n\tdef __init__(self, message: str, payload: Optional[Any] = ...) -> None: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "BadTimeSignature", "data": "class BadTimeSignature(BadSignature):\n\tdate_signed: Optional[int]\n\tdef __init__(self, message: str, payload: Optional[Any] = ..., date_signed: Optional[int] = ...) -> None: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "BadHeader", "data": "class BadHeader(BadSignature):\n\theader: Any\n\toriginal_error: Any\n\tdef __init__(self, message, payload: Optional[Any] = ..., header: Optional[Any] = ..., original_error: Optional[Any] = ...) -> None: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "SignatureExpired", "data": "class SignatureExpired(BadTimeSignature): ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "def", "name": "base64_decode", "data": "def base64_decode(string: Union[Text, bytes]) -> bytes: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "SigningAlgorithm", "data": "class SigningAlgorithm(object):\n\tdef get_signature(self, key: bytes, value: bytes) -> bytes: ...\n\tdef verify_signature(self, key: bytes, value: bytes, sig: bytes) -> bool: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "NoneAlgorithm", "data": "class NoneAlgorithm(SigningAlgorithm):\n\tdef get_signature(self, key: bytes, value: bytes) -> bytes: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "HMACAlgorithm", "data": "class HMACAlgorithm(SigningAlgorithm):\n\tdefault_digest_method: Callable\n\tdigest_method: Callable\n\tdef __init__(self, digest_method: Optional[Callable] = ...) -> None: ...\n\tdef get_signature(self, key: bytes, value: bytes) -> bytes: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "Signer", "data": "class Signer(object):\n\tdefault_digest_method: Callable = ...\n\tdefault_key_derivation: str = ...\n\n\tsecret_key: bytes\n\tsep: bytes\n\tsalt: Union[Text, bytes]\n\tkey_derivation: str\n\tdigest_method: Callable\n\talgorithm: SigningAlgorithm\n\n\tdef __init__(self,\n\t\t\t\t secret_key: Union[Text, bytes],\n\t\t\t\t salt: Optional[Union[Text, bytes]] = ...,\n\t\t\t\t sep: Optional[Union[Text, bytes]] = ...,\n\t\t\t\t key_derivation: Optional[str] = ...,\n\t\t\t\t digest_method: Optional[Callable] = ...,\n\t\t\t\t algorithm: Optional[SigningAlgorithm] = ...) -> None: ...\n\tdef derive_key(self) -> bytes: ...\n\tdef get_signature(self, value: Union[Text, bytes]) -> bytes: ...\n\tdef sign(self, value: Union[Text, bytes]) -> bytes: ...\n\tdef verify_signature(self, value: bytes, sig: Union[Text, bytes]) -> bool: ...\n\tdef unsign(self, signed_value: Union[Text, bytes]) -> bytes: ...\n\tdef validate(self, signed_value: Union[Text, bytes]) -> bool: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "TimestampSigner", "data": "class TimestampSigner(Signer):\n\tdef get_timestamp(self) -> int: ...\n\tdef timestamp_to_datetime(self, ts: float) -> datetime: ...\n\tdef sign(self, value: Union[Text, bytes]) -> bytes: ...\n\tdef unsign(self, value: Union[Text, bytes], max_age: Optional[int] = ...,\n\t\t\t   return_timestamp: bool = ...) -> Any: ...  # morally -> Union[bytes, Tuple[bytes, datetime]]\n\tdef validate(self, signed_value: Union[Text, bytes], max_age: Optional[int] = ...) -> bool: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "Serializer", "data": "class Serializer(object):\n\tdefault_serializer: _serializer = ...\n\tdefault_signer: Callable[..., Signer] = ...\n\n\tsecret_key: bytes\n\tsalt: bytes\n\tserializer: _serializer\n\tis_text_serializer: bool\n\tsigner: Callable[..., Signer]\n\tsigner_kwargs: MutableMapping[str, Any]\n\n\tdef __init__(self, secret_key: Union[Text, bytes], salt: Optional[Union[Text, bytes]] = ...,\n\t\t\t\t serializer: Optional[_serializer] = ..., signer: Optional[Callable[..., Signer]] = ...,\n\t\t\t\t signer_kwargs: Optional[MutableMapping[str, Any]] = ...) -> None: ...\n\tdef load_payload(self, payload: bytes, serializer: Optional[_serializer] = ...) -> Any: ...\n\tdef dump_payload(self, obj: Any) -> bytes: ...\n\tdef make_signer(self, salt: Optional[Union[Text, bytes]] = ...) -> Signer: ...\n\tdef iter_unsigners(self, salt: Optional[Union[Text, bytes]] = ...) -> Generator[Any, None, None]: ...\n\tdef dumps(self, obj: Any, salt: Optional[Union[Text, bytes]] = ...) -> Any: ...  # morally -> Union[str, bytes]\n\tdef dump(self, obj: Any, f: IO[Any], salt: Optional[Union[Text, bytes]] = ...) -> None: ...\n\tdef loads(self, s: Union[Text, bytes], salt: Optional[Union[Text, bytes]] = ...) -> Any: ...\n\tdef load(self, f: IO[Any], salt: Optional[Union[Text, bytes]] = ...): ...\n\tdef loads_unsafe(self, s: Union[Text, bytes], salt: Optional[Union[Text, bytes]] = ...) -> Tuple[bool, Optional[Any]]: ...\n\tdef load_unsafe(self, f: IO[Any], salt: Optional[Union[Text, bytes]] = ...) -> Tuple[bool, Optional[Any]]: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "TimedSerializer", "data": "class TimedSerializer(Serializer):\n\tdef loads(self, s: Union[Text, bytes], salt: Optional[Union[Text, bytes]] = ..., max_age: Optional[int] = ...,\n\t\t\t  return_timestamp: bool = ...) -> Any: ...  # morally -> Union[Any, Tuple[Any, datetime]]\n\tdef loads_unsafe(self, s: Union[Text, bytes], salt: Optional[Union[Text, bytes]] = ...,\n\t\t\t\t\t max_age: Optional[int] = ...) -> Tuple[bool, Any]: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "JSONWebSignatureSerializer", "data": "class JSONWebSignatureSerializer(Serializer):\n\tjws_algorithms: MutableMapping[Text, SigningAlgorithm] = ...\n\tdefault_algorithm: Text = ...\n\tdefault_serializer: Any = ...\n\n\talgorithm_name: Text\n\talgorithm: SigningAlgorithm\n\n\tdef __init__(self, secret_key: Union[Text, bytes], salt: Optional[Union[Text, bytes]] = ...,\n\t\t\t\t serializer: Optional[_serializer] = ..., signer: Optional[Callable[..., Signer]] = ...,\n\t\t\t\t signer_kwargs: Optional[MutableMapping[str, Any]] = ..., algorithm_name: Optional[Text] = ...) -> None: ...\n\tdef load_payload(self, payload: Union[Text, bytes], serializer: Optional[_serializer] = ...,\n\t\t\t\t\t return_header: bool = ...) -> Any: ...  # morally -> Union[Any, Tuple[Any, MutableMapping[str, Any]]]\n\tdef dump_payload(self, header: Mapping[str, Any], obj: Any) -> bytes: ...  # type: ignore\n\tdef make_algorithm(self, algorithm_name: Text) -> SigningAlgorithm: ...\n\tdef make_signer(self, salt: Optional[Union[Text, bytes]] = ..., algorithm: SigningAlgorithm = ...) -> Signer: ...\n\tdef make_header(self, header_fields: Optional[Mapping[str, Any]]) -> MutableMapping[str, Any]: ...\n\tdef dumps(self, obj: Any, salt: Optional[Union[Text, bytes]] = ...,\n\t\t\t  header_fields: Optional[Mapping[str, Any]] = ...) -> str: ...\n\tdef loads(self, s: Union[Text, bytes], salt: Optional[Union[Text, bytes]] = ...,\n\t\t\t  return_header: bool = ...) -> Any: ...  # morally -> Union[Any, Tuple[Any, MutableMapping[str, Any]]]\n\tdef loads_unsafe(self, s: Union[Text, bytes], salt: Optional[Union[Text, bytes]] = ...,\n\t\t\t\t\t return_header: bool = ...) -> Tuple[bool, Any]: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "TimedJSONWebSignatureSerializer", "data": "class TimedJSONWebSignatureSerializer(JSONWebSignatureSerializer):\n\tDEFAULT_EXPIRES_IN: int = ...\n\texpires_in: int\n\tdef __init__(self, secret_key: Union[Text, bytes], expires_in: Optional[int] = ..., salt: Optional[Union[Text, bytes]] = ...,\n\t\t\t\t serializer: Optional[_serializer] = ..., signer: Optional[Callable[..., Signer]] = ...,\n\t\t\t\t signer_kwargs: Optional[MutableMapping[str, Any]] = ..., algorithm_name: Optional[Text] = ...) -> None: ...\n\tdef make_header(self, header_fields: Optional[Mapping[str, Any]]) -> MutableMapping[str, Any]: ...\n\tdef loads(self, s: Union[Text, bytes], salt: Optional[Union[Text, bytes]] = ...,\n\t\t\t  return_header: bool = ...) -> Any: ...  # morally -> Union[Any, Tuple[Any, MutableMapping[str, Any]]]\n\tdef get_issue_date(self, header: Mapping[str, Any]) -> Optional[datetime]: ...\n\tdef now(self) -> int: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}, {"term": "class", "name": "_URLSafeSerializerMixin", "data": "class _URLSafeSerializerMixin(object):\n\tdefault_serializer: _serializer = ...\n\tdef load_payload(self, payload: bytes, serializer: Optional[_serializer] = ...) -> Any: ...\n\tdef dump_payload(self, obj: Any) -> bytes: ...\n", "description": null, "category": "def", "imports": ["from datetime import datetime", "from typing import Any, Callable, IO, Mapping, MutableMapping, Optional, Tuple, Union, Text, Generator"]}], [{"term": "def", "name": "symtable", "data": "def symtable(code, filename, compile_type):\n\ttop = _symtable.symtable(code, filename, compile_type)\n\treturn _newSymbolTable(top, filename)\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef has_import_star(self):", "\t\t\"\"\"Return true if the scope uses import *\"\"\"", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "classSymbolTableFactory:", "data": "class SymbolTableFactory:\n\tdef __init__(self):\n\t\tself.__memo = weakref.WeakValueDictionary()\n\n\tdef new(self, table, filename):\n\t\tif table.type == _symtable.TYPE_FUNCTION:\n\t\t\treturn Function(table, filename)\n\t\tif table.type == _symtable.TYPE_CLASS:\n\t\t\treturn Class(table, filename)\n\t\treturn SymbolTable(table, filename)\n\n\tdef __call__(self, table, filename):\n\t\tkey = table, filename\n\t\tobj = self.__memo.get(key, None)\n\t\tif obj is None:\n\t\t\tobj = self.__memo[key] = self.new(table, filename)\n\t\treturn obj\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef has_import_star(self):", "\t\t\"\"\"Return true if the scope uses import *\"\"\"", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "SymbolTable", "data": "class SymbolTable(object):\n\n\tdef __init__(self, raw_table, filename):\n\t\tself._table = raw_table\n\t\tself._filename = filename\n\t\tself._symbols = {}\n\n\tdef __repr__(self):\n\t\tif self.__class__ == SymbolTable:\n\t\t\tkind = \"\"\n\t\telse:\n\t\t\tkind = \"%s \" % self.__class__.__name__\n\n\t\tif self._table.name == \"global\":\n\t\t\treturn \"<{0}SymbolTable for module {1}>\".format(kind, self._filename)\n\t\telse:\n\t\t\treturn \"<{0}SymbolTable for {1} in {2}>\".format(kind,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself._table.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself._filename)\n\n\tdef get_type(self):\n\t\tif self._table.type == _symtable.TYPE_MODULE:\n\t\t\treturn \"module\"\n\t\tif self._table.type == _symtable.TYPE_FUNCTION:\n\t\t\treturn \"function\"\n\t\tif self._table.type == _symtable.TYPE_CLASS:\n\t\t\treturn \"class\"\n\t\tassert self._table.type in (1, 2, 3), \\\n\t\t\t   \"unexpected type: {0}\".format(self._table.type)\n\n\tdef get_id(self):\n\t\treturn self._table.id\n\n\tdef get_name(self):\n\t\treturn self._table.name\n\n\tdef get_lineno(self):\n\t\treturn self._table.lineno\n\n\tdef is_optimized(self):\n\t\treturn bool(self._table.type == _symtable.TYPE_FUNCTION\n\t\t\t\t\tand not self._table.optimized)\n\n\tdef is_nested(self):\n\t\treturn bool(self._table.nested)\n\n\tdef has_children(self):\n\t\treturn bool(self._table.children)\n\n\tdef has_exec(self):\n\t\t\"\"\"Return true if the scope uses exec\"\"\"\n\t\treturn bool(self._table.optimized & (OPT_EXEC | OPT_BARE_EXEC))\n\n\tdef has_import_star(self):\n\t\t\"\"\"Return true if the scope uses import *\"\"\"\n\t\treturn bool(self._table.optimized & OPT_IMPORT_STAR)\n\n\tdef get_identifiers(self):\n\t\treturn self._table.symbols.keys()\n\n\tdef lookup(self, name):\n\t\tsym = self._symbols.get(name)\n\t\tif sym is None:\n\t\t\tflags = self._table.symbols[name]\n\t\t\tnamespaces = self.__check_children(name)\n\t\t\tsym = self._symbols[name] = Symbol(name, flags, namespaces)\n\t\treturn sym\n\n\tdef get_symbols(self):\n\t\treturn [self.lookup(ident) for ident in self.get_identifiers()]\n\n\tdef __check_children(self, name):\n\t\treturn [_newSymbolTable(st, self._filename)\n\t\t\t\tfor st in self._table.children\n\t\t\t\tif st.name == name]\n\n\tdef get_children(self):\n\t\treturn [_newSymbolTable(st, self._filename)\n\t\t\t\tfor st in self._table.children]\n\n", "description": "Return true if the scope uses exec", "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef has_import_star(self):", "\t\t\"\"\"Return true if the scope uses import *\"\"\"", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "Function", "data": "class Function(SymbolTable):\n\n\t# Default values for instance variables\n\t__params = None\n\t__locals = None\n\t__frees = None\n\t__globals = None\n\n\tdef __idents_matching(self, test_func):\n\t\treturn tuple([ident for ident in self.get_identifiers()\n\t\t\t\t\t  if test_func(self._table.symbols[ident])])\n\n\tdef get_parameters(self):\n\t\tif self.__params is None:\n\t\t\tself.__params = self.__idents_matching(lambda x:x & DEF_PARAM)\n\t\treturn self.__params\n\n\tdef get_locals(self):\n\t\tif self.__locals is None:\n\t\t\tlocs = (LOCAL, CELL)\n\t\t\ttest = lambda x: ((x >> SCOPE_OFF) & SCOPE_MASK) in locs\n\t\t\tself.__locals = self.__idents_matching(test)\n\t\treturn self.__locals\n\n\tdef get_globals(self):\n\t\tif self.__globals is None:\n\t\t\tglob = (GLOBAL_IMPLICIT, GLOBAL_EXPLICIT)\n\t\t\ttest = lambda x:((x >> SCOPE_OFF) & SCOPE_MASK) in glob\n\t\t\tself.__globals = self.__idents_matching(test)\n\t\treturn self.__globals\n\n\tdef get_frees(self):\n\t\tif self.__frees is None:\n\t\t\tis_free = lambda x:((x >> SCOPE_OFF) & SCOPE_MASK) == FREE\n\t\t\tself.__frees = self.__idents_matching(is_free)\n\t\treturn self.__frees\n\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef has_import_star(self):", "\t\t\"\"\"Return true if the scope uses import *\"\"\"", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "Class", "data": "class Class(SymbolTable):\n\n\t__methods = None\n\n\tdef get_methods(self):\n\t\tif self.__methods is None:\n\t\t\td = {}\n\t\t\tfor st in self._table.children:\n\t\t\t\td[st.name] = 1\n\t\t\tself.__methods = tuple(d)\n\t\treturn self.__methods\n\n", "description": null, "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef has_import_star(self):", "\t\t\"\"\"Return true if the scope uses import *\"\"\"", "\tdef is_imported(self):", "\timport os, sys"]}, {"term": "class", "name": "Symbol", "data": "class Symbol(object):\n\n\tdef __init__(self, name, flags, namespaces=None):\n\t\tself.__name = name\n\t\tself.__flags = flags\n\t\tself.__scope = (flags >> SCOPE_OFF) & SCOPE_MASK # like PyST_GetScope()\n\t\tself.__namespaces = namespaces or ()\n\n\tdef __repr__(self):\n\t\treturn \"<symbol {0!r}>\".format(self.__name)\n\n\tdef get_name(self):\n\t\treturn self.__name\n\n\tdef is_referenced(self):\n\t\treturn bool(self.__flags & _symtable.USE)\n\n\tdef is_parameter(self):\n\t\treturn bool(self.__flags & DEF_PARAM)\n\n\tdef is_global(self):\n\t\treturn bool(self.__scope in (GLOBAL_IMPLICIT, GLOBAL_EXPLICIT))\n\n\tdef is_declared_global(self):\n\t\treturn bool(self.__scope == GLOBAL_EXPLICIT)\n\n\tdef is_local(self):\n\t\treturn bool(self.__flags & DEF_BOUND)\n\n\tdef is_free(self):\n\t\treturn bool(self.__scope == FREE)\n\n\tdef is_imported(self):\n\t\treturn bool(self.__flags & DEF_IMPORT)\n\n\tdef is_assigned(self):\n\t\treturn bool(self.__flags & DEF_LOCAL)\n\n\tdef is_namespace(self):\n\t\t\"\"\"Returns true if name binding introduces new namespace.\n\n\t\tIf the name is used as the target of a function or class\n\t\tstatement, this will be true.\n\n\t\tNote that a single name can be bound to multiple objects.  If\n\t\tis_namespace() is true, the name may also be bound to other\n\t\tobjects, like an int or list, that does not introduce a new\n\t\tnamespace.\n\t\t\"\"\"\n\t\treturn bool(self.__namespaces)\n\n\tdef get_namespaces(self):\n\t\t\"\"\"Return a list of namespaces bound to this name\"\"\"\n\t\treturn self.__namespaces\n\n\tdef get_namespace(self):\n\t\t\"\"\"Returns the single namespace bound to this name.\n\n\t\tRaises ValueError if the name is bound to multiple namespaces.\n\t\t\"\"\"\n\t\tif len(self.__namespaces) != 1:\n\t\t\traise ValueError, \"name is bound to multiple namespaces\"\n\t\treturn self.__namespaces[0]\n", "description": "Returns true if name binding introduces new namespace.\n\n\t\tIf the name is used as the target of a function or class\n\t\tstatement, this will be true.\n\n\t\tNote that a single name can be bound to multiple objects.  If\n\t\tis_namespace() is true, the name may also be bound to other\n\t\tobjects, like an int or list, that does not introduce a new\n\t\tnamespace.\n\t\t", "category": "def", "imports": ["import _symtable", "from _symtable import (USE, DEF_GLOBAL, DEF_LOCAL, DEF_PARAM,", "import weakref", "\tdef has_import_star(self):", "\t\t\"\"\"Return true if the scope uses import *\"\"\"", "\tdef is_imported(self):", "\timport os, sys"]}]]